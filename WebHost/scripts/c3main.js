// Generated by Construct, the game and animation creation tool
// Visit: https://www.construct.net

// file-map:scripts/c3runtime.js
{
  let setMatrixArrayType = function(t2) {
    ARRAY_TYPE = t2;
  }, toRadian = function(t2) {
    return t2 * degree;
  }, equals$9 = function(t2, a2) {
    return Math.abs(t2 - a2) <= EPSILON * Math.max(1, Math.abs(t2), Math.abs(a2));
  }, create$8 = function() {
    var t2 = new ARRAY_TYPE(4);
    return ARRAY_TYPE != Float32Array && (t2[1] = 0, t2[2] = 0), t2[0] = 1, t2[3] = 1, t2;
  }, clone$8 = function(t2) {
    var a2 = new ARRAY_TYPE(4);
    return a2[0] = t2[0], a2[1] = t2[1], a2[2] = t2[2], a2[3] = t2[3], a2;
  }, copy$8 = function(t2, a2) {
    return t2[0] = a2[0], t2[1] = a2[1], t2[2] = a2[2], t2[3] = a2[3], t2;
  }, identity$5 = function(t2) {
    return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2;
  }, fromValues$8 = function(t2, a2, r2, n) {
    var e = new ARRAY_TYPE(4);
    return e[0] = t2, e[1] = a2, e[2] = r2, e[3] = n, e;
  }, set$8 = function(t2, a2, r2, n, e) {
    return t2[0] = a2, t2[1] = r2, t2[2] = n, t2[3] = e, t2;
  }, transpose$2 = function(t2, a2) {
    if (t2 === a2) {
      var r2 = a2[1];
      t2[1] = a2[2], t2[2] = r2;
    } else t2[0] = a2[0], t2[1] = a2[2], t2[2] = a2[1], t2[3] = a2[3];
    return t2;
  }, invert$5 = function(t2, a2) {
    var r2 = a2[0], n = a2[1], e = a2[2], o2 = a2[3], u2 = r2 * o2 - e * n;
    return u2 ? (u2 = 1 / u2, t2[0] = o2 * u2, t2[1] = -n * u2, t2[2] = -e * u2, t2[3] = r2 * u2, t2) : null;
  }, adjoint$2 = function(t2, a2) {
    var r2 = a2[0];
    return t2[0] = a2[3], t2[1] = -a2[1], t2[2] = -a2[2], t2[3] = r2, t2;
  }, determinant$3 = function(t2) {
    return t2[0] * t2[3] - t2[2] * t2[1];
  }, multiply$8 = function(t2, a2, r2) {
    var n = a2[0], e = a2[1], o2 = a2[2], u2 = a2[3], s = r2[0], i = r2[1], c2 = r2[2], l = r2[3];
    return t2[0] = n * s + o2 * i, t2[1] = e * s + u2 * i, t2[2] = n * c2 + o2 * l, t2[3] = e * c2 + u2 * l, t2;
  }, rotate$4 = function(t2, a2, r2) {
    var n = a2[0], e = a2[1], o2 = a2[2], u2 = a2[3], s = Math.sin(r2), i = Math.cos(r2);
    return t2[0] = n * i + o2 * s, t2[1] = e * i + u2 * s, t2[2] = n * -s + o2 * i, t2[3] = e * -s + u2 * i, t2;
  }, scale$8 = function(t2, a2, r2) {
    var n = a2[0], e = a2[1], o2 = a2[2], u2 = a2[3], s = r2[0], i = r2[1];
    return t2[0] = n * s, t2[1] = e * s, t2[2] = o2 * i, t2[3] = u2 * i, t2;
  }, fromRotation$4 = function(t2, a2) {
    var r2 = Math.sin(a2), n = Math.cos(a2);
    return t2[0] = n, t2[1] = r2, t2[2] = -r2, t2[3] = n, t2;
  }, fromScaling$3 = function(t2, a2) {
    return t2[0] = a2[0], t2[1] = 0, t2[2] = 0, t2[3] = a2[1], t2;
  }, str$8 = function(t2) {
    return "mat2(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ", " + t2[3] + ")";
  }, frob$3 = function(t2) {
    return Math.hypot(t2[0], t2[1], t2[2], t2[3]);
  }, LDU = function(t2, a2, r2, n) {
    return t2[2] = n[2] / n[0], r2[0] = n[0], r2[1] = n[1], r2[3] = n[3] - t2[2] * r2[1], [t2, a2, r2];
  }, add$8 = function(t2, a2, r2) {
    return t2[0] = a2[0] + r2[0], t2[1] = a2[1] + r2[1], t2[2] = a2[2] + r2[2], t2[3] = a2[3] + r2[3], t2;
  }, subtract$6 = function(t2, a2, r2) {
    return t2[0] = a2[0] - r2[0], t2[1] = a2[1] - r2[1], t2[2] = a2[2] - r2[2], t2[3] = a2[3] - r2[3], t2;
  }, exactEquals$8 = function(t2, a2) {
    return t2[0] === a2[0] && t2[1] === a2[1] && t2[2] === a2[2] && t2[3] === a2[3];
  }, equals$8 = function(t2, a2) {
    var r2 = t2[0], n = t2[1], e = t2[2], o2 = t2[3], u2 = a2[0], s = a2[1], i = a2[2], c2 = a2[3];
    return Math.abs(r2 - u2) <= EPSILON * Math.max(1, Math.abs(r2), Math.abs(u2)) && Math.abs(n - s) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(s)) && Math.abs(e - i) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(i)) && Math.abs(o2 - c2) <= EPSILON * Math.max(1, Math.abs(o2), Math.abs(c2));
  }, multiplyScalar$3 = function(t2, a2, r2) {
    return t2[0] = a2[0] * r2, t2[1] = a2[1] * r2, t2[2] = a2[2] * r2, t2[3] = a2[3] * r2, t2;
  }, multiplyScalarAndAdd$3 = function(t2, a2, r2, n) {
    return t2[0] = a2[0] + r2[0] * n, t2[1] = a2[1] + r2[1] * n, t2[2] = a2[2] + r2[2] * n, t2[3] = a2[3] + r2[3] * n, t2;
  }, create$7 = function() {
    var t2 = new ARRAY_TYPE(6);
    return ARRAY_TYPE != Float32Array && (t2[1] = 0, t2[2] = 0, t2[4] = 0, t2[5] = 0), t2[0] = 1, t2[3] = 1, t2;
  }, clone$7 = function(t2) {
    var a2 = new ARRAY_TYPE(6);
    return a2[0] = t2[0], a2[1] = t2[1], a2[2] = t2[2], a2[3] = t2[3], a2[4] = t2[4], a2[5] = t2[5], a2;
  }, copy$7 = function(t2, a2) {
    return t2[0] = a2[0], t2[1] = a2[1], t2[2] = a2[2], t2[3] = a2[3], t2[4] = a2[4], t2[5] = a2[5], t2;
  }, identity$4 = function(t2) {
    return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2[4] = 0, t2[5] = 0, t2;
  }, fromValues$7 = function(t2, a2, r2, n, e, o2) {
    var u2 = new ARRAY_TYPE(6);
    return u2[0] = t2, u2[1] = a2, u2[2] = r2, u2[3] = n, u2[4] = e, u2[5] = o2, u2;
  }, set$7 = function(t2, a2, r2, n, e, o2, u2) {
    return t2[0] = a2, t2[1] = r2, t2[2] = n, t2[3] = e, t2[4] = o2, t2[5] = u2, t2;
  }, invert$4 = function(t2, a2) {
    var r2 = a2[0], n = a2[1], e = a2[2], o2 = a2[3], u2 = a2[4], s = a2[5], i = r2 * o2 - n * e;
    return i ? (i = 1 / i, t2[0] = o2 * i, t2[1] = -n * i, t2[2] = -e * i, t2[3] = r2 * i, t2[4] = (e * s - o2 * u2) * i, t2[5] = (n * u2 - r2 * s) * i, t2) : null;
  }, determinant$2 = function(t2) {
    return t2[0] * t2[3] - t2[1] * t2[2];
  }, multiply$7 = function(t2, a2, r2) {
    var n = a2[0], e = a2[1], o2 = a2[2], u2 = a2[3], s = a2[4], i = a2[5], c2 = r2[0], l = r2[1], $ = r2[2], h2 = r2[3], f2 = r2[4], M2 = r2[5];
    return t2[0] = n * c2 + o2 * l, t2[1] = e * c2 + u2 * l, t2[2] = n * $ + o2 * h2, t2[3] = e * $ + u2 * h2, t2[4] = n * f2 + o2 * M2 + s, t2[5] = e * f2 + u2 * M2 + i, t2;
  }, rotate$3 = function(t2, a2, r2) {
    var n = a2[0], e = a2[1], o2 = a2[2], u2 = a2[3], s = a2[4], i = a2[5], c2 = Math.sin(r2), l = Math.cos(r2);
    return t2[0] = n * l + o2 * c2, t2[1] = e * l + u2 * c2, t2[2] = n * -c2 + o2 * l, t2[3] = e * -c2 + u2 * l, t2[4] = s, t2[5] = i, t2;
  }, scale$7 = function(t2, a2, r2) {
    var n = a2[0], e = a2[1], o2 = a2[2], u2 = a2[3], s = a2[4], i = a2[5], c2 = r2[0], l = r2[1];
    return t2[0] = n * c2, t2[1] = e * c2, t2[2] = o2 * l, t2[3] = u2 * l, t2[4] = s, t2[5] = i, t2;
  }, translate$3 = function(t2, a2, r2) {
    var n = a2[0], e = a2[1], o2 = a2[2], u2 = a2[3], s = a2[4], i = a2[5], c2 = r2[0], l = r2[1];
    return t2[0] = n, t2[1] = e, t2[2] = o2, t2[3] = u2, t2[4] = n * c2 + o2 * l + s, t2[5] = e * c2 + u2 * l + i, t2;
  }, fromRotation$3 = function(t2, a2) {
    var r2 = Math.sin(a2), n = Math.cos(a2);
    return t2[0] = n, t2[1] = r2, t2[2] = -r2, t2[3] = n, t2[4] = 0, t2[5] = 0, t2;
  }, fromScaling$2 = function(t2, a2) {
    return t2[0] = a2[0], t2[1] = 0, t2[2] = 0, t2[3] = a2[1], t2[4] = 0, t2[5] = 0, t2;
  }, fromTranslation$3 = function(t2, a2) {
    return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2[4] = a2[0], t2[5] = a2[1], t2;
  }, str$7 = function(t2) {
    return "mat2d(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ", " + t2[3] + ", " + t2[4] + ", " + t2[5] + ")";
  }, frob$2 = function(t2) {
    return Math.hypot(t2[0], t2[1], t2[2], t2[3], t2[4], t2[5], 1);
  }, add$7 = function(t2, a2, r2) {
    return t2[0] = a2[0] + r2[0], t2[1] = a2[1] + r2[1], t2[2] = a2[2] + r2[2], t2[3] = a2[3] + r2[3], t2[4] = a2[4] + r2[4], t2[5] = a2[5] + r2[5], t2;
  }, subtract$5 = function(t2, a2, r2) {
    return t2[0] = a2[0] - r2[0], t2[1] = a2[1] - r2[1], t2[2] = a2[2] - r2[2], t2[3] = a2[3] - r2[3], t2[4] = a2[4] - r2[4], t2[5] = a2[5] - r2[5], t2;
  }, multiplyScalar$2 = function(t2, a2, r2) {
    return t2[0] = a2[0] * r2, t2[1] = a2[1] * r2, t2[2] = a2[2] * r2, t2[3] = a2[3] * r2, t2[4] = a2[4] * r2, t2[5] = a2[5] * r2, t2;
  }, multiplyScalarAndAdd$2 = function(t2, a2, r2, n) {
    return t2[0] = a2[0] + r2[0] * n, t2[1] = a2[1] + r2[1] * n, t2[2] = a2[2] + r2[2] * n, t2[3] = a2[3] + r2[3] * n, t2[4] = a2[4] + r2[4] * n, t2[5] = a2[5] + r2[5] * n, t2;
  }, exactEquals$7 = function(t2, a2) {
    return t2[0] === a2[0] && t2[1] === a2[1] && t2[2] === a2[2] && t2[3] === a2[3] && t2[4] === a2[4] && t2[5] === a2[5];
  }, equals$7 = function(t2, a2) {
    var r2 = t2[0], n = t2[1], e = t2[2], o2 = t2[3], u2 = t2[4], s = t2[5], i = a2[0], c2 = a2[1], l = a2[2], $ = a2[3], h2 = a2[4], f2 = a2[5];
    return Math.abs(r2 - i) <= EPSILON * Math.max(1, Math.abs(r2), Math.abs(i)) && Math.abs(n - c2) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(c2)) && Math.abs(e - l) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(l)) && Math.abs(o2 - $) <= EPSILON * Math.max(1, Math.abs(o2), Math.abs($)) && Math.abs(u2 - h2) <= EPSILON * Math.max(1, Math.abs(u2), Math.abs(h2)) && Math.abs(s - f2) <= EPSILON * Math.max(1, Math.abs(s), Math.abs(f2));
  }, create$6 = function() {
    var t2 = new ARRAY_TYPE(9);
    return ARRAY_TYPE != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[5] = 0, t2[6] = 0, t2[7] = 0), t2[0] = 1, t2[4] = 1, t2[8] = 1, t2;
  }, fromMat4$1 = function(t2, a2) {
    return t2[0] = a2[0], t2[1] = a2[1], t2[2] = a2[2], t2[3] = a2[4], t2[4] = a2[5], t2[5] = a2[6], t2[6] = a2[8], t2[7] = a2[9], t2[8] = a2[10], t2;
  }, clone$6 = function(t2) {
    var a2 = new ARRAY_TYPE(9);
    return a2[0] = t2[0], a2[1] = t2[1], a2[2] = t2[2], a2[3] = t2[3], a2[4] = t2[4], a2[5] = t2[5], a2[6] = t2[6], a2[7] = t2[7], a2[8] = t2[8], a2;
  }, copy$6 = function(t2, a2) {
    return t2[0] = a2[0], t2[1] = a2[1], t2[2] = a2[2], t2[3] = a2[3], t2[4] = a2[4], t2[5] = a2[5], t2[6] = a2[6], t2[7] = a2[7], t2[8] = a2[8], t2;
  }, fromValues$6 = function(t2, a2, r2, n, e, o2, u2, s, i) {
    var c2 = new ARRAY_TYPE(9);
    return c2[0] = t2, c2[1] = a2, c2[2] = r2, c2[3] = n, c2[4] = e, c2[5] = o2, c2[6] = u2, c2[7] = s, c2[8] = i, c2;
  }, set$6 = function(t2, a2, r2, n, e, o2, u2, s, i, c2) {
    return t2[0] = a2, t2[1] = r2, t2[2] = n, t2[3] = e, t2[4] = o2, t2[5] = u2, t2[6] = s, t2[7] = i, t2[8] = c2, t2;
  }, identity$3 = function(t2) {
    return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 1, t2[5] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 1, t2;
  }, transpose$1 = function(t2, a2) {
    if (t2 === a2) {
      var r2 = a2[1], n = a2[2], e = a2[5];
      t2[1] = a2[3], t2[2] = a2[6], t2[3] = r2, t2[5] = a2[7], t2[6] = n, t2[7] = e;
    } else t2[0] = a2[0], t2[1] = a2[3], t2[2] = a2[6], t2[3] = a2[1], t2[4] = a2[4], t2[5] = a2[7], t2[6] = a2[2], t2[7] = a2[5], t2[8] = a2[8];
    return t2;
  }, invert$3 = function(t2, a2) {
    var r2 = a2[0], n = a2[1], e = a2[2], o2 = a2[3], u2 = a2[4], s = a2[5], i = a2[6], c2 = a2[7], l = a2[8], $ = l * u2 - s * c2, h2 = -l * o2 + s * i, f2 = c2 * o2 - u2 * i, M2 = r2 * $ + n * h2 + e * f2;
    return M2 ? (M2 = 1 / M2, t2[0] = $ * M2, t2[1] = (-l * n + e * c2) * M2, t2[2] = (s * n - e * u2) * M2, t2[3] = h2 * M2, t2[4] = (l * r2 - e * i) * M2, t2[5] = (-s * r2 + e * o2) * M2, t2[6] = f2 * M2, t2[7] = (-c2 * r2 + n * i) * M2, t2[8] = (u2 * r2 - n * o2) * M2, t2) : null;
  }, adjoint$1 = function(t2, a2) {
    var r2 = a2[0], n = a2[1], e = a2[2], o2 = a2[3], u2 = a2[4], s = a2[5], i = a2[6], c2 = a2[7], l = a2[8];
    return t2[0] = u2 * l - s * c2, t2[1] = e * c2 - n * l, t2[2] = n * s - e * u2, t2[3] = s * i - o2 * l, t2[4] = r2 * l - e * i, t2[5] = e * o2 - r2 * s, t2[6] = o2 * c2 - u2 * i, t2[7] = n * i - r2 * c2, t2[8] = r2 * u2 - n * o2, t2;
  }, determinant$1 = function(t2) {
    var a2 = t2[0], r2 = t2[1], n = t2[2], e = t2[3], o2 = t2[4], u2 = t2[5], s = t2[6], i = t2[7], c2 = t2[8];
    return a2 * (c2 * o2 - u2 * i) + r2 * (-c2 * e + u2 * s) + n * (i * e - o2 * s);
  }, multiply$6 = function(t2, a2, r2) {
    var n = a2[0], e = a2[1], o2 = a2[2], u2 = a2[3], s = a2[4], i = a2[5], c2 = a2[6], l = a2[7], $ = a2[8], h2 = r2[0], f2 = r2[1], M2 = r2[2], m2 = r2[3], d2 = r2[4], v2 = r2[5], b2 = r2[6], p2 = r2[7], A = r2[8];
    return t2[0] = h2 * n + f2 * u2 + M2 * c2, t2[1] = h2 * e + f2 * s + M2 * l, t2[2] = h2 * o2 + f2 * i + M2 * $, t2[3] = m2 * n + d2 * u2 + v2 * c2, t2[4] = m2 * e + d2 * s + v2 * l, t2[5] = m2 * o2 + d2 * i + v2 * $, t2[6] = b2 * n + p2 * u2 + A * c2, t2[7] = b2 * e + p2 * s + A * l, t2[8] = b2 * o2 + p2 * i + A * $, t2;
  }, translate$2 = function(t2, a2, r2) {
    var n = a2[0], e = a2[1], o2 = a2[2], u2 = a2[3], s = a2[4], i = a2[5], c2 = a2[6], l = a2[7], $ = a2[8], h2 = r2[0], f2 = r2[1];
    return t2[0] = n, t2[1] = e, t2[2] = o2, t2[3] = u2, t2[4] = s, t2[5] = i, t2[6] = h2 * n + f2 * u2 + c2, t2[7] = h2 * e + f2 * s + l, t2[8] = h2 * o2 + f2 * i + $, t2;
  }, rotate$2 = function(t2, a2, r2) {
    var n = a2[0], e = a2[1], o2 = a2[2], u2 = a2[3], s = a2[4], i = a2[5], c2 = a2[6], l = a2[7], $ = a2[8], h2 = Math.sin(r2), f2 = Math.cos(r2);
    return t2[0] = f2 * n + h2 * u2, t2[1] = f2 * e + h2 * s, t2[2] = f2 * o2 + h2 * i, t2[3] = f2 * u2 - h2 * n, t2[4] = f2 * s - h2 * e, t2[5] = f2 * i - h2 * o2, t2[6] = c2, t2[7] = l, t2[8] = $, t2;
  }, scale$6 = function(t2, a2, r2) {
    var n = r2[0], e = r2[1];
    return t2[0] = n * a2[0], t2[1] = n * a2[1], t2[2] = n * a2[2], t2[3] = e * a2[3], t2[4] = e * a2[4], t2[5] = e * a2[5], t2[6] = a2[6], t2[7] = a2[7], t2[8] = a2[8], t2;
  }, fromTranslation$2 = function(t2, a2) {
    return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 1, t2[5] = 0, t2[6] = a2[0], t2[7] = a2[1], t2[8] = 1, t2;
  }, fromRotation$2 = function(t2, a2) {
    var r2 = Math.sin(a2), n = Math.cos(a2);
    return t2[0] = n, t2[1] = r2, t2[2] = 0, t2[3] = -r2, t2[4] = n, t2[5] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 1, t2;
  }, fromScaling$1 = function(t2, a2) {
    return t2[0] = a2[0], t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = a2[1], t2[5] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 1, t2;
  }, fromMat2d = function(t2, a2) {
    return t2[0] = a2[0], t2[1] = a2[1], t2[2] = 0, t2[3] = a2[2], t2[4] = a2[3], t2[5] = 0, t2[6] = a2[4], t2[7] = a2[5], t2[8] = 1, t2;
  }, fromQuat$1 = function(t2, a2) {
    var r2 = a2[0], n = a2[1], e = a2[2], o2 = a2[3], u2 = r2 + r2, s = n + n, i = e + e, c2 = r2 * u2, l = n * u2, $ = n * s, h2 = e * u2, f2 = e * s, M2 = e * i, m2 = o2 * u2, d2 = o2 * s, v2 = o2 * i;
    return t2[0] = 1 - $ - M2, t2[3] = l - v2, t2[6] = h2 + d2, t2[1] = l + v2, t2[4] = 1 - c2 - M2, t2[7] = f2 - m2, t2[2] = h2 - d2, t2[5] = f2 + m2, t2[8] = 1 - c2 - $, t2;
  }, normalFromMat4 = function(t2, a2) {
    var r2 = a2[0], n = a2[1], e = a2[2], o2 = a2[3], u2 = a2[4], s = a2[5], i = a2[6], c2 = a2[7], l = a2[8], $ = a2[9], h2 = a2[10], f2 = a2[11], M2 = a2[12], m2 = a2[13], d2 = a2[14], v2 = a2[15], b2 = r2 * s - n * u2, p2 = r2 * i - e * u2, A = r2 * c2 - o2 * u2, y2 = n * i - e * s, g2 = n * c2 - o2 * s, R = e * c2 - o2 * i, E2 = l * m2 - $ * M2, q = l * d2 - h2 * M2, x2 = l * v2 - f2 * M2, P2 = $ * d2 - h2 * m2, L = $ * v2 - f2 * m2, O2 = h2 * v2 - f2 * d2, S2 = b2 * O2 - p2 * L + A * P2 + y2 * x2 - g2 * q + R * E2;
    return S2 ? (S2 = 1 / S2, t2[0] = (s * O2 - i * L + c2 * P2) * S2, t2[1] = (i * x2 - u2 * O2 - c2 * q) * S2, t2[2] = (u2 * L - s * x2 + c2 * E2) * S2, t2[3] = (e * L - n * O2 - o2 * P2) * S2, t2[4] = (r2 * O2 - e * x2 + o2 * q) * S2, t2[5] = (n * x2 - r2 * L - o2 * E2) * S2, t2[6] = (m2 * R - d2 * g2 + v2 * y2) * S2, t2[7] = (d2 * A - M2 * R - v2 * p2) * S2, t2[8] = (M2 * g2 - m2 * A + v2 * b2) * S2, t2) : null;
  }, projection = function(t2, a2, r2) {
    return t2[0] = 2 / a2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = -2 / r2, t2[5] = 0, t2[6] = -1, t2[7] = 1, t2[8] = 1, t2;
  }, str$6 = function(t2) {
    return "mat3(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ", " + t2[3] + ", " + t2[4] + ", " + t2[5] + ", " + t2[6] + ", " + t2[7] + ", " + t2[8] + ")";
  }, frob$1 = function(t2) {
    return Math.hypot(t2[0], t2[1], t2[2], t2[3], t2[4], t2[5], t2[6], t2[7], t2[8]);
  }, add$6 = function(t2, a2, r2) {
    return t2[0] = a2[0] + r2[0], t2[1] = a2[1] + r2[1], t2[2] = a2[2] + r2[2], t2[3] = a2[3] + r2[3], t2[4] = a2[4] + r2[4], t2[5] = a2[5] + r2[5], t2[6] = a2[6] + r2[6], t2[7] = a2[7] + r2[7], t2[8] = a2[8] + r2[8], t2;
  }, subtract$4 = function(t2, a2, r2) {
    return t2[0] = a2[0] - r2[0], t2[1] = a2[1] - r2[1], t2[2] = a2[2] - r2[2], t2[3] = a2[3] - r2[3], t2[4] = a2[4] - r2[4], t2[5] = a2[5] - r2[5], t2[6] = a2[6] - r2[6], t2[7] = a2[7] - r2[7], t2[8] = a2[8] - r2[8], t2;
  }, multiplyScalar$1 = function(t2, a2, r2) {
    return t2[0] = a2[0] * r2, t2[1] = a2[1] * r2, t2[2] = a2[2] * r2, t2[3] = a2[3] * r2, t2[4] = a2[4] * r2, t2[5] = a2[5] * r2, t2[6] = a2[6] * r2, t2[7] = a2[7] * r2, t2[8] = a2[8] * r2, t2;
  }, multiplyScalarAndAdd$1 = function(t2, a2, r2, n) {
    return t2[0] = a2[0] + r2[0] * n, t2[1] = a2[1] + r2[1] * n, t2[2] = a2[2] + r2[2] * n, t2[3] = a2[3] + r2[3] * n, t2[4] = a2[4] + r2[4] * n, t2[5] = a2[5] + r2[5] * n, t2[6] = a2[6] + r2[6] * n, t2[7] = a2[7] + r2[7] * n, t2[8] = a2[8] + r2[8] * n, t2;
  }, exactEquals$6 = function(t2, a2) {
    return t2[0] === a2[0] && t2[1] === a2[1] && t2[2] === a2[2] && t2[3] === a2[3] && t2[4] === a2[4] && t2[5] === a2[5] && t2[6] === a2[6] && t2[7] === a2[7] && t2[8] === a2[8];
  }, equals$6 = function(t2, a2) {
    var r2 = t2[0], n = t2[1], e = t2[2], o2 = t2[3], u2 = t2[4], s = t2[5], i = t2[6], c2 = t2[7], l = t2[8], $ = a2[0], h2 = a2[1], f2 = a2[2], M2 = a2[3], m2 = a2[4], d2 = a2[5], v2 = a2[6], b2 = a2[7], p2 = a2[8];
    return Math.abs(r2 - $) <= EPSILON * Math.max(1, Math.abs(r2), Math.abs($)) && Math.abs(n - h2) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(h2)) && Math.abs(e - f2) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(f2)) && Math.abs(o2 - M2) <= EPSILON * Math.max(1, Math.abs(o2), Math.abs(M2)) && Math.abs(u2 - m2) <= EPSILON * Math.max(1, Math.abs(u2), Math.abs(m2)) && Math.abs(s - d2) <= EPSILON * Math.max(1, Math.abs(s), Math.abs(d2)) && Math.abs(i - v2) <= EPSILON * Math.max(1, Math.abs(i), Math.abs(v2)) && Math.abs(c2 - b2) <= EPSILON * Math.max(1, Math.abs(c2), Math.abs(b2)) && Math.abs(l - p2) <= EPSILON * Math.max(1, Math.abs(l), Math.abs(p2));
  }, create$5 = function() {
    var t2 = new ARRAY_TYPE(16);
    return ARRAY_TYPE != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0), t2[0] = 1, t2[5] = 1, t2[10] = 1, t2[15] = 1, t2;
  }, clone$5 = function(t2) {
    var a2 = new ARRAY_TYPE(16);
    return a2[0] = t2[0], a2[1] = t2[1], a2[2] = t2[2], a2[3] = t2[3], a2[4] = t2[4], a2[5] = t2[5], a2[6] = t2[6], a2[7] = t2[7], a2[8] = t2[8], a2[9] = t2[9], a2[10] = t2[10], a2[11] = t2[11], a2[12] = t2[12], a2[13] = t2[13], a2[14] = t2[14], a2[15] = t2[15], a2;
  }, copy$5 = function(t2, a2) {
    return t2[0] = a2[0], t2[1] = a2[1], t2[2] = a2[2], t2[3] = a2[3], t2[4] = a2[4], t2[5] = a2[5], t2[6] = a2[6], t2[7] = a2[7], t2[8] = a2[8], t2[9] = a2[9], t2[10] = a2[10], t2[11] = a2[11], t2[12] = a2[12], t2[13] = a2[13], t2[14] = a2[14], t2[15] = a2[15], t2;
  }, fromValues$5 = function(t2, a2, r2, n, e, o2, u2, s, i, c2, l, $, h2, f2, M2, m2) {
    var d2 = new ARRAY_TYPE(16);
    return d2[0] = t2, d2[1] = a2, d2[2] = r2, d2[3] = n, d2[4] = e, d2[5] = o2, d2[6] = u2, d2[7] = s, d2[8] = i, d2[9] = c2, d2[10] = l, d2[11] = $, d2[12] = h2, d2[13] = f2, d2[14] = M2, d2[15] = m2, d2;
  }, set$5 = function(t2, a2, r2, n, e, o2, u2, s, i, c2, l, $, h2, f2, M2, m2, d2) {
    return t2[0] = a2, t2[1] = r2, t2[2] = n, t2[3] = e, t2[4] = o2, t2[5] = u2, t2[6] = s, t2[7] = i, t2[8] = c2, t2[9] = l, t2[10] = $, t2[11] = h2, t2[12] = f2, t2[13] = M2, t2[14] = m2, t2[15] = d2, t2;
  }, identity$2 = function(t2) {
    return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
  }, transpose = function(t2, a2) {
    if (t2 === a2) {
      var r2 = a2[1], n = a2[2], e = a2[3], o2 = a2[6], u2 = a2[7], s = a2[11];
      t2[1] = a2[4], t2[2] = a2[8], t2[3] = a2[12], t2[4] = r2, t2[6] = a2[9], t2[7] = a2[13], t2[8] = n, t2[9] = o2, t2[11] = a2[14], t2[12] = e, t2[13] = u2, t2[14] = s;
    } else t2[0] = a2[0], t2[1] = a2[4], t2[2] = a2[8], t2[3] = a2[12], t2[4] = a2[1], t2[5] = a2[5], t2[6] = a2[9], t2[7] = a2[13], t2[8] = a2[2], t2[9] = a2[6], t2[10] = a2[10], t2[11] = a2[14], t2[12] = a2[3], t2[13] = a2[7], t2[14] = a2[11], t2[15] = a2[15];
    return t2;
  }, invert$2 = function(t2, a2) {
    var r2 = a2[0], n = a2[1], e = a2[2], o2 = a2[3], u2 = a2[4], s = a2[5], i = a2[6], c2 = a2[7], l = a2[8], $ = a2[9], h2 = a2[10], f2 = a2[11], M2 = a2[12], m2 = a2[13], d2 = a2[14], v2 = a2[15], b2 = r2 * s - n * u2, p2 = r2 * i - e * u2, A = r2 * c2 - o2 * u2, y2 = n * i - e * s, g2 = n * c2 - o2 * s, R = e * c2 - o2 * i, E2 = l * m2 - $ * M2, q = l * d2 - h2 * M2, x2 = l * v2 - f2 * M2, P2 = $ * d2 - h2 * m2, L = $ * v2 - f2 * m2, O2 = h2 * v2 - f2 * d2, S2 = b2 * O2 - p2 * L + A * P2 + y2 * x2 - g2 * q + R * E2;
    return S2 ? (S2 = 1 / S2, t2[0] = (s * O2 - i * L + c2 * P2) * S2, t2[1] = (e * L - n * O2 - o2 * P2) * S2, t2[2] = (m2 * R - d2 * g2 + v2 * y2) * S2, t2[3] = (h2 * g2 - $ * R - f2 * y2) * S2, t2[4] = (i * x2 - u2 * O2 - c2 * q) * S2, t2[5] = (r2 * O2 - e * x2 + o2 * q) * S2, t2[6] = (d2 * A - M2 * R - v2 * p2) * S2, t2[7] = (l * R - h2 * A + f2 * p2) * S2, t2[8] = (u2 * L - s * x2 + c2 * E2) * S2, t2[9] = (n * x2 - r2 * L - o2 * E2) * S2, t2[10] = (M2 * g2 - m2 * A + v2 * b2) * S2, t2[11] = ($ * A - l * g2 - f2 * b2) * S2, t2[12] = (s * q - u2 * P2 - i * E2) * S2, t2[13] = (r2 * P2 - n * q + e * E2) * S2, t2[14] = (m2 * p2 - M2 * y2 - d2 * b2) * S2, t2[15] = (l * y2 - $ * p2 + h2 * b2) * S2, t2) : null;
  }, adjoint = function(t2, a2) {
    var r2 = a2[0], n = a2[1], e = a2[2], o2 = a2[3], u2 = a2[4], s = a2[5], i = a2[6], c2 = a2[7], l = a2[8], $ = a2[9], h2 = a2[10], f2 = a2[11], M2 = a2[12], m2 = a2[13], d2 = a2[14], v2 = a2[15], b2 = r2 * s - n * u2, p2 = r2 * i - e * u2, A = r2 * c2 - o2 * u2, y2 = n * i - e * s, g2 = n * c2 - o2 * s, R = e * c2 - o2 * i, E2 = l * m2 - $ * M2, q = l * d2 - h2 * M2, x2 = l * v2 - f2 * M2, P2 = $ * d2 - h2 * m2, L = $ * v2 - f2 * m2, O2 = h2 * v2 - f2 * d2;
    return t2[0] = s * O2 - i * L + c2 * P2, t2[1] = e * L - n * O2 - o2 * P2, t2[2] = m2 * R - d2 * g2 + v2 * y2, t2[3] = h2 * g2 - $ * R - f2 * y2, t2[4] = i * x2 - u2 * O2 - c2 * q, t2[5] = r2 * O2 - e * x2 + o2 * q, t2[6] = d2 * A - M2 * R - v2 * p2, t2[7] = l * R - h2 * A + f2 * p2, t2[8] = u2 * L - s * x2 + c2 * E2, t2[9] = n * x2 - r2 * L - o2 * E2, t2[10] = M2 * g2 - m2 * A + v2 * b2, t2[11] = $ * A - l * g2 - f2 * b2, t2[12] = s * q - u2 * P2 - i * E2, t2[13] = r2 * P2 - n * q + e * E2, t2[14] = m2 * p2 - M2 * y2 - d2 * b2, t2[15] = l * y2 - $ * p2 + h2 * b2, t2;
  }, determinant = function(t2) {
    var a2 = t2[0], r2 = t2[1], n = t2[2], e = t2[3], o2 = t2[4], u2 = t2[5], s = t2[6], i = t2[7], c2 = t2[8], l = t2[9], $ = t2[10], h2 = t2[11], f2 = t2[12], M2 = t2[13], m2 = t2[14], d2 = a2 * u2 - r2 * o2, v2 = a2 * s - n * o2, b2 = r2 * s - n * u2, p2 = c2 * M2 - l * f2, A = c2 * m2 - $ * f2, y2 = l * m2 - $ * M2;
    return i * (a2 * y2 - r2 * A + n * p2) - e * (o2 * y2 - u2 * A + s * p2) + t2[15] * (c2 * b2 - l * v2 + $ * d2) - h2 * (f2 * b2 - M2 * v2 + m2 * d2);
  }, multiply$5 = function(t2, a2, r2) {
    var n = a2[0], e = a2[1], o2 = a2[2], u2 = a2[3], s = a2[4], i = a2[5], c2 = a2[6], l = a2[7], $ = a2[8], h2 = a2[9], f2 = a2[10], M2 = a2[11], m2 = a2[12], d2 = a2[13], v2 = a2[14], b2 = a2[15], p2 = r2[0], A = r2[1], y2 = r2[2], g2 = r2[3];
    return t2[0] = p2 * n + A * s + y2 * $ + g2 * m2, t2[1] = p2 * e + A * i + y2 * h2 + g2 * d2, t2[2] = p2 * o2 + A * c2 + y2 * f2 + g2 * v2, t2[3] = p2 * u2 + A * l + y2 * M2 + g2 * b2, p2 = r2[4], A = r2[5], y2 = r2[6], g2 = r2[7], t2[4] = p2 * n + A * s + y2 * $ + g2 * m2, t2[5] = p2 * e + A * i + y2 * h2 + g2 * d2, t2[6] = p2 * o2 + A * c2 + y2 * f2 + g2 * v2, t2[7] = p2 * u2 + A * l + y2 * M2 + g2 * b2, p2 = r2[8], A = r2[9], y2 = r2[10], g2 = r2[11], t2[8] = p2 * n + A * s + y2 * $ + g2 * m2, t2[9] = p2 * e + A * i + y2 * h2 + g2 * d2, t2[10] = p2 * o2 + A * c2 + y2 * f2 + g2 * v2, t2[11] = p2 * u2 + A * l + y2 * M2 + g2 * b2, p2 = r2[12], A = r2[13], y2 = r2[14], g2 = r2[15], t2[12] = p2 * n + A * s + y2 * $ + g2 * m2, t2[13] = p2 * e + A * i + y2 * h2 + g2 * d2, t2[14] = p2 * o2 + A * c2 + y2 * f2 + g2 * v2, t2[15] = p2 * u2 + A * l + y2 * M2 + g2 * b2, t2;
  }, translate$1 = function(t2, a2, r2) {
    var n, e, o2, u2, s, i, c2, l, $, h2, f2, M2, m2 = r2[0], d2 = r2[1], v2 = r2[2];
    return a2 === t2 ? (t2[12] = a2[0] * m2 + a2[4] * d2 + a2[8] * v2 + a2[12], t2[13] = a2[1] * m2 + a2[5] * d2 + a2[9] * v2 + a2[13], t2[14] = a2[2] * m2 + a2[6] * d2 + a2[10] * v2 + a2[14], t2[15] = a2[3] * m2 + a2[7] * d2 + a2[11] * v2 + a2[15]) : (n = a2[0], e = a2[1], o2 = a2[2], u2 = a2[3], s = a2[4], i = a2[5], c2 = a2[6], l = a2[7], $ = a2[8], h2 = a2[9], f2 = a2[10], M2 = a2[11], t2[0] = n, t2[1] = e, t2[2] = o2, t2[3] = u2, t2[4] = s, t2[5] = i, t2[6] = c2, t2[7] = l, t2[8] = $, t2[9] = h2, t2[10] = f2, t2[11] = M2, t2[12] = n * m2 + s * d2 + $ * v2 + a2[12], t2[13] = e * m2 + i * d2 + h2 * v2 + a2[13], t2[14] = o2 * m2 + c2 * d2 + f2 * v2 + a2[14], t2[15] = u2 * m2 + l * d2 + M2 * v2 + a2[15]), t2;
  }, scale$5 = function(t2, a2, r2) {
    var n = r2[0], e = r2[1], o2 = r2[2];
    return t2[0] = a2[0] * n, t2[1] = a2[1] * n, t2[2] = a2[2] * n, t2[3] = a2[3] * n, t2[4] = a2[4] * e, t2[5] = a2[5] * e, t2[6] = a2[6] * e, t2[7] = a2[7] * e, t2[8] = a2[8] * o2, t2[9] = a2[9] * o2, t2[10] = a2[10] * o2, t2[11] = a2[11] * o2, t2[12] = a2[12], t2[13] = a2[13], t2[14] = a2[14], t2[15] = a2[15], t2;
  }, rotate$1 = function(t2, a2, r2, n) {
    var e, o2, u2, s, i, c2, l, $, h2, f2, M2, m2, d2, v2, b2, p2, A, y2, g2, R, E2, q, x2, P2, L = n[0], O2 = n[1], S2 = n[2], Y = Math.hypot(L, O2, S2);
    return Y < EPSILON ? null : (L *= Y = 1 / Y, O2 *= Y, S2 *= Y, e = Math.sin(r2), u2 = 1 - (o2 = Math.cos(r2)), s = a2[0], i = a2[1], c2 = a2[2], l = a2[3], $ = a2[4], h2 = a2[5], f2 = a2[6], M2 = a2[7], m2 = a2[8], d2 = a2[9], v2 = a2[10], b2 = a2[11], p2 = L * L * u2 + o2, A = O2 * L * u2 + S2 * e, y2 = S2 * L * u2 - O2 * e, g2 = L * O2 * u2 - S2 * e, R = O2 * O2 * u2 + o2, E2 = S2 * O2 * u2 + L * e, q = L * S2 * u2 + O2 * e, x2 = O2 * S2 * u2 - L * e, P2 = S2 * S2 * u2 + o2, t2[0] = s * p2 + $ * A + m2 * y2, t2[1] = i * p2 + h2 * A + d2 * y2, t2[2] = c2 * p2 + f2 * A + v2 * y2, t2[3] = l * p2 + M2 * A + b2 * y2, t2[4] = s * g2 + $ * R + m2 * E2, t2[5] = i * g2 + h2 * R + d2 * E2, t2[6] = c2 * g2 + f2 * R + v2 * E2, t2[7] = l * g2 + M2 * R + b2 * E2, t2[8] = s * q + $ * x2 + m2 * P2, t2[9] = i * q + h2 * x2 + d2 * P2, t2[10] = c2 * q + f2 * x2 + v2 * P2, t2[11] = l * q + M2 * x2 + b2 * P2, a2 !== t2 && (t2[12] = a2[12], t2[13] = a2[13], t2[14] = a2[14], t2[15] = a2[15]), t2);
  }, rotateX$3 = function(t2, a2, r2) {
    var n = Math.sin(r2), e = Math.cos(r2), o2 = a2[4], u2 = a2[5], s = a2[6], i = a2[7], c2 = a2[8], l = a2[9], $ = a2[10], h2 = a2[11];
    return a2 !== t2 && (t2[0] = a2[0], t2[1] = a2[1], t2[2] = a2[2], t2[3] = a2[3], t2[12] = a2[12], t2[13] = a2[13], t2[14] = a2[14], t2[15] = a2[15]), t2[4] = o2 * e + c2 * n, t2[5] = u2 * e + l * n, t2[6] = s * e + $ * n, t2[7] = i * e + h2 * n, t2[8] = c2 * e - o2 * n, t2[9] = l * e - u2 * n, t2[10] = $ * e - s * n, t2[11] = h2 * e - i * n, t2;
  }, rotateY$3 = function(t2, a2, r2) {
    var n = Math.sin(r2), e = Math.cos(r2), o2 = a2[0], u2 = a2[1], s = a2[2], i = a2[3], c2 = a2[8], l = a2[9], $ = a2[10], h2 = a2[11];
    return a2 !== t2 && (t2[4] = a2[4], t2[5] = a2[5], t2[6] = a2[6], t2[7] = a2[7], t2[12] = a2[12], t2[13] = a2[13], t2[14] = a2[14], t2[15] = a2[15]), t2[0] = o2 * e - c2 * n, t2[1] = u2 * e - l * n, t2[2] = s * e - $ * n, t2[3] = i * e - h2 * n, t2[8] = o2 * n + c2 * e, t2[9] = u2 * n + l * e, t2[10] = s * n + $ * e, t2[11] = i * n + h2 * e, t2;
  }, rotateZ$3 = function(t2, a2, r2) {
    var n = Math.sin(r2), e = Math.cos(r2), o2 = a2[0], u2 = a2[1], s = a2[2], i = a2[3], c2 = a2[4], l = a2[5], $ = a2[6], h2 = a2[7];
    return a2 !== t2 && (t2[8] = a2[8], t2[9] = a2[9], t2[10] = a2[10], t2[11] = a2[11], t2[12] = a2[12], t2[13] = a2[13], t2[14] = a2[14], t2[15] = a2[15]), t2[0] = o2 * e + c2 * n, t2[1] = u2 * e + l * n, t2[2] = s * e + $ * n, t2[3] = i * e + h2 * n, t2[4] = c2 * e - o2 * n, t2[5] = l * e - u2 * n, t2[6] = $ * e - s * n, t2[7] = h2 * e - i * n, t2;
  }, fromTranslation$1 = function(t2, a2) {
    return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = a2[0], t2[13] = a2[1], t2[14] = a2[2], t2[15] = 1, t2;
  }, fromScaling = function(t2, a2) {
    return t2[0] = a2[0], t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = a2[1], t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = a2[2], t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
  }, fromRotation$1 = function(t2, a2, r2) {
    var n, e, o2, u2 = r2[0], s = r2[1], i = r2[2], c2 = Math.hypot(u2, s, i);
    return c2 < EPSILON ? null : (u2 *= c2 = 1 / c2, s *= c2, i *= c2, n = Math.sin(a2), o2 = 1 - (e = Math.cos(a2)), t2[0] = u2 * u2 * o2 + e, t2[1] = s * u2 * o2 + i * n, t2[2] = i * u2 * o2 - s * n, t2[3] = 0, t2[4] = u2 * s * o2 - i * n, t2[5] = s * s * o2 + e, t2[6] = i * s * o2 + u2 * n, t2[7] = 0, t2[8] = u2 * i * o2 + s * n, t2[9] = s * i * o2 - u2 * n, t2[10] = i * i * o2 + e, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2);
  }, fromXRotation = function(t2, a2) {
    var r2 = Math.sin(a2), n = Math.cos(a2);
    return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = n, t2[6] = r2, t2[7] = 0, t2[8] = 0, t2[9] = -r2, t2[10] = n, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
  }, fromYRotation = function(t2, a2) {
    var r2 = Math.sin(a2), n = Math.cos(a2);
    return t2[0] = n, t2[1] = 0, t2[2] = -r2, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = r2, t2[9] = 0, t2[10] = n, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
  }, fromZRotation = function(t2, a2) {
    var r2 = Math.sin(a2), n = Math.cos(a2);
    return t2[0] = n, t2[1] = r2, t2[2] = 0, t2[3] = 0, t2[4] = -r2, t2[5] = n, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
  }, fromRotationTranslation$1 = function(t2, a2, r2) {
    var n = a2[0], e = a2[1], o2 = a2[2], u2 = a2[3], s = n + n, i = e + e, c2 = o2 + o2, l = n * s, $ = n * i, h2 = n * c2, f2 = e * i, M2 = e * c2, m2 = o2 * c2, d2 = u2 * s, v2 = u2 * i, b2 = u2 * c2;
    return t2[0] = 1 - (f2 + m2), t2[1] = $ + b2, t2[2] = h2 - v2, t2[3] = 0, t2[4] = $ - b2, t2[5] = 1 - (l + m2), t2[6] = M2 + d2, t2[7] = 0, t2[8] = h2 + v2, t2[9] = M2 - d2, t2[10] = 1 - (l + f2), t2[11] = 0, t2[12] = r2[0], t2[13] = r2[1], t2[14] = r2[2], t2[15] = 1, t2;
  }, fromQuat2 = function(t2, a2) {
    var r2 = new ARRAY_TYPE(3), n = -a2[0], e = -a2[1], o2 = -a2[2], u2 = a2[3], s = a2[4], i = a2[5], c2 = a2[6], l = a2[7], $ = n * n + e * e + o2 * o2 + u2 * u2;
    return $ > 0 ? (r2[0] = 2 * (s * u2 + l * n + i * o2 - c2 * e) / $, r2[1] = 2 * (i * u2 + l * e + c2 * n - s * o2) / $, r2[2] = 2 * (c2 * u2 + l * o2 + s * e - i * n) / $) : (r2[0] = 2 * (s * u2 + l * n + i * o2 - c2 * e), r2[1] = 2 * (i * u2 + l * e + c2 * n - s * o2), r2[2] = 2 * (c2 * u2 + l * o2 + s * e - i * n)), fromRotationTranslation$1(t2, a2, r2), t2;
  }, getTranslation$1 = function(t2, a2) {
    return t2[0] = a2[12], t2[1] = a2[13], t2[2] = a2[14], t2;
  }, getScaling = function(t2, a2) {
    var r2 = a2[0], n = a2[1], e = a2[2], o2 = a2[4], u2 = a2[5], s = a2[6], i = a2[8], c2 = a2[9], l = a2[10];
    return t2[0] = Math.hypot(r2, n, e), t2[1] = Math.hypot(o2, u2, s), t2[2] = Math.hypot(i, c2, l), t2;
  }, getRotation = function(t2, a2) {
    var r2 = new ARRAY_TYPE(3);
    getScaling(r2, a2);
    var n = 1 / r2[0], e = 1 / r2[1], o2 = 1 / r2[2], u2 = a2[0] * n, s = a2[1] * e, i = a2[2] * o2, c2 = a2[4] * n, l = a2[5] * e, $ = a2[6] * o2, h2 = a2[8] * n, f2 = a2[9] * e, M2 = a2[10] * o2, m2 = u2 + l + M2, d2 = 0;
    return m2 > 0 ? (d2 = 2 * Math.sqrt(m2 + 1), t2[3] = 0.25 * d2, t2[0] = ($ - f2) / d2, t2[1] = (h2 - i) / d2, t2[2] = (s - c2) / d2) : u2 > l && u2 > M2 ? (d2 = 2 * Math.sqrt(1 + u2 - l - M2), t2[3] = ($ - f2) / d2, t2[0] = 0.25 * d2, t2[1] = (s + c2) / d2, t2[2] = (h2 + i) / d2) : l > M2 ? (d2 = 2 * Math.sqrt(1 + l - u2 - M2), t2[3] = (h2 - i) / d2, t2[0] = (s + c2) / d2, t2[1] = 0.25 * d2, t2[2] = ($ + f2) / d2) : (d2 = 2 * Math.sqrt(1 + M2 - u2 - l), t2[3] = (s - c2) / d2, t2[0] = (h2 + i) / d2, t2[1] = ($ + f2) / d2, t2[2] = 0.25 * d2), t2;
  }, decompose = function(t2, a2, r2, n) {
    a2[0] = n[12], a2[1] = n[13], a2[2] = n[14];
    var e = n[0], o2 = n[1], u2 = n[2], s = n[4], i = n[5], c2 = n[6], l = n[8], $ = n[9], h2 = n[10];
    r2[0] = Math.hypot(e, o2, u2), r2[1] = Math.hypot(s, i, c2), r2[2] = Math.hypot(l, $, h2);
    var f2 = 1 / r2[0], M2 = 1 / r2[1], m2 = 1 / r2[2], d2 = e * f2, v2 = o2 * M2, b2 = u2 * m2, p2 = s * f2, A = i * M2, y2 = c2 * m2, g2 = l * f2, R = $ * M2, E2 = h2 * m2, q = d2 + A + E2, x2 = 0;
    return q > 0 ? (x2 = 2 * Math.sqrt(q + 1), t2[3] = 0.25 * x2, t2[0] = (y2 - R) / x2, t2[1] = (g2 - b2) / x2, t2[2] = (v2 - p2) / x2) : d2 > A && d2 > E2 ? (x2 = 2 * Math.sqrt(1 + d2 - A - E2), t2[3] = (y2 - R) / x2, t2[0] = 0.25 * x2, t2[1] = (v2 + p2) / x2, t2[2] = (g2 + b2) / x2) : A > E2 ? (x2 = 2 * Math.sqrt(1 + A - d2 - E2), t2[3] = (g2 - b2) / x2, t2[0] = (v2 + p2) / x2, t2[1] = 0.25 * x2, t2[2] = (y2 + R) / x2) : (x2 = 2 * Math.sqrt(1 + E2 - d2 - A), t2[3] = (v2 - p2) / x2, t2[0] = (g2 + b2) / x2, t2[1] = (y2 + R) / x2, t2[2] = 0.25 * x2), t2;
  }, fromRotationTranslationScale = function(t2, a2, r2, n) {
    var e = a2[0], o2 = a2[1], u2 = a2[2], s = a2[3], i = e + e, c2 = o2 + o2, l = u2 + u2, $ = e * i, h2 = e * c2, f2 = e * l, M2 = o2 * c2, m2 = o2 * l, d2 = u2 * l, v2 = s * i, b2 = s * c2, p2 = s * l, A = n[0], y2 = n[1], g2 = n[2];
    return t2[0] = (1 - (M2 + d2)) * A, t2[1] = (h2 + p2) * A, t2[2] = (f2 - b2) * A, t2[3] = 0, t2[4] = (h2 - p2) * y2, t2[5] = (1 - ($ + d2)) * y2, t2[6] = (m2 + v2) * y2, t2[7] = 0, t2[8] = (f2 + b2) * g2, t2[9] = (m2 - v2) * g2, t2[10] = (1 - ($ + M2)) * g2, t2[11] = 0, t2[12] = r2[0], t2[13] = r2[1], t2[14] = r2[2], t2[15] = 1, t2;
  }, fromRotationTranslationScaleOrigin = function(t2, a2, r2, n, e) {
    var o2 = a2[0], u2 = a2[1], s = a2[2], i = a2[3], c2 = o2 + o2, l = u2 + u2, $ = s + s, h2 = o2 * c2, f2 = o2 * l, M2 = o2 * $, m2 = u2 * l, d2 = u2 * $, v2 = s * $, b2 = i * c2, p2 = i * l, A = i * $, y2 = n[0], g2 = n[1], R = n[2], E2 = e[0], q = e[1], x2 = e[2], P2 = (1 - (m2 + v2)) * y2, L = (f2 + A) * y2, O2 = (M2 - p2) * y2, S2 = (f2 - A) * g2, Y = (1 - (h2 + v2)) * g2, T2 = (d2 + b2) * g2, N = (M2 + p2) * R, _2 = (d2 - b2) * R, I2 = (1 - (h2 + m2)) * R;
    return t2[0] = P2, t2[1] = L, t2[2] = O2, t2[3] = 0, t2[4] = S2, t2[5] = Y, t2[6] = T2, t2[7] = 0, t2[8] = N, t2[9] = _2, t2[10] = I2, t2[11] = 0, t2[12] = r2[0] + E2 - (P2 * E2 + S2 * q + N * x2), t2[13] = r2[1] + q - (L * E2 + Y * q + _2 * x2), t2[14] = r2[2] + x2 - (O2 * E2 + T2 * q + I2 * x2), t2[15] = 1, t2;
  }, fromQuat = function(t2, a2) {
    var r2 = a2[0], n = a2[1], e = a2[2], o2 = a2[3], u2 = r2 + r2, s = n + n, i = e + e, c2 = r2 * u2, l = n * u2, $ = n * s, h2 = e * u2, f2 = e * s, M2 = e * i, m2 = o2 * u2, d2 = o2 * s, v2 = o2 * i;
    return t2[0] = 1 - $ - M2, t2[1] = l + v2, t2[2] = h2 - d2, t2[3] = 0, t2[4] = l - v2, t2[5] = 1 - c2 - M2, t2[6] = f2 + m2, t2[7] = 0, t2[8] = h2 + d2, t2[9] = f2 - m2, t2[10] = 1 - c2 - $, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
  }, frustum = function(t2, a2, r2, n, e, o2, u2) {
    var s = 1 / (r2 - a2), i = 1 / (e - n), c2 = 1 / (o2 - u2);
    return t2[0] = 2 * o2 * s, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 2 * o2 * i, t2[6] = 0, t2[7] = 0, t2[8] = (r2 + a2) * s, t2[9] = (e + n) * i, t2[10] = (u2 + o2) * c2, t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[14] = u2 * o2 * 2 * c2, t2[15] = 0, t2;
  }, perspectiveNO = function(t2, a2, r2, n, e) {
    var o2 = 1 / Math.tan(a2 / 2);
    if (t2[0] = o2 / r2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = o2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[15] = 0, null != e && e !== 1 / 0) {
      var u2 = 1 / (n - e);
      t2[10] = (e + n) * u2, t2[14] = 2 * e * n * u2;
    } else t2[10] = -1, t2[14] = -2 * n;
    return t2;
  }, perspectiveZO = function(t2, a2, r2, n, e) {
    var o2 = 1 / Math.tan(a2 / 2);
    if (t2[0] = o2 / r2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = o2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[15] = 0, null != e && e !== 1 / 0) {
      var u2 = 1 / (n - e);
      t2[10] = e * u2, t2[14] = e * n * u2;
    } else t2[10] = -1, t2[14] = -n;
    return t2;
  }, perspectiveFromFieldOfView = function(t2, a2, r2, n) {
    var e = Math.tan(a2.upDegrees * Math.PI / 180), o2 = Math.tan(a2.downDegrees * Math.PI / 180), u2 = Math.tan(a2.leftDegrees * Math.PI / 180), s = Math.tan(a2.rightDegrees * Math.PI / 180), i = 2 / (u2 + s), c2 = 2 / (e + o2);
    return t2[0] = i, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = c2, t2[6] = 0, t2[7] = 0, t2[8] = -(u2 - s) * i * 0.5, t2[9] = (e - o2) * c2 * 0.5, t2[10] = n / (r2 - n), t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[14] = n * r2 / (r2 - n), t2[15] = 0, t2;
  }, orthoNO = function(t2, a2, r2, n, e, o2, u2) {
    var s = 1 / (a2 - r2), i = 1 / (n - e), c2 = 1 / (o2 - u2);
    return t2[0] = -2 * s, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = -2 * i, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 2 * c2, t2[11] = 0, t2[12] = (a2 + r2) * s, t2[13] = (e + n) * i, t2[14] = (u2 + o2) * c2, t2[15] = 1, t2;
  }, orthoZO = function(t2, a2, r2, n, e, o2, u2) {
    var s = 1 / (a2 - r2), i = 1 / (n - e), c2 = 1 / (o2 - u2);
    return t2[0] = -2 * s, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = -2 * i, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = c2, t2[11] = 0, t2[12] = (a2 + r2) * s, t2[13] = (e + n) * i, t2[14] = o2 * c2, t2[15] = 1, t2;
  }, lookAt = function(t2, a2, r2, n) {
    var e, o2, u2, s, i, c2, l, $, h2, f2, M2 = a2[0], m2 = a2[1], d2 = a2[2], v2 = n[0], b2 = n[1], p2 = n[2], A = r2[0], y2 = r2[1], g2 = r2[2];
    return Math.abs(M2 - A) < EPSILON && Math.abs(m2 - y2) < EPSILON && Math.abs(d2 - g2) < EPSILON ? identity$2(t2) : (l = M2 - A, $ = m2 - y2, h2 = d2 - g2, e = b2 * (h2 *= f2 = 1 / Math.hypot(l, $, h2)) - p2 * ($ *= f2), o2 = p2 * (l *= f2) - v2 * h2, u2 = v2 * $ - b2 * l, (f2 = Math.hypot(e, o2, u2)) ? (e *= f2 = 1 / f2, o2 *= f2, u2 *= f2) : (e = 0, o2 = 0, u2 = 0), s = $ * u2 - h2 * o2, i = h2 * e - l * u2, c2 = l * o2 - $ * e, (f2 = Math.hypot(s, i, c2)) ? (s *= f2 = 1 / f2, i *= f2, c2 *= f2) : (s = 0, i = 0, c2 = 0), t2[0] = e, t2[1] = s, t2[2] = l, t2[3] = 0, t2[4] = o2, t2[5] = i, t2[6] = $, t2[7] = 0, t2[8] = u2, t2[9] = c2, t2[10] = h2, t2[11] = 0, t2[12] = -(e * M2 + o2 * m2 + u2 * d2), t2[13] = -(s * M2 + i * m2 + c2 * d2), t2[14] = -(l * M2 + $ * m2 + h2 * d2), t2[15] = 1, t2);
  }, targetTo = function(t2, a2, r2, n) {
    var e = a2[0], o2 = a2[1], u2 = a2[2], s = n[0], i = n[1], c2 = n[2], l = e - r2[0], $ = o2 - r2[1], h2 = u2 - r2[2], f2 = l * l + $ * $ + h2 * h2;
    f2 > 0 && (l *= f2 = 1 / Math.sqrt(f2), $ *= f2, h2 *= f2);
    var M2 = i * h2 - c2 * $, m2 = c2 * l - s * h2, d2 = s * $ - i * l;
    return (f2 = M2 * M2 + m2 * m2 + d2 * d2) > 0 && (M2 *= f2 = 1 / Math.sqrt(f2), m2 *= f2, d2 *= f2), t2[0] = M2, t2[1] = m2, t2[2] = d2, t2[3] = 0, t2[4] = $ * d2 - h2 * m2, t2[5] = h2 * M2 - l * d2, t2[6] = l * m2 - $ * M2, t2[7] = 0, t2[8] = l, t2[9] = $, t2[10] = h2, t2[11] = 0, t2[12] = e, t2[13] = o2, t2[14] = u2, t2[15] = 1, t2;
  }, str$5 = function(t2) {
    return "mat4(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ", " + t2[3] + ", " + t2[4] + ", " + t2[5] + ", " + t2[6] + ", " + t2[7] + ", " + t2[8] + ", " + t2[9] + ", " + t2[10] + ", " + t2[11] + ", " + t2[12] + ", " + t2[13] + ", " + t2[14] + ", " + t2[15] + ")";
  }, frob = function(t2) {
    return Math.hypot(t2[0], t2[1], t2[2], t2[3], t2[4], t2[5], t2[6], t2[7], t2[8], t2[9], t2[10], t2[11], t2[12], t2[13], t2[14], t2[15]);
  }, add$5 = function(t2, a2, r2) {
    return t2[0] = a2[0] + r2[0], t2[1] = a2[1] + r2[1], t2[2] = a2[2] + r2[2], t2[3] = a2[3] + r2[3], t2[4] = a2[4] + r2[4], t2[5] = a2[5] + r2[5], t2[6] = a2[6] + r2[6], t2[7] = a2[7] + r2[7], t2[8] = a2[8] + r2[8], t2[9] = a2[9] + r2[9], t2[10] = a2[10] + r2[10], t2[11] = a2[11] + r2[11], t2[12] = a2[12] + r2[12], t2[13] = a2[13] + r2[13], t2[14] = a2[14] + r2[14], t2[15] = a2[15] + r2[15], t2;
  }, subtract$3 = function(t2, a2, r2) {
    return t2[0] = a2[0] - r2[0], t2[1] = a2[1] - r2[1], t2[2] = a2[2] - r2[2], t2[3] = a2[3] - r2[3], t2[4] = a2[4] - r2[4], t2[5] = a2[5] - r2[5], t2[6] = a2[6] - r2[6], t2[7] = a2[7] - r2[7], t2[8] = a2[8] - r2[8], t2[9] = a2[9] - r2[9], t2[10] = a2[10] - r2[10], t2[11] = a2[11] - r2[11], t2[12] = a2[12] - r2[12], t2[13] = a2[13] - r2[13], t2[14] = a2[14] - r2[14], t2[15] = a2[15] - r2[15], t2;
  }, multiplyScalar = function(t2, a2, r2) {
    return t2[0] = a2[0] * r2, t2[1] = a2[1] * r2, t2[2] = a2[2] * r2, t2[3] = a2[3] * r2, t2[4] = a2[4] * r2, t2[5] = a2[5] * r2, t2[6] = a2[6] * r2, t2[7] = a2[7] * r2, t2[8] = a2[8] * r2, t2[9] = a2[9] * r2, t2[10] = a2[10] * r2, t2[11] = a2[11] * r2, t2[12] = a2[12] * r2, t2[13] = a2[13] * r2, t2[14] = a2[14] * r2, t2[15] = a2[15] * r2, t2;
  }, multiplyScalarAndAdd = function(t2, a2, r2, n) {
    return t2[0] = a2[0] + r2[0] * n, t2[1] = a2[1] + r2[1] * n, t2[2] = a2[2] + r2[2] * n, t2[3] = a2[3] + r2[3] * n, t2[4] = a2[4] + r2[4] * n, t2[5] = a2[5] + r2[5] * n, t2[6] = a2[6] + r2[6] * n, t2[7] = a2[7] + r2[7] * n, t2[8] = a2[8] + r2[8] * n, t2[9] = a2[9] + r2[9] * n, t2[10] = a2[10] + r2[10] * n, t2[11] = a2[11] + r2[11] * n, t2[12] = a2[12] + r2[12] * n, t2[13] = a2[13] + r2[13] * n, t2[14] = a2[14] + r2[14] * n, t2[15] = a2[15] + r2[15] * n, t2;
  }, exactEquals$5 = function(t2, a2) {
    return t2[0] === a2[0] && t2[1] === a2[1] && t2[2] === a2[2] && t2[3] === a2[3] && t2[4] === a2[4] && t2[5] === a2[5] && t2[6] === a2[6] && t2[7] === a2[7] && t2[8] === a2[8] && t2[9] === a2[9] && t2[10] === a2[10] && t2[11] === a2[11] && t2[12] === a2[12] && t2[13] === a2[13] && t2[14] === a2[14] && t2[15] === a2[15];
  }, equals$5 = function(t2, a2) {
    var r2 = t2[0], n = t2[1], e = t2[2], o2 = t2[3], u2 = t2[4], s = t2[5], i = t2[6], c2 = t2[7], l = t2[8], $ = t2[9], h2 = t2[10], f2 = t2[11], M2 = t2[12], m2 = t2[13], d2 = t2[14], v2 = t2[15], b2 = a2[0], p2 = a2[1], A = a2[2], y2 = a2[3], g2 = a2[4], R = a2[5], E2 = a2[6], q = a2[7], x2 = a2[8], P2 = a2[9], L = a2[10], O2 = a2[11], S2 = a2[12], Y = a2[13], T2 = a2[14], N = a2[15];
    return Math.abs(r2 - b2) <= EPSILON * Math.max(1, Math.abs(r2), Math.abs(b2)) && Math.abs(n - p2) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(p2)) && Math.abs(e - A) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(A)) && Math.abs(o2 - y2) <= EPSILON * Math.max(1, Math.abs(o2), Math.abs(y2)) && Math.abs(u2 - g2) <= EPSILON * Math.max(1, Math.abs(u2), Math.abs(g2)) && Math.abs(s - R) <= EPSILON * Math.max(1, Math.abs(s), Math.abs(R)) && Math.abs(i - E2) <= EPSILON * Math.max(1, Math.abs(i), Math.abs(E2)) && Math.abs(c2 - q) <= EPSILON * Math.max(1, Math.abs(c2), Math.abs(q)) && Math.abs(l - x2) <= EPSILON * Math.max(1, Math.abs(l), Math.abs(x2)) && Math.abs($ - P2) <= EPSILON * Math.max(1, Math.abs($), Math.abs(P2)) && Math.abs(h2 - L) <= EPSILON * Math.max(1, Math.abs(h2), Math.abs(L)) && Math.abs(f2 - O2) <= EPSILON * Math.max(1, Math.abs(f2), Math.abs(O2)) && Math.abs(M2 - S2) <= EPSILON * Math.max(1, Math.abs(M2), Math.abs(S2)) && Math.abs(m2 - Y) <= EPSILON * Math.max(1, Math.abs(m2), Math.abs(Y)) && Math.abs(d2 - T2) <= EPSILON * Math.max(1, Math.abs(d2), Math.abs(T2)) && Math.abs(v2 - N) <= EPSILON * Math.max(1, Math.abs(v2), Math.abs(N));
  }, create$4 = function() {
    var t2 = new ARRAY_TYPE(3);
    return ARRAY_TYPE != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0), t2;
  }, clone$4 = function(t2) {
    var a2 = new ARRAY_TYPE(3);
    return a2[0] = t2[0], a2[1] = t2[1], a2[2] = t2[2], a2;
  }, length$4 = function(t2) {
    var a2 = t2[0], r2 = t2[1], n = t2[2];
    return Math.hypot(a2, r2, n);
  }, fromValues$4 = function(t2, a2, r2) {
    var n = new ARRAY_TYPE(3);
    return n[0] = t2, n[1] = a2, n[2] = r2, n;
  }, copy$4 = function(t2, a2) {
    return t2[0] = a2[0], t2[1] = a2[1], t2[2] = a2[2], t2;
  }, set$4 = function(t2, a2, r2, n) {
    return t2[0] = a2, t2[1] = r2, t2[2] = n, t2;
  }, add$4 = function(t2, a2, r2) {
    return t2[0] = a2[0] + r2[0], t2[1] = a2[1] + r2[1], t2[2] = a2[2] + r2[2], t2;
  }, subtract$2 = function(t2, a2, r2) {
    return t2[0] = a2[0] - r2[0], t2[1] = a2[1] - r2[1], t2[2] = a2[2] - r2[2], t2;
  }, multiply$4 = function(t2, a2, r2) {
    return t2[0] = a2[0] * r2[0], t2[1] = a2[1] * r2[1], t2[2] = a2[2] * r2[2], t2;
  }, divide$2 = function(t2, a2, r2) {
    return t2[0] = a2[0] / r2[0], t2[1] = a2[1] / r2[1], t2[2] = a2[2] / r2[2], t2;
  }, ceil$2 = function(t2, a2) {
    return t2[0] = Math.ceil(a2[0]), t2[1] = Math.ceil(a2[1]), t2[2] = Math.ceil(a2[2]), t2;
  }, floor$2 = function(t2, a2) {
    return t2[0] = Math.floor(a2[0]), t2[1] = Math.floor(a2[1]), t2[2] = Math.floor(a2[2]), t2;
  }, min$2 = function(t2, a2, r2) {
    return t2[0] = Math.min(a2[0], r2[0]), t2[1] = Math.min(a2[1], r2[1]), t2[2] = Math.min(a2[2], r2[2]), t2;
  }, max$2 = function(t2, a2, r2) {
    return t2[0] = Math.max(a2[0], r2[0]), t2[1] = Math.max(a2[1], r2[1]), t2[2] = Math.max(a2[2], r2[2]), t2;
  }, round$2 = function(t2, a2) {
    return t2[0] = Math.round(a2[0]), t2[1] = Math.round(a2[1]), t2[2] = Math.round(a2[2]), t2;
  }, scale$4 = function(t2, a2, r2) {
    return t2[0] = a2[0] * r2, t2[1] = a2[1] * r2, t2[2] = a2[2] * r2, t2;
  }, scaleAndAdd$2 = function(t2, a2, r2, n) {
    return t2[0] = a2[0] + r2[0] * n, t2[1] = a2[1] + r2[1] * n, t2[2] = a2[2] + r2[2] * n, t2;
  }, distance$2 = function(t2, a2) {
    var r2 = a2[0] - t2[0], n = a2[1] - t2[1], e = a2[2] - t2[2];
    return Math.hypot(r2, n, e);
  }, squaredDistance$2 = function(t2, a2) {
    var r2 = a2[0] - t2[0], n = a2[1] - t2[1], e = a2[2] - t2[2];
    return r2 * r2 + n * n + e * e;
  }, squaredLength$4 = function(t2) {
    var a2 = t2[0], r2 = t2[1], n = t2[2];
    return a2 * a2 + r2 * r2 + n * n;
  }, negate$2 = function(t2, a2) {
    return t2[0] = -a2[0], t2[1] = -a2[1], t2[2] = -a2[2], t2;
  }, inverse$2 = function(t2, a2) {
    return t2[0] = 1 / a2[0], t2[1] = 1 / a2[1], t2[2] = 1 / a2[2], t2;
  }, normalize$4 = function(t2, a2) {
    var r2 = a2[0], n = a2[1], e = a2[2], o2 = r2 * r2 + n * n + e * e;
    return o2 > 0 && (o2 = 1 / Math.sqrt(o2)), t2[0] = a2[0] * o2, t2[1] = a2[1] * o2, t2[2] = a2[2] * o2, t2;
  }, dot$4 = function(t2, a2) {
    return t2[0] * a2[0] + t2[1] * a2[1] + t2[2] * a2[2];
  }, cross$2 = function(t2, a2, r2) {
    var n = a2[0], e = a2[1], o2 = a2[2], u2 = r2[0], s = r2[1], i = r2[2];
    return t2[0] = e * i - o2 * s, t2[1] = o2 * u2 - n * i, t2[2] = n * s - e * u2, t2;
  }, lerp$4 = function(t2, a2, r2, n) {
    var e = a2[0], o2 = a2[1], u2 = a2[2];
    return t2[0] = e + n * (r2[0] - e), t2[1] = o2 + n * (r2[1] - o2), t2[2] = u2 + n * (r2[2] - u2), t2;
  }, slerp$1 = function(t2, a2, r2, n) {
    var e = Math.acos(Math.min(Math.max(dot$4(a2, r2), -1), 1)), o2 = Math.sin(e), u2 = Math.sin((1 - n) * e) / o2, s = Math.sin(n * e) / o2;
    return t2[0] = u2 * a2[0] + s * r2[0], t2[1] = u2 * a2[1] + s * r2[1], t2[2] = u2 * a2[2] + s * r2[2], t2;
  }, hermite = function(t2, a2, r2, n, e, o2) {
    var u2 = o2 * o2, s = u2 * (2 * o2 - 3) + 1, i = u2 * (o2 - 2) + o2, c2 = u2 * (o2 - 1), l = u2 * (3 - 2 * o2);
    return t2[0] = a2[0] * s + r2[0] * i + n[0] * c2 + e[0] * l, t2[1] = a2[1] * s + r2[1] * i + n[1] * c2 + e[1] * l, t2[2] = a2[2] * s + r2[2] * i + n[2] * c2 + e[2] * l, t2;
  }, bezier = function(t2, a2, r2, n, e, o2) {
    var u2 = 1 - o2, s = u2 * u2, i = o2 * o2, c2 = s * u2, l = 3 * o2 * s, $ = 3 * i * u2, h2 = i * o2;
    return t2[0] = a2[0] * c2 + r2[0] * l + n[0] * $ + e[0] * h2, t2[1] = a2[1] * c2 + r2[1] * l + n[1] * $ + e[1] * h2, t2[2] = a2[2] * c2 + r2[2] * l + n[2] * $ + e[2] * h2, t2;
  }, random$3 = function(t2, a2) {
    a2 = a2 || 1;
    var r2 = 2 * RANDOM() * Math.PI, n = 2 * RANDOM() - 1, e = Math.sqrt(1 - n * n) * a2;
    return t2[0] = Math.cos(r2) * e, t2[1] = Math.sin(r2) * e, t2[2] = n * a2, t2;
  }, transformMat4$2 = function(t2, a2, r2) {
    var n = a2[0], e = a2[1], o2 = a2[2], u2 = r2[3] * n + r2[7] * e + r2[11] * o2 + r2[15];
    return u2 = u2 || 1, t2[0] = (r2[0] * n + r2[4] * e + r2[8] * o2 + r2[12]) / u2, t2[1] = (r2[1] * n + r2[5] * e + r2[9] * o2 + r2[13]) / u2, t2[2] = (r2[2] * n + r2[6] * e + r2[10] * o2 + r2[14]) / u2, t2;
  }, transformMat3$1 = function(t2, a2, r2) {
    var n = a2[0], e = a2[1], o2 = a2[2];
    return t2[0] = n * r2[0] + e * r2[3] + o2 * r2[6], t2[1] = n * r2[1] + e * r2[4] + o2 * r2[7], t2[2] = n * r2[2] + e * r2[5] + o2 * r2[8], t2;
  }, transformQuat$1 = function(t2, a2, r2) {
    var n = r2[0], e = r2[1], o2 = r2[2], u2 = r2[3], s = a2[0], i = a2[1], c2 = a2[2], l = e * c2 - o2 * i, $ = o2 * s - n * c2, h2 = n * i - e * s, f2 = e * h2 - o2 * $, M2 = o2 * l - n * h2, m2 = n * $ - e * l, d2 = 2 * u2;
    return l *= d2, $ *= d2, h2 *= d2, f2 *= 2, M2 *= 2, m2 *= 2, t2[0] = s + l + f2, t2[1] = i + $ + M2, t2[2] = c2 + h2 + m2, t2;
  }, rotateX$2 = function(t2, a2, r2, n) {
    var e = [], o2 = [];
    return e[0] = a2[0] - r2[0], e[1] = a2[1] - r2[1], e[2] = a2[2] - r2[2], o2[0] = e[0], o2[1] = e[1] * Math.cos(n) - e[2] * Math.sin(n), o2[2] = e[1] * Math.sin(n) + e[2] * Math.cos(n), t2[0] = o2[0] + r2[0], t2[1] = o2[1] + r2[1], t2[2] = o2[2] + r2[2], t2;
  }, rotateY$2 = function(t2, a2, r2, n) {
    var e = [], o2 = [];
    return e[0] = a2[0] - r2[0], e[1] = a2[1] - r2[1], e[2] = a2[2] - r2[2], o2[0] = e[2] * Math.sin(n) + e[0] * Math.cos(n), o2[1] = e[1], o2[2] = e[2] * Math.cos(n) - e[0] * Math.sin(n), t2[0] = o2[0] + r2[0], t2[1] = o2[1] + r2[1], t2[2] = o2[2] + r2[2], t2;
  }, rotateZ$2 = function(t2, a2, r2, n) {
    var e = [], o2 = [];
    return e[0] = a2[0] - r2[0], e[1] = a2[1] - r2[1], e[2] = a2[2] - r2[2], o2[0] = e[0] * Math.cos(n) - e[1] * Math.sin(n), o2[1] = e[0] * Math.sin(n) + e[1] * Math.cos(n), o2[2] = e[2], t2[0] = o2[0] + r2[0], t2[1] = o2[1] + r2[1], t2[2] = o2[2] + r2[2], t2;
  }, angle$1 = function(t2, a2) {
    var r2 = t2[0], n = t2[1], e = t2[2], o2 = a2[0], u2 = a2[1], s = a2[2], i = Math.sqrt((r2 * r2 + n * n + e * e) * (o2 * o2 + u2 * u2 + s * s)), c2 = i && dot$4(t2, a2) / i;
    return Math.acos(Math.min(Math.max(c2, -1), 1));
  }, zero$2 = function(t2) {
    return t2[0] = 0, t2[1] = 0, t2[2] = 0, t2;
  }, str$4 = function(t2) {
    return "vec3(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ")";
  }, exactEquals$4 = function(t2, a2) {
    return t2[0] === a2[0] && t2[1] === a2[1] && t2[2] === a2[2];
  }, equals$4 = function(t2, a2) {
    var r2 = t2[0], n = t2[1], e = t2[2], o2 = a2[0], u2 = a2[1], s = a2[2];
    return Math.abs(r2 - o2) <= EPSILON * Math.max(1, Math.abs(r2), Math.abs(o2)) && Math.abs(n - u2) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(u2)) && Math.abs(e - s) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(s));
  }, create$3 = function() {
    var t2 = new ARRAY_TYPE(4);
    return ARRAY_TYPE != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = 0), t2;
  }, clone$3 = function(t2) {
    var a2 = new ARRAY_TYPE(4);
    return a2[0] = t2[0], a2[1] = t2[1], a2[2] = t2[2], a2[3] = t2[3], a2;
  }, fromValues$3 = function(t2, a2, r2, n) {
    var e = new ARRAY_TYPE(4);
    return e[0] = t2, e[1] = a2, e[2] = r2, e[3] = n, e;
  }, copy$3 = function(t2, a2) {
    return t2[0] = a2[0], t2[1] = a2[1], t2[2] = a2[2], t2[3] = a2[3], t2;
  }, set$3 = function(t2, a2, r2, n, e) {
    return t2[0] = a2, t2[1] = r2, t2[2] = n, t2[3] = e, t2;
  }, add$3 = function(t2, a2, r2) {
    return t2[0] = a2[0] + r2[0], t2[1] = a2[1] + r2[1], t2[2] = a2[2] + r2[2], t2[3] = a2[3] + r2[3], t2;
  }, subtract$1 = function(t2, a2, r2) {
    return t2[0] = a2[0] - r2[0], t2[1] = a2[1] - r2[1], t2[2] = a2[2] - r2[2], t2[3] = a2[3] - r2[3], t2;
  }, multiply$3 = function(t2, a2, r2) {
    return t2[0] = a2[0] * r2[0], t2[1] = a2[1] * r2[1], t2[2] = a2[2] * r2[2], t2[3] = a2[3] * r2[3], t2;
  }, divide$1 = function(t2, a2, r2) {
    return t2[0] = a2[0] / r2[0], t2[1] = a2[1] / r2[1], t2[2] = a2[2] / r2[2], t2[3] = a2[3] / r2[3], t2;
  }, ceil$1 = function(t2, a2) {
    return t2[0] = Math.ceil(a2[0]), t2[1] = Math.ceil(a2[1]), t2[2] = Math.ceil(a2[2]), t2[3] = Math.ceil(a2[3]), t2;
  }, floor$1 = function(t2, a2) {
    return t2[0] = Math.floor(a2[0]), t2[1] = Math.floor(a2[1]), t2[2] = Math.floor(a2[2]), t2[3] = Math.floor(a2[3]), t2;
  }, min$1 = function(t2, a2, r2) {
    return t2[0] = Math.min(a2[0], r2[0]), t2[1] = Math.min(a2[1], r2[1]), t2[2] = Math.min(a2[2], r2[2]), t2[3] = Math.min(a2[3], r2[3]), t2;
  }, max$1 = function(t2, a2, r2) {
    return t2[0] = Math.max(a2[0], r2[0]), t2[1] = Math.max(a2[1], r2[1]), t2[2] = Math.max(a2[2], r2[2]), t2[3] = Math.max(a2[3], r2[3]), t2;
  }, round$1 = function(t2, a2) {
    return t2[0] = Math.round(a2[0]), t2[1] = Math.round(a2[1]), t2[2] = Math.round(a2[2]), t2[3] = Math.round(a2[3]), t2;
  }, scale$3 = function(t2, a2, r2) {
    return t2[0] = a2[0] * r2, t2[1] = a2[1] * r2, t2[2] = a2[2] * r2, t2[3] = a2[3] * r2, t2;
  }, scaleAndAdd$1 = function(t2, a2, r2, n) {
    return t2[0] = a2[0] + r2[0] * n, t2[1] = a2[1] + r2[1] * n, t2[2] = a2[2] + r2[2] * n, t2[3] = a2[3] + r2[3] * n, t2;
  }, distance$1 = function(t2, a2) {
    var r2 = a2[0] - t2[0], n = a2[1] - t2[1], e = a2[2] - t2[2], o2 = a2[3] - t2[3];
    return Math.hypot(r2, n, e, o2);
  }, squaredDistance$1 = function(t2, a2) {
    var r2 = a2[0] - t2[0], n = a2[1] - t2[1], e = a2[2] - t2[2], o2 = a2[3] - t2[3];
    return r2 * r2 + n * n + e * e + o2 * o2;
  }, length$3 = function(t2) {
    var a2 = t2[0], r2 = t2[1], n = t2[2], e = t2[3];
    return Math.hypot(a2, r2, n, e);
  }, squaredLength$3 = function(t2) {
    var a2 = t2[0], r2 = t2[1], n = t2[2], e = t2[3];
    return a2 * a2 + r2 * r2 + n * n + e * e;
  }, negate$1 = function(t2, a2) {
    return t2[0] = -a2[0], t2[1] = -a2[1], t2[2] = -a2[2], t2[3] = -a2[3], t2;
  }, inverse$1 = function(t2, a2) {
    return t2[0] = 1 / a2[0], t2[1] = 1 / a2[1], t2[2] = 1 / a2[2], t2[3] = 1 / a2[3], t2;
  }, normalize$3 = function(t2, a2) {
    var r2 = a2[0], n = a2[1], e = a2[2], o2 = a2[3], u2 = r2 * r2 + n * n + e * e + o2 * o2;
    return u2 > 0 && (u2 = 1 / Math.sqrt(u2)), t2[0] = r2 * u2, t2[1] = n * u2, t2[2] = e * u2, t2[3] = o2 * u2, t2;
  }, dot$3 = function(t2, a2) {
    return t2[0] * a2[0] + t2[1] * a2[1] + t2[2] * a2[2] + t2[3] * a2[3];
  }, cross$1 = function(t2, a2, r2, n) {
    var e = r2[0] * n[1] - r2[1] * n[0], o2 = r2[0] * n[2] - r2[2] * n[0], u2 = r2[0] * n[3] - r2[3] * n[0], s = r2[1] * n[2] - r2[2] * n[1], i = r2[1] * n[3] - r2[3] * n[1], c2 = r2[2] * n[3] - r2[3] * n[2], l = a2[0], $ = a2[1], h2 = a2[2], f2 = a2[3];
    return t2[0] = $ * c2 - h2 * i + f2 * s, t2[1] = -l * c2 + h2 * u2 - f2 * o2, t2[2] = l * i - $ * u2 + f2 * e, t2[3] = -l * s + $ * o2 - h2 * e, t2;
  }, lerp$3 = function(t2, a2, r2, n) {
    var e = a2[0], o2 = a2[1], u2 = a2[2], s = a2[3];
    return t2[0] = e + n * (r2[0] - e), t2[1] = o2 + n * (r2[1] - o2), t2[2] = u2 + n * (r2[2] - u2), t2[3] = s + n * (r2[3] - s), t2;
  }, random$2 = function(t2, a2) {
    var r2, n, e, o2, u2, s;
    a2 = a2 || 1;
    do {
      u2 = (r2 = 2 * RANDOM() - 1) * r2 + (n = 2 * RANDOM() - 1) * n;
    } while (u2 >= 1);
    do {
      s = (e = 2 * RANDOM() - 1) * e + (o2 = 2 * RANDOM() - 1) * o2;
    } while (s >= 1);
    var i = Math.sqrt((1 - u2) / s);
    return t2[0] = a2 * r2, t2[1] = a2 * n, t2[2] = a2 * e * i, t2[3] = a2 * o2 * i, t2;
  }, transformMat4$1 = function(t2, a2, r2) {
    var n = a2[0], e = a2[1], o2 = a2[2], u2 = a2[3];
    return t2[0] = r2[0] * n + r2[4] * e + r2[8] * o2 + r2[12] * u2, t2[1] = r2[1] * n + r2[5] * e + r2[9] * o2 + r2[13] * u2, t2[2] = r2[2] * n + r2[6] * e + r2[10] * o2 + r2[14] * u2, t2[3] = r2[3] * n + r2[7] * e + r2[11] * o2 + r2[15] * u2, t2;
  }, transformQuat = function(t2, a2, r2) {
    var n = a2[0], e = a2[1], o2 = a2[2], u2 = r2[0], s = r2[1], i = r2[2], c2 = r2[3], l = c2 * n + s * o2 - i * e, $ = c2 * e + i * n - u2 * o2, h2 = c2 * o2 + u2 * e - s * n, f2 = -u2 * n - s * e - i * o2;
    return t2[0] = l * c2 + f2 * -u2 + $ * -i - h2 * -s, t2[1] = $ * c2 + f2 * -s + h2 * -u2 - l * -i, t2[2] = h2 * c2 + f2 * -i + l * -s - $ * -u2, t2[3] = a2[3], t2;
  }, zero$1 = function(t2) {
    return t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2;
  }, str$3 = function(t2) {
    return "vec4(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ", " + t2[3] + ")";
  }, exactEquals$3 = function(t2, a2) {
    return t2[0] === a2[0] && t2[1] === a2[1] && t2[2] === a2[2] && t2[3] === a2[3];
  }, equals$3 = function(t2, a2) {
    var r2 = t2[0], n = t2[1], e = t2[2], o2 = t2[3], u2 = a2[0], s = a2[1], i = a2[2], c2 = a2[3];
    return Math.abs(r2 - u2) <= EPSILON * Math.max(1, Math.abs(r2), Math.abs(u2)) && Math.abs(n - s) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(s)) && Math.abs(e - i) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(i)) && Math.abs(o2 - c2) <= EPSILON * Math.max(1, Math.abs(o2), Math.abs(c2));
  }, create$2 = function() {
    var t2 = new ARRAY_TYPE(4);
    return ARRAY_TYPE != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0), t2[3] = 1, t2;
  }, identity$1 = function(t2) {
    return t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2;
  }, setAxisAngle = function(t2, a2, r2) {
    r2 *= 0.5;
    var n = Math.sin(r2);
    return t2[0] = n * a2[0], t2[1] = n * a2[1], t2[2] = n * a2[2], t2[3] = Math.cos(r2), t2;
  }, getAxisAngle = function(t2, a2) {
    var r2 = 2 * Math.acos(a2[3]), n = Math.sin(r2 / 2);
    return n > EPSILON ? (t2[0] = a2[0] / n, t2[1] = a2[1] / n, t2[2] = a2[2] / n) : (t2[0] = 1, t2[1] = 0, t2[2] = 0), r2;
  }, getAngle = function(t2, a2) {
    var r2 = dot$2(t2, a2);
    return Math.acos(2 * r2 * r2 - 1);
  }, multiply$2 = function(t2, a2, r2) {
    var n = a2[0], e = a2[1], o2 = a2[2], u2 = a2[3], s = r2[0], i = r2[1], c2 = r2[2], l = r2[3];
    return t2[0] = n * l + u2 * s + e * c2 - o2 * i, t2[1] = e * l + u2 * i + o2 * s - n * c2, t2[2] = o2 * l + u2 * c2 + n * i - e * s, t2[3] = u2 * l - n * s - e * i - o2 * c2, t2;
  }, rotateX$1 = function(t2, a2, r2) {
    r2 *= 0.5;
    var n = a2[0], e = a2[1], o2 = a2[2], u2 = a2[3], s = Math.sin(r2), i = Math.cos(r2);
    return t2[0] = n * i + u2 * s, t2[1] = e * i + o2 * s, t2[2] = o2 * i - e * s, t2[3] = u2 * i - n * s, t2;
  }, rotateY$1 = function(t2, a2, r2) {
    r2 *= 0.5;
    var n = a2[0], e = a2[1], o2 = a2[2], u2 = a2[3], s = Math.sin(r2), i = Math.cos(r2);
    return t2[0] = n * i - o2 * s, t2[1] = e * i + u2 * s, t2[2] = o2 * i + n * s, t2[3] = u2 * i - e * s, t2;
  }, rotateZ$1 = function(t2, a2, r2) {
    r2 *= 0.5;
    var n = a2[0], e = a2[1], o2 = a2[2], u2 = a2[3], s = Math.sin(r2), i = Math.cos(r2);
    return t2[0] = n * i + e * s, t2[1] = e * i - n * s, t2[2] = o2 * i + u2 * s, t2[3] = u2 * i - o2 * s, t2;
  }, calculateW = function(t2, a2) {
    var r2 = a2[0], n = a2[1], e = a2[2];
    return t2[0] = r2, t2[1] = n, t2[2] = e, t2[3] = Math.sqrt(Math.abs(1 - r2 * r2 - n * n - e * e)), t2;
  }, exp = function(t2, a2) {
    var r2 = a2[0], n = a2[1], e = a2[2], o2 = a2[3], u2 = Math.sqrt(r2 * r2 + n * n + e * e), s = Math.exp(o2), i = u2 > 0 ? s * Math.sin(u2) / u2 : 0;
    return t2[0] = r2 * i, t2[1] = n * i, t2[2] = e * i, t2[3] = s * Math.cos(u2), t2;
  }, ln = function(t2, a2) {
    var r2 = a2[0], n = a2[1], e = a2[2], o2 = a2[3], u2 = Math.sqrt(r2 * r2 + n * n + e * e), s = u2 > 0 ? Math.atan2(u2, o2) / u2 : 0;
    return t2[0] = r2 * s, t2[1] = n * s, t2[2] = e * s, t2[3] = 0.5 * Math.log(r2 * r2 + n * n + e * e + o2 * o2), t2;
  }, pow = function(t2, a2, r2) {
    return ln(t2, a2), scale$2(t2, t2, r2), exp(t2, t2), t2;
  }, slerp = function(t2, a2, r2, n) {
    var e, o2, u2, s, i, c2 = a2[0], l = a2[1], $ = a2[2], h2 = a2[3], f2 = r2[0], M2 = r2[1], m2 = r2[2], d2 = r2[3];
    return (o2 = c2 * f2 + l * M2 + $ * m2 + h2 * d2) < 0 && (o2 = -o2, f2 = -f2, M2 = -M2, m2 = -m2, d2 = -d2), 1 - o2 > EPSILON ? (e = Math.acos(o2), u2 = Math.sin(e), s = Math.sin((1 - n) * e) / u2, i = Math.sin(n * e) / u2) : (s = 1 - n, i = n), t2[0] = s * c2 + i * f2, t2[1] = s * l + i * M2, t2[2] = s * $ + i * m2, t2[3] = s * h2 + i * d2, t2;
  }, random$1 = function(t2) {
    var a2 = RANDOM(), r2 = RANDOM(), n = RANDOM(), e = Math.sqrt(1 - a2), o2 = Math.sqrt(a2);
    return t2[0] = e * Math.sin(2 * Math.PI * r2), t2[1] = e * Math.cos(2 * Math.PI * r2), t2[2] = o2 * Math.sin(2 * Math.PI * n), t2[3] = o2 * Math.cos(2 * Math.PI * n), t2;
  }, invert$1 = function(t2, a2) {
    var r2 = a2[0], n = a2[1], e = a2[2], o2 = a2[3], u2 = r2 * r2 + n * n + e * e + o2 * o2, s = u2 ? 1 / u2 : 0;
    return t2[0] = -r2 * s, t2[1] = -n * s, t2[2] = -e * s, t2[3] = o2 * s, t2;
  }, conjugate$1 = function(t2, a2) {
    return t2[0] = -a2[0], t2[1] = -a2[1], t2[2] = -a2[2], t2[3] = a2[3], t2;
  }, fromMat3 = function(t2, a2) {
    var r2, n = a2[0] + a2[4] + a2[8];
    if (n > 0) r2 = Math.sqrt(n + 1), t2[3] = 0.5 * r2, r2 = 0.5 / r2, t2[0] = (a2[5] - a2[7]) * r2, t2[1] = (a2[6] - a2[2]) * r2, t2[2] = (a2[1] - a2[3]) * r2;
    else {
      var e = 0;
      a2[4] > a2[0] && (e = 1), a2[8] > a2[3 * e + e] && (e = 2);
      var o2 = (e + 1) % 3, u2 = (e + 2) % 3;
      r2 = Math.sqrt(a2[3 * e + e] - a2[3 * o2 + o2] - a2[3 * u2 + u2] + 1), t2[e] = 0.5 * r2, r2 = 0.5 / r2, t2[3] = (a2[3 * o2 + u2] - a2[3 * u2 + o2]) * r2, t2[o2] = (a2[3 * o2 + e] + a2[3 * e + o2]) * r2, t2[u2] = (a2[3 * u2 + e] + a2[3 * e + u2]) * r2;
    }
    return t2;
  }, fromEuler = function(t2, a2, r2, n) {
    var e = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : ANGLE_ORDER, o2 = Math.PI / 360;
    a2 *= o2, n *= o2, r2 *= o2;
    var u2 = Math.sin(a2), s = Math.cos(a2), i = Math.sin(r2), c2 = Math.cos(r2), l = Math.sin(n), $ = Math.cos(n);
    switch (e) {
      case "xyz":
        t2[0] = u2 * c2 * $ + s * i * l, t2[1] = s * i * $ - u2 * c2 * l, t2[2] = s * c2 * l + u2 * i * $, t2[3] = s * c2 * $ - u2 * i * l;
        break;
      case "xzy":
        t2[0] = u2 * c2 * $ - s * i * l, t2[1] = s * i * $ - u2 * c2 * l, t2[2] = s * c2 * l + u2 * i * $, t2[3] = s * c2 * $ + u2 * i * l;
        break;
      case "yxz":
        t2[0] = u2 * c2 * $ + s * i * l, t2[1] = s * i * $ - u2 * c2 * l, t2[2] = s * c2 * l - u2 * i * $, t2[3] = s * c2 * $ + u2 * i * l;
        break;
      case "yzx":
        t2[0] = u2 * c2 * $ + s * i * l, t2[1] = s * i * $ + u2 * c2 * l, t2[2] = s * c2 * l - u2 * i * $, t2[3] = s * c2 * $ - u2 * i * l;
        break;
      case "zxy":
        t2[0] = u2 * c2 * $ - s * i * l, t2[1] = s * i * $ + u2 * c2 * l, t2[2] = s * c2 * l + u2 * i * $, t2[3] = s * c2 * $ - u2 * i * l;
        break;
      case "zyx":
        t2[0] = u2 * c2 * $ - s * i * l, t2[1] = s * i * $ + u2 * c2 * l, t2[2] = s * c2 * l - u2 * i * $, t2[3] = s * c2 * $ + u2 * i * l;
        break;
      default:
        throw new Error("Unknown angle order " + e);
    }
    return t2;
  }, str$2 = function(t2) {
    return "quat(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ", " + t2[3] + ")";
  }, equals$2 = function(t2, a2) {
    return Math.abs(dot$3(t2, a2)) >= 1 - EPSILON;
  }, create$1 = function() {
    var t2 = new ARRAY_TYPE(8);
    return ARRAY_TYPE != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[4] = 0, t2[5] = 0, t2[6] = 0, t2[7] = 0), t2[3] = 1, t2;
  }, clone$1 = function(t2) {
    var a2 = new ARRAY_TYPE(8);
    return a2[0] = t2[0], a2[1] = t2[1], a2[2] = t2[2], a2[3] = t2[3], a2[4] = t2[4], a2[5] = t2[5], a2[6] = t2[6], a2[7] = t2[7], a2;
  }, fromValues$1 = function(t2, a2, r2, n, e, o2, u2, s) {
    var i = new ARRAY_TYPE(8);
    return i[0] = t2, i[1] = a2, i[2] = r2, i[3] = n, i[4] = e, i[5] = o2, i[6] = u2, i[7] = s, i;
  }, fromRotationTranslationValues = function(t2, a2, r2, n, e, o2, u2) {
    var s = new ARRAY_TYPE(8);
    s[0] = t2, s[1] = a2, s[2] = r2, s[3] = n;
    var i = 0.5 * e, c2 = 0.5 * o2, l = 0.5 * u2;
    return s[4] = i * n + c2 * r2 - l * a2, s[5] = c2 * n + l * t2 - i * r2, s[6] = l * n + i * a2 - c2 * t2, s[7] = -i * t2 - c2 * a2 - l * r2, s;
  }, fromRotationTranslation = function(t2, a2, r2) {
    var n = 0.5 * r2[0], e = 0.5 * r2[1], o2 = 0.5 * r2[2], u2 = a2[0], s = a2[1], i = a2[2], c2 = a2[3];
    return t2[0] = u2, t2[1] = s, t2[2] = i, t2[3] = c2, t2[4] = n * c2 + e * i - o2 * s, t2[5] = e * c2 + o2 * u2 - n * i, t2[6] = o2 * c2 + n * s - e * u2, t2[7] = -n * u2 - e * s - o2 * i, t2;
  }, fromTranslation = function(t2, a2) {
    return t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2[4] = 0.5 * a2[0], t2[5] = 0.5 * a2[1], t2[6] = 0.5 * a2[2], t2[7] = 0, t2;
  }, fromRotation = function(t2, a2) {
    return t2[0] = a2[0], t2[1] = a2[1], t2[2] = a2[2], t2[3] = a2[3], t2[4] = 0, t2[5] = 0, t2[6] = 0, t2[7] = 0, t2;
  }, fromMat4 = function(t2, a2) {
    var r2 = create$2();
    getRotation(r2, a2);
    var n = new ARRAY_TYPE(3);
    return getTranslation$1(n, a2), fromRotationTranslation(t2, r2, n), t2;
  }, copy$1 = function(t2, a2) {
    return t2[0] = a2[0], t2[1] = a2[1], t2[2] = a2[2], t2[3] = a2[3], t2[4] = a2[4], t2[5] = a2[5], t2[6] = a2[6], t2[7] = a2[7], t2;
  }, identity = function(t2) {
    return t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2[4] = 0, t2[5] = 0, t2[6] = 0, t2[7] = 0, t2;
  }, set$1 = function(t2, a2, r2, n, e, o2, u2, s, i) {
    return t2[0] = a2, t2[1] = r2, t2[2] = n, t2[3] = e, t2[4] = o2, t2[5] = u2, t2[6] = s, t2[7] = i, t2;
  }, getDual = function(t2, a2) {
    return t2[0] = a2[4], t2[1] = a2[5], t2[2] = a2[6], t2[3] = a2[7], t2;
  }, setDual = function(t2, a2) {
    return t2[4] = a2[0], t2[5] = a2[1], t2[6] = a2[2], t2[7] = a2[3], t2;
  }, getTranslation = function(t2, a2) {
    var r2 = a2[4], n = a2[5], e = a2[6], o2 = a2[7], u2 = -a2[0], s = -a2[1], i = -a2[2], c2 = a2[3];
    return t2[0] = 2 * (r2 * c2 + o2 * u2 + n * i - e * s), t2[1] = 2 * (n * c2 + o2 * s + e * u2 - r2 * i), t2[2] = 2 * (e * c2 + o2 * i + r2 * s - n * u2), t2;
  }, translate = function(t2, a2, r2) {
    var n = a2[0], e = a2[1], o2 = a2[2], u2 = a2[3], s = 0.5 * r2[0], i = 0.5 * r2[1], c2 = 0.5 * r2[2], l = a2[4], $ = a2[5], h2 = a2[6], f2 = a2[7];
    return t2[0] = n, t2[1] = e, t2[2] = o2, t2[3] = u2, t2[4] = u2 * s + e * c2 - o2 * i + l, t2[5] = u2 * i + o2 * s - n * c2 + $, t2[6] = u2 * c2 + n * i - e * s + h2, t2[7] = -n * s - e * i - o2 * c2 + f2, t2;
  }, rotateX = function(t2, a2, r2) {
    var n = -a2[0], e = -a2[1], o2 = -a2[2], u2 = a2[3], s = a2[4], i = a2[5], c2 = a2[6], l = a2[7], $ = s * u2 + l * n + i * o2 - c2 * e, h2 = i * u2 + l * e + c2 * n - s * o2, f2 = c2 * u2 + l * o2 + s * e - i * n, M2 = l * u2 - s * n - i * e - c2 * o2;
    return rotateX$1(t2, a2, r2), n = t2[0], e = t2[1], o2 = t2[2], u2 = t2[3], t2[4] = $ * u2 + M2 * n + h2 * o2 - f2 * e, t2[5] = h2 * u2 + M2 * e + f2 * n - $ * o2, t2[6] = f2 * u2 + M2 * o2 + $ * e - h2 * n, t2[7] = M2 * u2 - $ * n - h2 * e - f2 * o2, t2;
  }, rotateY = function(t2, a2, r2) {
    var n = -a2[0], e = -a2[1], o2 = -a2[2], u2 = a2[3], s = a2[4], i = a2[5], c2 = a2[6], l = a2[7], $ = s * u2 + l * n + i * o2 - c2 * e, h2 = i * u2 + l * e + c2 * n - s * o2, f2 = c2 * u2 + l * o2 + s * e - i * n, M2 = l * u2 - s * n - i * e - c2 * o2;
    return rotateY$1(t2, a2, r2), n = t2[0], e = t2[1], o2 = t2[2], u2 = t2[3], t2[4] = $ * u2 + M2 * n + h2 * o2 - f2 * e, t2[5] = h2 * u2 + M2 * e + f2 * n - $ * o2, t2[6] = f2 * u2 + M2 * o2 + $ * e - h2 * n, t2[7] = M2 * u2 - $ * n - h2 * e - f2 * o2, t2;
  }, rotateZ = function(t2, a2, r2) {
    var n = -a2[0], e = -a2[1], o2 = -a2[2], u2 = a2[3], s = a2[4], i = a2[5], c2 = a2[6], l = a2[7], $ = s * u2 + l * n + i * o2 - c2 * e, h2 = i * u2 + l * e + c2 * n - s * o2, f2 = c2 * u2 + l * o2 + s * e - i * n, M2 = l * u2 - s * n - i * e - c2 * o2;
    return rotateZ$1(t2, a2, r2), n = t2[0], e = t2[1], o2 = t2[2], u2 = t2[3], t2[4] = $ * u2 + M2 * n + h2 * o2 - f2 * e, t2[5] = h2 * u2 + M2 * e + f2 * n - $ * o2, t2[6] = f2 * u2 + M2 * o2 + $ * e - h2 * n, t2[7] = M2 * u2 - $ * n - h2 * e - f2 * o2, t2;
  }, rotateByQuatAppend = function(t2, a2, r2) {
    var n = r2[0], e = r2[1], o2 = r2[2], u2 = r2[3], s = a2[0], i = a2[1], c2 = a2[2], l = a2[3];
    return t2[0] = s * u2 + l * n + i * o2 - c2 * e, t2[1] = i * u2 + l * e + c2 * n - s * o2, t2[2] = c2 * u2 + l * o2 + s * e - i * n, t2[3] = l * u2 - s * n - i * e - c2 * o2, s = a2[4], i = a2[5], c2 = a2[6], l = a2[7], t2[4] = s * u2 + l * n + i * o2 - c2 * e, t2[5] = i * u2 + l * e + c2 * n - s * o2, t2[6] = c2 * u2 + l * o2 + s * e - i * n, t2[7] = l * u2 - s * n - i * e - c2 * o2, t2;
  }, rotateByQuatPrepend = function(t2, a2, r2) {
    var n = a2[0], e = a2[1], o2 = a2[2], u2 = a2[3], s = r2[0], i = r2[1], c2 = r2[2], l = r2[3];
    return t2[0] = n * l + u2 * s + e * c2 - o2 * i, t2[1] = e * l + u2 * i + o2 * s - n * c2, t2[2] = o2 * l + u2 * c2 + n * i - e * s, t2[3] = u2 * l - n * s - e * i - o2 * c2, s = r2[4], i = r2[5], c2 = r2[6], l = r2[7], t2[4] = n * l + u2 * s + e * c2 - o2 * i, t2[5] = e * l + u2 * i + o2 * s - n * c2, t2[6] = o2 * l + u2 * c2 + n * i - e * s, t2[7] = u2 * l - n * s - e * i - o2 * c2, t2;
  }, rotateAroundAxis = function(t2, a2, r2, n) {
    if (Math.abs(n) < EPSILON) return copy$1(t2, a2);
    var e = Math.hypot(r2[0], r2[1], r2[2]);
    n *= 0.5;
    var o2 = Math.sin(n), u2 = o2 * r2[0] / e, s = o2 * r2[1] / e, i = o2 * r2[2] / e, c2 = Math.cos(n), l = a2[0], $ = a2[1], h2 = a2[2], f2 = a2[3];
    t2[0] = l * c2 + f2 * u2 + $ * i - h2 * s, t2[1] = $ * c2 + f2 * s + h2 * u2 - l * i, t2[2] = h2 * c2 + f2 * i + l * s - $ * u2, t2[3] = f2 * c2 - l * u2 - $ * s - h2 * i;
    var M2 = a2[4], m2 = a2[5], d2 = a2[6], v2 = a2[7];
    return t2[4] = M2 * c2 + v2 * u2 + m2 * i - d2 * s, t2[5] = m2 * c2 + v2 * s + d2 * u2 - M2 * i, t2[6] = d2 * c2 + v2 * i + M2 * s - m2 * u2, t2[7] = v2 * c2 - M2 * u2 - m2 * s - d2 * i, t2;
  }, add$1 = function(t2, a2, r2) {
    return t2[0] = a2[0] + r2[0], t2[1] = a2[1] + r2[1], t2[2] = a2[2] + r2[2], t2[3] = a2[3] + r2[3], t2[4] = a2[4] + r2[4], t2[5] = a2[5] + r2[5], t2[6] = a2[6] + r2[6], t2[7] = a2[7] + r2[7], t2;
  }, multiply$1 = function(t2, a2, r2) {
    var n = a2[0], e = a2[1], o2 = a2[2], u2 = a2[3], s = r2[4], i = r2[5], c2 = r2[6], l = r2[7], $ = a2[4], h2 = a2[5], f2 = a2[6], M2 = a2[7], m2 = r2[0], d2 = r2[1], v2 = r2[2], b2 = r2[3];
    return t2[0] = n * b2 + u2 * m2 + e * v2 - o2 * d2, t2[1] = e * b2 + u2 * d2 + o2 * m2 - n * v2, t2[2] = o2 * b2 + u2 * v2 + n * d2 - e * m2, t2[3] = u2 * b2 - n * m2 - e * d2 - o2 * v2, t2[4] = n * l + u2 * s + e * c2 - o2 * i + $ * b2 + M2 * m2 + h2 * v2 - f2 * d2, t2[5] = e * l + u2 * i + o2 * s - n * c2 + h2 * b2 + M2 * d2 + f2 * m2 - $ * v2, t2[6] = o2 * l + u2 * c2 + n * i - e * s + f2 * b2 + M2 * v2 + $ * d2 - h2 * m2, t2[7] = u2 * l - n * s - e * i - o2 * c2 + M2 * b2 - $ * m2 - h2 * d2 - f2 * v2, t2;
  }, scale$1 = function(t2, a2, r2) {
    return t2[0] = a2[0] * r2, t2[1] = a2[1] * r2, t2[2] = a2[2] * r2, t2[3] = a2[3] * r2, t2[4] = a2[4] * r2, t2[5] = a2[5] * r2, t2[6] = a2[6] * r2, t2[7] = a2[7] * r2, t2;
  }, lerp$1 = function(t2, a2, r2, n) {
    var e = 1 - n;
    return dot$1(a2, r2) < 0 && (n = -n), t2[0] = a2[0] * e + r2[0] * n, t2[1] = a2[1] * e + r2[1] * n, t2[2] = a2[2] * e + r2[2] * n, t2[3] = a2[3] * e + r2[3] * n, t2[4] = a2[4] * e + r2[4] * n, t2[5] = a2[5] * e + r2[5] * n, t2[6] = a2[6] * e + r2[6] * n, t2[7] = a2[7] * e + r2[7] * n, t2;
  }, invert = function(t2, a2) {
    var r2 = squaredLength$1(a2);
    return t2[0] = -a2[0] / r2, t2[1] = -a2[1] / r2, t2[2] = -a2[2] / r2, t2[3] = a2[3] / r2, t2[4] = -a2[4] / r2, t2[5] = -a2[5] / r2, t2[6] = -a2[6] / r2, t2[7] = a2[7] / r2, t2;
  }, conjugate = function(t2, a2) {
    return t2[0] = -a2[0], t2[1] = -a2[1], t2[2] = -a2[2], t2[3] = a2[3], t2[4] = -a2[4], t2[5] = -a2[5], t2[6] = -a2[6], t2[7] = a2[7], t2;
  }, normalize$1 = function(t2, a2) {
    var r2 = squaredLength$1(a2);
    if (r2 > 0) {
      r2 = Math.sqrt(r2);
      var n = a2[0] / r2, e = a2[1] / r2, o2 = a2[2] / r2, u2 = a2[3] / r2, s = a2[4], i = a2[5], c2 = a2[6], l = a2[7], $ = n * s + e * i + o2 * c2 + u2 * l;
      t2[0] = n, t2[1] = e, t2[2] = o2, t2[3] = u2, t2[4] = (s - n * $) / r2, t2[5] = (i - e * $) / r2, t2[6] = (c2 - o2 * $) / r2, t2[7] = (l - u2 * $) / r2;
    }
    return t2;
  }, str$1 = function(t2) {
    return "quat2(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ", " + t2[3] + ", " + t2[4] + ", " + t2[5] + ", " + t2[6] + ", " + t2[7] + ")";
  }, exactEquals$1 = function(t2, a2) {
    return t2[0] === a2[0] && t2[1] === a2[1] && t2[2] === a2[2] && t2[3] === a2[3] && t2[4] === a2[4] && t2[5] === a2[5] && t2[6] === a2[6] && t2[7] === a2[7];
  }, equals$1 = function(t2, a2) {
    var r2 = t2[0], n = t2[1], e = t2[2], o2 = t2[3], u2 = t2[4], s = t2[5], i = t2[6], c2 = t2[7], l = a2[0], $ = a2[1], h2 = a2[2], f2 = a2[3], M2 = a2[4], m2 = a2[5], d2 = a2[6], v2 = a2[7];
    return Math.abs(r2 - l) <= EPSILON * Math.max(1, Math.abs(r2), Math.abs(l)) && Math.abs(n - $) <= EPSILON * Math.max(1, Math.abs(n), Math.abs($)) && Math.abs(e - h2) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(h2)) && Math.abs(o2 - f2) <= EPSILON * Math.max(1, Math.abs(o2), Math.abs(f2)) && Math.abs(u2 - M2) <= EPSILON * Math.max(1, Math.abs(u2), Math.abs(M2)) && Math.abs(s - m2) <= EPSILON * Math.max(1, Math.abs(s), Math.abs(m2)) && Math.abs(i - d2) <= EPSILON * Math.max(1, Math.abs(i), Math.abs(d2)) && Math.abs(c2 - v2) <= EPSILON * Math.max(1, Math.abs(c2), Math.abs(v2));
  }, create = function() {
    var t2 = new ARRAY_TYPE(2);
    return ARRAY_TYPE != Float32Array && (t2[0] = 0, t2[1] = 0), t2;
  }, clone = function(t2) {
    var a2 = new ARRAY_TYPE(2);
    return a2[0] = t2[0], a2[1] = t2[1], a2;
  }, fromValues = function(t2, a2) {
    var r2 = new ARRAY_TYPE(2);
    return r2[0] = t2, r2[1] = a2, r2;
  }, copy = function(t2, a2) {
    return t2[0] = a2[0], t2[1] = a2[1], t2;
  }, set = function(t2, a2, r2) {
    return t2[0] = a2, t2[1] = r2, t2;
  }, add = function(t2, a2, r2) {
    return t2[0] = a2[0] + r2[0], t2[1] = a2[1] + r2[1], t2;
  }, subtract = function(t2, a2, r2) {
    return t2[0] = a2[0] - r2[0], t2[1] = a2[1] - r2[1], t2;
  }, multiply = function(t2, a2, r2) {
    return t2[0] = a2[0] * r2[0], t2[1] = a2[1] * r2[1], t2;
  }, divide = function(t2, a2, r2) {
    return t2[0] = a2[0] / r2[0], t2[1] = a2[1] / r2[1], t2;
  }, ceil = function(t2, a2) {
    return t2[0] = Math.ceil(a2[0]), t2[1] = Math.ceil(a2[1]), t2;
  }, floor = function(t2, a2) {
    return t2[0] = Math.floor(a2[0]), t2[1] = Math.floor(a2[1]), t2;
  }, min = function(t2, a2, r2) {
    return t2[0] = Math.min(a2[0], r2[0]), t2[1] = Math.min(a2[1], r2[1]), t2;
  }, max = function(t2, a2, r2) {
    return t2[0] = Math.max(a2[0], r2[0]), t2[1] = Math.max(a2[1], r2[1]), t2;
  }, round = function(t2, a2) {
    return t2[0] = Math.round(a2[0]), t2[1] = Math.round(a2[1]), t2;
  }, scale = function(t2, a2, r2) {
    return t2[0] = a2[0] * r2, t2[1] = a2[1] * r2, t2;
  }, scaleAndAdd = function(t2, a2, r2, n) {
    return t2[0] = a2[0] + r2[0] * n, t2[1] = a2[1] + r2[1] * n, t2;
  }, distance = function(t2, a2) {
    var r2 = a2[0] - t2[0], n = a2[1] - t2[1];
    return Math.hypot(r2, n);
  }, squaredDistance = function(t2, a2) {
    var r2 = a2[0] - t2[0], n = a2[1] - t2[1];
    return r2 * r2 + n * n;
  }, length = function(t2) {
    var a2 = t2[0], r2 = t2[1];
    return Math.hypot(a2, r2);
  }, squaredLength = function(t2) {
    var a2 = t2[0], r2 = t2[1];
    return a2 * a2 + r2 * r2;
  }, negate = function(t2, a2) {
    return t2[0] = -a2[0], t2[1] = -a2[1], t2;
  }, inverse = function(t2, a2) {
    return t2[0] = 1 / a2[0], t2[1] = 1 / a2[1], t2;
  }, normalize = function(t2, a2) {
    var r2 = a2[0], n = a2[1], e = r2 * r2 + n * n;
    return e > 0 && (e = 1 / Math.sqrt(e)), t2[0] = a2[0] * e, t2[1] = a2[1] * e, t2;
  }, dot = function(t2, a2) {
    return t2[0] * a2[0] + t2[1] * a2[1];
  }, cross = function(t2, a2, r2) {
    var n = a2[0] * r2[1] - a2[1] * r2[0];
    return t2[0] = t2[1] = 0, t2[2] = n, t2;
  }, lerp = function(t2, a2, r2, n) {
    var e = a2[0], o2 = a2[1];
    return t2[0] = e + n * (r2[0] - e), t2[1] = o2 + n * (r2[1] - o2), t2;
  }, random = function(t2, a2) {
    a2 = a2 || 1;
    var r2 = 2 * RANDOM() * Math.PI;
    return t2[0] = Math.cos(r2) * a2, t2[1] = Math.sin(r2) * a2, t2;
  }, transformMat2 = function(t2, a2, r2) {
    var n = a2[0], e = a2[1];
    return t2[0] = r2[0] * n + r2[2] * e, t2[1] = r2[1] * n + r2[3] * e, t2;
  }, transformMat2d = function(t2, a2, r2) {
    var n = a2[0], e = a2[1];
    return t2[0] = r2[0] * n + r2[2] * e + r2[4], t2[1] = r2[1] * n + r2[3] * e + r2[5], t2;
  }, transformMat3 = function(t2, a2, r2) {
    var n = a2[0], e = a2[1];
    return t2[0] = r2[0] * n + r2[3] * e + r2[6], t2[1] = r2[1] * n + r2[4] * e + r2[7], t2;
  }, transformMat4 = function(t2, a2, r2) {
    var n = a2[0], e = a2[1];
    return t2[0] = r2[0] * n + r2[4] * e + r2[12], t2[1] = r2[1] * n + r2[5] * e + r2[13], t2;
  }, rotate = function(t2, a2, r2, n) {
    var e = a2[0] - r2[0], o2 = a2[1] - r2[1], u2 = Math.sin(n), s = Math.cos(n);
    return t2[0] = e * s - o2 * u2 + r2[0], t2[1] = e * u2 + o2 * s + r2[1], t2;
  }, angle = function(t2, a2) {
    var r2 = t2[0], n = t2[1], e = a2[0], o2 = a2[1], u2 = Math.sqrt((r2 * r2 + n * n) * (e * e + o2 * o2)), s = u2 && (r2 * e + n * o2) / u2;
    return Math.acos(Math.min(Math.max(s, -1), 1));
  }, zero = function(t2) {
    return t2[0] = 0, t2[1] = 0, t2;
  }, str = function(t2) {
    return "vec2(" + t2[0] + ", " + t2[1] + ")";
  }, exactEquals = function(t2, a2) {
    return t2[0] === a2[0] && t2[1] === a2[1];
  }, equals = function(t2, a2) {
    var r2 = t2[0], n = t2[1], e = a2[0], o2 = a2[1];
    return Math.abs(r2 - e) <= EPSILON * Math.max(1, Math.abs(r2), Math.abs(e)) && Math.abs(n - o2) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(o2));
  };
  setMatrixArrayType2 = setMatrixArrayType, toRadian2 = toRadian, equals$92 = equals$9, create$82 = create$8, clone$82 = clone$8, copy$82 = copy$8, identity$52 = identity$5, fromValues$82 = fromValues$8, set$82 = set$8, transpose$22 = transpose$2, invert$52 = invert$5, adjoint$22 = adjoint$2, determinant$32 = determinant$3, multiply$82 = multiply$8, rotate$42 = rotate$4, scale$82 = scale$8, fromRotation$42 = fromRotation$4, fromScaling$32 = fromScaling$3, str$82 = str$8, frob$32 = frob$3, LDU2 = LDU, add$82 = add$8, subtract$62 = subtract$6, exactEquals$82 = exactEquals$8, equals$82 = equals$8, multiplyScalar$32 = multiplyScalar$3, multiplyScalarAndAdd$32 = multiplyScalarAndAdd$3, create$72 = create$7, clone$72 = clone$7, copy$72 = copy$7, identity$42 = identity$4, fromValues$72 = fromValues$7, set$72 = set$7, invert$42 = invert$4, determinant$22 = determinant$2, multiply$72 = multiply$7, rotate$32 = rotate$3, scale$72 = scale$7, translate$32 = translate$3, fromRotation$32 = fromRotation$3, fromScaling$22 = fromScaling$2, fromTranslation$32 = fromTranslation$3, str$72 = str$7, frob$22 = frob$2, add$72 = add$7, subtract$52 = subtract$5, multiplyScalar$22 = multiplyScalar$2, multiplyScalarAndAdd$22 = multiplyScalarAndAdd$2, exactEquals$72 = exactEquals$7, equals$72 = equals$7, create$62 = create$6, fromMat4$12 = fromMat4$1, clone$62 = clone$6, copy$62 = copy$6, fromValues$62 = fromValues$6, set$62 = set$6, identity$32 = identity$3, transpose$12 = transpose$1, invert$32 = invert$3, adjoint$12 = adjoint$1, determinant$12 = determinant$1, multiply$62 = multiply$6, translate$22 = translate$2, rotate$22 = rotate$2, scale$62 = scale$6, fromTranslation$22 = fromTranslation$2, fromRotation$22 = fromRotation$2, fromScaling$12 = fromScaling$1, fromMat2d2 = fromMat2d, fromQuat$12 = fromQuat$1, normalFromMat42 = normalFromMat4, projection2 = projection, str$62 = str$6, frob$12 = frob$1, add$62 = add$6, subtract$42 = subtract$4, multiplyScalar$12 = multiplyScalar$1, multiplyScalarAndAdd$12 = multiplyScalarAndAdd$1, exactEquals$62 = exactEquals$6, equals$62 = equals$6, create$52 = create$5, clone$52 = clone$5, copy$52 = copy$5, fromValues$52 = fromValues$5, set$52 = set$5, identity$22 = identity$2, transpose2 = transpose, invert$22 = invert$2, adjoint2 = adjoint, determinant2 = determinant, multiply$52 = multiply$5, translate$12 = translate$1, scale$52 = scale$5, rotate$12 = rotate$1, rotateX$32 = rotateX$3, rotateY$32 = rotateY$3, rotateZ$32 = rotateZ$3, fromTranslation$12 = fromTranslation$1, fromScaling2 = fromScaling, fromRotation$12 = fromRotation$1, fromXRotation2 = fromXRotation, fromYRotation2 = fromYRotation, fromZRotation2 = fromZRotation, fromRotationTranslation$12 = fromRotationTranslation$1, fromQuat22 = fromQuat2, getTranslation$12 = getTranslation$1, getScaling2 = getScaling, getRotation2 = getRotation, decompose2 = decompose, fromRotationTranslationScale2 = fromRotationTranslationScale, fromRotationTranslationScaleOrigin2 = fromRotationTranslationScaleOrigin, fromQuat3 = fromQuat, frustum2 = frustum, perspectiveNO2 = perspectiveNO, perspectiveZO2 = perspectiveZO, perspectiveFromFieldOfView2 = perspectiveFromFieldOfView, orthoNO2 = orthoNO, orthoZO2 = orthoZO, lookAt2 = lookAt, targetTo2 = targetTo, str$52 = str$5, frob2 = frob, add$52 = add$5, subtract$32 = subtract$3, multiplyScalar2 = multiplyScalar, multiplyScalarAndAdd2 = multiplyScalarAndAdd, exactEquals$52 = exactEquals$5, equals$52 = equals$5, create$42 = create$4, clone$42 = clone$4, length$42 = length$4, fromValues$42 = fromValues$4, copy$42 = copy$4, set$42 = set$4, add$42 = add$4, subtract$22 = subtract$2, multiply$42 = multiply$4, divide$22 = divide$2, ceil$22 = ceil$2, floor$22 = floor$2, min$22 = min$2, max$22 = max$2, round$22 = round$2, scale$42 = scale$4, scaleAndAdd$22 = scaleAndAdd$2, distance$22 = distance$2, squaredDistance$22 = squaredDistance$2, squaredLength$42 = squaredLength$4, negate$22 = negate$2, inverse$22 = inverse$2, normalize$42 = normalize$4, dot$42 = dot$4, cross$22 = cross$2, lerp$42 = lerp$4, slerp$12 = slerp$1, hermite2 = hermite, bezier2 = bezier, random$32 = random$3, transformMat4$22 = transformMat4$2, transformMat3$12 = transformMat3$1, transformQuat$12 = transformQuat$1, rotateX$22 = rotateX$2, rotateY$22 = rotateY$2, rotateZ$22 = rotateZ$2, angle$12 = angle$1, zero$22 = zero$2, str$42 = str$4, exactEquals$42 = exactEquals$4, equals$42 = equals$4, create$32 = create$3, clone$32 = clone$3, fromValues$32 = fromValues$3, copy$32 = copy$3, set$32 = set$3, add$32 = add$3, subtract$12 = subtract$1, multiply$32 = multiply$3, divide$12 = divide$1, ceil$12 = ceil$1, floor$12 = floor$1, min$12 = min$1, max$12 = max$1, round$12 = round$1, scale$32 = scale$3, scaleAndAdd$12 = scaleAndAdd$1, distance$12 = distance$1, squaredDistance$12 = squaredDistance$1, length$32 = length$3, squaredLength$32 = squaredLength$3, negate$12 = negate$1, inverse$12 = inverse$1, normalize$32 = normalize$3, dot$32 = dot$3, cross$12 = cross$1, lerp$32 = lerp$3, random$22 = random$2, transformMat4$12 = transformMat4$1, transformQuat2 = transformQuat, zero$12 = zero$1, str$32 = str$3, exactEquals$32 = exactEquals$3, equals$32 = equals$3, create$22 = create$2, identity$12 = identity$1, setAxisAngle2 = setAxisAngle, getAxisAngle2 = getAxisAngle, getAngle2 = getAngle, multiply$22 = multiply$2, rotateX$12 = rotateX$1, rotateY$12 = rotateY$1, rotateZ$12 = rotateZ$1, calculateW2 = calculateW, exp2 = exp, ln2 = ln, pow2 = pow, slerp2 = slerp, random$12 = random$1, invert$12 = invert$1, conjugate$12 = conjugate$1, fromMat32 = fromMat3, fromEuler2 = fromEuler, str$22 = str$2, equals$22 = equals$2, create$12 = create$1, clone$12 = clone$1, fromValues$12 = fromValues$1, fromRotationTranslationValues2 = fromRotationTranslationValues, fromRotationTranslation2 = fromRotationTranslation, fromTranslation2 = fromTranslation, fromRotation2 = fromRotation, fromMat42 = fromMat4, copy$12 = copy$1, identity2 = identity, set$12 = set$1, getDual2 = getDual, setDual2 = setDual, getTranslation2 = getTranslation, translate2 = translate, rotateX2 = rotateX, rotateY2 = rotateY, rotateZ2 = rotateZ, rotateByQuatAppend2 = rotateByQuatAppend, rotateByQuatPrepend2 = rotateByQuatPrepend, rotateAroundAxis2 = rotateAroundAxis, add$12 = add$1, multiply$12 = multiply$1, scale$12 = scale$1, lerp$12 = lerp$1, invert2 = invert, conjugate2 = conjugate, normalize$12 = normalize$1, str$12 = str$1, exactEquals$12 = exactEquals$1, equals$12 = equals$1, create2 = create, clone2 = clone, fromValues2 = fromValues, copy2 = copy, set2 = set, add2 = add, subtract2 = subtract, multiply2 = multiply, divide2 = divide, ceil2 = ceil, floor2 = floor, min2 = min, max2 = max, round2 = round, scale2 = scale, scaleAndAdd2 = scaleAndAdd, distance2 = distance, squaredDistance2 = squaredDistance, length2 = length, squaredLength2 = squaredLength, negate2 = negate, inverse2 = inverse, normalize2 = normalize, dot2 = dot, cross2 = cross, lerp2 = lerp, random2 = random, transformMat22 = transformMat2, transformMat2d2 = transformMat2d, transformMat32 = transformMat3, transformMat42 = transformMat4, rotate2 = rotate, angle2 = angle, zero2 = zero, str2 = str, exactEquals2 = exactEquals, equals2 = equals;
  EPSILON = 1e-6, ARRAY_TYPE = "undefined" != typeof Float32Array ? Float32Array : Array, RANDOM = Math.random, ANGLE_ORDER = "zyx";
  degree = Math.PI / 180;
  Math.hypot || (Math.hypot = function() {
    for (var t2 = 0, a2 = arguments.length; a2--; ) t2 += arguments[a2] * arguments[a2];
    return Math.sqrt(t2);
  });
  common = { __proto__: null, EPSILON, get ARRAY_TYPE() {
    return ARRAY_TYPE;
  }, RANDOM, ANGLE_ORDER, setMatrixArrayType, toRadian, equals: equals$9 };
  mul$8 = multiply$8, sub$6 = subtract$6, mat2 = Object.freeze({ __proto__: null, create: create$8, clone: clone$8, copy: copy$8, identity: identity$5, fromValues: fromValues$8, set: set$8, transpose: transpose$2, invert: invert$5, adjoint: adjoint$2, determinant: determinant$3, multiply: multiply$8, rotate: rotate$4, scale: scale$8, fromRotation: fromRotation$4, fromScaling: fromScaling$3, str: str$8, frob: frob$3, LDU, add: add$8, subtract: subtract$6, exactEquals: exactEquals$8, equals: equals$8, multiplyScalar: multiplyScalar$3, multiplyScalarAndAdd: multiplyScalarAndAdd$3, mul: mul$8, sub: sub$6 });
  mul$7 = multiply$7, sub$5 = subtract$5, mat2d = Object.freeze({ __proto__: null, create: create$7, clone: clone$7, copy: copy$7, identity: identity$4, fromValues: fromValues$7, set: set$7, invert: invert$4, determinant: determinant$2, multiply: multiply$7, rotate: rotate$3, scale: scale$7, translate: translate$3, fromRotation: fromRotation$3, fromScaling: fromScaling$2, fromTranslation: fromTranslation$3, str: str$7, frob: frob$2, add: add$7, subtract: subtract$5, multiplyScalar: multiplyScalar$2, multiplyScalarAndAdd: multiplyScalarAndAdd$2, exactEquals: exactEquals$7, equals: equals$7, mul: mul$7, sub: sub$5 });
  mul$6 = multiply$6, sub$4 = subtract$4, mat3 = Object.freeze({ __proto__: null, create: create$6, fromMat4: fromMat4$1, clone: clone$6, copy: copy$6, fromValues: fromValues$6, set: set$6, identity: identity$3, transpose: transpose$1, invert: invert$3, adjoint: adjoint$1, determinant: determinant$1, multiply: multiply$6, translate: translate$2, rotate: rotate$2, scale: scale$6, fromTranslation: fromTranslation$2, fromRotation: fromRotation$2, fromScaling: fromScaling$1, fromMat2d, fromQuat: fromQuat$1, normalFromMat4, projection, str: str$6, frob: frob$1, add: add$6, subtract: subtract$4, multiplyScalar: multiplyScalar$1, multiplyScalarAndAdd: multiplyScalarAndAdd$1, exactEquals: exactEquals$6, equals: equals$6, mul: mul$6, sub: sub$4 });
  perspective = perspectiveNO;
  ortho = orthoNO;
  mul$5 = multiply$5, sub$3 = subtract$3, mat4 = Object.freeze({ __proto__: null, create: create$5, clone: clone$5, copy: copy$5, fromValues: fromValues$5, set: set$5, identity: identity$2, transpose, invert: invert$2, adjoint, determinant, multiply: multiply$5, translate: translate$1, scale: scale$5, rotate: rotate$1, rotateX: rotateX$3, rotateY: rotateY$3, rotateZ: rotateZ$3, fromTranslation: fromTranslation$1, fromScaling, fromRotation: fromRotation$1, fromXRotation, fromYRotation, fromZRotation, fromRotationTranslation: fromRotationTranslation$1, fromQuat2, getTranslation: getTranslation$1, getScaling, getRotation, decompose, fromRotationTranslationScale, fromRotationTranslationScaleOrigin, fromQuat, frustum, perspectiveNO, perspective, perspectiveZO, perspectiveFromFieldOfView, orthoNO, ortho, orthoZO, lookAt, targetTo, str: str$5, frob, add: add$5, subtract: subtract$3, multiplyScalar, multiplyScalarAndAdd, exactEquals: exactEquals$5, equals: equals$5, mul: mul$5, sub: sub$3 });
  sub$2 = subtract$2, mul$4 = multiply$4, div$2 = divide$2, dist$2 = distance$2, sqrDist$2 = squaredDistance$2, len$4 = length$4, sqrLen$4 = squaredLength$4, forEach$2 = function() {
    var t2 = create$4();
    return function(a2, r2, n, e, o2, u2) {
      var s, i;
      for (r2 || (r2 = 3), n || (n = 0), i = e ? Math.min(e * r2 + n, a2.length) : a2.length, s = n; s < i; s += r2) t2[0] = a2[s], t2[1] = a2[s + 1], t2[2] = a2[s + 2], o2(t2, t2, u2), a2[s] = t2[0], a2[s + 1] = t2[1], a2[s + 2] = t2[2];
      return a2;
    };
  }(), vec3 = Object.freeze({ __proto__: null, create: create$4, clone: clone$4, length: length$4, fromValues: fromValues$4, copy: copy$4, set: set$4, add: add$4, subtract: subtract$2, multiply: multiply$4, divide: divide$2, ceil: ceil$2, floor: floor$2, min: min$2, max: max$2, round: round$2, scale: scale$4, scaleAndAdd: scaleAndAdd$2, distance: distance$2, squaredDistance: squaredDistance$2, squaredLength: squaredLength$4, negate: negate$2, inverse: inverse$2, normalize: normalize$4, dot: dot$4, cross: cross$2, lerp: lerp$4, slerp: slerp$1, hermite, bezier, random: random$3, transformMat4: transformMat4$2, transformMat3: transformMat3$1, transformQuat: transformQuat$1, rotateX: rotateX$2, rotateY: rotateY$2, rotateZ: rotateZ$2, angle: angle$1, zero: zero$2, str: str$4, exactEquals: exactEquals$4, equals: equals$4, sub: sub$2, mul: mul$4, div: div$2, dist: dist$2, sqrDist: sqrDist$2, len: len$4, sqrLen: sqrLen$4, forEach: forEach$2 });
  sub$1 = subtract$1, mul$3 = multiply$3, div$1 = divide$1, dist$1 = distance$1, sqrDist$1 = squaredDistance$1, len$3 = length$3, sqrLen$3 = squaredLength$3, forEach$1 = function() {
    var t2 = create$3();
    return function(a2, r2, n, e, o2, u2) {
      var s, i;
      for (r2 || (r2 = 4), n || (n = 0), i = e ? Math.min(e * r2 + n, a2.length) : a2.length, s = n; s < i; s += r2) t2[0] = a2[s], t2[1] = a2[s + 1], t2[2] = a2[s + 2], t2[3] = a2[s + 3], o2(t2, t2, u2), a2[s] = t2[0], a2[s + 1] = t2[1], a2[s + 2] = t2[2], a2[s + 3] = t2[3];
      return a2;
    };
  }(), vec4 = Object.freeze({ __proto__: null, create: create$3, clone: clone$3, fromValues: fromValues$3, copy: copy$3, set: set$3, add: add$3, subtract: subtract$1, multiply: multiply$3, divide: divide$1, ceil: ceil$1, floor: floor$1, min: min$1, max: max$1, round: round$1, scale: scale$3, scaleAndAdd: scaleAndAdd$1, distance: distance$1, squaredDistance: squaredDistance$1, length: length$3, squaredLength: squaredLength$3, negate: negate$1, inverse: inverse$1, normalize: normalize$3, dot: dot$3, cross: cross$1, lerp: lerp$3, random: random$2, transformMat4: transformMat4$1, transformQuat, zero: zero$1, str: str$3, exactEquals: exactEquals$3, equals: equals$3, sub: sub$1, mul: mul$3, div: div$1, dist: dist$1, sqrDist: sqrDist$1, len: len$3, sqrLen: sqrLen$3, forEach: forEach$1 });
  clone$2 = clone$3, fromValues$2 = fromValues$3, copy$2 = copy$3, set$2 = set$3, add$2 = add$3, mul$2 = multiply$2, scale$2 = scale$3, dot$2 = dot$3, lerp$2 = lerp$3, length$2 = length$3, len$2 = length$2, squaredLength$2 = squaredLength$3, sqrLen$2 = squaredLength$2, normalize$2 = normalize$3, exactEquals$2 = exactEquals$3;
  rotationTo = function() {
    var t2 = create$4(), a2 = fromValues$4(1, 0, 0), r2 = fromValues$4(0, 1, 0);
    return function(n, e, o2) {
      var u2 = dot$4(e, o2);
      return u2 < -0.999999 ? (cross$2(t2, a2, e), len$4(t2) < 1e-6 && cross$2(t2, r2, e), normalize$4(t2, t2), setAxisAngle(n, t2, Math.PI), n) : u2 > 0.999999 ? (n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 1, n) : (cross$2(t2, e, o2), n[0] = t2[0], n[1] = t2[1], n[2] = t2[2], n[3] = 1 + u2, normalize$2(n, n));
    };
  }(), sqlerp = function() {
    var t2 = create$2(), a2 = create$2();
    return function(r2, n, e, o2, u2, s) {
      return slerp(t2, n, u2, s), slerp(a2, e, o2, s), slerp(r2, t2, a2, 2 * s * (1 - s)), r2;
    };
  }(), setAxes = function() {
    var t2 = create$6();
    return function(a2, r2, n, e) {
      return t2[0] = n[0], t2[3] = n[1], t2[6] = n[2], t2[1] = e[0], t2[4] = e[1], t2[7] = e[2], t2[2] = -r2[0], t2[5] = -r2[1], t2[8] = -r2[2], normalize$2(a2, fromMat3(a2, t2));
    };
  }(), quat = Object.freeze({ __proto__: null, create: create$2, identity: identity$1, setAxisAngle, getAxisAngle, getAngle, multiply: multiply$2, rotateX: rotateX$1, rotateY: rotateY$1, rotateZ: rotateZ$1, calculateW, exp, ln, pow, slerp, random: random$1, invert: invert$1, conjugate: conjugate$1, fromMat3, fromEuler, str: str$2, clone: clone$2, fromValues: fromValues$2, copy: copy$2, set: set$2, add: add$2, mul: mul$2, scale: scale$2, dot: dot$2, lerp: lerp$2, length: length$2, len: len$2, squaredLength: squaredLength$2, sqrLen: sqrLen$2, normalize: normalize$2, exactEquals: exactEquals$2, equals: equals$2, rotationTo, sqlerp, setAxes });
  getReal = copy$2;
  setReal = copy$2;
  mul$1 = multiply$1;
  dot$1 = dot$2;
  length$1 = length$2, len$1 = length$1, squaredLength$1 = squaredLength$2, sqrLen$1 = squaredLength$1;
  quat2 = Object.freeze({ __proto__: null, create: create$1, clone: clone$1, fromValues: fromValues$1, fromRotationTranslationValues, fromRotationTranslation, fromTranslation, fromRotation, fromMat4, copy: copy$1, identity, set: set$1, getReal, getDual, setReal, setDual, getTranslation, translate, rotateX, rotateY, rotateZ, rotateByQuatAppend, rotateByQuatPrepend, rotateAroundAxis, add: add$1, multiply: multiply$1, mul: mul$1, scale: scale$1, dot: dot$1, lerp: lerp$1, invert, conjugate, length: length$1, len: len$1, squaredLength: squaredLength$1, sqrLen: sqrLen$1, normalize: normalize$1, str: str$1, exactEquals: exactEquals$1, equals: equals$1 });
  len = length, sub = subtract, mul = multiply, div = divide, dist = distance, sqrDist = squaredDistance, sqrLen = squaredLength, forEach = function() {
    var t2 = create();
    return function(a2, r2, n, e, o2, u2) {
      var s, i;
      for (r2 || (r2 = 2), n || (n = 0), i = e ? Math.min(e * r2 + n, a2.length) : a2.length, s = n; s < i; s += r2) t2[0] = a2[s], t2[1] = a2[s + 1], o2(t2, t2, u2), a2[s] = t2[0], a2[s + 1] = t2[1];
      return a2;
    };
  }(), vec2 = Object.freeze({ __proto__: null, create, clone, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, length, squaredLength, negate, inverse, normalize, dot, cross, lerp, random, transformMat2, transformMat2d, transformMat3, transformMat4, rotate, angle, zero, str, exactEquals, equals, len, sub, mul, div, dist, sqrDist, sqrLen, forEach });
  globalThis.glMatrix = common, globalThis.glMatrix.mat2 = mat2, globalThis.glMatrix.mat2d = mat2d, globalThis.glMatrix.mat3 = mat3, globalThis.glMatrix.mat4 = mat4, globalThis.glMatrix.quat = quat, globalThis.glMatrix.quat2 = quat2, globalThis.glMatrix.vec2 = vec2, globalThis.glMatrix.vec3 = vec3, globalThis.glMatrix.vec4 = vec4;
}
var EPSILON;
var ARRAY_TYPE;
var RANDOM;
var ANGLE_ORDER;
var degree;
var common;
var mul$8;
var sub$6;
var mat2;
var mul$7;
var sub$5;
var mat2d;
var mul$6;
var sub$4;
var mat3;
var perspective;
var ortho;
var mul$5;
var sub$3;
var mat4;
var sub$2;
var mul$4;
var div$2;
var dist$2;
var sqrDist$2;
var len$4;
var sqrLen$4;
var forEach$2;
var vec3;
var sub$1;
var mul$3;
var div$1;
var dist$1;
var sqrDist$1;
var len$3;
var sqrLen$3;
var forEach$1;
var vec4;
var clone$2;
var fromValues$2;
var copy$2;
var set$2;
var add$2;
var mul$2;
var scale$2;
var dot$2;
var lerp$2;
var length$2;
var len$2;
var squaredLength$2;
var sqrLen$2;
var normalize$2;
var exactEquals$2;
var rotationTo;
var sqlerp;
var setAxes;
var quat;
var getReal;
var setReal;
var mul$1;
var dot$1;
var length$1;
var len$1;
var squaredLength$1;
var sqrLen$1;
var quat2;
var len;
var sub;
var mul;
var div;
var dist;
var sqrDist;
var sqrLen;
var forEach;
var vec2;
var setMatrixArrayType2;
var toRadian2;
var equals$92;
var create$82;
var clone$82;
var copy$82;
var identity$52;
var fromValues$82;
var set$82;
var transpose$22;
var invert$52;
var adjoint$22;
var determinant$32;
var multiply$82;
var rotate$42;
var scale$82;
var fromRotation$42;
var fromScaling$32;
var str$82;
var frob$32;
var LDU2;
var add$82;
var subtract$62;
var exactEquals$82;
var equals$82;
var multiplyScalar$32;
var multiplyScalarAndAdd$32;
var create$72;
var clone$72;
var copy$72;
var identity$42;
var fromValues$72;
var set$72;
var invert$42;
var determinant$22;
var multiply$72;
var rotate$32;
var scale$72;
var translate$32;
var fromRotation$32;
var fromScaling$22;
var fromTranslation$32;
var str$72;
var frob$22;
var add$72;
var subtract$52;
var multiplyScalar$22;
var multiplyScalarAndAdd$22;
var exactEquals$72;
var equals$72;
var create$62;
var fromMat4$12;
var clone$62;
var copy$62;
var fromValues$62;
var set$62;
var identity$32;
var transpose$12;
var invert$32;
var adjoint$12;
var determinant$12;
var multiply$62;
var translate$22;
var rotate$22;
var scale$62;
var fromTranslation$22;
var fromRotation$22;
var fromScaling$12;
var fromMat2d2;
var fromQuat$12;
var normalFromMat42;
var projection2;
var str$62;
var frob$12;
var add$62;
var subtract$42;
var multiplyScalar$12;
var multiplyScalarAndAdd$12;
var exactEquals$62;
var equals$62;
var create$52;
var clone$52;
var copy$52;
var fromValues$52;
var set$52;
var identity$22;
var transpose2;
var invert$22;
var adjoint2;
var determinant2;
var multiply$52;
var translate$12;
var scale$52;
var rotate$12;
var rotateX$32;
var rotateY$32;
var rotateZ$32;
var fromTranslation$12;
var fromScaling2;
var fromRotation$12;
var fromXRotation2;
var fromYRotation2;
var fromZRotation2;
var fromRotationTranslation$12;
var fromQuat22;
var getTranslation$12;
var getScaling2;
var getRotation2;
var decompose2;
var fromRotationTranslationScale2;
var fromRotationTranslationScaleOrigin2;
var fromQuat3;
var frustum2;
var perspectiveNO2;
var perspectiveZO2;
var perspectiveFromFieldOfView2;
var orthoNO2;
var orthoZO2;
var lookAt2;
var targetTo2;
var str$52;
var frob2;
var add$52;
var subtract$32;
var multiplyScalar2;
var multiplyScalarAndAdd2;
var exactEquals$52;
var equals$52;
var create$42;
var clone$42;
var length$42;
var fromValues$42;
var copy$42;
var set$42;
var add$42;
var subtract$22;
var multiply$42;
var divide$22;
var ceil$22;
var floor$22;
var min$22;
var max$22;
var round$22;
var scale$42;
var scaleAndAdd$22;
var distance$22;
var squaredDistance$22;
var squaredLength$42;
var negate$22;
var inverse$22;
var normalize$42;
var dot$42;
var cross$22;
var lerp$42;
var slerp$12;
var hermite2;
var bezier2;
var random$32;
var transformMat4$22;
var transformMat3$12;
var transformQuat$12;
var rotateX$22;
var rotateY$22;
var rotateZ$22;
var angle$12;
var zero$22;
var str$42;
var exactEquals$42;
var equals$42;
var create$32;
var clone$32;
var fromValues$32;
var copy$32;
var set$32;
var add$32;
var subtract$12;
var multiply$32;
var divide$12;
var ceil$12;
var floor$12;
var min$12;
var max$12;
var round$12;
var scale$32;
var scaleAndAdd$12;
var distance$12;
var squaredDistance$12;
var length$32;
var squaredLength$32;
var negate$12;
var inverse$12;
var normalize$32;
var dot$32;
var cross$12;
var lerp$32;
var random$22;
var transformMat4$12;
var transformQuat2;
var zero$12;
var str$32;
var exactEquals$32;
var equals$32;
var create$22;
var identity$12;
var setAxisAngle2;
var getAxisAngle2;
var getAngle2;
var multiply$22;
var rotateX$12;
var rotateY$12;
var rotateZ$12;
var calculateW2;
var exp2;
var ln2;
var pow2;
var slerp2;
var random$12;
var invert$12;
var conjugate$12;
var fromMat32;
var fromEuler2;
var str$22;
var equals$22;
var create$12;
var clone$12;
var fromValues$12;
var fromRotationTranslationValues2;
var fromRotationTranslation2;
var fromTranslation2;
var fromRotation2;
var fromMat42;
var copy$12;
var identity2;
var set$12;
var getDual2;
var setDual2;
var getTranslation2;
var translate2;
var rotateX2;
var rotateY2;
var rotateZ2;
var rotateByQuatAppend2;
var rotateByQuatPrepend2;
var rotateAroundAxis2;
var add$12;
var multiply$12;
var scale$12;
var lerp$12;
var invert2;
var conjugate2;
var normalize$12;
var str$12;
var exactEquals$12;
var equals$12;
var create2;
var clone2;
var fromValues2;
var copy2;
var set2;
var add2;
var subtract2;
var multiply2;
var divide2;
var ceil2;
var floor2;
var min2;
var max2;
var round2;
var scale2;
var scaleAndAdd2;
var distance2;
var squaredDistance2;
var length2;
var squaredLength2;
var negate2;
var inverse2;
var normalize2;
var dot2;
var cross2;
var lerp2;
var random2;
var transformMat22;
var transformMat2d2;
var transformMat32;
var transformMat42;
var rotate2;
var angle2;
var zero2;
var str2;
var exactEquals2;
var equals2;
{
  let lineInt = function(o2, n, t2) {
    t2 = t2 || 0;
    var e, l, p2, g2, r2, i, y2, u2 = [0, 0];
    return e = o2[1][1] - o2[0][1], l = o2[0][0] - o2[1][0], p2 = e * o2[0][0] + l * o2[0][1], g2 = n[1][1] - n[0][1], r2 = n[0][0] - n[1][0], i = g2 * n[0][0] + r2 * n[0][1], scalar_eq(y2 = e * r2 - g2 * l, 0, t2) || (u2[0] = (r2 * p2 - l * i) / y2, u2[1] = (e * i - g2 * p2) / y2), u2;
  }, lineSegmentsIntersect = function(o2, n, t2, e) {
    var l = n[0] - o2[0], p2 = n[1] - o2[1], g2 = e[0] - t2[0], r2 = e[1] - t2[1];
    if (g2 * p2 - r2 * l === 0) return false;
    var i = (l * (t2[1] - o2[1]) + p2 * (o2[0] - t2[0])) / (g2 * p2 - r2 * l), y2 = (g2 * (o2[1] - t2[1]) + r2 * (t2[0] - o2[0])) / (r2 * l - g2 * p2);
    return i >= 0 && i <= 1 && y2 >= 0 && y2 <= 1;
  }, triangleArea = function(o2, n, t2) {
    return (n[0] - o2[0]) * (t2[1] - o2[1]) - (t2[0] - o2[0]) * (n[1] - o2[1]);
  }, isLeft = function(o2, n, t2) {
    return triangleArea(o2, n, t2) > 0;
  }, isLeftOn = function(o2, n, t2) {
    return triangleArea(o2, n, t2) >= 0;
  }, isRight = function(o2, n, t2) {
    return triangleArea(o2, n, t2) < 0;
  }, isRightOn = function(o2, n, t2) {
    return triangleArea(o2, n, t2) <= 0;
  }, collinear = function(o2, n, t2, e) {
    if (e) {
      var l = tmpPoint1, p2 = tmpPoint2;
      l[0] = n[0] - o2[0], l[1] = n[1] - o2[1], p2[0] = t2[0] - n[0], p2[1] = t2[1] - n[1];
      var g2 = l[0] * p2[0] + l[1] * p2[1], r2 = Math.sqrt(l[0] * l[0] + l[1] * l[1]), i = Math.sqrt(p2[0] * p2[0] + p2[1] * p2[1]);
      return Math.acos(g2 / (r2 * i)) < e;
    }
    return 0 === triangleArea(o2, n, t2);
  }, sqdist = function(o2, n) {
    var t2 = n[0] - o2[0], e = n[1] - o2[1];
    return t2 * t2 + e * e;
  }, polygonAt = function(o2, n) {
    var t2 = o2.length;
    return o2[n < 0 ? n % t2 + t2 : n % t2];
  }, polygonClear = function(o2) {
    o2.length = 0;
  }, polygonAppend = function(o2, n, t2, e) {
    for (var l = t2; l < e; l++) o2.push(n[l]);
  }, polygonMakeCCW = function(o2) {
    for (var n = 0, t2 = o2, e = 1; e < o2.length; ++e) (t2[e][1] < t2[n][1] || t2[e][1] === t2[n][1] && t2[e][0] > t2[n][0]) && (n = e);
    return !isLeft(polygonAt(o2, n - 1), polygonAt(o2, n), polygonAt(o2, n + 1)) && (polygonReverse(o2), true);
  }, polygonReverse = function(o2) {
    for (var n = [], t2 = o2.length, e = 0; e !== t2; e++) n.push(o2.pop());
    for (e = 0; e !== t2; e++) o2[e] = n[e];
  }, polygonIsReflex = function(o2, n) {
    return isRight(polygonAt(o2, n - 1), polygonAt(o2, n), polygonAt(o2, n + 1));
  }, polygonCanSee = function(o2, n, t2) {
    var e, l, p2 = tmpLine1, g2 = tmpLine2;
    if (isLeftOn(polygonAt(o2, n + 1), polygonAt(o2, n), polygonAt(o2, t2)) && isRightOn(polygonAt(o2, n - 1), polygonAt(o2, n), polygonAt(o2, t2))) return false;
    l = sqdist(polygonAt(o2, n), polygonAt(o2, t2));
    for (var r2 = 0; r2 !== o2.length; ++r2) if ((r2 + 1) % o2.length !== n && r2 !== n && isLeftOn(polygonAt(o2, n), polygonAt(o2, t2), polygonAt(o2, r2 + 1)) && isRightOn(polygonAt(o2, n), polygonAt(o2, t2), polygonAt(o2, r2)) && (p2[0] = polygonAt(o2, n), p2[1] = polygonAt(o2, t2), g2[0] = polygonAt(o2, r2), g2[1] = polygonAt(o2, r2 + 1), e = lineInt(p2, g2), sqdist(polygonAt(o2, n), e) < l)) return false;
    return true;
  }, polygonCanSee2 = function(o2, n, t2) {
    for (var e = 0; e !== o2.length; ++e) if (e !== n && e !== t2 && (e + 1) % o2.length !== n && (e + 1) % o2.length !== t2 && lineSegmentsIntersect(polygonAt(o2, n), polygonAt(o2, t2), polygonAt(o2, e), polygonAt(o2, e + 1))) return false;
    return true;
  }, polygonCopy = function(o2, n, t2, e) {
    var l = e || [];
    if (polygonClear(l), n < t2) for (var p2 = n; p2 <= t2; p2++) l.push(o2[p2]);
    else {
      for (p2 = 0; p2 <= t2; p2++) l.push(o2[p2]);
      for (p2 = n; p2 < o2.length; p2++) l.push(o2[p2]);
    }
    return l;
  }, polygonGetCutEdges = function(o2) {
    for (var n = [], t2 = [], e = [], l = [], p2 = Number.MAX_VALUE, g2 = 0; g2 < o2.length; ++g2) if (polygonIsReflex(o2, g2)) {
      for (var r2 = 0; r2 < o2.length; ++r2) if (polygonCanSee(o2, g2, r2)) {
        t2 = polygonGetCutEdges(polygonCopy(o2, g2, r2, l)), e = polygonGetCutEdges(polygonCopy(o2, r2, g2, l));
        for (var i = 0; i < e.length; i++) t2.push(e[i]);
        t2.length < p2 && (n = t2, p2 = t2.length, n.push([polygonAt(o2, g2), polygonAt(o2, r2)]));
      }
    }
    return n;
  }, polygonDecomp = function(o2) {
    var n = polygonGetCutEdges(o2);
    return n.length > 0 ? polygonSlice(o2, n) : [o2];
  }, polygonSlice = function(o2, n) {
    if (0 === n.length) return [o2];
    if (n instanceof Array && n.length && n[0] instanceof Array && 2 === n[0].length && n[0][0] instanceof Array) {
      for (var t2 = [o2], e = 0; e < n.length; e++) for (var l = n[e], p2 = 0; p2 < t2.length; p2++) {
        var g2 = polygonSlice(t2[p2], l);
        if (g2) {
          t2.splice(p2, 1), t2.push(g2[0], g2[1]);
          break;
        }
      }
      return t2;
    }
    l = n, e = o2.indexOf(l[0]), p2 = o2.indexOf(l[1]);
    return -1 !== e && -1 !== p2 && [polygonCopy(o2, e, p2), polygonCopy(o2, p2, e)];
  }, polygonIsSimple = function(o2) {
    var n, t2 = o2;
    for (n = 0; n < t2.length - 1; n++) for (var e = 0; e < n - 1; e++) if (lineSegmentsIntersect(t2[n], t2[n + 1], t2[e], t2[e + 1])) return false;
    for (n = 1; n < t2.length - 2; n++) if (lineSegmentsIntersect(t2[0], t2[t2.length - 1], t2[n], t2[n + 1])) return false;
    return true;
  }, getIntersectionPoint = function(o2, n, t2, e, l) {
    l = l || 0;
    var p2 = n[1] - o2[1], g2 = o2[0] - n[0], r2 = p2 * o2[0] + g2 * o2[1], i = e[1] - t2[1], y2 = t2[0] - e[0], u2 = i * t2[0] + y2 * t2[1], s = p2 * y2 - i * g2;
    return scalar_eq(s, 0, l) ? [0, 0] : [(y2 * r2 - g2 * u2) / s, (p2 * u2 - i * r2) / s];
  }, polygonQuickDecomp = function(o2, n, t2, e, l, p2, g2) {
    p2 = p2 || 100, g2 = g2 || 0, l = l || 25, n = void 0 !== n ? n : [], t2 = t2 || [], e = e || [];
    var r2 = [0, 0], i = [0, 0], y2 = [0, 0], u2 = 0, s = 0, A = 0, a2 = 0, f2 = 0, c2 = 0, h2 = 0, v2 = [], m2 = [], d2 = o2, C2 = o2;
    if (C2.length < 3) return n;
    if (++g2 > p2) return console.warn("quickDecomp: max level (" + p2 + ") reached."), n;
    for (var R = 0; R < o2.length; ++R) if (polygonIsReflex(d2, R)) {
      t2.push(d2[R]), u2 = s = Number.MAX_VALUE;
      for (var q = 0; q < o2.length; ++q) isLeft(polygonAt(d2, R - 1), polygonAt(d2, R), polygonAt(d2, q)) && isRightOn(polygonAt(d2, R - 1), polygonAt(d2, R), polygonAt(d2, q - 1)) && (y2 = getIntersectionPoint(polygonAt(d2, R - 1), polygonAt(d2, R), polygonAt(d2, q), polygonAt(d2, q - 1)), isRight(polygonAt(d2, R + 1), polygonAt(d2, R), y2) && (A = sqdist(d2[R], y2)) < s && (s = A, i = y2, c2 = q)), isLeft(polygonAt(d2, R + 1), polygonAt(d2, R), polygonAt(d2, q + 1)) && isRightOn(polygonAt(d2, R + 1), polygonAt(d2, R), polygonAt(d2, q)) && (y2 = getIntersectionPoint(polygonAt(d2, R + 1), polygonAt(d2, R), polygonAt(d2, q), polygonAt(d2, q + 1)), isLeft(polygonAt(d2, R - 1), polygonAt(d2, R), y2) && (A = sqdist(d2[R], y2)) < u2 && (u2 = A, r2 = y2, f2 = q));
      if (c2 === (f2 + 1) % o2.length) y2[0] = (i[0] + r2[0]) / 2, y2[1] = (i[1] + r2[1]) / 2, e.push(y2), R < f2 ? (polygonAppend(v2, d2, R, f2 + 1), v2.push(y2), m2.push(y2), 0 !== c2 && polygonAppend(m2, d2, c2, d2.length), polygonAppend(m2, d2, 0, R + 1)) : (0 !== R && polygonAppend(v2, d2, R, d2.length), polygonAppend(v2, d2, 0, f2 + 1), v2.push(y2), m2.push(y2), polygonAppend(m2, d2, c2, R + 1));
      else {
        if (c2 > f2 && (f2 += o2.length), a2 = Number.MAX_VALUE, f2 < c2) return n;
        for (q = c2; q <= f2; ++q) isLeftOn(polygonAt(d2, R - 1), polygonAt(d2, R), polygonAt(d2, q)) && isRightOn(polygonAt(d2, R + 1), polygonAt(d2, R), polygonAt(d2, q)) && (A = sqdist(polygonAt(d2, R), polygonAt(d2, q))) < a2 && polygonCanSee2(d2, R, q) && (a2 = A, h2 = q % o2.length);
        R < h2 ? (polygonAppend(v2, d2, R, h2 + 1), 0 !== h2 && polygonAppend(m2, d2, h2, C2.length), polygonAppend(m2, d2, 0, R + 1)) : (0 !== R && polygonAppend(v2, d2, R, C2.length), polygonAppend(v2, d2, 0, h2 + 1), polygonAppend(m2, d2, h2, R + 1));
      }
      return v2.length < m2.length ? (polygonQuickDecomp(v2, n, t2, e, l, p2, g2), polygonQuickDecomp(m2, n, t2, e, l, p2, g2)) : (polygonQuickDecomp(m2, n, t2, e, l, p2, g2), polygonQuickDecomp(v2, n, t2, e, l, p2, g2)), n;
    }
    return n.push(o2), n;
  }, polygonRemoveCollinearPoints = function(o2, n) {
    for (var t2 = 0, e = o2.length - 1; o2.length > 3 && e >= 0; --e) collinear(polygonAt(o2, e - 1), polygonAt(o2, e), polygonAt(o2, e + 1), n) && (o2.splice(e % o2.length, 1), t2++);
    return t2;
  }, polygonRemoveDuplicatePoints = function(o2, n) {
    for (var t2 = o2.length - 1; t2 >= 1; --t2) for (var e = o2[t2], l = t2 - 1; l >= 0; --l) points_eq(e, o2[l], n) && o2.splice(t2, 1);
  }, scalar_eq = function(o2, n, t2) {
    return t2 = t2 || 0, Math.abs(o2 - n) <= t2;
  }, points_eq = function(o2, n, t2) {
    return scalar_eq(o2[0], n[0], t2) && scalar_eq(o2[1], n[1], t2);
  };
  lineInt2 = lineInt, lineSegmentsIntersect2 = lineSegmentsIntersect, triangleArea2 = triangleArea, isLeft2 = isLeft, isLeftOn2 = isLeftOn, isRight2 = isRight, isRightOn2 = isRightOn, collinear2 = collinear, sqdist2 = sqdist, polygonAt2 = polygonAt, polygonClear2 = polygonClear, polygonAppend2 = polygonAppend, polygonMakeCCW2 = polygonMakeCCW, polygonReverse2 = polygonReverse, polygonIsReflex2 = polygonIsReflex, polygonCanSee3 = polygonCanSee, polygonCanSee22 = polygonCanSee2, polygonCopy2 = polygonCopy, polygonGetCutEdges2 = polygonGetCutEdges, polygonDecomp2 = polygonDecomp, polygonSlice2 = polygonSlice, polygonIsSimple2 = polygonIsSimple, getIntersectionPoint2 = getIntersectionPoint, polygonQuickDecomp2 = polygonQuickDecomp, polygonRemoveCollinearPoints2 = polygonRemoveCollinearPoints, polygonRemoveDuplicatePoints2 = polygonRemoveDuplicatePoints, scalar_eq2 = scalar_eq, points_eq2 = points_eq;
  tmpPoint1 = [], tmpPoint2 = [];
  tmpLine1 = [], tmpLine2 = [];
  self.polyDecomp = { decomp: polygonDecomp, quickDecomp: polygonQuickDecomp, isSimple: polygonIsSimple, removeCollinearPoints: polygonRemoveCollinearPoints, removeDuplicatePoints: polygonRemoveDuplicatePoints, makeCCW: polygonMakeCCW };
}
var tmpPoint1;
var tmpPoint2;
var tmpLine1;
var tmpLine2;
var lineInt2;
var lineSegmentsIntersect2;
var triangleArea2;
var isLeft2;
var isLeftOn2;
var isRight2;
var isRightOn2;
var collinear2;
var sqdist2;
var polygonAt2;
var polygonClear2;
var polygonAppend2;
var polygonMakeCCW2;
var polygonReverse2;
var polygonIsReflex2;
var polygonCanSee3;
var polygonCanSee22;
var polygonCopy2;
var polygonGetCutEdges2;
var polygonDecomp2;
var polygonSlice2;
var polygonIsSimple2;
var getIntersectionPoint2;
var polygonQuickDecomp2;
var polygonRemoveCollinearPoints2;
var polygonRemoveDuplicatePoints2;
var scalar_eq2;
var points_eq2;
{
  let isReady = false, hasAppStarted = false, buildMode = "dev";
  const internalApiToken = Symbol("Construct internal API token");
  let internalApiTokenAccessesRemaining = 16;
  const C32 = self.C3 = class {
    constructor() {
      throw TypeError("static class can't be instantiated");
    }
    static _GetInternalAPIToken() {
      if (internalApiTokenAccessesRemaining <= 0) throw new Error("cannot obtain internal API token");
      return --internalApiTokenAccessesRemaining, internalApiToken;
    }
    static SetReady() {
      isReady = true;
    }
    static IsReady() {
      return isReady;
    }
    static SetAppStarted() {
      hasAppStarted = true;
    }
    static HasAppStarted() {
      return hasAppStarted;
    }
    static SetBuildMode(e) {
      buildMode = e;
    }
    static GetBuildMode() {
      return buildMode;
    }
    static IsReleaseBuild() {
      return "final" === buildMode;
    }
  };
  C32.isDebug = false, C32.isDebugDefend = false, C32.hardwareConcurrency = navigator.hardwareConcurrency || 2, self.C3X = {};
}
{
  const C32 = self.C3;
  C32.QueryParser = class {
    constructor(e) {
      this._queryString = e, this._parameters = /* @__PURE__ */ new Map(), this._Parse();
    }
    _Parse() {
      let e = this._queryString;
      (e.startsWith("?") || e.startsWith("#")) && (e = e.substr(1));
      const r2 = e.split("&");
      for (const e2 of r2) this._ParseParameter(e2);
    }
    _ParseParameter(e) {
      if (!e) return;
      if (!e.includes("=")) return void this._parameters.set(e, null);
      const r2 = e.indexOf("="), t2 = decodeURIComponent(e.substring(0, r2)), s = decodeURIComponent(e.substring(r2 + 1));
      this._parameters.set(t2, s);
    }
    LogAll() {
      for (const e of this._parameters) console.log("[QueryParser] Parameter '" + e[0] + "' = " + (null === e[1] ? "null" : "'" + e[1] + "'"));
    }
    Has(e) {
      return this._parameters.has(e);
    }
    Get(e) {
      const r2 = this._parameters.get(e);
      return void 0 === r2 ? null : r2;
    }
    ClearHash() {
      history.replaceState("", document.title, location.pathname + location.search);
    }
    Reparse(e) {
      this._queryString = e, this._parameters.clear(), this._Parse();
    }
  }, C32.QueryString = new C32.QueryParser(location.search), C32.LocationHashString = new C32.QueryParser(location.hash), C32.QueryString.Has("perf") && (C32.isPerformanceProfiling = true), "dev" !== C32.QueryString.Get("mode") && C32.SetBuildMode("final");
}
{
  let GetWindowsNTVersionName = function(r2) {
    const o2 = parseFloat(r2), e = windowsNTVerMap.get(o2);
    return e || (o2 >= 13 ? "11" : "NT " + r2);
  };
  GetWindowsNTVersionName2 = GetWindowsNTVersionName;
  const C32 = self.C3, UNKNOWN = "(unknown)";
  C32.Platform = { OS: UNKNOWN, OSVersion: UNKNOWN, Browser: UNKNOWN, BrowserVersion: UNKNOWN, BrowserVersionNumber: NaN, BrowserEngine: UNKNOWN, Context: "browser", IsDesktop: true, IsMobile: false, IsAppleOS: false, IsIpadOS: false, GetDetailedInfo: async () => {
  } };
  const windowsNTVerMap = /* @__PURE__ */ new Map([[5, "2000"], [5.1, "XP"], [5.2, "XP"], [6, "Vista"], [6.1, "7"], [6.2, "8"], [6.3, "8.1"], [10, "10"]]);
  const uaStr = navigator.userAgent, uaData = navigator["userAgentData"];
  if (uaData && uaData["brands"].length > 0) {
    let ReadBrandList = function(e2) {
      let t2 = "", a2 = "", s = "", n = "";
      for (const i of e2) {
        const e3 = r2.get(i["brand"]);
        !t2 && e3 && (t2 = e3, a2 = i["version"]);
        const m2 = o2.get(i["brand"]);
        !s && m2 && (s = m2, n = i["version"]);
      }
      t2 || "Chromium" !== s || (C32.Platform.Browser = "Chromium", C32.Platform.BrowserVersion = n), C32.Platform.Browser = t2 || UNKNOWN, C32.Platform.BrowserVersion = a2 || UNKNOWN, C32.Platform.BrowserEngine = s || UNKNOWN;
    };
    ReadBrandList2 = ReadBrandList;
    C32.Platform.OS = uaData["platform"], C32.Platform.IsMobile = uaData["mobile"], C32.Platform.IsDesktop = !C32.Platform.IsMobile;
    const r2 = /* @__PURE__ */ new Map([["Google Chrome", "Chrome"], ["Microsoft Edge", "Edge"], ["Opera", "Opera"], ["Opera GX", "Opera GX"], ["Mozilla Firefox", "Firefox"], ["Apple Safari", "Safari"], ["NW.js", "NW.js"]]), o2 = /* @__PURE__ */ new Map([["Chromium", "Chromium"], ["Gecko", "Gecko"], ["WebKit", "WebKit"]]);
    ReadBrandList(uaData["brands"]);
    let e = false;
    C32.Platform.GetDetailedInfo = async () => {
      if (!e) try {
        const r3 = await navigator["userAgentData"]["getHighEntropyValues"](["platformVersion", "fullVersionList"]);
        ReadBrandList(r3["fullVersionList"]), "Windows" === C32.Platform.OS ? C32.Platform.OSVersion = GetWindowsNTVersionName(r3["platformVersion"]) : C32.Platform.OSVersion = r3["platformVersion"], e = true;
      } catch (r3) {
        console.warn("Failed to get detailed user agent information: ", r3);
      }
    };
  } else {
    let RunTest = function(r2, o2) {
      const e = Array.isArray(r2) ? r2 : [r2];
      for (const r3 of e) {
        const e2 = r3.exec(uaStr);
        if (e2) {
          o2(e2);
          break;
        }
      }
    };
    RunTest2 = RunTest;
    RunTest(/windows\s+nt\s+([\d\.]+)/i, (r2) => {
      C32.Platform.OS = "Windows";
      const o2 = r2[1];
      C32.Platform.OSVersion = GetWindowsNTVersionName(o2);
    }), RunTest(/mac\s+os\s+x\s+([\d\._]+)/i, (r2) => {
      C32.Platform.OS = "macOS", C32.Platform.OSVersion = r2[1].replace(/_/g, ".");
    }), RunTest(/CrOS/, () => {
      C32.Platform.OS = "Chrome OS";
    }), RunTest(/linux|openbsd|freebsd|netbsd/i, () => {
      C32.Platform.OS = "Linux";
    }), RunTest(/android/i, () => {
      C32.Platform.OS = "Android";
    }), RunTest(/android\s+([\d\.]+)/i, (r2) => {
      C32.Platform.OS = "Android", C32.Platform.OSVersion = r2[1];
    }), C32.Platform.OS === UNKNOWN && (RunTest(/(iphone|ipod|ipad)/i, (r2) => {
      C32.Platform.OS = "iOS";
    }), RunTest([/iphone\s+os\s+([\d\._]+)/i, /ipad[^)]*os\s+([\d\._]+)/i], (r2) => {
      C32.Platform.OS = "iOS", C32.Platform.OSVersion = r2[1].replace(/_/g, ".");
    }));
    const t2 = /chrome\//i.test(uaStr), a2 = /chromium\//i.test(uaStr), s = /edg\//i.test(uaStr), n = /OPR\//.test(uaStr), i = /nwjs/i.test(uaStr), m2 = /safari\//i.test(uaStr), l = /webkit/i.test(uaStr);
    s || n || RunTest(/chrome\/([\d\.]+)/i, (r2) => {
      C32.Platform.Browser = "Chrome", C32.Platform.BrowserVersion = r2[1], C32.Platform.BrowserEngine = "Chromium";
    }), RunTest(/edg\/([\d\.]+)/i, (r2) => {
      C32.Platform.Browser = "Edge", C32.Platform.BrowserVersion = r2[1], C32.Platform.BrowserEngine = "Chromium";
    }), RunTest(/OPR\/([\d\.]+)/, (r2) => {
      C32.Platform.Browser = "Opera", C32.Platform.BrowserVersion = r2[1], C32.Platform.BrowserEngine = "Chromium";
    }), RunTest(/chromium\/([\d\.]+)/i, (r2) => {
      C32.Platform.Browser = "Chromium", C32.Platform.BrowserVersion = r2[1], C32.Platform.BrowserEngine = "Chromium";
    }), RunTest(/nwjs\/[0-9.]+/i, (r2) => {
      C32.Platform.Browser = "NW.js", C32.Platform.BrowserVersion = r2[1], C32.Platform.BrowserEngine = "Chromium", C32.Platform.Context = "nwjs";
    }), RunTest(/firefox\/([\d\.]+)/i, (r2) => {
      C32.Platform.Browser = "Firefox", C32.Platform.BrowserVersion = r2[1], C32.Platform.BrowserEngine = "Gecko";
    }), !m2 || t2 || a2 || s || n || i || (C32.Platform.Browser = "Safari", C32.Platform.BrowserEngine = "WebKit", RunTest(/version\/([\d\.]+)/i, (r2) => {
      C32.Platform.BrowserVersion = r2[1];
    }), RunTest(/crios\/([\d\.]+)/i, (r2) => {
      C32.Platform.Browser = "Chrome for iOS", C32.Platform.BrowserVersion = r2[1];
    }), RunTest(/fxios\/([\d\.]+)/i, (r2) => {
      C32.Platform.Browser = "Firefox for iOS", C32.Platform.BrowserVersion = r2[1];
    }), RunTest(/edgios\/([\d\.]+)/i, (r2) => {
      C32.Platform.Browser = "Edge for iOS", C32.Platform.BrowserVersion = r2[1];
    })), C32.Platform.BrowserEngine === UNKNOWN && l && (C32.Platform.BrowserEngine = "WebKit"), "Android" === C32.Platform.OS && "Safari" === C32.Platform.Browser && (C32.Platform.Browser = "Stock");
    const f2 = (/* @__PURE__ */ new Set(["Windows", "macOS", "Linux", "Chrome OS"])).has(C32.Platform.OS) || "nwjs" === C32.Platform.Context;
    C32.Platform.IsDesktop = f2, C32.Platform.IsMobile = !f2;
  }
  "Chrome" === C32.Platform.Browser && "browser" === C32.Platform.Context && /wv\)/.test(uaStr) && (C32.Platform.Context = "webview"), "nwjs" !== C32.Platform.Context && "undefined" != typeof window && (window.matchMedia && window.matchMedia("(display-mode: standalone)").matches || navigator["standalone"]) && (C32.Platform.Context = "webapp"), C32.Platform.BrowserVersionNumber = parseFloat(C32.Platform.BrowserVersion);
  const looksLikeIPadOS = "macOS" === C32.Platform.OS && navigator["maxTouchPoints"] && navigator["maxTouchPoints"] > 2;
  looksLikeIPadOS && (C32.Platform.OS = "iOS", C32.Platform.OSVersion = C32.Platform.BrowserVersion, C32.Platform.IsDesktop = false, C32.Platform.IsMobile = true, C32.Platform.IsIpadOS = true), C32.Platform.IsAppleOS = "macOS" === C32.Platform.OS || "iOS" === C32.Platform.OS;
}
var ReadBrandList2;
var RunTest2;
var GetWindowsNTVersionName2;
{
  "use strict";
  {
    let s = function(e2) {
      return new Promise((t3, r3) => {
        e2.onsuccess = () => t3(e2.result), e2.onerror = () => r3(e2.error);
      });
    }, a2 = function(e2) {
      return new Promise((t3, r3) => {
        e2.oncomplete = () => t3(), e2.onerror = () => r3(e2.error), e2.onabort = () => r3(e2.error);
      });
    }, c2 = function(e2, t3) {
      return u2(e2, t3);
    }, i = function(e2, t3) {
      return u2(e2, t3, true);
    }, l = function(e2) {
      f2(e2);
      let t3 = r2.get(e2);
      return t3 instanceof Promise || (t3 = y2(e2), r2.set(e2, t3), t3.catch((t4) => r2.delete(e2))), t3;
    }, f2 = function(e2) {
      if ("string" != typeof e2) throw new TypeError("expected string");
    }, d2 = function(e2, r3) {
      const n2 = e2.objectStore(t2).openCursor();
      return new Promise((e3) => {
        const t3 = [];
        n2.onsuccess = (n3) => {
          const o3 = n3.target.result;
          if (o3) {
            switch (r3) {
              case "entries":
                t3.push([o3.key, o3.value]);
                break;
              case "keys":
                t3.push(o3.key);
                break;
              case "values":
                t3.push(o3.value);
            }
            o3.continue();
          } else e3(t3);
        };
      });
    };
    s2 = s, a3 = a2, c3 = c2, i2 = i, l2 = l, f3 = f2, d3 = d2;
    const e = 2, t2 = "keyvaluepairs", r2 = /* @__PURE__ */ new Map(), n = "undefined" != typeof IDBObjectStore && "function" == typeof IDBObjectStore.prototype.getAll, o2 = "undefined" != typeof IDBObjectStore && "function" == typeof IDBObjectStore.prototype.getAllKeys;
    async function u2(e2, n2, o3 = false, s3 = true) {
      const a4 = await l(e2);
      try {
        return n2(a4.transaction([t2], o3 ? "readwrite" : "readonly"));
      } catch (t3) {
        if (s3 && "InvalidStateError" === t3["name"]) return r2.delete(e2), u2(e2, n2, o3, false);
        throw t3;
      }
    }
    async function y2(r3) {
      f2(r3);
      const n2 = indexedDB.open(r3, e);
      return n2.addEventListener("upgradeneeded", (e2) => {
        try {
          e2.target.result.createObjectStore(t2);
        } catch (e3) {
          console.error(`Failed to create objectstore for database ${r3}`, e3);
        }
      }), s(n2);
    }
    class m2 {
      constructor(e2) {
        f2(e2), this.name = e2;
      }
      async ready() {
        await l(this.name);
      }
      set(e2, r3) {
        return f2(e2), i(this.name, async (n2) => {
          const o3 = s(n2.objectStore(t2).put(r3, e2)), c4 = a2(n2);
          await Promise.all([c4, o3]);
        });
      }
      get(e2) {
        return f2(e2), c2(this.name, async (r3) => {
          const n2 = s(r3.objectStore(t2).get(e2)), o3 = a2(r3), [c4, i3] = await Promise.all([o3, n2]);
          return i3;
        });
      }
      delete(e2) {
        return f2(e2), i(this.name, async (r3) => {
          const n2 = s(r3.objectStore(t2).delete(e2)), o3 = a2(r3);
          await Promise.all([o3, n2]);
        });
      }
      clear() {
        return i(this.name, async (e2) => {
          const r3 = s(e2.objectStore(t2).clear()), n2 = a2(e2);
          await Promise.all([n2, r3]);
        });
      }
      keys() {
        return c2(this.name, async (e2) => {
          let r3;
          if (o2) {
            r3 = s(e2.objectStore(t2).getAllKeys());
          } else r3 = d2(e2, "keys");
          const n2 = a2(e2), [c4, i3] = await Promise.all([n2, r3]);
          return i3;
        });
      }
      values() {
        return c2(this.name, async (e2) => {
          let r3;
          if (n) {
            r3 = s(e2.objectStore(t2).getAll());
          } else r3 = d2(e2, "values");
          const o3 = a2(e2), [c4, i3] = await Promise.all([o3, r3]);
          return i3;
        });
      }
      entries() {
        return c2(this.name, async (e2) => {
          const t3 = d2(e2, "entries"), r3 = a2(e2), [n2, o3] = await Promise.all([r3, t3]);
          return o3;
        });
      }
    }
    self.KVStorageContainer = m2;
  }
}
var s2;
var a3;
var c3;
var i2;
var l2;
var f3;
var d3;
{
  "use strict";
  {
    let r2 = function(e2) {
      throw new Error(`"${e2}" is not implemented`);
    }, a2 = function(e2) {
      if ("function" == typeof e2) throw new Error("localforage callback API is not implemented; please use the promise API instead");
    }, o2 = function(e2) {
      return "object" == typeof e2 ? new Promise((t3) => {
        const { port1: r4, port2: a3 } = new MessageChannel();
        a3.onmessage = (e3) => t3(e3.data), r4.postMessage(e2);
      }) : Promise.resolve(e2);
    };
    r3 = r2, a3 = a2, o3 = o2;
    const e = self.KVStorageContainer, t2 = [/no available storage method found/i, /an attempt was made to break through the security policy of the user agent/i, /the user denied permission to access the database/i, /a mutation operation was attempted on a database that did not allow mutations/i, /idbfactory\.open\(\) called in an invalid security context/i];
    /* @__PURE__ */ new WeakMap();
    class s {
      constructor(e2) {
        this._inst = e2, this._isInMemory = !this._inst, this._isInMemory || "undefined" != typeof indexedDB || (this._isInMemory = true, console.warn("Unable to use local storage because IndexedDB API is not available")), this._memoryStorage = /* @__PURE__ */ new Map();
      }
      _MaybeSwitchToMemoryFallback(e2) {
        if (!this._isInMemory) {
          for (const r4 of t2) if (e2 && r4.test(e2.message)) {
            console.error("Unable to use local storage, reverting to in-memory store: ", e2, e2.message), this._isInMemory = true;
            break;
          }
        }
      }
      async _getItemFallback(e2) {
        const t3 = this._memoryStorage.get(e2), r4 = await o2(t3);
        return void 0 === r4 ? null : r4;
      }
      async _setItemFallback(e2, t3) {
        t3 = await o2(t3), this._memoryStorage.set(e2, t3);
      }
      _removeItemFallback(e2) {
        this._memoryStorage.delete(e2);
      }
      _clearFallback() {
        this._memoryStorage.clear();
      }
      _keysFallback() {
        return Array.from(this._memoryStorage.keys());
      }
      IsInMemory() {
        return this._isInMemory;
      }
      GetMemoryStorage() {
        return this._memoryStorage;
      }
      SetMemoryStorage(e2) {
        this._memoryStorage = e2;
      }
      async getItem(e2, t3) {
        if (a2(t3), this._isInMemory) return await this._getItemFallback(e2);
        let r4;
        try {
          r4 = await this._inst.get(e2);
        } catch (t4) {
          return this._MaybeSwitchToMemoryFallback(t4), this._isInMemory ? await this._getItemFallback(e2) : (console.error(`Error reading '${e2}' from storage, returning null: `, t4), null);
        }
        return void 0 === r4 ? null : r4;
      }
      async setItem(e2, t3, r4) {
        if (a2(r4), void 0 === t3 && (t3 = null), this._isInMemory) await this._setItemFallback(e2, t3);
        else try {
          await this._inst.set(e2, t3);
        } catch (r5) {
          if (this._MaybeSwitchToMemoryFallback(r5), !this._isInMemory) throw r5;
          await this._setItemFallback(e2, t3);
        }
      }
      async removeItem(e2, t3) {
        if (a2(t3), this._isInMemory) this._removeItemFallback(e2);
        else try {
          await this._inst.delete(e2);
        } catch (t4) {
          this._MaybeSwitchToMemoryFallback(t4), this._isInMemory ? this._removeItemFallback(e2) : console.error(`Error removing '${e2}' from storage: `, t4);
        }
      }
      async clear(e2) {
        if (a2(e2), this._isInMemory) this._clearFallback();
        else try {
          await this._inst.clear();
        } catch (e3) {
          this._MaybeSwitchToMemoryFallback(e3), this._isInMemory ? this._clearFallback() : console.error("Error clearing storage: ", e3);
        }
      }
      async keys(e2) {
        if (a2(e2), this._isInMemory) return this._keysFallback();
        let t3 = [];
        try {
          t3 = await this._inst.keys();
        } catch (e3) {
          if (this._MaybeSwitchToMemoryFallback(e3), this._isInMemory) return this._keysFallback();
          console.error("Error getting storage keys: ", e3);
        }
        return t3;
      }
      ready(e2) {
        return a2(e2), this._isInMemory ? Promise.resolve(true) : this._inst.ready();
      }
      createInstance(t3) {
        if (t3.forceInMemoryFallback) return new s(null);
        {
          const r4 = t3.name;
          if ("string" != typeof r4) throw new TypeError("invalid store name");
          const a3 = new e(r4);
          return new s(a3);
        }
      }
      length(e2) {
        r2("localforage.length()");
      }
      key(e2, t3) {
        r2("localforage.key()");
      }
      iterate(e2, t3) {
        r2("localforage.iterate()");
      }
      setDriver(e2) {
        r2("localforage.setDriver()");
      }
      config(e2) {
        r2("localforage.config()");
      }
      defineDriver(e2) {
        r2("localforage.defineDriver()");
      }
      driver() {
        r2("localforage.driver()");
      }
      supports(e2) {
        r2("localforage.supports()");
      }
      dropInstance() {
        r2("localforage.dropInstance()");
      }
    }
    self["localforage"] = new s(new e("localforage"));
  }
}
var r3;
var a3;
var o3;
{
  const C32 = self.C3;
  if (C32.Supports = {}, C32.Supports.WebAnimations = (() => {
    try {
      if ("undefined" == typeof document) return false;
      const e = document.createElement("div");
      if (void 0 === e.animate) return false;
      return void 0 !== e.animate([{ opacity: "0" }, { opacity: "1" }], 1e3).reverse;
    } catch (e) {
      return false;
    }
  })(), C32.Supports.DialogElement = "undefined" != typeof HTMLDialogElement, C32.Supports.RequestIdleCallback = !!self.requestIdleCallback, C32.Supports.ImageBitmap = !!self.createImageBitmap, C32.Supports.ImageBitmapOptions = false, C32.Supports.ImageBitmapOptionsResize = false, C32.Supports.ImageBitmap) {
    try {
      self.createImageBitmap(new ImageData(32, 32), { "premultiplyAlpha": "none" }).then(() => {
        C32.Supports.ImageBitmapOptions = true;
      }).catch(() => {
        C32.Supports.ImageBitmapOptions = false;
      });
    } catch (e) {
      C32.Supports.ImageBitmapOptions = false;
    }
    try {
      self.createImageBitmap(new ImageData(32, 32), { "resizeWidth": 10, "resizeHeight": 10 }).then((e) => {
        C32.Supports.ImageBitmapOptionsResize = 10 === e.width && 10 === e.height;
      }).catch(() => {
        C32.Supports.ImageBitmapOptionsResize = false;
      });
    } catch (e) {
      C32.Supports.ImageBitmapOptionsResize = false;
    }
  }
  if (C32.Supports.ClipboardReadText = !(!navigator["clipboard"] || !navigator["clipboard"]["readText"]), C32.Supports.PermissionsQuery = !(!navigator["permissions"] || !navigator["permissions"]["query"]), C32.Supports.ClipboardPermissionsQuery = false, C32.Supports.PermissionsQuery) {
    const e = { "name": "clipboard-read" };
    navigator["permissions"]["query"](e).then(() => {
      C32.Supports.ClipboardPermissionsQuery = true;
    }).catch(() => {
      C32.Supports.ClipboardPermissionsQuery = false;
    });
  }
  C32.Supports.AsyncClipboardApi = !!(navigator["permissions"] && navigator["clipboard"] && self["ClipboardItem"]), C32.Supports.Proxies = "undefined" != typeof Proxy, C32.Supports.DownloadAttribute = (() => {
    if ("undefined" == typeof document) return false;
    return void 0 !== document.createElement("a").download;
  })(), C32.Supports.Fetch = "function" == typeof fetch, C32.Supports.PersistentStorage = !!(self.isSecureContext && "Opera" !== C32.Platform.Browser && navigator["storage"] && navigator["storage"]["persist"]), C32.Supports.StorageQuotaEstimate = !!(self.isSecureContext && navigator["storage"] && navigator["storage"]["estimate"]), C32.Supports.Fullscreen = (() => {
    if ("undefined" == typeof document) return false;
    if ("iOS" === C32.Platform.OS) return false;
    const e = document.documentElement;
    return !!(e.requestFullscreen || e.msRequestFullscreen || e.mozRequestFullScreen || e.webkitRequestFullscreen);
  })(), C32.Supports.ImageDecoder = void 0 !== self["ImageDecoder"], C32.Supports.WebCodecs = !!self["VideoEncoder"], C32.Supports.NativeFileSystemAPI = !!self["showOpenFilePicker"], C32.Supports.QueryLocalFonts = !!self["queryLocalFonts"], C32.Supports.UserActivation = !!navigator["userActivation"], C32.Supports.CanvasToBlobWebP = false, (async () => {
    let e;
    "undefined" == typeof document ? e = new OffscreenCanvas(32, 32) : (e = document.createElement("canvas"), e.width = 32, e.height = 32);
    const t2 = e.getContext("2d");
    t2.fillStyle = "blue", t2.fillRect(0, 0, 32, 32);
    let o2 = null;
    try {
      e["convertToBlob"] ? o2 = await e["convertToBlob"]({ "type": "image/webp", "quality": 1 }) : e.toBlob && (o2 = await new Promise((t3) => e.toBlob(t3, "image/webp", 1))), C32.Supports.CanvasToBlobWebP = o2 && "image/webp" === o2.type;
    } catch (e2) {
      C32.Supports.CanvasToBlobWebP = false;
    }
  })();
}
{
  const C32 = self.C3;
  String.prototype.replaceAll || (String.prototype.replaceAll = function(t2, e) {
    return this.replace(new RegExp(C32.EscapeRegex(t2), "g"), e);
  }), Array.prototype.at || (Array.prototype.at = function(t2) {
    if ((t2 = Math.trunc(t2) || 0) < 0 && (t2 += this.length), !(t2 < 0 || t2 >= this.length)) return this[t2];
  }), String.prototype.at || (String.prototype.at = function(t2) {
    if ((t2 = Math.trunc(t2) || 0) < 0 && (t2 += this.length), !(t2 < 0 || t2 >= this.length)) return this[t2];
  }), RegExp.escape || (RegExp.escape = function(t2) {
    return String(t2).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
  }), Set.prototype.isSubsetOf || (Set.prototype.isSubsetOf = function(t2) {
    if (!(t2 instanceof Set)) throw new TypeError("argument must be a Set");
    for (const e of this) if (!t2.has(e)) return false;
    return true;
  }), navigator["storage"] && !navigator["storage"]["estimate"] && navigator["webkitTemporaryStorage"] && navigator["webkitTemporaryStorage"]["queryUsageAndQuota"] && (navigator["storage"]["estimate"] = function() {
    return new Promise((t2, e) => navigator["webkitTemporaryStorage"]["queryUsageAndQuota"]((e2, r2) => t2({ "usage": e2, "quota": r2 }), e));
  });
}
{
  let assertFail = function(e) {
    let s = "Assertion failure: " + e + "\n\nStack trace:\n" + C32.GetCallStack();
    console.error(s);
  };
  assertFail2 = assertFail;
  const C32 = self.C3;
  self.assert = function(e, s) {
    e || assertFail(s);
  };
}
var assertFail2;
{
  const C32 = self.C3, C3X = self.C3X;
  C32.IsNumber = function(e) {
    return "number" == typeof e;
  }, C32.IsFiniteNumber = function(e) {
    return C32.IsNumber(e) && isFinite(e);
  }, C32.RequireNumber = function(e) {
    if (!C32.IsNumber(e)) throw new TypeError("expected number");
  }, C32.RequireOptionalNumber = function(e) {
    C32.IsNullOrUndefined(e);
  }, C32.RequireNumberInRange = function(e, n, r2) {
    if (!C32.IsNumber(e) || isNaN(e) || n > e || r2 < e) throw new RangeError("number outside of range");
  }, C32.RequireAllNumber = function(...e) {
    for (let n of e) ;
  }, C32.RequireFiniteNumber = function(e) {
    if (!C32.IsFiniteNumber(e)) throw new TypeError("expected finite number");
  }, C32.RequireOptionalFiniteNumber = function(e) {
    C32.IsNullOrUndefined(e);
  }, C32.RequireAllFiniteNumber = function(...e) {
    for (let n of e) ;
  }, C32.IsString = function(e) {
    return "string" == typeof e;
  }, C32.RequireString = function(e) {
    if (!C32.IsString(e)) throw new TypeError("expected string");
  }, C32.RequireOptionalString = function(e) {
    C32.IsNullOrUndefined(e);
  }, C32.RequireAllString = function(...e) {
    for (let n of e) ;
  }, C32.IsSimpleObject = function(e) {
    if ("object" != typeof e || null === e) return false;
    let n = Object.getPrototypeOf(e);
    return n ? n.constructor === Object : null === n;
  }, C32.RequireSimpleObject = function(e) {
    if (!C32.IsSimpleObject(e)) throw new TypeError("expected simple object");
  }, C32.RequireOptionalSimpleObject = function(e) {
    if (!C32.IsNullOrUndefined(e) && !C32.IsSimpleObject(e)) throw new TypeError("expected simple object");
  }, C32.IsObject = function(e) {
    return "object" == typeof e && null !== e && !Array.isArray(e);
  }, C32.RequireObject = function(e) {
    if (!C32.IsObject(e)) throw new TypeError("expected object");
  }, C32.RequireOptionalObject = function(e) {
    C32.IsNullOrUndefined(e);
  }, C32.RequireAllObject = function(...e) {
    for (let n of e) ;
  }, C32.IsFileLike = function(e) {
    return C32.WeakIsInstanceOf(e, Blob) && "string" == typeof e["name"];
  }, C32.RequireFileLike = function(e) {
    if (!C32.IsFileLike(e)) throw new TypeError("expected file");
  }, C32.RequireOptionalFileLike = function(e) {
    C32.IsNullOrUndefined(e);
  }, C32.IsArray = function(e) {
    return Array.isArray(e);
  }, C32.RequireArray = function(e) {
    if (!C32.IsArray(e)) throw new TypeError("expected array");
  }, C32.RequireOptionalArray = function(e) {
    C32.IsNullOrUndefined(e);
  }, C32.RequireAllArray = function(...e) {
    for (let n of e) ;
  }, C32.Is2DArray = function(e) {
    return !!C32.IsArray(e) && (!e.length || !!C32.IsArray(e[0]));
  }, C32.Require2DArray = function(e) {
    if (!C32.Is2DArray(e)) throw new TypeError("expected 2d array");
    for (let n of e) if (!C32.IsArray(n)) throw new TypeError("expected 2d array");
  }, C32.RequireOptional2DArray = function(e) {
    C32.IsNullOrUndefined(e);
  }, C32.IsFunction = function(e) {
    return "function" == typeof e;
  }, C32.RequireFunction = function(e, n) {
    if (!C32.IsFunction(e)) throw new TypeError("expected function");
    if (!C32.IsNullOrUndefined(n) && e !== n) throw new TypeError("expected same function reference");
  }, C32.RequireOptionalFunction = function(e) {
    C32.IsNullOrUndefined(e);
  }, C32.RequireAllFunction = function(...e) {
    for (let n of e) ;
  }, C32.RequireAnyFunction = function(e, ...n) {
    if (!C32.IsFunction(e)) throw new TypeError("expected function");
    if (!n.length) throw new Error("missing comparison functions");
    for (let r2 of n) if (!C32.IsNullOrUndefined(r2) && e === r2) return;
    throw new TypeError("expected same function reference");
  }, C32.RequireOptionalAllFunction = function(...e) {
    if (!C32.IsNullOrUndefined(e)) for (let n of e) ;
  }, C32.IsInstanceOf = function(e, n) {
    return e instanceof n;
  }, C32.IsInstanceOfAny = function(e, ...n) {
    for (let r2 of n) if (C32.IsInstanceOf(e, r2)) return true;
    return false;
  }, C32.RequireInstanceOf = function(e, n) {
    if (!C32.IsInstanceOf(e, n)) throw new TypeError("unexpected type");
  }, C32.RequireOptionalInstanceOf = function(e, n) {
    C32.IsNullOrUndefined(e);
  }, C32.RequireAllInstanceOf = function(e, ...n) {
    for (let e2 of n) ;
  }, C32.RequireAnyInstanceOf = function(e, ...n) {
    if (!C32.IsInstanceOfAny(e, ...n)) throw new TypeError("unexpected type");
  }, C32.RequireAnyOptionalInstanceOf = function(e, ...n) {
    if (!C32.IsNullOrUndefined(e) && !C32.IsInstanceOfAny(e, ...n)) throw new TypeError("unexpected type");
  }, C32.IsArrayOf = function(e, n) {
    for (let r2 of e) if (!C32.IsInstanceOf(r2, n)) return false;
    return true;
  }, C32.IsArrayOfFiniteNumbers = function(e) {
    for (let n of e) if (!C32.IsFiniteNumber(n)) return false;
    return true;
  }, C32.RequireArrayOf = function(e, n) {
    for (let n2 of e) ;
  }, C32.RequireOptionalArrayOf = function(e, n) {
    if (!C32.IsNullOrUndefined(e)) for (let n2 of e) ;
  }, C32.RequireOptionalArrayOfFunctions = function(e, n) {
    if (!C32.IsNullOrUndefined(e)) for (let n2 of e) ;
  }, C32.RequireArrayOfAny = function(e, ...n) {
    for (let n2 of e) ;
  }, C32.RequireOptionalArrayOfAny = function(e, ...n) {
    if (!C32.IsNullOrUndefined(e)) for (let n2 of e) ;
  }, C32.IsDOMNode = function(e, n) {
    return !(C32.IsNullOrUndefined(e) || !C32.IsString(e.nodeName)) && (!n || C32.equalsNoCase(e.nodeName, n));
  }, C32.RequireDOMNode = function(e, n) {
    if (C32.IsNullOrUndefined(e) || !C32.IsString(e.nodeName)) throw new TypeError("expected DOM node");
    if (n && !C32.equalsNoCase(e.nodeName, n)) throw new TypeError(`expected DOM '${n}' node`);
  }, C32.RequireOptionalDOMNode = function(e, n) {
    C32.IsNullOrUndefined(e);
  }, C32.IsHTMLElement = function(e, n) {
    return !(C32.IsNullOrUndefined(e) || !C32.IsString(e.tagName)) && (!n || C32.equalsNoCase(e.tagName, n));
  }, C32.RequireHTMLElement = function(e, n) {
    if (C32.IsNullOrUndefined(e) || !C32.IsString(e.tagName)) throw new TypeError("expected HTML element");
    if (n && !C32.equalsNoCase(e.tagName, n)) throw new TypeError(`expected HTML '${n}' element`);
  }, C32.RequireOptionalHTMLElement = function(e, n) {
    C32.IsNullOrUndefined(e);
  }, C32.IsDrawable = function(e) {
    return C32.IsHTMLElement(e, "img") || C32.IsHTMLElement(e, "canvas") || C32.IsHTMLElement(e, "video") || "undefined" != typeof OffscreenCanvas && e instanceof OffscreenCanvas || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap;
  }, C32.RequireDrawable = function(e) {
    if (!C32.IsDrawable(e)) throw new TypeError("expected drawable");
  }, C32.RequireOptionalDrawable = function(e) {
    C32.IsNullOrUndefined(e);
  }, C32.IsDrawableOrImageData = function(e) {
    return e instanceof ImageData || C32.IsDrawable(e);
  }, C32.RequireDrawableOrImageData = function(e) {
    if (!C32.IsDrawableOrImageData(e)) throw new TypeError("expected drawable or image data");
  }, C32.RequireOptionalDrawableOrImageData = function(e) {
    if (!C32.IsNullOrUndefined(e) && !C32.IsDrawableOrImageData(e)) throw new TypeError("expected drawable or image data");
  }, C32.IsStringLike = function(e) {
    return "string" == typeof e || C32.HtmlString && e instanceof C32.HtmlString || e instanceof C32.BBString;
  }, C32.RequireStringLike = function(e) {
    if (!C32.IsStringLike(e)) throw new TypeError("expected string-like");
  }, C32.RequireOptionalStringLike = function(e) {
    C32.IsNullOrUndefined(e);
  }, C32.RequireAllStringLike = function(...e) {
    for (let n of e) ;
  }, C32.RequireOverride = function() {
    throw new Error("must be overridden");
  }, C32.NotYetImplemented = function() {
    throw new Error("not yet implemented");
  }, C32.IsGeneratorFunction = function(e) {
    return e.constructor === function* () {
    }.constructor;
  }, C32.RequireGeneratorFunction = function(e) {
    if (!C32.IsGeneratorFunction(e)) throw new Error("expected generator function");
  }, C32.IsIterable = function(e) {
    return "function" === e[Symbol.iterator];
  }, C32.RequireIterable = function(e) {
    if (!C32.IsIterable(e)) throw new Error("expected iterable");
  }, C32.IsDefined = function(e) {
    return !C32.IsNullOrUndefined(e);
  }, C32.IsNullOrUndefined = function(e) {
    return null == e;
  }, C32.AreArrayElementsOfSameType = function(e) {
    let n = e[0].constructor;
    for (let r2 of e) if (r2.constructor !== n) return false;
    return n;
  }, C32.AreArrayElementsOfType = function(e, n) {
    for (let r2 of e) if (!(r2 instanceof n)) return false;
    return true;
  };
  const TypedArray = Object.getPrototypeOf(Uint8Array);
  C32.IsTypedArray = function(e) {
    return C32.IsInstanceOf(e, TypedArray);
  }, C32.RequireTypedArray = function(e) {
  }, C32.WeakRequireTypedArray = function(e) {
    C32.WeakRequireInstanceOf(e, TypedArray);
  }, C32.WeakRequireAnyInstanceOf = function(e, ...n) {
    if (!C32.WeakIsAnyInstanceOf(e, ...n)) throw new TypeError("unexpected type");
  }, C32.WeakIsAnyInstanceOf = function(e, ...n) {
    for (const r2 of n) if (C32.WeakIsInstanceOf(e, r2)) return true;
    return false;
  }, C32.WeakRequireInstanceOf = function(e, n) {
    if (!C32.WeakIsInstanceOf(e, n)) throw new TypeError("unexpected type");
  }, C32.WeakIsInstanceOf = function(e, n) {
    for (; e = Object.getPrototypeOf(e); ) if (e.constructor.name === n.name) return true;
    return false;
  }, C3X.RequireNumber = C32.RequireNumber, C3X.RequireOptionalNumber = C32.RequireOptionalNumber, C3X.RequireFiniteNumber = C32.RequireFiniteNumber, C3X.RequireOptionalFiniteNumber = C32.RequireOptionalFiniteNumber, C3X.RequireString = C32.RequireString, C3X.RequireOptionalString = C32.RequireOptionalString, C3X.RequireObject = C32.RequireObject, C3X.RequireOptionalObject = C32.RequireOptionalObject, C3X.RequireArray = C32.RequireArray, C3X.RequireOptionalArray = C32.RequireOptionalArray, C3X.RequireFunction = C32.RequireFunction, C3X.RequireOptionalFunction = C32.RequireOptionalFunction, C3X.RequireInstanceOf = C32.RequireInstanceOf, C3X.RequireOptionalInstanceOf = C32.RequireOptionalInstanceOf, C3X.IsNullOrUndefined = C32.IsNullOrUndefined;
}
{
  let isValidTypeChange = function(e, t2) {
    let r2 = C32.getType(e), n = C32.getType(t2);
    return "null" === r2 || "null" === n || "undefined" !== r2 && "undefined" !== n && r2 === n;
  }, logDefendedObjectWarning = function(e) {
    console.warn("[Defence] " + e + " @", C32.GetCallStack());
  }, CheckDefendedObjectsUsedCorrectly = function() {
    if (checkRafId = -1, ctorObjectToProxy.size > 0 || ctorProxyToObject.size > 0) {
      let e = [...new Set([...ctorObjectToProxy.keys()].map((e2) => C32.getName(e2)))].join(",");
      console.warn(`An object derived from DefendedBase was not protected with debugDefend(). This will disable some checks. See the coding guidelines! Possible affected class names: ${e}`), ctorObjectToProxy.clear(), ctorProxyToObject.clear();
    }
  }, getObjectPropertySet = function(e) {
    let t2 = /* @__PURE__ */ new Set();
    for (let r2 in e) t2.add(r2);
    return t2;
  }, VerifyObjectPropertiesConsistent = function(e, t2) {
    let r2 = getObjectPropertySet(t2), n = typeProperties.get(e);
    if (n) {
      let t3 = [];
      for (let e2 of n.values()) r2.has(e2) ? r2.delete(e2) : t3.push(e2);
      C32.appendArray(t3, [...r2]), t3.length && console.warn(`[Defence] '${C32.getName(e)}' constructor creates inconsistent properties: ${t3.join(", ")}`);
    } else typeProperties.set(e, r2);
  };
  isValidTypeChange2 = isValidTypeChange, logDefendedObjectWarning2 = logDefendedObjectWarning, CheckDefendedObjectsUsedCorrectly2 = CheckDefendedObjectsUsedCorrectly, getObjectPropertySet2 = getObjectPropertySet, VerifyObjectPropertiesConsistent2 = VerifyObjectPropertiesConsistent;
  const C32 = self.C3, logRafIds = /* @__PURE__ */ new Map();
  let measures;
  C32.ColorLog = function(e, t2) {
    console.log(`%c${e}`, `font-weight: bold; color:${t2}`);
  }, C32.RafLog = function(e, ...t2) {
    logRafIds.has(e) || logRafIds.set(e, -1), -1 === logRafIds.get(e) && logRafIds.set(e, requestAnimationFrame(() => {
      console.log(`%c${e}`, "font-weight: bold", ...t2), logRafIds.set(e, -1);
    }));
  }, C32.StartMeasure = function(e) {
    performance.mark(e), measures || (measures = /* @__PURE__ */ new Map()), measures.has(e) || measures.set(e, { current: 0, total: 0, average: 0, calls: 1, toString: function() {
      return `${e} :: current => ${this.current.toPrecision(3)} :: average => ${this.average.toPrecision(3)} :: calls => ${this.calls}`;
    } });
  }, C32.EndMeasure = function(e) {
    performance.measure(`measure-${e}`, e);
    const t2 = performance.getEntriesByName(`measure-${e}`)[0], r2 = measures.get(e);
    r2.current = t2.duration, r2.total += r2.current, r2.average = r2.total / r2.calls, console.log(r2.toString()), r2.calls++, performance.clearMarks(e), performance.clearMeasures(`measure-${e}`);
  }, C32.GetCallStack = function() {
    return new Error().stack;
  }, C32.Debugger = function() {
  }, C32.cast = function(e, t2) {
    return e && e instanceof t2 ? e : null;
  }, C32.getName = function(e) {
    return void 0 === e ? "undefined" : null === e ? "null" : "boolean" == typeof e ? "<boolean>" : C32.IsNumber(e) ? "<number>" : C32.IsString(e) ? "<string>" : C32.IsArray(e) ? "<array>" : "symbol" == typeof e ? "<" + e.toString() + ">" : C32.IsFunction(e) ? e.name && "Function" !== e.name ? e.name : "<anonymous function>" : "object" == typeof e ? e.constructor && e.constructor.name && "Object" !== e.constructor.name ? e.constructor.name : "<anonymous object>" : "<unknown>";
  }, C32.getType = function(e) {
    return null === e ? "null" : Array.isArray(e) ? "array" : typeof e;
  }, C32.range = function* (e, t2) {
    if (!isFinite(Math.abs(e - t2))) throw new Error("Invalid parameters");
    if (e > t2) for (let r2 = e - 1; r2 >= t2; r2--) yield r2;
    else for (let r2 = e; r2 < t2; r2++) yield r2;
  };
  let ctorObjectToProxy = /* @__PURE__ */ new Map(), ctorProxyToObject = /* @__PURE__ */ new Map(), proxyToObject = /* @__PURE__ */ new WeakMap(), releasedObjects = /* @__PURE__ */ new WeakMap();
  C32.DefendHandler = {};
  const VALID_GET_MISSING_KEYS = /* @__PURE__ */ new Set(["then", "splice"]);
  C32.DefendHandler.get = function(e, t2) {
    return t2 in e || "symbol" == typeof t2 || VALID_GET_MISSING_KEYS.has(t2) || logDefendedObjectWarning(`Accessed missing property '${t2}' from defended object '${C32.getName(e)}', returning undefined`), releasedObjects.has(e) && "symbol" != typeof t2 && !VALID_GET_MISSING_KEYS.has(t2) && logDefendedObjectWarning(`Accessed property '${t2}' on a released object '${C32.getName(e)}'
Object was originally released at: ${releasedObjects.get(e)})
Call stack at access: `), e[t2];
  }, C32.DefendHandler.set = function(e, t2, r2) {
    return t2 in e || ctorObjectToProxy.has(e) || logDefendedObjectWarning(`Set non-existent property '${t2}' to '${r2}' on defended object '${C32.getName(e)}'`), isValidTypeChange(e[t2], r2) || ctorObjectToProxy.has(e) || logDefendedObjectWarning(`Set '${C32.getType(e[t2])}' property '${t2}' to type '${C32.getType(r2)}' on defended object '${C32.getName(e)}'`), releasedObjects.has(e) && logDefendedObjectWarning(`Set property '${t2}' on a released object '${C32.getName(e)}'
Object was originally released at: ${releasedObjects.get(e)})
Call stack at access: `), e[t2] = r2, true;
  }, C32.DefendHandler.deleteProperty = function(e, t2) {
    throw new ReferenceError(`Cannot delete property '${t2}' from defended object '${C32.getName(e)}'`);
  }, C32.DefendHandler.defineProperty = function(e, t2, r2) {
    throw new ReferenceError(`Cannot define property '${t2}' on defended object '${C32.getName(e)}'`);
  }, C32.DefendHandler.enumerate = function(e) {
    throw new ReferenceError(`Cannot enumerate defended object '${C32.getName(e)}'`);
  };
  let checkRafId = -1;
  C32.DefendedBase = class {
    constructor() {
      if (!C32.isDebugDefend || !C32.Supports.Proxies) return;
      let e = new.target, t2 = Object.create(e.prototype), r2 = new Proxy(t2, C32.DefendHandler);
      return ctorObjectToProxy.set(t2, r2), ctorProxyToObject.set(r2, t2), proxyToObject.set(r2, t2), -1 === checkRafId && (checkRafId = requestAnimationFrame(CheckDefendedObjectsUsedCorrectly)), r2;
    }
  }, C32.debugDefend = function(e) {
    if (C32.isDebugDefend && C32.Supports.Proxies && e instanceof C32.DefendedBase) {
      if (!ctorProxyToObject.has(e)) return e;
      let t2 = ctorProxyToObject.get(e);
      return ctorProxyToObject.delete(e), ctorObjectToProxy.delete(t2), e;
    }
    return C32.isDebug ? Object.seal(e) : e;
  }, C32.New = function(e, ...t2) {
    let r2;
    try {
      r2 = new e(...t2);
    } catch (e2) {
      throw ctorProxyToObject.clear(), ctorObjectToProxy.clear(), e2;
    }
    return C32.isDebugDefend && VerifyObjectPropertiesConsistent(e, r2), C32.debugDefend(r2);
  }, C32.Release = function(e) {
    let t2 = proxyToObject.get(e);
    t2 && releasedObjects.set(t2, C32.GetCallStack());
  }, C32.WasReleased = function(e) {
    let t2 = proxyToObject.get(e);
    return !!t2 && !!releasedObjects.get(t2);
  };
  let typeProperties = /* @__PURE__ */ new Map();
  C32.PerfMark = class {
    constructor(e) {
      this._name = "", e && this.start(e);
    }
    start(e) {
      C32.isPerformanceProfiling && (this._name = e, performance.mark(this._name + "-Start"));
    }
    end() {
      C32.isPerformanceProfiling && (performance.mark(this._name + "-End"), performance.measure(this._name, this._name + "-Start", this._name + "-End"));
    }
    next(e) {
      C32.isPerformanceProfiling && (this.end(), this._name = e, performance.mark(this._name + "-Start"));
    }
  };
}
var isValidTypeChange2;
var logDefendedObjectWarning2;
var CheckDefendedObjectsUsedCorrectly2;
var getObjectPropertySet2;
var VerifyObjectPropertiesConsistent2;
{
  let isNegativeZero = function(t2) {
    return 0 === t2 && 1 / t2 < 0;
  };
  isNegativeZero2 = isNegativeZero;
  const C32 = self.C3, TWO_PI = 2 * Math.PI, D_TO_R = Math.PI / 180, R_TO_D = 180 / Math.PI;
  C32.wrap = function(t2, n, e) {
    t2 = Math.floor(t2), n = Math.floor(n);
    const r2 = (e = Math.floor(e)) - n;
    if (0 === r2) return e;
    if (t2 < n) {
      const a2 = e - (n - t2) % r2;
      return a2 === e ? 0 : a2;
    }
    return n + (t2 - n) % r2;
  }, C32.mapToRange = function(t2, n, e, r2, a2) {
    const o2 = e - n;
    if (0 === o2 && 0 === r2) return t2;
    return (t2 - n) * (a2 - r2) / o2 + r2;
  }, C32.normalize = function(t2, n, e) {
    return n - e === 0 ? 1 : (t2 - n) / (e - n);
  }, C32.clamp = function(t2, n, e) {
    return t2 < n ? n : t2 > e ? e : t2;
  }, C32.clampAngle = function(t2) {
    return (t2 %= TWO_PI) < 0 && (t2 += TWO_PI), t2;
  }, C32.toRadians = function(t2) {
    return t2 * D_TO_R;
  }, C32.toDegrees = function(t2) {
    return t2 * R_TO_D;
  }, C32.hypot2DFast = function(t2, n) {
    return Math.sqrt(t2 * t2 + n * n);
  }, C32.hypot3DFast = function(t2, n, e) {
    return Math.sqrt(t2 * t2 + n * n + e * e);
  }, C32.distanceTo = function(t2, n, e, r2) {
    return C32.hypot2DFast(e - t2, r2 - n);
  }, C32.distanceSquared = function(t2, n, e, r2) {
    const a2 = e - t2, o2 = r2 - n;
    return a2 * a2 + o2 * o2;
  }, C32.angleTo = function(t2, n, e, r2) {
    return Math.atan2(r2 - n, e - t2);
  }, C32.angleDiff = function(t2, n) {
    if (t2 === n) return 0;
    let e = Math.sin(t2), r2 = Math.cos(t2), a2 = e * Math.sin(n) + r2 * Math.cos(n);
    return a2 >= 1 ? 0 : a2 <= -1 ? Math.PI : Math.acos(a2);
  }, C32.angleRotate = function(t2, n, e) {
    let r2 = Math.sin(t2), a2 = Math.cos(t2), o2 = Math.sin(n), c2 = Math.cos(n);
    return Math.acos(r2 * o2 + a2 * c2) > e ? a2 * o2 - r2 * c2 > 0 ? C32.clampAngle(t2 + e) : C32.clampAngle(t2 - e) : C32.clampAngle(n);
  }, C32.angleClockwise = function(t2, n) {
    let e = Math.sin(t2);
    return Math.cos(t2) * Math.sin(n) - e * Math.cos(n) <= 0;
  }, C32.angleLerp = function(t2, n, e, r2 = 0) {
    let a2 = C32.angleDiff(t2, n);
    const o2 = TWO_PI * r2;
    return C32.angleClockwise(n, t2) ? C32.clampAngle(t2 + (a2 + o2) * e) : C32.clampAngle(t2 - (a2 + o2) * e);
  }, C32.angleLerpClockwise = function(t2, n, e, r2 = 0) {
    const a2 = C32.angleDiff(t2, n), o2 = TWO_PI * r2;
    return C32.angleClockwise(n, t2) ? C32.clampAngle(t2 + (a2 + o2) * e) : C32.clampAngle(t2 + (TWO_PI - a2 + o2) * e);
  }, C32.angleLerpAntiClockwise = function(t2, n, e, r2 = 0) {
    const a2 = C32.angleDiff(t2, n), o2 = TWO_PI * r2;
    return C32.angleClockwise(n, t2) ? C32.clampAngle(t2 - (-TWO_PI + a2 - o2) * e) : C32.clampAngle(t2 - (a2 + o2) * e);
  }, C32.angleReflect = function(t2, n) {
    const e = C32.angleDiff(t2, n);
    return C32.angleClockwise(t2, n) ? C32.clampAngle(n - e) : C32.clampAngle(n + e);
  }, C32.lerp = function(t2, n, e) {
    return t2 + e * (n - t2);
  }, C32.unlerp = function(t2, n, e) {
    return t2 === n ? 0 : (e - t2) / (n - t2);
  }, C32.relerp = function(t2, n, e, r2, a2) {
    return C32.lerp(r2, a2, C32.unlerp(t2, n, e));
  }, C32.qarp = function(t2, n, e, r2) {
    return C32.lerp(C32.lerp(t2, n, r2), C32.lerp(n, e, r2), r2);
  }, C32.cubic = function(t2, n, e, r2, a2) {
    return C32.lerp(C32.qarp(t2, n, e, a2), C32.qarp(n, e, r2, a2), a2);
  }, C32.cosp = function(t2, n, e) {
    return (t2 + n + (t2 - n) * Math.cos(e * Math.PI)) / 2;
  }, C32.isPOT = function(t2) {
    return t2 > 0 && !(t2 - 1 & t2);
  }, C32.nextHighestPowerOfTwo = function(t2) {
    --t2;
    for (let n = 1; n < 32; n <<= 1) t2 |= t2 >> n;
    return t2 + 1;
  }, C32.roundToNearestFraction = function(t2, n) {
    return Math.round(t2 * n) / n;
  }, C32.floorToNearestFraction = function(t2, n) {
    return Math.floor(t2 * n) / n;
  }, C32.roundToDp = function(t2, n) {
    n = Math.max(Math.floor(n), 0);
    const e = Math.pow(10, n);
    return Math.round(t2 * e) / e;
  }, C32.countDecimals = function(t2) {
    return Math.floor(t2) !== t2 && t2.toString().split(".")[1].length || 0;
  }, C32.toFixed = function(t2, n) {
    let e = t2.toFixed(n), r2 = e.length - 1;
    for (; r2 >= 0 && "0" === e.charAt(r2); --r2) ;
    return r2 >= 0 && "." === e.charAt(r2) && --r2, r2 < 0 ? e : e.substr(0, r2 + 1);
  }, C32.PackRGB = function(t2, n, e) {
    return C32.clamp(t2, 0, 255) | C32.clamp(n, 0, 255) << 8 | C32.clamp(e, 0, 255) << 16;
  };
  const ALPHAEX_SHIFT = 1024, ALPHAEX_MAX = 1023, RGBEX_SHIFT = 16384, RGBEX_MAX = 8191, RGBEX_MIN = -8192;
  C32.PackRGBAEx = function(t2, n, e, r2) {
    return (t2 = C32.clamp(Math.floor(1024 * t2), -8192, 8191)) < 0 && (t2 += 16384), (n = C32.clamp(Math.floor(1024 * n), -8192, 8191)) < 0 && (n += 16384), (e = C32.clamp(Math.floor(1024 * e), -8192, 8191)) < 0 && (e += 16384), -(16384 * t2 * 16384 * 1024 + 16384 * n * 1024 + 1024 * e + (r2 = C32.clamp(Math.floor(1023 * r2), 0, 1023)));
  }, C32.PackRGBEx = function(t2, n, e) {
    return C32.PackRGBAEx(t2, n, e, 1);
  }, C32.GetRValue = function(t2) {
    if (t2 >= 0) return (255 & t2) / 255;
    {
      let n = Math.floor(-t2 / 274877906944);
      return n > 8191 && (n -= 16384), n / 1024;
    }
  }, C32.GetGValue = function(t2) {
    if (t2 >= 0) return ((65280 & t2) >> 8) / 255;
    {
      let n = Math.floor(-t2 % 274877906944 / 16777216);
      return n > 8191 && (n -= 16384), n / 1024;
    }
  }, C32.GetBValue = function(t2) {
    if (t2 >= 0) return ((16711680 & t2) >> 16) / 255;
    {
      let n = Math.floor(-t2 % 16777216 / 1024);
      return n > 8191 && (n -= 16384), n / 1024;
    }
  }, C32.GetAValue = function(t2) {
    if (isNegativeZero(t2)) return 0;
    if (t2 >= 0) return 1;
    return Math.floor(-t2 % 1024) / 1023;
  }, C32.greatestCommonDivisor = function(t2, n) {
    for (t2 = Math.floor(t2), n = Math.floor(n); 0 !== n; ) {
      let e = n;
      n = t2 % n, t2 = e;
    }
    return t2;
  };
  const COMMON_ASPECT_RATIOS = [[3, 2], [4, 3], [5, 4], [5, 3], [6, 5], [14, 9], [16, 9], [16, 10], [21, 9]];
  C32.getAspectRatio = function(t2, n) {
    if ((t2 = Math.floor(t2)) === (n = Math.floor(n))) return [1, 1];
    for (let e2 of COMMON_ASPECT_RATIOS) {
      let r2 = t2 / e2[0] * e2[1];
      if (Math.abs(n - r2) < 1) return e2.slice(0);
      if (r2 = t2 / e2[1] * e2[0], Math.abs(n - r2) < 1) return [e2[1], e2[0]];
    }
    let e = C32.greatestCommonDivisor(t2, n);
    return [t2 / e, n / e];
  }, C32.segmentsIntersect = function(t2, n, e, r2, a2, o2, c2, u2) {
    const i = Math.min(t2, e), l = Math.max(t2, e), s = Math.min(a2, c2), C2 = Math.max(a2, c2);
    if (l < s || i > C2) return false;
    const f2 = Math.min(n, r2), h2 = Math.max(n, r2), M2 = Math.min(o2, u2), g2 = Math.max(o2, u2);
    if (h2 < M2 || f2 > g2) return false;
    const m2 = a2 - t2 + c2 - e, p2 = o2 - n + u2 - r2, I2 = e - t2, T2 = r2 - n, P2 = c2 - a2, A = u2 - o2, _2 = Math.abs(T2 * P2 - A * I2), x2 = P2 * p2 - A * m2;
    if (Math.abs(x2) > _2) return false;
    const O2 = I2 * p2 - T2 * m2;
    return Math.abs(O2) <= _2;
  }, C32.segmentsIntersectPreCalc = function(t2, n, e, r2, a2, o2, c2, u2, i, l, s, C2) {
    const f2 = Math.min(i, s), h2 = Math.max(i, s);
    if (o2 < f2 || a2 > h2) return false;
    const M2 = Math.min(l, C2), g2 = Math.max(l, C2);
    if (u2 < M2 || c2 > g2) return false;
    const m2 = i - t2 + s - e, p2 = l - n + C2 - r2, I2 = e - t2, T2 = r2 - n, P2 = s - i, A = C2 - l, _2 = Math.abs(T2 * P2 - A * I2), x2 = P2 * p2 - A * m2;
    if (Math.abs(x2) > _2) return false;
    const O2 = I2 * p2 - T2 * m2;
    return Math.abs(O2) <= _2;
  }, C32.segmentIntersectsQuad = function(t2, n, e, r2, a2) {
    const o2 = Math.min(t2, e), c2 = Math.max(t2, e), u2 = Math.min(n, r2), i = Math.max(n, r2), l = a2.getTlx(), s = a2.getTly(), C2 = a2.getTrx(), f2 = a2.getTry(), h2 = a2.getBrx(), M2 = a2.getBry(), g2 = a2.getBlx(), m2 = a2.getBly();
    return C32.segmentsIntersectPreCalc(t2, n, e, r2, o2, c2, u2, i, l, s, C2, f2) || C32.segmentsIntersectPreCalc(t2, n, e, r2, o2, c2, u2, i, C2, f2, h2, M2) || C32.segmentsIntersectPreCalc(t2, n, e, r2, o2, c2, u2, i, h2, M2, g2, m2) || C32.segmentsIntersectPreCalc(t2, n, e, r2, o2, c2, u2, i, g2, m2, l, s);
  }, C32.segmentIntersectsAnyN = function(t2, n, e, r2, a2) {
    const o2 = Math.min(t2, e), c2 = Math.max(t2, e), u2 = Math.min(n, r2), i = Math.max(n, r2);
    let l = 0;
    for (let s = a2.length - 4; l <= s; l += 2) if (C32.segmentsIntersectPreCalc(t2, n, e, r2, o2, c2, u2, i, a2[l], a2[l + 1], a2[l + 2], a2[l + 3])) return true;
    return C32.segmentsIntersectPreCalc(t2, n, e, r2, o2, c2, u2, i, a2[l], a2[l + 1], a2[0], a2[1]);
  };
  const NO_HIT = 2, PADDING = 1e-6;
  C32.rayIntersect = function(t2, n, e, r2, a2, o2, c2, u2) {
    const i = e - t2, l = u2 - o2, s = i * l - (r2 - n) * (c2 - a2);
    if (0 === s) return 2;
    const C2 = ((n - r2) * (c2 - t2) + i * (u2 - n)) / s;
    return 0 < C2 && C2 < 1.000001 ? (l * (c2 - t2) + (a2 - c2) * (u2 - n)) / s : 2;
  }, C32.rayIntersectExtended = function(t2, n, e, r2, a2, o2, c2, u2, i) {
    const l = (c2 - a2) * i, s = (u2 - o2) * i;
    return C32.rayIntersect(t2, n, e, r2, a2 - l, o2 - s, c2 + l, u2 + s);
  }, C32.isPointInTriangleInclusive = function(t2, n, e, r2, a2, o2, c2, u2) {
    const i = a2 - e, l = o2 - r2, s = c2 - e, C2 = u2 - r2, f2 = t2 - e, h2 = n - r2, M2 = i * i + l * l, g2 = i * s + l * C2, m2 = i * f2 + l * h2, p2 = s * s + C2 * C2, I2 = s * f2 + C2 * h2, T2 = 1 / (M2 * p2 - g2 * g2), P2 = (p2 * m2 - g2 * I2) * T2, A = (M2 * I2 - g2 * m2) * T2;
    return P2 >= 0 && A >= 0 && P2 + A <= 1;
  }, C32.triangleCartesianToBarycentric = function(t2, n, e, r2, a2, o2, c2, u2) {
    const i = a2 - e, l = o2 - r2, s = c2 - e, C2 = u2 - r2, f2 = t2 - e, h2 = n - r2, M2 = i * i + l * l, g2 = i * s + l * C2, m2 = s * s + C2 * C2, p2 = f2 * i + h2 * l, I2 = f2 * s + h2 * C2, T2 = M2 * m2 - g2 * g2, P2 = (m2 * p2 - g2 * I2) / T2, A = (M2 * I2 - g2 * p2) / T2;
    return [1 - P2 - A, P2, A];
  }, C32.triangleBarycentricToCartesian3d = function(t2, n, e, r2, a2, o2, c2, u2, i, l, s, C2) {
    return [t2 * r2 + n * c2 + e * l, t2 * a2 + n * u2 + e * s, t2 * o2 + n * i + e * C2];
  };
}
var isNegativeZero2;
{
  const C32 = self.C3;
  let mainDocument = null, baseHref = "";
  if ("undefined" != typeof document) {
    mainDocument = document;
    const e = document.querySelector("base");
    baseHref = e && e.hasAttribute("href") ? e.getAttribute("href") : "", baseHref && (baseHref.startsWith("/") && (baseHref = baseHref.substr(1)), baseHref.endsWith("/") || (baseHref += "/"));
  }
  C32.GetBaseHref = function() {
    return baseHref;
  }, C32.GetBaseURL = function() {
    if (!mainDocument) return "";
    const e = mainDocument.location;
    return C32.GetPathFromURL(e.origin + e.pathname) + baseHref;
  }, C32.GetPathFromURL = function(e) {
    if (!e.length) return e;
    if (e.endsWith("/") || e.endsWith("\\")) return e;
    const t2 = Math.max(e.lastIndexOf("/"), e.lastIndexOf("\\"));
    return -1 === t2 ? "" : e.substr(0, t2 + 1);
  }, C32.GetFilenameFromURL = function(e) {
    if (!e.length) return e;
    if (e.endsWith("/") || e.endsWith("\\")) return "";
    const t2 = Math.max(e.lastIndexOf("/"), e.lastIndexOf("\\"));
    return -1 === t2 ? e : e.substr(t2 + 1);
  }, C32.GetFileExtension = function(e) {
    let t2 = e.lastIndexOf(".");
    return t2 < 1 ? "" : e.substr(t2);
  }, C32.SetFileExtension = function(e, t2) {
    const n = e.lastIndexOf(".");
    return -1 === n ? e + "." + t2 : e.substr(0, n + 1) + t2;
  }, C32.GetFileNamePart = function(e) {
    let t2 = e.lastIndexOf(".");
    return t2 < 1 ? e : e.substr(0, t2);
  }, C32.NormalizeFileSeparator = function(e) {
    return e.replace(/\\/g, "/");
  }, C32.IsFileExtension = function(e, t2) {
    return t2 === (e ? C32.GetFileExtension(e).slice(1) : "");
  }, C32.FileNameEquals = function(e, t2) {
    let n, r2;
    return C32.IsFileLike(e) && (n = C32.GetFileNamePart(e["name"])), C32.IsString(e) && (n = C32.GetFileNamePart(e)), C32.IsFileLike(t2) && (r2 = C32.GetFileNamePart(t2["name"])), C32.IsString(t2) && (r2 = C32.GetFileNamePart(t2)), n === r2;
  }, C32.ParseFilePath = function(e) {
    e = C32.NormalizeFileSeparator(e);
    let t2 = /^\w\:\//.exec(e);
    t2 ? (t2 = t2[0], "/" !== (e = e.slice(3))[0] && (e = "/" + e)) : t2 = "", (e = e.replace(/\/{2,}/g, "/")).length > 1 && "/" === e.slice(-1) && (e = e.slice(0, -1));
    const n = e.lastIndexOf("/") + 1;
    let r2, a2 = "", o2 = e, s = "";
    n > 0 && (a2 = e.slice(0, n), o2 = e.slice(n)), r2 = o2;
    const i = o2.lastIndexOf(".");
    i > 0 && (s = o2.slice(i), r2 = o2.slice(0, -s.length));
    return { dir: a2, base: o2, name: r2, root: t2, ext: s, full: t2 + a2 + o2 };
  }, C32.Wait = function(e, t2) {
    return new Promise((n, r2) => {
      self.setTimeout(n, e, t2);
    });
  }, C32.swallowException = function(e) {
    try {
      e();
    } catch (e2) {
      C32.isDebug && console.warn("Swallowed exception: ", e2);
    }
  }, C32.noop = function() {
  }, C32.equalsNoCase = function(e, t2) {
    return "string" == typeof e && "string" == typeof t2 && (e === t2 || e.normalize().toLowerCase() === t2.normalize().toLowerCase());
  }, C32.equalsCase = function(e, t2) {
    return "string" == typeof e && "string" == typeof t2 && (e === t2 || e.normalize() === t2.normalize());
  }, C32.typedArraySet16 = function(e, t2, n) {
    e[n++] = t2[0], e[n++] = t2[1], e[n++] = t2[2], e[n++] = t2[3], e[n++] = t2[4], e[n++] = t2[5], e[n++] = t2[6], e[n++] = t2[7], e[n++] = t2[8], e[n++] = t2[9], e[n++] = t2[10], e[n++] = t2[11], e[n++] = t2[12], e[n++] = t2[13], e[n++] = t2[14], e[n] = t2[15];
  }, C32.truncateArray = function(e, t2) {
    e.length = t2;
  }, C32.clearArray = function(e) {
    e && 0 !== e.length && C32.truncateArray(e, 0);
  }, C32.clear2DArray = function(e) {
    if (e) {
      for (let t2 = 0; t2 < e.length; t2++) {
        let n = e[t2];
        C32.truncateArray(n, 0);
      }
      C32.truncateArray(e, 0);
    }
  }, C32.extendArray = function(e, t2, n) {
    t2 |= 0;
    const r2 = e.length;
    if (!(t2 <= r2)) for (let a2 = r2; a2 < t2; ++a2) e.push(n);
  }, C32.resizeArray = function(e, t2, n) {
    t2 |= 0;
    const r2 = e.length;
    t2 < r2 ? C32.truncateArray(e, t2) : t2 > r2 && C32.extendArray(e, t2, n);
  }, C32.shallowAssignArray = function(e, t2) {
    C32.clearArray(e), C32.appendArray(e, t2);
  }, C32.appendArray = function(e, t2) {
    if (t2.length < 1e4) e.push(...t2);
    else for (let n = 0, r2 = t2.length; n < r2; ++n) e.push(t2[n]);
  }, C32.arrayRemove = function(e, t2) {
    if ((t2 = Math.floor(t2)) < 0 || t2 >= e.length) return;
    let n = e.length - 1;
    for (let r2 = t2; r2 < n; ++r2) e[r2] = e[r2 + 1];
    C32.truncateArray(e, n);
  }, C32.arrayFindRemove = function(e, t2) {
    let n = e.indexOf(t2);
    n >= 0 && e.splice(n, 1);
  }, C32.arraysEqual = function(e, t2) {
    let n = e.length;
    if (t2.length !== n) return false;
    for (let r2 = 0; r2 < n; ++r2) if (e[r2] !== t2[r2]) return false;
    return true;
  }, C32.arrayFilterOut = function(e, t2) {
    let n = [], r2 = 0;
    for (let a2 = 0, o2 = e.length; a2 < o2; ++a2) {
      let o3 = e[a2];
      t2(o3) ? n.push(o3) : (e[r2] = o3, ++r2);
    }
    return C32.truncateArray(e, r2), n;
  }, C32.arrayRemoveAllInSet = function(e, t2) {
    const n = e.length;
    let r2 = 0;
    for (let n2 = 0, a2 = e.length; n2 < a2; ++n2) {
      let a3 = e[n2];
      t2.has(a3) || (e[r2++] = a3);
    }
    return C32.truncateArray(e, r2), n - r2;
  }, C32.isArrayIndexInBounds = function(e, t2) {
    return e === Math.floor(e) && (e >= 0 && e < t2.length);
  }, C32.validateArrayIndex = function(e, t2) {
    if (!C32.isArrayIndexInBounds(e, t2)) throw new RangeError("array index out of bounds");
  }, C32.cloneArray = function(e) {
    return e.slice();
  }, C32.deepCloneArray = function(e, t2) {
    let n = [];
    for (let r2 of e) if (C32.IsObject(r2)) {
      let e2 = t2(r2);
      if (!e2) throw new Error("missing clone");
      if (e2.constructor !== r2.constructor) throw new Error("object is not a clone");
      n.push(e2);
    } else C32.IsArray(r2) ? n.push(C32.deepCloneArray(r2, t2)) : n.push(r2);
    return n;
  }, C32.clone2DArray = function(e) {
    let t2 = [];
    for (let n of e) t2.push(n.slice());
    return t2;
  }, C32.splitStringAndNormalize = function(e, t2 = " ") {
    return e ? e.split(t2).map((e2) => e2.trim()).filter((e2) => !!e2) : [];
  }, C32.filterSet = function(e, t2, n) {
    const r2 = /* @__PURE__ */ new Set();
    for (const a2 of e.values()) t2(a2) && (n ? r2.add(n(a2)) : r2.add(a2));
    return r2;
  }, C32.mergeSets = function(e, t2) {
    return e["union"] ? e["union"](t2) : /* @__PURE__ */ new Set([...e, ...t2]);
  }, C32.mergeSetsInPlace = function(e, t2) {
    for (const n of t2) e.add(n);
    return e;
  }, C32.first = function(e) {
    for (let t2 of e) return t2;
    return null;
  }, C32.xor = function(e, t2) {
    return !e != !t2;
  }, C32.compare = function(e, t2, n) {
    switch (t2) {
      case 0:
        return e === n;
      case 1:
        return e !== n;
      case 2:
        return e < n;
      case 3:
        return e <= n;
      case 4:
        return e > n;
      case 5:
        return e >= n;
      default:
        return false;
    }
  }, C32.hasAnyOwnProperty = function(e) {
    for (let t2 in e) if (e.hasOwnProperty(t2)) return true;
    return false;
  }, C32.PromiseAllWithProgress = function(e, t2) {
    return e.length ? new Promise((n, r2) => {
      const a2 = [];
      let o2 = 0, s = false;
      for (let i = 0, l = e.length; i < l; ++i) a2.push(void 0), e[i].then((r3) => {
        s || (a2[i] = r3, ++o2, o2 === e.length ? n(a2) : t2(o2, e.length));
      }).catch((e2) => {
        s = true, r2(e2);
      });
    }) : Promise.resolve([]);
  };
  let memoryCallbacks = [];
  C32.AddLibraryMemoryCallback = function(e) {
    memoryCallbacks.push(e);
  }, C32.GetEstimatedLibraryMemoryUsage = function() {
    let e = 0;
    for (let t2 of memoryCallbacks) {
      e += t2();
    }
    return Math.floor(e);
  };
  let nextTaskId = 1;
  const activeTaskIds = /* @__PURE__ */ new Map(), taskMessageChannel = new MessageChannel();
  taskMessageChannel.port2.onmessage = function(e) {
    const t2 = e.data, n = activeTaskIds.get(t2);
    activeTaskIds.delete(t2), n && n(performance.now());
  }, C32.RequestUnlimitedAnimationFrame = function(e) {
    const t2 = nextTaskId++;
    return activeTaskIds.set(t2, e), taskMessageChannel.port1.postMessage(t2), t2;
  }, C32.CancelUnlimitedAnimationFrame = function(e) {
    activeTaskIds.delete(e);
  }, C32.PostTask = C32.RequestUnlimitedAnimationFrame, C32.WaitForNextTask = function() {
    return new Promise((e) => C32.PostTask(e));
  };
  const activeRPAFids = /* @__PURE__ */ new Set();
  C32.RequestPostAnimationFrame = function(e) {
    const t2 = self.requestAnimationFrame(async (n) => {
      await C32.WaitForNextTask(), activeRPAFids.has(t2) && (activeRPAFids.delete(t2), e(n));
    });
    return activeRPAFids.add(t2), t2;
  }, C32.CancelPostAnimationFrame = function(e) {
    activeRPAFids.has(e) && (self.cancelAnimationFrame(e), activeRPAFids.delete(e));
  };
}
{
  const C32 = self.C3;
  C32.IsAbsoluteURL = function(e) {
    return /^(?:[a-z\-]+:)?\/\//.test(e) || "data:" === e.substr(0, 5) || "blob:" === e.substr(0, 5);
  }, C32.IsRelativeURL = function(e) {
    return !C32.IsAbsoluteURL(e);
  }, C32.ThrowIfNotOk = function(e) {
    if (!e.ok) throw new Error(`fetch '${e.url}' response returned ${e.status} ${e.statusText}`);
  }, C32.FetchOk = function(e, t2) {
    return fetch(e, t2).then((e2) => (C32.ThrowIfNotOk(e2), e2));
  }, C32.FetchText = function(e) {
    return C32.FetchOk(e).then((e2) => e2.text());
  }, C32.FetchJson = function(e) {
    return C32.FetchOk(e).then((e2) => e2.json());
  }, C32.FetchBlob = function(e) {
    return C32.FetchOk(e).then((e2) => e2.blob());
  }, C32.FetchArrayBuffer = function(e) {
    return C32.FetchOk(e).then((e2) => e2.arrayBuffer());
  }, C32.FetchImage = function(e) {
    return new Promise((t2, n) => {
      const r2 = new Image();
      r2.onload = () => t2(r2), r2.onerror = (e2) => n(e2), r2.src = e;
    });
  }, C32.BlobToArrayBuffer = function(e) {
    return "function" == typeof e["arrayBuffer"] ? e["arrayBuffer"]() : new Promise((t2, n) => {
      const r2 = new FileReader();
      r2.onload = () => t2(r2.result), r2.onerror = () => n(r2.error), r2.readAsArrayBuffer(e);
    });
  }, C32.BlobToString = function(e) {
    return "function" == typeof e["text"] ? e["text"]() : new Promise((t2, n) => {
      const r2 = new FileReader();
      r2.onload = () => t2(r2.result), r2.onerror = () => n(r2.error), r2.readAsText(e);
    });
  }, C32.BlobToJson = function(e) {
    return C32.BlobToString(e).then((e2) => JSON.parse(e2));
  }, C32.BlobToImage = async function(e, t2) {
    let n = URL.createObjectURL(e);
    try {
      const e2 = await C32.FetchImage(n);
      return URL.revokeObjectURL(n), n = "", t2 && "function" == typeof e2["decode"] && await e2["decode"](), e2;
    } finally {
      n && URL.revokeObjectURL(n);
    }
  }, C32.CreateCanvas = function(e, t2) {
    if ("undefined" != typeof document && "function" == typeof document.createElement) {
      const n = document.createElement("canvas");
      return n.width = e, n.height = t2, n;
    }
    return new OffscreenCanvas(e, t2);
  }, C32.CanvasToBlob = function(e, t2, n) {
    if ("number" != typeof n && (n = 1), t2 = t2 || "image/png", n = C32.clamp(n, 0, 1), e["convertToBlob"]) return e["convertToBlob"]({ "type": t2, "quality": n });
    if (e.toBlob) return new Promise((r2) => e.toBlob(r2, t2, n));
    throw new Error("could not convert canvas to blob");
  }, C32.DrawableToBlob = function(e, t2, n) {
    const r2 = C32.CreateCanvas(e.width, e.height);
    return r2.getContext("2d").drawImage(e, 0, 0), C32.CanvasToBlob(r2, t2, n);
  }, C32.ImageDataToBlob = function(e, t2, n) {
    if (C32.Supports.ImageBitmapOptions) return createImageBitmap(e, { "premultiplyAlpha": "none" }).then((e2) => C32.DrawableToBlob(e2, t2, n));
    if (C32.Supports.ImageBitmap) return createImageBitmap(e).then((e2) => C32.DrawableToBlob(e2, t2, n));
    {
      const r2 = C32.CreateCanvas(e.width, e.height);
      return r2.getContext("2d").putImageData(e, 0, 0), C32.CanvasToBlob(r2, t2, n);
    }
  }, C32.CopySet = function(e, t2) {
    e.clear();
    for (const n of t2) e.add(n);
  }, C32.MapToObject = function(e) {
    const t2 = /* @__PURE__ */ Object.create(null);
    for (const [n, r2] of e.entries()) t2[n] = r2;
    return t2;
  }, C32.ObjectToMap = function(e, t2) {
    t2.clear();
    for (const [n, r2] of Object.entries(e)) t2.set(n, r2);
  }, C32.ToSuperJSON = function e(t2) {
    if ("object" == typeof t2 && null !== t2) {
      if (t2 instanceof Set) return { "_c3type_": "set", "data": [...t2].map((t3) => e(t3)) };
      if (t2 instanceof Map) return { "_c3type_": "map", "data": [...t2].map((t3) => [t3[0], e(t3[1])]) };
      {
        const n = /* @__PURE__ */ Object.create(null);
        for (const [r2, o2] of Object.entries(t2)) n[r2] = e(o2);
        return n;
      }
    }
    return t2;
  }, C32.FromSuperJSON = function e(t2) {
    if ("object" == typeof t2 & null !== t2) {
      if ("set" === t2["_c3type_"]) return new Set(t2["data"].map((t3) => e(t3)));
      if ("map" === t2["_c3type_"]) return new Map(t2["data"].map((t3) => [t3[0], e(t3[1])]));
      {
        const n = /* @__PURE__ */ Object.create(null);
        for (const [r2, o2] of Object.entries(t2)) n[r2] = e(o2);
        return n;
      }
    }
    return t2;
  }, C32.CSSToCamelCase = function(e) {
    if (e.startsWith("--")) return e;
    let t2 = "", n = false, r2 = 0;
    for (const o2 of e) "-" === o2 ? r2 > 0 && (n = true) : n ? (t2 += o2.toUpperCase(), n = false) : t2 += o2, ++r2;
    return t2;
  }, C32.IsIterator = function(e) {
    return "object" == typeof e && "function" == typeof e.next;
  }, C32.MakeFilledArray = function(e, t2) {
    const n = [];
    if ("function" == typeof t2) for (let r2 = 0; r2 < e; ++r2) n.push(t2());
    else for (let r2 = 0; r2 < e; ++r2) n.push(t2);
    return n;
  };
}
{
  let padTwoDigits = function(t2) {
    return 0 === t2.length ? "00" : 1 === t2.length ? "0" + t2 : t2;
  }, hueToRGB = function(t2, s, e) {
    return e < 0 && (e += 1), e > 1 && (e -= 1), e < 1 / 6 ? t2 + 6 * (s - t2) * e : e < 0.5 ? s : e < 2 / 3 ? t2 + (s - t2) * (2 / 3 - e) * 6 : t2;
  };
  padTwoDigits2 = padTwoDigits, hueToRGB2 = hueToRGB;
  const C32 = self.C3, HSL_TEST = /([0-9.]+),([0-9.]+)\%?,([0-9.]+)\%?/i, HSLA_TEST = /([0-9.]+),([0-9.]+)\%?,([0-9.]+)\%?,([0-9.])/i;
  C32.Color = class {
    constructor(t2, s, e, r2) {
      this._r = NaN, this._g = NaN, this._b = NaN, this._a = NaN, this._r = 0, this._g = 0, this._b = 0, this._a = 0, t2 instanceof C32.Color ? this.set(t2) : this.setRgba(t2 || 0, s || 0, e || 0, r2 || 0);
    }
    setRgb(t2, s, e) {
      return this._r = +t2, this._g = +s, this._b = +e, this.clamp(), this;
    }
    setRgba(t2, s, e, r2) {
      return this._r = +t2, this._g = +s, this._b = +e, this._a = +r2, this.clamp(), this;
    }
    set(t2) {
      return this._r = t2._r, this._g = t2._g, this._b = t2._b, this._a = t2._a, this;
    }
    copy(t2) {
      return this.set(t2);
    }
    add(t2) {
      this._r += t2._r, this._g += t2._g, this._b += t2._b, this._a += t2._a, this.clamp();
    }
    addRgb(t2, s, e, r2 = 0) {
      this._r += +t2, this._g += +s, this._b += +e, this._a += +r2, this.clamp();
    }
    diff(t2) {
      this.setR(Math.max(this._r, t2._r) - Math.min(this._r, t2._r)), this.setG(Math.max(this._g, t2._g) - Math.min(this._g, t2._g)), this.setB(Math.max(this._b, t2._b) - Math.min(this._b, t2._b)), this.setA(Math.max(this._a, t2._a) - Math.min(this._a, t2._a)), this.clamp();
    }
    copyRgb(t2) {
      this._r = t2._r, this._g = t2._g, this._b = t2._b;
    }
    setR(t2) {
      this._r = C32.clamp(+t2, 0, 1);
    }
    getR() {
      return this._r;
    }
    setG(t2) {
      this._g = C32.clamp(+t2, 0, 1);
    }
    getG() {
      return this._g;
    }
    setB(t2) {
      this._b = C32.clamp(+t2, 0, 1);
    }
    getB() {
      return this._b;
    }
    setA(t2) {
      this._a = C32.clamp(+t2, 0, 1);
    }
    getA() {
      return this._a;
    }
    clone() {
      return C32.New(C32.Color, this._r, this._g, this._b, this._a);
    }
    toArray() {
      return [this._r, this._g, this._b, this._a];
    }
    toTypedArray() {
      return new Float64Array(this.toArray());
    }
    writeToTypedArray(t2, s) {
      t2[s++] = this._r, t2[s++] = this._g, t2[s++] = this._b, t2[s] = this._a;
    }
    writeToTypedArrayx4(t2, s) {
      const e = this._r, r2 = this._g, i = this._b, a2 = this._a;
      for (let h2 = 0; h2 < 4; ++h2) t2[s++] = e, t2[s++] = r2, t2[s++] = i, t2[s++] = a2;
    }
    writeRGBToTypedArray(t2, s) {
      t2[s++] = this._r, t2[s++] = this._g, t2[s] = this._b;
    }
    equals(t2) {
      return this._r === t2._r && this._g === t2._g && this._b === t2._b && this._a === t2._a;
    }
    equalsIgnoringAlpha(t2) {
      return this._r === t2._r && this._g === t2._g && this._b === t2._b;
    }
    equalsRgb(t2, s, e) {
      return this._r === t2 && this._g === s && this._b === e;
    }
    equalsRgba(t2, s, e, r2) {
      return this._r === t2 && this._g === s && this._b === e && this._a === r2;
    }
    equalsF32Array(t2, s) {
      return t2[s] === Math.fround(this._r) && t2[s + 1] === Math.fround(this._g) && t2[s + 2] === Math.fround(this._b) && t2[s + 3] === Math.fround(this._a);
    }
    equalsRGBF32Array(t2, s) {
      return t2[s] === Math.fround(this._r) && t2[s + 1] === Math.fround(this._g) && t2[s + 2] === Math.fround(this._b);
    }
    multiply(t2) {
      this._r *= t2._r, this._g *= t2._g, this._b *= t2._b, this._a *= t2._a;
    }
    multiplyAlpha(t2) {
      this._r *= t2, this._g *= t2, this._b *= t2, this._a *= t2;
    }
    premultiply() {
      return this._r *= this._a, this._g *= this._a, this._b *= this._a, this;
    }
    unpremultiply() {
      return this._r /= this._a, this._g /= this._a, this._b /= this._a, this;
    }
    clamp() {
      return this._r = C32.clamp(this._r, 0, 1), this._g = C32.clamp(this._g, 0, 1), this._b = C32.clamp(this._b, 0, 1), this._a = C32.clamp(this._a, 0, 1), this;
    }
    setFromRgbValue(t2) {
      this._r = C32.GetRValue(t2), this._g = C32.GetGValue(t2), this._b = C32.GetBValue(t2), this._a = C32.GetAValue(t2);
    }
    getCssRgb(t2, s, e) {
      return `rgb(${100 * (C32.IsFiniteNumber(t2) ? t2 : this.getR())}%, ${100 * (C32.IsFiniteNumber(s) ? s : this.getG())}%, ${100 * (C32.IsFiniteNumber(e) ? e : this.getB())}%)`;
    }
    getCssRgba(t2, s, e, r2) {
      return `rgba(${100 * (C32.IsFiniteNumber(t2) ? t2 : this.getR())}%, ${100 * (C32.IsFiniteNumber(s) ? s : this.getG())}%, ${100 * (C32.IsFiniteNumber(e) ? e : this.getB())}%, ${C32.IsFiniteNumber(r2) ? r2 : this.getA()})`;
    }
    toHexString() {
      const t2 = Math.round(255 * this.getR()), s = Math.round(255 * this.getG()), e = Math.round(255 * this.getB());
      return "#" + padTwoDigits(t2.toString(16)) + padTwoDigits(s.toString(16)) + padTwoDigits(e.toString(16));
    }
    parseHexString(t2) {
      if ("string" != typeof t2) return false;
      let s, e, r2;
      if ("#" === (t2 = t2.trim()).charAt(0) && (t2 = t2.substr(1)), 3 === t2.length) s = parseInt(t2[0], 16) / 15, e = parseInt(t2[1], 16) / 15, r2 = parseInt(t2[2], 16) / 15;
      else {
        if (6 !== t2.length) return false;
        s = parseInt(t2.substr(0, 2), 16) / 255, e = parseInt(t2.substr(2, 2), 16) / 255, r2 = parseInt(t2.substr(4, 2), 16) / 255;
      }
      return isFinite(s) && this.setR(s), isFinite(e) && this.setG(e), isFinite(r2) && this.setB(r2), this.setA(1), true;
    }
    toCommaSeparatedRgb() {
      return `${Math.round(255 * this.getR())}, ${Math.round(255 * this.getG())}, ${Math.round(255 * this.getB())}`;
    }
    toRgbArray() {
      return [Math.round(255 * this.getR()), Math.round(255 * this.getG()), Math.round(255 * this.getB())];
    }
    parseCommaSeparatedRgb(t2) {
      if ("string" != typeof t2) return false;
      const s = (t2 = t2.replace(/^rgb\(|\)|%/, "")).split(",");
      if (s.length < 3) return false;
      const e = parseInt(s[0].trim(), 10) / 255, r2 = parseInt(s[1].trim(), 10) / 255, i = parseInt(s[2].trim(), 10) / 255;
      return isFinite(e) && this.setR(e), isFinite(r2) && this.setG(r2), isFinite(i) && this.setB(i), this.setA(1), true;
    }
    parseCommaSeparatedPercentageRgb(t2) {
      if ("string" != typeof t2) return false;
      const s = (t2 = t2.replace(/^rgb\(|\)|%/, "")).split(",");
      if (s.length < 3) return false;
      const e = parseInt(s[0].trim(), 10) / 100, r2 = parseInt(s[1].trim(), 10) / 100, i = parseInt(s[2].trim(), 10) / 100;
      return isFinite(e) && this.setR(e), isFinite(r2) && this.setG(r2), isFinite(i) && this.setB(i), this.setA(1), true;
    }
    parseCommaSeparatedRgba(t2) {
      if ("string" != typeof t2) return false;
      const s = (t2 = t2.replace(/^rgba\(|\)|%/, "")).split(",");
      if (s.length < 4) return false;
      const e = parseInt(s[0].trim(), 10) / 255, r2 = parseInt(s[1].trim(), 10) / 255, i = parseInt(s[2].trim(), 10) / 255, a2 = parseFloat(s[3].trim());
      return isFinite(e) && this.setR(e), isFinite(r2) && this.setG(r2), isFinite(i) && this.setB(i), isFinite(a2) && this.setA(a2), true;
    }
    parseCommaSeparatedPercentageRgba(t2) {
      if ("string" != typeof t2) return false;
      const s = (t2 = t2.replace(/^rgba\(|\)|%/, "")).split(",");
      if (s.length < 4) return false;
      const e = parseInt(s[0].trim(), 10) / 100, r2 = parseInt(s[1].trim(), 10) / 100, i = parseInt(s[2].trim(), 10) / 100, a2 = parseFloat(s[3].trim());
      return isFinite(e) && this.setR(e), isFinite(r2) && this.setG(r2), isFinite(i) && this.setB(i), isFinite(a2) && this.setA(a2), true;
    }
    parseString(t2) {
      if ("string" != typeof t2) return false;
      if ((t2 = t2.replace(/\s+/, "")).includes(",")) {
        if (t2.startsWith("rgb(")) return t2.includes("%") ? this.parseCommaSeparatedPercentageRgb(t2) : this.parseCommaSeparatedRgb(t2);
        if (t2.startsWith("rgba(")) return t2.includes("%") ? this.parseCommaSeparatedPercentageRgba(t2) : this.parseCommaSeparatedRgba(t2);
        if (t2.startsWith("hsl(") || t2.startsWith("hsla(")) return this.parseHSLString(t2);
        {
          const s = t2.split(",");
          return t2.includes("%") ? 3 === s.length ? this.parseCommaSeparatedPercentageRgb(t2) : 4 === s.length && this.parseCommaSeparatedPercentageRgba(t2) : 3 === s.length ? this.parseCommaSeparatedRgb(t2) : 4 === s.length && this.parseCommaSeparatedRgba(t2);
        }
      }
      return this.parseHexString(t2);
    }
    toJSON() {
      return [this._r, this._g, this._b, this._a];
    }
    setFromHSLA(t2, s, e, r2) {
      let i, a2, h2;
      if (t2 %= 360, s = C32.clamp(s, 0, 100), e = C32.clamp(e, 0, 100), r2 = C32.clamp(r2, 0, 1), t2 /= 360, e /= 100, 0 === (s /= 100)) i = a2 = h2 = e;
      else {
        const r3 = e < 0.5 ? e * (1 + s) : e + s - e * s, n = 2 * e - r3;
        i = hueToRGB(n, r3, t2 + 1 / 3), a2 = hueToRGB(n, r3, t2), h2 = hueToRGB(n, r3, t2 - 1 / 3);
      }
      return this.setR(i), this.setG(a2), this.setB(h2), this.setA(r2), this;
    }
    parseHSLString(t2) {
      const s = t2.replace(/ |hsl|hsla|\(|\)|;/gi, ""), e = HSL_TEST.exec(s), r2 = HSLA_TEST.exec(s);
      return e && 4 === e.length ? (this.setFromHSLA(+e[1], +e[2], +e[3], 1), true) : !(!r2 || 5 !== r2.length) && (this.setFromHSLA(+e[1], +e[2], +e[3], +e[4]), true);
    }
    toHSLAString() {
      const t2 = this._r, s = this._g, e = this._b, r2 = this._a;
      return `hsla(${C32.Color.GetHue(t2, s, e)}, ${C32.Color.GetSaturation(t2, s, e)}%, ${C32.Color.GetLuminosity(t2, s, e)}%, ${r2})`;
    }
    toHSLAArray() {
      const t2 = this._r, s = this._g, e = this._b;
      return [C32.Color.GetHue(t2, s, e), C32.Color.GetSaturation(t2, s, e), C32.Color.GetLuminosity(t2, s, e), this._a];
    }
    setFromJSON(t2) {
      Array.isArray(t2) && (t2.length < 3 || (this._r = t2[0], this._g = t2[1], this._b = t2[2], t2.length >= 4 ? this._a = t2[3] : this._a = 1));
    }
    set r(t2) {
      this.setR(t2);
    }
    get r() {
      return this.getR();
    }
    set g(t2) {
      this.setG(t2);
    }
    get g() {
      return this.getG();
    }
    set b(t2) {
      this.setB(t2);
    }
    get b() {
      return this.getB();
    }
    set a(t2) {
      this.setA(t2);
    }
    get a() {
      return this.getA();
    }
    setAtIndex(t2, s) {
      switch (t2) {
        case 0:
          this.setR(s);
          break;
        case 1:
          this.setG(s);
          break;
        case 2:
          this.setB(s);
          break;
        case 3:
          this.setA(s);
          break;
        default:
          throw new RangeError("invalid color index");
      }
    }
    getAtIndex(t2) {
      switch (t2) {
        case 0:
          return this.getR();
        case 1:
          return this.getG();
        case 2:
          return this.getB();
        case 3:
          return this.getA();
        default:
          throw new RangeError("invalid color index");
      }
    }
    static Equals(t2, s) {
      let e, r2;
      if (Array.isArray(t2)) e = new C32.Color(), e.setFromJSON(t2);
      else {
        if (!(t2 instanceof C32.Color)) throw new Error("unexpected type");
        e = t2;
      }
      if (Array.isArray(s)) r2 = new C32.Color(), r2.setFromJSON(s);
      else {
        if (!(s instanceof C32.Color)) throw new Error("unexpected type");
        r2 = s;
      }
      return e.equals(r2);
    }
    static DiffChannel(t2, s) {
      return C32.clamp(Math.max(t2, s) - Math.min(t2, s), 0, 1);
    }
    static Diff(t2, s) {
      const e = new C32.Color();
      return e.setR(Math.max(t2._r, s._r) - Math.min(t2._r, s._r)), e.setG(Math.max(t2._g, s._g) - Math.min(t2._g, s._g)), e.setB(Math.max(t2._b, s._b) - Math.min(t2._b, s._b)), e.setA(Math.max(t2._a, s._a) - Math.min(t2._a, s._a)), e;
    }
    static DiffNoAlpha(t2, s) {
      const e = new C32.Color(0, 0, 0, 1);
      return e.setR(Math.max(t2._r, s._r) - Math.min(t2._r, s._r)), e.setG(Math.max(t2._g, s._g) - Math.min(t2._g, s._g)), e.setB(Math.max(t2._b, s._b) - Math.min(t2._b, s._b)), e;
    }
    static GetHue(t2, s, e) {
      const r2 = Math.max(t2, s, e), i = Math.min(t2, s, e);
      if (r2 === i) return 0;
      let a2 = 0;
      switch (r2) {
        case t2:
          a2 = (s - e) / (r2 - i) + (s < e ? 6 : 0);
          break;
        case s:
          a2 = (e - t2) / (r2 - i) + 2;
          break;
        case e:
          a2 = (t2 - s) / (r2 - i) + 4;
      }
      return Math.round(a2 / 6 * 360);
    }
    static GetSaturation(t2, s, e) {
      const r2 = Math.max(t2, s, e), i = Math.min(t2, s, e);
      if (r2 === i) return 0;
      const a2 = r2 - i, h2 = (r2 + i) / 2 > 0.5 ? a2 / (2 - r2 - i) : a2 / (r2 + i);
      return Math.round(100 * h2);
    }
    static GetLuminosity(t2, s, e) {
      const r2 = Math.max(t2, s, e), i = (r2 + Math.min(t2, s, e)) / 2;
      return r2 ? Math.round(100 * i) : 0;
    }
  }, C32.Color.White = Object.freeze(C32.New(C32.Color, 1, 1, 1, 1)), C32.Color.Black = Object.freeze(C32.New(C32.Color, 0, 0, 0, 1)), C32.Color.TransparentBlack = Object.freeze(C32.New(C32.Color, 0, 0, 0, 0));
}
var padTwoDigits2;
var hueToRGB2;
{
  const C32 = self.C3;
  C32.Vector2 = class {
    constructor(t2, s) {
      this._x = 0, this._y = 0, t2 instanceof C32.Vector2 ? this.copy(t2) : this.set(t2 || 0, s || 0);
    }
    set(t2, s) {
      this._x = +t2, this._y = +s;
    }
    copy(t2) {
      this._x = t2._x, this._y = t2._y;
    }
    equals(t2) {
      return this._x === t2._x && this._y === t2._y;
    }
    equalsValues(t2, s) {
      return this._x === t2 && this._y === s;
    }
    equalsF32Array(t2, s) {
      return t2[s] === Math.fround(this._x) && t2[s + 1] === Math.fround(this._y);
    }
    setX(t2) {
      this._x = +t2;
    }
    getX() {
      return this._x;
    }
    setY(t2) {
      this._y = +t2;
    }
    getY() {
      return this._y;
    }
    toArray() {
      return [this._x, this._y];
    }
    toTypedArray() {
      return new Float64Array(this.toArray());
    }
    writeToTypedArray(t2, s) {
      t2[s++] = this._x, t2[s] = this._y;
    }
    offset(t2, s) {
      this._x += +t2, this._y += +s;
    }
    scale(t2, s) {
      this._x *= t2, this._y *= s;
    }
    divide(t2, s) {
      this._x /= t2, this._y /= s;
    }
    round() {
      this._x = Math.round(this._x), this._y = Math.round(this._y);
    }
    floor() {
      this._x = Math.floor(this._x), this._y = Math.floor(this._y);
    }
    ceil() {
      this._x = Math.ceil(this._x), this._y = Math.ceil(this._y);
    }
    angle() {
      return C32.angleTo(0, 0, this._x, this._y);
    }
    lengthSquared() {
      return this._x * this._x + this._y * this._y;
    }
    length() {
      return C32.hypot2DFast(this._x, this._y);
    }
    rotatePrecalc(t2, s) {
      const h2 = this._x * s - this._y * t2;
      this._y = this._y * s + this._x * t2, this._x = h2;
    }
    rotate(t2) {
      0 !== t2 && this.rotatePrecalc(Math.sin(t2), Math.cos(t2));
    }
    rotateAbout(t2, s, h2) {
      0 === t2 || s === this._x && h2 === this._y || (this._x -= s, this._y -= h2, this.rotatePrecalc(Math.sin(t2), Math.cos(t2)), this._x += +s, this._y += +h2);
    }
    move(t2, s) {
      0 !== s && (this._x += Math.cos(t2) * s, this._y += Math.sin(t2) * s);
    }
    normalize() {
      const t2 = this.length();
      0 !== t2 && 1 !== t2 && (this._x /= t2, this._y /= t2);
    }
    clamp(t2, s) {
      this._x = C32.clamp(this._x, t2, s), this._y = C32.clamp(this._y, t2, s);
    }
    dot(t2) {
      return this._x * t2._x + this._y * t2._y;
    }
    reverse() {
      this._x = -this._x, this._y = -this._y;
    }
    perp() {
      let t2 = this._x;
      return this._x = this._y, this._y = -t2, this;
    }
  };
}
{
  const C32 = self.C3;
  C32.Rect = class {
    constructor(t2, h2, i, o2) {
      this._left = NaN, this._top = NaN, this._right = NaN, this._bottom = NaN, this._left = 0, this._top = 0, this._right = 0, this._bottom = 0, t2 instanceof C32.Rect ? this.copy(t2) : this.set(t2 || 0, h2 || 0, i || 0, o2 || 0);
    }
    set(t2, h2, i, o2) {
      this._left = +t2, this._top = +h2, this._right = +i, this._bottom = +o2;
    }
    setWH(t2, h2, i, o2) {
      t2 = +t2, h2 = +h2, this._left = t2, this._top = h2, this._right = t2 + +i, this._bottom = h2 + +o2;
    }
    copy(t2) {
      this._left = +t2._left, this._top = +t2._top, this._right = +t2._right, this._bottom = +t2._bottom;
    }
    clone() {
      return new C32.Rect(this._left, this._top, this._right, this._bottom);
    }
    static Merge(t2, h2) {
      const i = new C32.Rect();
      return i.setLeft(Math.min(t2._left, h2._left)), i.setTop(Math.min(t2._top, h2._top)), i.setRight(Math.max(t2._right, h2._right)), i.setBottom(Math.max(t2._bottom, h2._bottom)), i;
    }
    static FromObject(t2) {
      return new C32.Rect(t2.left, t2.top, t2.right, t2.bottom);
    }
    equals(t2) {
      return this._left === t2._left && this._top === t2._top && this._right === t2._right && this._bottom === t2._bottom;
    }
    equalsWH(t2, h2, i, o2) {
      return this._left === t2 && this._top === h2 && this.width() === i && this.height() === o2;
    }
    equalsF32Array(t2, h2) {
      return t2[h2] === Math.fround(this._left) && t2[h2 + 1] === Math.fround(this._top) && t2[h2 + 2] === Math.fround(this._right) && t2[h2 + 3] === Math.fround(this._bottom);
    }
    setLeft(t2) {
      this._left = +t2;
    }
    getLeft() {
      return this._left;
    }
    setTop(t2) {
      this._top = +t2;
    }
    getTop() {
      return this._top;
    }
    setRight(t2) {
      this._right = +t2;
    }
    getRight() {
      return this._right;
    }
    setBottom(t2) {
      this._bottom = +t2;
    }
    getBottom() {
      return this._bottom;
    }
    toArray() {
      return [this._left, this._top, this._right, this._bottom];
    }
    toTypedArray() {
      return new Float64Array(this.toArray());
    }
    toDOMRect() {
      return new DOMRect(this._left, this._top, this.width(), this.height());
    }
    static fromDOMRect(t2) {
      return C32.New(C32.Rect, t2.left, t2.top, t2.right, t2.bottom);
    }
    writeToTypedArray(t2, h2) {
      t2[h2++] = this._left, t2[h2++] = this._top, t2[h2++] = this._right, t2[h2] = this._bottom;
    }
    writeAsQuadToTypedArray(t2, h2) {
      t2[h2++] = this._left, t2[h2++] = this._top, t2[h2++] = this._right, t2[h2++] = this._top, t2[h2++] = this._right, t2[h2++] = this._bottom, t2[h2++] = this._left, t2[h2] = this._bottom;
    }
    writeAsQuadToTypedArray3D(t2, h2, i) {
      t2[h2++] = this._left, t2[h2++] = this._top, t2[h2++] = i, t2[h2++] = this._right, t2[h2++] = this._top, t2[h2++] = i, t2[h2++] = this._right, t2[h2++] = this._bottom, t2[h2++] = i, t2[h2++] = this._left, t2[h2++] = this._bottom, t2[h2] = i;
    }
    width() {
      return this._right - this._left;
    }
    height() {
      return this._bottom - this._top;
    }
    midX() {
      return (this._left + this._right) / 2;
    }
    midY() {
      return (this._top + this._bottom) / 2;
    }
    offset(t2, h2) {
      t2 = +t2, h2 = +h2, this._left += t2, this._top += h2, this._right += t2, this._bottom += h2;
    }
    offsetLeft(t2) {
      this._left += +t2;
    }
    offsetTop(t2) {
      this._top += +t2;
    }
    offsetRight(t2) {
      this._right += +t2;
    }
    offsetBottom(t2) {
      this._bottom += +t2;
    }
    toSquare(t2) {
      if ("x" !== t2) throw new Error("invalid axis, only 'x' supported");
      this._top < this._bottom ? this._left < this._right ? this._bottom = this._top + this.width() : this._bottom = this._top - this.width() : this._left < this._right ? this._bottom = this._top - this.width() : this._bottom = this._top + this.width();
    }
    inflate(t2, h2) {
      t2 = +t2, h2 = +h2, this._left -= t2, this._top -= h2, this._right += t2, this._bottom += h2;
    }
    deflate(t2, h2) {
      t2 = +t2, h2 = +h2, this._left += t2, this._top += h2, this._right -= t2, this._bottom -= h2;
    }
    multiply(t2, h2) {
      this._left *= t2, this._top *= h2, this._right *= t2, this._bottom *= h2;
    }
    divide(t2, h2) {
      this._left /= t2, this._top /= h2, this._right /= t2, this._bottom /= h2;
    }
    mirrorAround(t2) {
      this._left = +t2 - this._left, this._right = +t2 - this._right;
    }
    flipAround(t2) {
      this._top = +t2 - this._top, this._bottom = +t2 - this._bottom;
    }
    rotate90DegreesAround(t2, h2) {
      const i = this.width(), o2 = this.height(), s = this.getLeft() + i * t2, _2 = this.getTop() + o2 * h2;
      this.setWH(s - o2 * h2, _2 - i * t2, o2, i);
    }
    swapLeftRight() {
      const t2 = this._left;
      this._left = this._right, this._right = t2;
    }
    swapTopBottom() {
      const t2 = this._top;
      this._top = this._bottom, this._bottom = t2;
    }
    shuntY(t2) {
      const h2 = this._top;
      this._top = +t2 - this._bottom, this._bottom = +t2 - h2;
    }
    round() {
      this._left = Math.round(this._left), this._top = Math.round(this._top), this._right = Math.round(this._right), this._bottom = Math.round(this._bottom);
    }
    roundInner() {
      this._left = Math.ceil(this._left), this._top = Math.ceil(this._top), this._right = Math.floor(this._right), this._bottom = Math.floor(this._bottom);
    }
    roundOuter() {
      this._left = Math.floor(this._left), this._top = Math.floor(this._top), this._right = Math.ceil(this._right), this._bottom = Math.ceil(this._bottom);
    }
    floor() {
      this._left = Math.floor(this._left), this._top = Math.floor(this._top), this._right = Math.floor(this._right), this._bottom = Math.floor(this._bottom);
    }
    ceil() {
      this._left = Math.ceil(this._left), this._top = Math.ceil(this._top), this._right = Math.ceil(this._right), this._bottom = Math.ceil(this._bottom);
    }
    clamp(t2, h2, i, o2) {
      this._left = Math.max(this._left, +t2), this._top = Math.max(this._top, +h2), this._right = Math.min(this._right, +i), this._bottom = Math.min(this._bottom, +o2);
    }
    clampBoth(t2, h2, i, o2) {
      t2 = +t2, h2 = +h2, i = +i, o2 = +o2, this._left = C32.clamp(this._left, t2, i), this._top = C32.clamp(this._top, h2, o2), this._right = C32.clamp(this._right, t2, i), this._bottom = C32.clamp(this._bottom, h2, o2);
    }
    normalize() {
      this._left > this._right && this.swapLeftRight(), this._top > this._bottom && this.swapTopBottom();
    }
    intersectsRect(t2) {
      return !(t2._right < this._left || t2._bottom < this._top || t2._left > this._right || t2._top > this._bottom);
    }
    intersectsRectOffset(t2, h2, i) {
      return !(t2._right + h2 < this._left || t2._bottom + i < this._top || t2._left + h2 > this._right || t2._top + i > this._bottom);
    }
    containsPoint(t2, h2) {
      return t2 >= this._left && t2 <= this._right && h2 >= this._top && h2 <= this._bottom;
    }
    containsRect(t2) {
      return t2._left >= this._left && t2._top >= this._top && t2._right <= this._right && t2._bottom <= this._bottom;
    }
    expandToContain(t2) {
      t2._left < this._left && (this._left = +t2._left), t2._top < this._top && (this._top = +t2._top), t2._right > this._right && (this._right = +t2._right), t2._bottom > this._bottom && (this._bottom = +t2._bottom);
    }
    lerpInto(t2) {
      this._left = C32.lerp(t2._left, t2._right, this._left), this._top = C32.lerp(t2._top, t2._bottom, this._top), this._right = C32.lerp(t2._left, t2._right, this._right), this._bottom = C32.lerp(t2._top, t2._bottom, this._bottom);
    }
  };
}
{
  const C32 = self.C3;
  C32.Quad = class {
    constructor(t2, s, i, h2, _2, r2, l, e) {
      this._tlx = NaN, this._tly = NaN, this._trx = NaN, this._try = NaN, this._brx = NaN, this._bry = NaN, this._blx = NaN, this._bly = NaN, this._tlx = 0, this._tly = 0, this._trx = 0, this._try = 0, this._brx = 0, this._bry = 0, this._blx = 0, this._bly = 0, t2 instanceof C32.Quad ? this.copy(t2) : this.set(t2 || 0, s || 0, i || 0, h2 || 0, _2 || 0, r2 || 0, l || 0, e || 0);
    }
    set(t2, s, i, h2, _2, r2, l, e) {
      this._tlx = +t2, this._tly = +s, this._trx = +i, this._try = +h2, this._brx = +_2, this._bry = +r2, this._blx = +l, this._bly = +e;
    }
    setRect(t2, s, i, h2) {
      this.set(t2, s, i, s, i, h2, t2, h2);
    }
    copy(t2) {
      this._tlx = t2._tlx, this._tly = t2._tly, this._trx = t2._trx, this._try = t2._try, this._brx = t2._brx, this._bry = t2._bry, this._blx = t2._blx, this._bly = t2._bly;
    }
    equals(t2) {
      return this._tlx === t2._tlx && this._tly === t2._tly && this._trx === t2._trx && this._try === t2._try && this._brx === t2._brx && this._bry === t2._bry && this._blx === t2._blx && this._bly === t2._bly;
    }
    setTlx(t2) {
      this._tlx = +t2;
    }
    getTlx() {
      return this._tlx;
    }
    setTly(t2) {
      this._tly = +t2;
    }
    getTly() {
      return this._tly;
    }
    setTrx(t2) {
      this._trx = +t2;
    }
    getTrx() {
      return this._trx;
    }
    setTry(t2) {
      this._try = +t2;
    }
    getTry() {
      return this._try;
    }
    setBrx(t2) {
      this._brx = +t2;
    }
    getBrx() {
      return this._brx;
    }
    setBry(t2) {
      this._bry = +t2;
    }
    getBry() {
      return this._bry;
    }
    setBlx(t2) {
      this._blx = +t2;
    }
    getBlx() {
      return this._blx;
    }
    setBly(t2) {
      this._bly = +t2;
    }
    getBly() {
      return this._bly;
    }
    toDOMQuad() {
      return new DOMQuad(new DOMPoint(this._tlx, this._tly), new DOMPoint(this._trx, this._try), new DOMPoint(this._brx, this._bry), new DOMPoint(this._blx, this._bly));
    }
    static fromDOMQuad(t2) {
      return C32.New(C32.Quad, t2.p1.x, t2.p1.y, t2.p2.x, t2.p2.y, t2.p3.x, t2.p3.y, t2.p4.x, t2.p4.y);
    }
    toArray() {
      return [this._tlx, this._tly, this._trx, this._try, this._brx, this._bry, this._blx, this._bly];
    }
    toTypedArray() {
      return new Float64Array(this.toArray());
    }
    writeToTypedArray(t2, s) {
      t2[s++] = this._tlx, t2[s++] = this._tly, t2[s++] = this._trx, t2[s++] = this._try, t2[s++] = this._brx, t2[s++] = this._bry, t2[s++] = this._blx, t2[s] = this._bly;
    }
    writeToTypedArray3D(t2, s, i) {
      t2[s++] = this._tlx, t2[s++] = this._tly, t2[s++] = i, t2[s++] = this._trx, t2[s++] = this._try, t2[s++] = i, t2[s++] = this._brx, t2[s++] = this._bry, t2[s++] = i, t2[s++] = this._blx, t2[s++] = this._bly, t2[s] = i;
    }
    offset(t2, s) {
      t2 = +t2, s = +s, this._tlx += t2, this._tly += s, this._trx += t2, this._try += s, this._brx += t2, this._bry += s, this._blx += t2, this._bly += s;
    }
    round() {
      this._tlx = Math.round(this._tlx), this._tly = Math.round(this._tly), this._trx = Math.round(this._trx), this._try = Math.round(this._try), this._brx = Math.round(this._brx), this._bry = Math.round(this._bry), this._blx = Math.round(this._blx), this._bly = Math.round(this._bly);
    }
    floor() {
      this._tlx = Math.floor(this._tlx), this._tly = Math.floor(this._tly), this._trx = Math.floor(this._trx), this._try = Math.floor(this._try), this._brx = Math.floor(this._brx), this._bry = Math.floor(this._bry), this._blx = Math.floor(this._blx), this._bly = Math.floor(this._bly);
    }
    ceil() {
      this._tlx = Math.ceil(this._tlx), this._tly = Math.ceil(this._tly), this._trx = Math.ceil(this._trx), this._try = Math.ceil(this._try), this._brx = Math.ceil(this._brx), this._bry = Math.ceil(this._bry), this._blx = Math.ceil(this._blx), this._bly = Math.ceil(this._bly);
    }
    setFromRect(t2) {
      this._tlx = t2._left, this._tly = t2._top, this._trx = t2._right, this._try = t2._top, this._brx = t2._right, this._bry = t2._bottom, this._blx = t2._left, this._bly = t2._bottom;
    }
    setFromRotatedRect(t2, s) {
      0 === s ? this.setFromRect(t2) : this.setFromRotatedRectPrecalc(t2, Math.sin(s), Math.cos(s));
    }
    setFromRotatedRectPrecalc(t2, s, i) {
      const h2 = t2._left * s, _2 = t2._top * s, r2 = t2._right * s, l = t2._bottom * s, e = t2._left * i, x2 = t2._top * i, y2 = t2._right * i, b2 = t2._bottom * i;
      this._tlx = e - _2, this._tly = x2 + h2, this._trx = y2 - _2, this._try = x2 + r2, this._brx = y2 - l, this._bry = b2 + r2, this._blx = e - l, this._bly = b2 + h2;
    }
    getBoundingBox(t2) {
      t2.set(Math.min(this._tlx, this._trx, this._brx, this._blx), Math.min(this._tly, this._try, this._bry, this._bly), Math.max(this._tlx, this._trx, this._brx, this._blx), Math.max(this._tly, this._try, this._bry, this._bly));
    }
    containsPoint(t2, s) {
      let i = this._trx - this._tlx, h2 = this._try - this._tly;
      const _2 = this._brx - this._tlx, r2 = this._bry - this._tly, l = t2 - this._tlx, e = s - this._tly;
      let x2 = i * i + h2 * h2, y2 = i * _2 + h2 * r2, b2 = i * l + h2 * e;
      const a2 = _2 * _2 + r2 * r2, n = _2 * l + r2 * e;
      let o2 = 1 / (x2 * a2 - y2 * y2), c2 = (a2 * b2 - y2 * n) * o2, u2 = (x2 * n - y2 * b2) * o2;
      return c2 >= 0 && u2 > 0 && c2 + u2 < 1 || (i = this._blx - this._tlx, h2 = this._bly - this._tly, x2 = i * i + h2 * h2, y2 = i * _2 + h2 * r2, b2 = i * l + h2 * e, o2 = 1 / (x2 * a2 - y2 * y2), c2 = (a2 * b2 - y2 * n) * o2, u2 = (x2 * n - y2 * b2) * o2, c2 >= 0 && u2 > 0 && c2 + u2 < 1);
    }
    midX() {
      return (this._tlx + this._trx + this._brx + this._blx) / 4;
    }
    midY() {
      return (this._tly + this._try + this._bry + this._bly) / 4;
    }
    intersectsSegment(t2, s, i, h2) {
      return !(!this.containsPoint(t2, s) && !this.containsPoint(i, h2)) || C32.segmentIntersectsQuad(t2, s, i, h2, this);
    }
    intersectsQuad(t2) {
      let s = t2.midX(), i = t2.midY();
      if (this.containsPoint(s, i)) return true;
      if (s = this.midX(), i = this.midY(), t2.containsPoint(s, i)) return true;
      const h2 = this._tlx, _2 = this._tly, r2 = this._trx, l = this._try, e = this._brx, x2 = this._bry, y2 = this._blx, b2 = this._bly;
      return C32.segmentIntersectsQuad(h2, _2, r2, l, t2) || C32.segmentIntersectsQuad(r2, l, e, x2, t2) || C32.segmentIntersectsQuad(e, x2, y2, b2, t2) || C32.segmentIntersectsQuad(y2, b2, h2, _2, t2);
    }
    rotatePointsAnticlockwise() {
      const t2 = this._tlx, s = this._tly;
      this._tlx = this._trx, this._tly = this._try, this._trx = this._brx, this._try = this._bry, this._brx = this._blx, this._bry = this._bly, this._blx = t2, this._bly = s;
    }
    mirror() {
      this._swap(0, 2), this._swap(1, 3), this._swap(6, 4), this._swap(7, 5);
    }
    flip() {
      this._swap(0, 6), this._swap(1, 7), this._swap(2, 4), this._swap(3, 5);
    }
    diag() {
      this._swap(2, 6), this._swap(3, 7);
    }
    _swap(t2, s) {
      const i = this._getAtIndex(t2);
      this._setAtIndex(t2, this._getAtIndex(s)), this._setAtIndex(s, i);
    }
    _getAtIndex(t2) {
      switch (t2) {
        case 0:
          return this._tlx;
        case 1:
          return this._tly;
        case 2:
          return this._trx;
        case 3:
          return this._try;
        case 4:
          return this._brx;
        case 5:
          return this._bry;
        case 6:
          return this._blx;
        case 7:
          return this._bly;
        default:
          throw new RangeError("invalid quad point index");
      }
    }
    _setAtIndex(t2, s) {
      switch (s = +s, t2) {
        case 0:
          this._tlx = s;
          break;
        case 1:
          this._tly = s;
          break;
        case 2:
          this._trx = s;
          break;
        case 3:
          this._try = s;
          break;
        case 4:
          this._brx = s;
          break;
        case 5:
          this._bry = s;
          break;
        case 6:
          this._blx = s;
          break;
        case 7:
          this._bly = s;
          break;
        default:
          throw new RangeError("invalid quad point index");
      }
    }
    divide(t2, s) {
      this._tlx /= t2, this._tly /= s, this._trx /= t2, this._try /= s, this._brx /= t2, this._bry /= s, this._blx /= t2, this._bly /= s;
    }
  };
}
{
  const C32 = self.C3, assert = self.assert, DEFAULT_POLY_POINTS = [0, 0, 1, 0, 1, 1, 0, 1], tempQuad = C32.New(C32.Quad);
  C32.CollisionPoly = class extends C32.DefendedBase {
    constructor(t2, s = true) {
      super(), t2 || (t2 = DEFAULT_POLY_POINTS), this._ptsArr = Float64Array.from(t2), this._bbox = new C32.Rect(), this._isBboxChanged = true, this._enabled = s;
    }
    Release() {
    }
    pointsArr() {
      return this._ptsArr;
    }
    pointCount() {
      return this._ptsArr.length / 2;
    }
    setPoints(t2) {
      this._ptsArr.length === t2.length ? this._ptsArr.set(t2) : this._ptsArr = Float64Array.from(t2), this._isBboxChanged = true;
    }
    setDefaultPoints() {
      this.setPoints(DEFAULT_POLY_POINTS);
    }
    copy(t2) {
      this.setPoints(t2._ptsArr);
    }
    setBboxChanged() {
      this._isBboxChanged = true;
    }
    _updateBbox() {
      if (!this._isBboxChanged) return;
      const t2 = this._ptsArr;
      let s = t2[0], e = t2[1], r2 = s, n = e;
      for (let o2 = 0, i = t2.length; o2 < i; o2 += 2) {
        const i2 = t2[o2], h2 = t2[o2 + 1];
        i2 < s && (s = i2), i2 > r2 && (r2 = i2), h2 < e && (e = h2), h2 > n && (n = h2);
      }
      this._bbox.set(s, e, r2, n), this._isBboxChanged = false;
    }
    setFromRect(t2, s, e) {
      let r2 = this._ptsArr;
      8 !== r2.length && (r2 = new Float64Array(8), this._ptsArr = r2), r2[0] = t2.getLeft() - s, r2[1] = t2.getTop() - e, r2[2] = t2.getRight() - s, r2[3] = t2.getTop() - e, r2[4] = t2.getRight() - s, r2[5] = t2.getBottom() - e, r2[6] = t2.getLeft() - s, r2[7] = t2.getBottom() - e, this._bbox.copy(t2), 0 === s && 0 === e || this._bbox.offset(-s, -e), this._isBboxChanged = false;
    }
    setFromQuad(t2, s, e) {
      tempQuad.copy(t2), tempQuad.offset(s, e), this.setPoints(tempQuad.toArray()), this._isBboxChanged = true;
    }
    transform(t2, s, e) {
      let r2 = 0, n = 1;
      0 !== e && (r2 = Math.sin(e), n = Math.cos(e)), this.transformPrecalc(t2, s, r2, n);
    }
    transformPrecalc(t2, s, e, r2) {
      const n = this._ptsArr;
      for (let o2 = 0, i = n.length; o2 < i; o2 += 2) {
        const i2 = o2 + 1, h2 = n[o2] * t2, l = n[i2] * s;
        n[o2] = h2 * r2 - l * e, n[i2] = l * r2 + h2 * e;
      }
      this._isBboxChanged = true;
    }
    offset(t2, s) {
      const e = this._ptsArr;
      for (let r2 = 0, n = e.length; r2 < n; r2 += 2) e[r2] += t2, e[r2 + 1] += s;
    }
    containsPoint(t2, s) {
      const e = this._ptsArr;
      if (t2 === e[0] && s === e[1]) return true;
      this._updateBbox();
      const r2 = this._bbox, n = r2.getLeft() - 110, o2 = r2.getTop() - 101, i = r2.getRight() + 131, h2 = r2.getBottom() + 120;
      let l = 0, a2 = 0, c2 = 0, g2 = 0, _2 = 0, p2 = 0, f2 = 0, u2 = 0;
      n < t2 ? (l = n, c2 = t2) : (l = t2, c2 = n), o2 < s ? (a2 = o2, g2 = s) : (a2 = s, g2 = o2), i < t2 ? (_2 = i, f2 = t2) : (_2 = t2, f2 = i), h2 < s ? (p2 = h2, u2 = s) : (p2 = s, u2 = h2);
      let C2 = 0, A = 0;
      for (let r3 = 0, d2 = e.length; r3 < d2; r3 += 2) {
        const b2 = (r3 + 2) % d2, P2 = e[r3], m2 = e[r3 + 1], x2 = e[b2], B2 = e[b2 + 1];
        C32.segmentsIntersectPreCalc(n, o2, t2, s, l, c2, a2, g2, P2, m2, x2, B2) && ++C2, C32.segmentsIntersectPreCalc(i, h2, t2, s, _2, f2, p2, u2, P2, m2, x2, B2) && ++A;
      }
      return C2 % 2 == 1 || A % 2 == 1;
    }
    intersectsPoly(t2, s, e) {
      const r2 = t2._ptsArr, n = this._ptsArr;
      if (this.containsPoint(r2[0] + s, r2[1] + e)) return true;
      if (t2.containsPoint(n[0] - s, n[1] - e)) return true;
      for (let t3 = 0, o2 = n.length; t3 < o2; t3 += 2) {
        const i = (t3 + 2) % o2, h2 = n[t3], l = n[t3 + 1], a2 = n[i], c2 = n[i + 1];
        let g2 = 0, _2 = 0, p2 = 0, f2 = 0;
        h2 < a2 ? (g2 = h2, p2 = a2) : (g2 = a2, p2 = h2), l < c2 ? (_2 = l, f2 = c2) : (_2 = c2, f2 = l);
        for (let t4 = 0, n2 = r2.length; t4 < n2; t4 += 2) {
          const o3 = (t4 + 2) % n2, i2 = r2[t4] + s, u2 = r2[t4 + 1] + e, C2 = r2[o3] + s, A = r2[o3 + 1] + e;
          if (C32.segmentsIntersectPreCalc(h2, l, a2, c2, g2, p2, _2, f2, i2, u2, C2, A)) return true;
        }
      }
      return false;
    }
    intersectsSegment(t2, s, e, r2, n, o2) {
      if (this.containsPoint(e - t2, r2 - s)) return true;
      if (this.containsPoint(n - t2, o2 - s)) return true;
      let i = 0, h2 = 0, l = 0, a2 = 0;
      e < n ? (i = e, l = n) : (i = n, l = e), r2 < o2 ? (h2 = r2, a2 = o2) : (h2 = o2, a2 = r2);
      const c2 = this._ptsArr;
      for (let g2 = 0, _2 = c2.length; g2 < _2; g2 += 2) {
        const p2 = (g2 + 2) % _2, f2 = c2[g2] + t2, u2 = c2[g2 + 1] + s, C2 = c2[p2] + t2, A = c2[p2 + 1] + s;
        if (C32.segmentsIntersectPreCalc(e, r2, n, o2, i, l, h2, a2, f2, u2, C2, A)) return true;
      }
      return false;
    }
    mirror(t2) {
      const s = this._ptsArr;
      for (let e = 0, r2 = s.length; e < r2; e += 2) s[e] = 2 * t2 - s[e];
      this._isBboxChanged = true;
    }
    flip(t2) {
      const s = this._ptsArr;
      for (let e = 0, r2 = s.length; e < r2; e += 2) {
        const r3 = e + 1;
        s[r3] = 2 * t2 - s[r3];
      }
      this._isBboxChanged = true;
    }
    diag() {
      const t2 = this._ptsArr;
      for (let s = 0, e = t2.length; s < e; s += 2) {
        const e2 = s + 1, r2 = t2[s];
        t2[s] = t2[e2], t2[e2] = r2;
      }
      this._isBboxChanged = true;
    }
    GetMidX() {
      const t2 = this._ptsArr;
      let s = 0;
      for (let e = 0, r2 = t2.length; e < r2; e += 2) s += t2[e];
      return s / this.pointCount();
    }
    GetMidY() {
      const t2 = this._ptsArr;
      let s = 0;
      for (let e = 0, r2 = t2.length; e < r2; e += 2) s += t2[e + 1];
      return s / this.pointCount();
    }
    GetPointsArray() {
      return this._ptsArr;
    }
    GetPointCount() {
      return this.pointCount();
    }
    IsEnabled() {
      return this._enabled;
    }
  };
}
{
  const C32 = self.C3;
  C32.PairMap = class extends C32.DefendedBase {
    constructor(e) {
      if (super(), this._firstMap = /* @__PURE__ */ new Map(), e) for (const [t2, s, r2] of e) this.Set(t2, s, r2);
    }
    Release() {
      this.Clear(), this._firstMap = null;
    }
    IsEmpty() {
      return 0 === this._firstMap.size;
    }
    Clear() {
      const e = this._firstMap;
      for (const t2 of e.values()) t2.clear();
      e.clear();
    }
    Set(e, t2, s) {
      const r2 = this._firstMap;
      let i = r2.get(e);
      i || (i = /* @__PURE__ */ new Map(), r2.set(e, i)), i.set(t2, s);
    }
    Get(e, t2) {
      const s = this._firstMap.get(e);
      return s ? s.get(t2) : s;
    }
    Has(e, t2) {
      const s = this._firstMap.get(e);
      return !!s && s.has(t2);
    }
    Delete(e, t2) {
      const s = this._firstMap, r2 = s.get(e);
      if (!r2) return false;
      const i = r2.delete(t2);
      return i && 0 === r2.size && s.delete(e), i;
    }
    DeleteEither(e) {
      const t2 = this._firstMap, s = t2.get(e);
      s && (s.clear(), t2.delete(e));
      for (const [s2, r2] of t2.entries()) r2.delete(e) && 0 === r2.size && t2.delete(s2);
    }
    GetSize() {
      let e = 0;
      for (const t2 of this._firstMap.values()) e += t2.size;
      return e;
    }
    *values() {
      for (const e of this._firstMap.values()) yield* e.values();
    }
    *keyPairs() {
      for (const [e, t2] of this._firstMap.entries()) for (const s of t2.keys()) yield [e, s];
    }
    *entries() {
      for (const [e, t2] of this._firstMap.entries()) for (const [s, r2] of t2.entries()) yield [e, s, r2];
    }
  };
}
{
  const C32 = self.C3;
  C32.ArraySet = class extends C32.DefendedBase {
    constructor() {
      super(), this._set = /* @__PURE__ */ new Set(), this._arr = [], this._needToRebuildArray = false;
    }
    Release() {
      this.Clear();
    }
    Clear() {
      this._set.clear(), C32.clearArray(this._arr), this._needToRebuildArray = false;
    }
    Add(e) {
      this._set.has(e) || (this._set.add(e), this._needToRebuildArray || this._arr.push(e));
    }
    Has(e) {
      return this._set.has(e);
    }
    Delete(e) {
      this._set.delete(e) && (this._needToRebuildArray = true);
    }
    GetSize() {
      return this._set.size;
    }
    IsEmpty() {
      return 0 === this._set.size;
    }
    GetArray() {
      return this._needToRebuildArray && (this._RebuildArray(), this._needToRebuildArray = false), this._arr;
    }
    _RebuildArray() {
      const e = this._arr;
      C32.clearArray(e);
      for (const r2 of this._set) e.push(r2);
    }
  };
}
{
  const C32 = self.C3, EASE_MAP = /* @__PURE__ */ new Map(), PREDEFINED_EASE_MAP = /* @__PURE__ */ new Map(), CUSTOM_EASE_EDITOR_MAP = /* @__PURE__ */ new Map(), CUSTOM_EASE_DATA_EDITOR_MAP = /* @__PURE__ */ new Map(), CUSTOM_EASE_RUNTIME_MAP = /* @__PURE__ */ new Map(), CUSTOM_EASE_DATA_RUNTIME_MAP = /* @__PURE__ */ new Map(), PRIVATE_EASE_MAP = /* @__PURE__ */ new Map(), BUILT_IN_TRANSITION_MAP = /* @__PURE__ */ new Map(), ALIAS_MAP = /* @__PURE__ */ new Map();
  ALIAS_MAP.set("linear", "noease"), ALIAS_MAP.set("default", "noease");
  const EASE_TRANSLATION_KEYS = ["default", "noease", "easeinquad", "easeoutquad", "easeinoutquad", "easeincubic", "easeoutcubic", "easeinoutcubic", "easeinquart", "easeoutquart", "easeinoutquart", "easeinquint", "easeoutquint", "easeinoutquint", "easeinsine", "easeoutsine", "easeinoutsine", "easeinexpo", "easeoutexpo", "easeinoutexpo", "easeincirc", "easeoutcirc", "easeinoutcirc", "easeinelastic", "easeoutelastic", "easeinoutelastic", "easeinback", "easeoutback", "easeinoutback", "easeinbounce", "easeoutbounce", "easeinoutbounce"], SHORT_EASE_TRANSLATION_KEYS = ["default", "noease", "quad", "cubic", "quart", "quint", "sine", "expo", "circ", "elastic", "back", "bounce"], EASE_API2INTERNAL_NAMES = /* @__PURE__ */ new Map([["linear", "noease"], ["in-sine", "easeinsine"], ["out-sine", "easeoutsine"], ["in-out-sine", "easeinoutsine"], ["in-elastic", "easeinelastic"], ["out-elastic", "easeoutelastic"], ["in-out-elastic", "easeinoutelastic"], ["in-back", "easeinback"], ["out-back", "easeoutback"], ["in-out-back", "easeinoutback"], ["in-bounce", "easeinbounce"], ["out-bounce", "easeoutbounce"], ["in-out-bounce", "easeinoutbounce"], ["in-cubic", "easeincubic"], ["out-cubic", "easeoutcubic"], ["in-out-cubic", "easeinoutcubic"], ["in-quadratic", "easeinquad"], ["out-quadratic", "easeoutquad"], ["in-out-quadratic", "easeinoutquad"], ["in-quartic", "easeinquart"], ["out-quartic", "easeoutquart"], ["in-out-quartic", "easeinoutquart"], ["in-quintic", "easeinquint"], ["out-quintic", "easeoutquint"], ["in-out-quintic", "easeinoutquint"], ["in-circular", "easeincirc"], ["out-circular", "easeoutcirc"], ["in-out-circular", "easeinoutcirc"], ["in-exponential", "easeinexpo"], ["out-exponential", "easeoutexpo"], ["in-out-exponential", "easeinoutexpo"]]);
  self.Ease = class e {
    constructor() {
    }
    static InheritEase() {
      return "default";
    }
    static DefaultEase() {
      return "noease";
    }
    static ToInternal(e2) {
      return EASE_API2INTERNAL_NAMES.get(e2);
    }
    static GetEditorEaseNames(a3, ...s) {
      let t2, i;
      this._CreateEaseMap(), a3 ? (CUSTOM_EASE_EDITOR_MAP.has(a3) || CUSTOM_EASE_EDITOR_MAP.set(a3, /* @__PURE__ */ new Map()), t2 = CUSTOM_EASE_EDITOR_MAP.get(a3), i = [...t2.keys()].filter((s2) => !e.GetEditorEaseData(s2, a3) || e.GetEditorEaseData(s2, a3).transition.IsForAnyPurpose())) : (t2 = CUSTOM_EASE_RUNTIME_MAP, i = [...t2.keys()]);
      const x2 = i.sort();
      return [...PREDEFINED_EASE_MAP.keys()].concat(x2).filter((e2) => !s.includes(e2));
    }
    static GetRuntimeEaseNames() {
      this._CreateEaseMap();
      const e2 = [...CUSTOM_EASE_RUNTIME_MAP.keys()];
      return e2.sort(), [...PREDEFINED_EASE_MAP.keys()].concat(e2);
    }
    static GetCustomRuntimeEaseNames() {
      this._CreateEaseMap();
      const e2 = [...CUSTOM_EASE_RUNTIME_MAP.keys()];
      return e2.sort(), e2;
    }
    static IsPredefinedTranslatedName(e2) {
      for (const a3 of EASE_TRANSLATION_KEYS) {
        if (self.lang(`ui.bars.timeline.eases.${a3}`) === e2) return true;
      }
      for (const a3 of SHORT_EASE_TRANSLATION_KEYS) {
        if (self.lang(`ui.bars.timeline.short-eases.${a3}`) === e2) return true;
      }
    }
    static IsNamePredefined(e2) {
      return this._CreateEaseMap(), [...PREDEFINED_EASE_MAP.keys()].includes(e2);
    }
    static _GetEase(a3) {
      const s = ALIAS_MAP.get(a3);
      return s ? EASE_MAP.get(s) : e.IsNamePredefined(a3) ? EASE_MAP.get(a3) : PRIVATE_EASE_MAP.has(a3) ? PRIVATE_EASE_MAP.get(a3) : void 0;
    }
    static GetBuiltInTransition(e2) {
      return this._CreateEaseMap(), BUILT_IN_TRANSITION_MAP.get(e2);
    }
    static GetEditorEase(a3, s) {
      this._CreateEaseMap();
      const t2 = e._GetEase(a3);
      if (t2) return t2;
      if (!s) throw new Error("missing ease function");
      return CUSTOM_EASE_EDITOR_MAP.get(s).get(a3);
    }
    static GetEditorEaseData(e2, a3) {
      this._CreateEaseMap();
      const s = CUSTOM_EASE_DATA_EDITOR_MAP.get(a3);
      if (s) return s.get(e2);
    }
    static HasEditorEase(a3, s) {
      this._CreateEaseMap();
      return !!e._GetEase(a3) || !!CUSTOM_EASE_EDITOR_MAP.get(s).get(a3);
    }
    static GetRuntimeEase(a3) {
      this._CreateEaseMap();
      const s = e._GetEase(a3);
      return s || CUSTOM_EASE_RUNTIME_MAP.get(a3);
    }
    static GetRuntimeEaseData(e2) {
      return this._CreateEaseMap(), CUSTOM_EASE_DATA_RUNTIME_MAP.get(e2);
    }
    static GetEaseFromIndex(e2) {
      this._CreateEaseMap();
      return this.GetRuntimeEaseNames()[e2];
    }
    static GetIndexForEase(e2, a3) {
      this._CreateEaseMap();
      return this.GetEditorEaseNames(a3).indexOf(e2);
    }
    static GetIndexForEaseAtRuntime(e2) {
      return this.GetIndexForEase(e2);
    }
    static _CreateEaseMap() {
      0 === EASE_MAP.size && (this._AddPredifinedEase("default", () => {
      }), this._AddPredifinedEase("noease", [{ "x": 0, "y": 0, "sax": 0.336, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.336, "eay": 0, "se": false, "ee": true }], true), this._AddPredifinedEase("easeinsine", [{ "x": 0, "y": 0, "sax": 0.485, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.038, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutsine", [{ "x": 0, "y": 0, "sax": 0.038, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.485, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutsine", [{ "x": 0, "y": 0, "sax": 0.336, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.336, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinelastic", [{ "x": 0, "y": 0, "sax": 0.018, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.116, "y": 2e-3, "sax": 0.025, "say": 0, "eax": -0.025, "eay": 0, "se": true, "ee": true }, { "x": 0.266, "y": -5e-3, "sax": 0.024, "say": 0, "eax": -0.021, "eay": 0, "se": true, "ee": true }, { "x": 0.416, "y": 0.016, "sax": 0.024, "say": 0, "eax": -0.026, "eay": 0, "se": true, "ee": true }, { "x": 0.566, "y": -0.045, "sax": 0.061, "say": 0, "eax": -0.025, "eay": 0, "se": true, "ee": true }, { "x": 0.716, "y": 0.132, "sax": 0.072, "say": -4e-3, "eax": -0.045, "eay": 0, "se": true, "ee": true }, { "x": 0.866, "y": -0.373, "sax": 0.06, "say": 0, "eax": -0.049, "eay": -2e-3, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.038, "eay": -0.263, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutelastic", [{ "x": 0, "y": 0, "sax": 0.038, "say": 0.263, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.136, "y": 1.373, "sax": 0.049, "say": 2e-3, "eax": -0.06, "eay": 0, "se": true, "ee": true }, { "x": 0.286, "y": 0.868, "sax": 0.045, "say": 0, "eax": -0.072, "eay": 4e-3, "se": true, "ee": true }, { "x": 0.436, "y": 1.045, "sax": 0.025, "say": 0, "eax": -0.061, "eay": 0, "se": true, "ee": true }, { "x": 0.586, "y": 0.984, "sax": 0.026, "say": 0, "eax": -0.024, "eay": 0, "se": true, "ee": true }, { "x": 0.736, "y": 1.005, "sax": 0.021, "say": 0, "eax": -0.024, "eay": 0, "se": true, "ee": true }, { "x": 0.886, "y": 0.998, "sax": 0.025, "say": 0, "eax": -0.025, "eay": 0, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.018, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutelastic", [{ "x": 0, "y": 0, "sax": 0.025, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.067, "y": 1e-3, "sax": 0.025, "say": 0, "eax": -0.025, "eay": 0, "se": true, "ee": true }, { "x": 0.18, "y": -5e-3, "sax": 0.025, "say": 0, "eax": -0.025, "eay": 0, "se": true, "ee": true }, { "x": 0.292, "y": 0.025, "sax": 0.053, "say": 0, "eax": -0.025, "eay": 0, "se": true, "ee": true }, { "x": 0.405, "y": -0.118, "sax": 0.069, "say": 0, "eax": -0.027, "eay": 0, "se": true, "ee": true }, { "x": 0.597, "y": 1.118, "sax": 0.027, "say": 0, "eax": -0.069, "eay": 0, "se": true, "ee": true }, { "x": 0.71, "y": 0.975, "sax": 0.025, "say": 0, "eax": -0.053, "eay": 0, "se": true, "ee": true }, { "x": 0.822, "y": 1.005, "sax": 0.025, "say": 0, "eax": -0.025, "eay": 0, "se": true, "ee": true }, { "x": 0.935, "y": 0.999, "sax": 0.025, "say": 0, "eax": -0.025, "eay": 0, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.025, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinback", [{ "x": 0, "y": 0, "sax": 0.35, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.34, "eay": -1.579, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutback", [{ "x": 0, "y": 0, "sax": 0.34, "say": 1.579, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.35, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutback", [{ "x": 0, "y": 0, "sax": 0.035, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.242, "y": -0.1, "sax": 0.258, "say": 0, "eax": -0.025, "eay": 0, "se": true, "ee": true }, { "x": 0.76, "y": 1.1, "sax": 0.025, "say": 0, "eax": -0.26, "eay": 0, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.035, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinbounce", [{ "x": 0, "y": 0, "sax": 0.033, "say": 0.025, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.092, "y": 0, "sax": 0.026, "say": 0.078, "eax": -0.033, "eay": 0.025, "se": true, "ee": true }, { "x": 0.274, "y": 0, "sax": 0.097, "say": 0.319, "eax": -0.026, "eay": 0.078, "se": true, "ee": true }, { "x": 0.637, "y": 0, "sax": 0.105, "say": 0.625, "eax": -0.097, "eay": 0.319, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.125, "eay": -4e-3, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutbounce", [{ "x": 0, "y": 0, "sax": 0.125, "say": 4e-3, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.365, "y": 1, "sax": 0.097, "say": -0.319, "eax": -0.105, "eay": -0.625, "se": true, "ee": true }, { "x": 0.728, "y": 1, "sax": 0.026, "say": -0.078, "eax": -0.097, "eay": -0.319, "se": true, "ee": true }, { "x": 0.91, "y": 1, "sax": 0.033, "say": -0.025, "eax": -0.026, "eay": -0.078, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.033, "eay": -0.025, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutbounce", [{ "x": 0, "y": 0, "sax": 0.01, "say": 6e-3, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.046, "y": 0, "sax": 0.021, "say": 0.038, "eax": -0.01, "eay": 6e-3, "se": true, "ee": true }, { "x": 0.137, "y": 0, "sax": 0.059, "say": 0.158, "eax": -0.021, "eay": 0.038, "se": true, "ee": true }, { "x": 0.319, "y": 0, "sax": 0.117, "say": 0.744, "eax": -0.059, "eay": 0.158, "se": true, "ee": true }, { "x": 0.683, "y": 1, "sax": 0.059, "say": -0.158, "eax": -0.117, "eay": -0.744, "se": true, "ee": true }, { "x": 0.865, "y": 1, "sax": 0.021, "say": -0.038, "eax": -0.059, "eay": -0.158, "se": true, "ee": true }, { "x": 0.956, "y": 1, "sax": 0.01, "say": -6e-3, "eax": -0.021, "eay": -0.038, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.01, "eay": -6e-3, "se": false, "ee": true }]), this._AddPredifinedEase("easeincubic", [{ "x": 0, "y": 0, "sax": 0.75, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.138, "eay": -0.321, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutcubic", [{ "x": 0, "y": 0, "sax": 0.138, "say": 0.321, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.75, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutcubic", [{ "x": 0, "y": 0, "sax": 0.285, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.5, "y": 0.5, "sax": 0.081, "say": 0.272, "eax": -0.081, "eay": -0.272, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.285, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinquad", [{ "x": 0, "y": 0, "sax": 0.4, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.178, "eay": -0.392, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutquad", [{ "x": 0, "y": 0, "sax": 0.178, "say": 0.392, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.4, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutquad", [{ "x": 0, "y": 0, "sax": 0.25, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.5, "y": 0.5, "sax": 0.03, "say": 0.065, "eax": -0.03, "eay": -0.065, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.25, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinquart", [{ "x": 0, "y": 0, "sax": 0.5, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.25, "eay": -1, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutquart", [{ "x": 0, "y": 0, "sax": 0.25, "say": 1, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.5, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutquart", [{ "x": 0, "y": 0, "sax": 0.765, "say": 0.03, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.765, "eay": -0.03, "se": false, "ee": true }]), this._AddPredifinedEase("easeinquint", [{ "x": 0, "y": 0, "sax": 0.6, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.2, "eay": -1, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutquint", [{ "x": 0, "y": 0, "sax": 0.2, "say": 1, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.6, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutquint", [{ "eax": 0, "eay": 0, "ee": false, "sax": 0.84, "say": 0, "se": true, "x": 0, "y": 0 }, { "eax": -0.84, "eay": 0, "ee": true, "sax": 0, "say": 0, "se": false, "x": 1, "y": 1 }]), this._AddPredifinedEase("easeincirc", [{ "x": 0, "y": 0, "sax": 0.25, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.024, "eay": -0.808, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutcirc", [{ "x": 0, "y": 0, "sax": 0.024, "say": 0.808, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.25, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutcirc", [{ "x": 0, "y": 0, "sax": 0.125, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 0.5, "y": 0.5, "sax": 0.02, "say": 0.428, "eax": -0.02, "eay": -0.428, "se": true, "ee": true }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.125, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinexpo", [{ "x": 0, "y": 0, "sax": 0.66, "say": 0, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.14, "eay": -1, "se": false, "ee": true }]), this._AddPredifinedEase("easeoutexpo", [{ "x": 0, "y": 0, "sax": 0.14, "say": 1, "eax": 0, "eay": 0, "se": true, "ee": false }, { "x": 1, "y": 1, "sax": 0, "say": 0, "eax": -0.66, "eay": 0, "se": false, "ee": true }]), this._AddPredifinedEase("easeinoutexpo", [{ "eax": 0, "eay": 0, "ee": false, "sax": 0.345, "say": 0, "se": true, "x": 0, "y": 0 }, { "eax": -0.06, "eay": -0.5, "ee": true, "sax": 0.06, "say": 0.5, "se": true, "x": 0.5, "y": 0.5 }, { "eax": -0.335, "eay": 0, "ee": true, "sax": 0, "say": 0, "se": false, "x": 1, "y": 1 }]), this._AddPrivateCustomEase("cubicbezier", this.EaseCubicBezier), this._AddPrivateCustomEase("spline", this.EaseSpline));
    }
    static _AddPredifinedEase(a3, s, t2 = false) {
      if ("function" == typeof s) e._AddEase(a3, s, "predefined");
      else {
        if (!C32.IsArray(s)) throw new Error("unexpected arguments");
        if (self.BuiltInTransition) {
          const i = C32.New(self.BuiltInTransition, a3, t2);
          i.SetFromJson(s), e._AddEase(a3, (e2, a4, s2, t3) => i.Interpolate(e2, a4, s2, t3), "predefined"), BUILT_IN_TRANSITION_MAP.set(a3, i);
        } else {
          const i = C32.New(C32.Transition, [a3, s.map((e2) => [e2["x"], e2["y"], e2["sax"], e2["say"], e2["eax"], e2["eay"], e2["se"], e2["ee"]])], false);
          i.MakeLinear(t2), e._AddEase(a3, (e2, a4, s2, t3) => i.Interpolate(e2, a4, s2, t3), "predefined");
        }
      }
    }
    static _AddPrivateCustomEase(a3, s) {
      e._AddEase(a3, s, "private");
    }
    static AddCustomEase(a3, s, t2, i) {
      this._CreateEaseMap(), e._AddEase(a3, s, "custom", t2, i);
    }
    static RemoveCustomEase(e2, a3) {
      if (this.IsNamePredefined(e2)) return;
      if ([...PRIVATE_EASE_MAP.keys()].includes(e2)) return;
      const s = CUSTOM_EASE_EDITOR_MAP.get(a3);
      s && s.delete(e2);
      const t2 = CUSTOM_EASE_DATA_EDITOR_MAP.get(a3);
      t2 && t2.delete(e2);
    }
    static _AddEase(e2, a3, s, t2, i) {
      switch (s) {
        case "predefined":
          EASE_MAP.set(e2, a3), PREDEFINED_EASE_MAP.set(e2, a3);
          break;
        case "custom":
          if (t2) {
            CUSTOM_EASE_EDITOR_MAP.has(t2) || CUSTOM_EASE_EDITOR_MAP.set(t2, /* @__PURE__ */ new Map()), CUSTOM_EASE_DATA_EDITOR_MAP.has(t2) || CUSTOM_EASE_DATA_EDITOR_MAP.set(t2, /* @__PURE__ */ new Map());
            CUSTOM_EASE_EDITOR_MAP.get(t2).set(e2, a3);
            CUSTOM_EASE_DATA_EDITOR_MAP.get(t2).set(e2, i);
          } else CUSTOM_EASE_RUNTIME_MAP.set(e2, a3), CUSTOM_EASE_DATA_RUNTIME_MAP.set(e2, i);
          break;
        case "private":
          EASE_MAP.set(e2, a3), PRIVATE_EASE_MAP.set(e2, a3);
          break;
        default:
          throw new Error("unexpected ease mode");
      }
    }
    static NoEase(e2, a3, s, t2) {
      return 0 === t2 ? a3 : s * e2 / t2 + a3;
    }
    static EaseCubicBezier(e2, a3, s, t2, i) {
      return a3 + 3 * e2 * (s - a3) + 3 * e2 ** 2 * (a3 + t2 - 2 * s) + e2 ** 3 * (i - a3 + 3 * s - 3 * t2);
    }
    static EaseSpline(e2, s, t2, i, x2, y2, n, E2, _2, r2) {
      if (i === x2 && y2 === n) return e2;
      const u2 = get_t_for_x(e2, s, i, y2, E2, r2), d2 = a2(t2, x2, n, _2), A = b2(t2, x2, n, _2), o2 = c2(t2, x2, n, _2);
      return calc_bezier(u2, d2, A, o2);
    }
    static GetBezierSamples(e2, s, t2, i) {
      const x2 = [], y2 = a2(e2, s, t2, i), n = b2(e2, s, t2, i), E2 = c2(e2, s, t2, i);
      for (let e3 = 0; e3 < SAMPLE_COUNT; ++e3) {
        const a3 = calc_bezier(e3 * SAMPLE_STEP, y2, n, E2);
        x2.push(a3);
      }
      return x2;
    }
  };
  const SAMPLE_COUNT = 11, SAMPLE_STEP = 1 / (SAMPLE_COUNT - 1), NEWTON_RAPHSON_ITERATIONS = 4, NEWTON_RAPHSON_MIN_SLOPE = 0.01, SUBDIVISION_PRECISION = 1e-7, SUBDIVISION_MAX_ITERATIONS = 10, a2 = (e, a3, s, t2) => t2 - 3 * s + 3 * a3 - e, b2 = (e, a3, s, t2) => 3 * s - 6 * a3 + 3 * e, c2 = (e, a3, s, t2) => 3 * (a3 - e), calc_bezier = (e, a3, s, t2) => ((a3 * e + s) * e + t2) * e, get_slope = (e, a3, s, t2) => 3 * a3 * e * e + 2 * s * e + t2, get_t_for_x = (e, s, t2, i, x2, y2) => {
    if (1 == e) return 1;
    let n = 0, E2 = 1, _2 = y2[E2], r2 = SAMPLE_COUNT - 1;
    y2[SAMPLE_COUNT - 1];
    for (; E2 != r2 && _2 <= e; ) E2++, _2 = y2[E2], n += SAMPLE_STEP;
    E2--, _2 = y2[E2];
    let u2 = n + (e - _2) / (y2[E2 + 1] - _2) * SAMPLE_STEP;
    const d2 = a2(s, t2, i, x2), A = b2(s, t2, i, x2), o2 = c2(s, t2, i, x2), M2 = get_slope(u2, d2, A, o2);
    if (0 === M2) return u2;
    if (M2 >= 0.01) {
      for (let a3 = 0; a3 < 4; ++a3) {
        u2 -= (calc_bezier(u2, d2, A, o2) - e) / get_slope(u2, d2, A, o2);
      }
      return u2;
    }
    {
      let a3, s2, t3 = n, i2 = n + SAMPLE_STEP, x3 = 0;
      do {
        u2 = t3 + (i2 - t3) / 2;
        let y3 = calc_bezier(u2, d2, A, o2) - e;
        y3 > 0 ? i2 = u2 : t3 = u2, a3 = Math.abs(y3) > 1e-7, s2 = ++x3 < 10;
      } while (a3 && s2);
      return u2;
    }
  };
}
{
  let RequireStringOrNumber = function(t2) {
    C32.IsString(t2);
  };
  RequireStringOrNumber2 = RequireStringOrNumber;
  const C32 = self.C3;
  C32.ProbabilityTable = class {
    constructor(t2) {
      this._items = [], this._name = t2 || "", this._totalWeight = 0;
    }
    Release() {
      this.Clear(), this._items = null;
    }
    GetName() {
      return this._name;
    }
    Clear() {
      C32.clear2DArray(this._items), this._totalWeight = 0;
    }
    GetTotalWeight() {
      return this._totalWeight;
    }
    Sample(t2 = Math.random() * this.GetTotalWeight()) {
      let e = 0;
      for (const [i, s] of this._items) if (e += i, t2 < e) return s;
      return 0;
    }
    HasItems() {
      return !!this._items.length;
    }
    AddItem(t2, e) {
      RequireStringOrNumber(e), this._totalWeight += t2, this._items.push([t2, e]);
    }
    RemoveItem(t2, e) {
      RequireStringOrNumber(e);
      const i = 0 === t2;
      for (let s = 0; s < this._items.length; s++) {
        const r2 = this._items[s], h2 = i || r2[0] === t2, n = r2[1] === e;
        if (h2 && n) {
          this._items.splice(s, 1), this._totalWeight -= r2[0];
          break;
        }
      }
    }
    asJSON() {
      return JSON.stringify(this._items);
    }
    static fromJSON(t2, e) {
      const i = new C32.ProbabilityTable(e), s = JSON.parse(t2);
      for (const t3 of s) {
        const e2 = t3[0], s2 = t3[1];
        i.AddItem(e2, s2);
      }
      return i;
    }
  };
}
var RequireStringOrNumber2;
{
  const C32 = self.C3;
  let nextId = 0;
  C32.ScreenReaderText = class {
    constructor(t2, e) {
      this._runtime = t2, this._text = e, this._id = nextId++, this._runtime.PostComponentMessageToDOM("runtime", "screen-reader-text", { "type": "create", "id": this._id, "text": this._text });
    }
    Release() {
      this._runtime.PostComponentMessageToDOM("runtime", "screen-reader-text", { "type": "release", "id": this._id }), this._runtime = null, this._text = "", this._id = -1;
    }
    SetText(t2) {
      this._text !== t2 && (this._text = t2, this._runtime.PostComponentMessageToDOM("runtime", "screen-reader-text", { "type": "update", "id": this._id, "text": this._text }));
    }
  };
}
{
  const C32 = self.C3;
  C32.Event = class {
    constructor(t2, e) {
      this.type = t2, this.cancelable = !!e, this.defaultPrevented = false, this.propagationStopped = false, this.isAsync = false;
    }
    preventDefault() {
      if (!this.cancelable) throw new Error(`event '${this.type}' is not cancelable`);
      this.defaultPrevented = true;
    }
    stopPropagation() {
      if (!this.cancelable) throw new Error(`event '${this.type}' cannot be stopped`);
      if (this.isAsync) throw new Error(`cannot stop async event '${this.type}' propagation`);
      this.propagationStopped = true;
    }
  };
}
{
  const C32 = self.C3, assert = self.assert;
  C32.Event.Handler = class extends C32.DefendedBase {
    constructor(e) {
      super(), this._type = e, this._captureListeners = [], this._captureListenersSet = /* @__PURE__ */ new Set(), this._listeners = [], this._listenersSet = /* @__PURE__ */ new Set(), this._fireDepth = 0, this._queueModifyListeners = [];
    }
    Release() {
      this._fireDepth > 0 || (C32.clearArray(this._captureListeners), this._captureListenersSet.clear(), C32.clearArray(this._listeners), this._listenersSet.clear(), C32.clearArray(this._queueModifyListeners), C32.Release(this));
    }
    _AddListener(e, t2) {
      if (this._IsFiring()) this._queueModifyListeners.push({ op: "add", func: e, capture: t2 });
      else if (t2) {
        if (this._captureListenersSet.has(e)) return;
        this._captureListeners.push(e), this._captureListenersSet.add(e);
      } else {
        if (this._listenersSet.has(e)) return;
        this._listeners.push(e), this._listenersSet.add(e);
      }
    }
    _RemoveListener(e, t2) {
      this._IsFiring() ? this._queueModifyListeners.push({ op: "remove", func: e, capture: t2 }) : t2 ? this._captureListenersSet.has(e) && (this._captureListenersSet.delete(e), C32.arrayFindRemove(this._captureListeners, e)) : this._listenersSet.has(e) && (this._listenersSet.delete(e), C32.arrayFindRemove(this._listeners, e));
    }
    _IsEmpty() {
      return !this._captureListeners.length && !this._listeners.length;
    }
    _IsFiring() {
      return this._fireDepth > 0;
    }
    _ProcessQueuedListeners() {
      const e = /* @__PURE__ */ new Set(), t2 = /* @__PURE__ */ new Set();
      for (const s of this._queueModifyListeners) if ("add" === s.op) this._AddListener(s.func, s.capture), s.capture ? t2.delete(s.func) : e.delete(s.func);
      else {
        if ("remove" !== s.op) throw new Error("invalid op");
        s.capture ? (this._captureListenersSet.delete(s.func), t2.add(s.func)) : (this._listenersSet.delete(s.func), e.add(s.func));
      }
      C32.arrayRemoveAllInSet(this._listeners, e), C32.arrayRemoveAllInSet(this._captureListeners, t2), C32.clearArray(this._queueModifyListeners);
    }
    _FireCancellable(e) {
      this._IncreaseFireDepth();
      let t2 = false;
      for (let s = 0, r2 = this._captureListeners.length; s < r2; ++s) if (this._captureListeners[s](e), e.propagationStopped) {
        t2 = true;
        break;
      }
      if (!t2) for (let t3 = 0, s = this._listeners.length; t3 < s && (this._listeners[t3](e), !e.propagationStopped); ++t3) ;
      return this._DecreaseFireDepth(), !e.defaultPrevented;
    }
    _FireNonCancellable(e) {
      this._IncreaseFireDepth();
      for (let t2 = 0, s = this._captureListeners.length; t2 < s; ++t2) this._captureListeners[t2](e);
      for (let t2 = 0, s = this._listeners.length; t2 < s; ++t2) this._listeners[t2](e);
      return this._DecreaseFireDepth(), true;
    }
    _IncreaseFireDepth() {
      this._fireDepth++;
    }
    _DecreaseFireDepth() {
      this._fireDepth--, 0 === this._fireDepth && this._queueModifyListeners.length > 0 && this._ProcessQueuedListeners();
    }
    SetDelayRemoveEventsEnabled(e) {
      e ? this._IncreaseFireDepth() : this._DecreaseFireDepth();
    }
    _FireAsync(e) {
      let t2 = [];
      for (let s = 0, r2 = this._captureListeners.length; s < r2; ++s) {
        let r3 = this._captureListeners[s];
        t2.push(C32.Asyncify(() => r3(e)));
      }
      for (let s = 0, r2 = this._listeners.length; s < r2; ++s) {
        let r3 = this._listeners[s];
        t2.push(C32.Asyncify(() => r3(e)));
      }
      return Promise.all(t2).then(() => !e.defaultPrevented);
    }
    _FireAndWait_AsyncOptional(e) {
      const t2 = [];
      this._IncreaseFireDepth();
      for (let s = 0, r2 = this._captureListeners.length; s < r2; ++s) {
        const r3 = this._captureListeners[s](e);
        r3 instanceof Promise && t2.push(r3);
      }
      for (let s = 0, r2 = this._listeners.length; s < r2; ++s) {
        const r3 = this._listeners[s](e);
        r3 instanceof Promise && t2.push(r3);
      }
      return this._DecreaseFireDepth(), t2.length ? Promise.all(t2).then(() => !e.defaultPrevented) : !e.defaultPrevented;
    }
    async _FireAndWaitAsync(e) {
      return await this._FireAndWait_AsyncOptional(e);
    }
    async _FireAndWaitAsyncSequential(e) {
      this._IncreaseFireDepth();
      for (let t2 = 0, s = this._captureListeners.length; t2 < s; ++t2) {
        const s2 = this._captureListeners[t2](e);
        s2 instanceof Promise && await s2;
      }
      for (let t2 = 0, s = this._listeners.length; t2 < s; ++t2) {
        const s2 = this._listeners[t2](e);
        s2 instanceof Promise && await s2;
      }
      return this._DecreaseFireDepth(), !e.defaultPrevented;
    }
    *_FireAsGenerator(e) {
      this._IncreaseFireDepth();
      for (let t2 = 0, s = this._captureListeners.length; t2 < s; ++t2) {
        const s2 = this._captureListeners[t2](e);
        C32.IsIterator(s2) && (yield* s2);
      }
      for (let t2 = 0, s = this._listeners.length; t2 < s; ++t2) {
        const s2 = this._listeners[t2](e);
        C32.IsIterator(s2) && (yield* s2);
      }
      this._DecreaseFireDepth();
    }
  };
}
{
  const C32 = self.C3;
  C32.Event.Dispatcher = class extends C32.DefendedBase {
    constructor() {
      super(), this._eventHandlers = /* @__PURE__ */ new Map(), this._dispatcherWasReleased = false;
    }
    Release() {
      if (this._dispatcherWasReleased) throw new Error("already released");
      this.ClearEvents(), this._dispatcherWasReleased = true, C32.Release(this);
    }
    WasReleased() {
      return this._dispatcherWasReleased;
    }
    ClearEvents() {
      if (this._eventHandlers) {
        for (let e of this._eventHandlers.values()) e.Release();
        this._eventHandlers.clear();
      }
    }
    _GetHandlerByType(e, t2) {
      let n = this._eventHandlers.get(e);
      return n || (t2 ? (n = C32.New(C32.Event.Handler, e), this._eventHandlers.set(e, n), n) : null);
    }
    HasAnyHandlerFor(e) {
      return this._eventHandlers.has(e);
    }
    addEventListener(e, t2, n) {
      this._GetHandlerByType(e, true)._AddListener(t2, !!n);
    }
    removeEventListener(e, t2, n) {
      let s = this._GetHandlerByType(e, false);
      s && (s._RemoveListener(t2, !!n), s._IsEmpty() && this._eventHandlers.delete(e));
    }
    dispatchEvent(e) {
      const t2 = this._GetHandlerByType(e.type, false);
      return !t2 || (e.cancelable ? t2._FireCancellable(e) : t2._FireNonCancellable(e));
    }
    dispatchEventAsync(e) {
      const t2 = this._GetHandlerByType(e.type, false);
      return t2 ? (e.isAsync = true, t2._FireAsync(e)) : Promise.resolve(true);
    }
    async dispatchEventAndClearAsync(e) {
      const t2 = this._GetHandlerByType(e.type, false);
      if (!t2) return true;
      this._eventHandlers.delete(e.type), e.isAsync = true;
      const n = await t2._FireAsync(e);
      return t2.Release(), n;
    }
    async dispatchEventAndWaitAsync(e) {
      const t2 = this._GetHandlerByType(e.type, false);
      return !t2 || await t2._FireAndWaitAsync(e);
    }
    dispatchEventAndWait_AsyncOptional(e) {
      const t2 = this._GetHandlerByType(e.type, false);
      return !t2 || t2._FireAndWait_AsyncOptional(e);
    }
    async dispatchEventAndWaitAsyncSequential(e) {
      const t2 = this._GetHandlerByType(e.type, false);
      return !t2 || await t2._FireAndWaitAsyncSequential(e);
    }
    dispatchGeneratorEvent(e) {
      const t2 = this._GetHandlerByType(e.type, false);
      if (!t2) return null;
      if (e.cancelable) throw new Error("not supported");
      return t2._FireAsGenerator(e);
    }
    SetDelayRemoveEventsEnabled(e) {
      for (const t2 of this._eventHandlers.values()) t2.SetDelayRemoveEventsEnabled(e);
    }
  };
}
{
  let SetNewCallback = function(e) {
    callbackId = SUPPORTS_RIC && 0 === highThroughputMode ? requestIdleCallback(DoAsyncifiedWork, { timeout: 35 }) : setTimeout(DoAsyncifiedWork, highThroughputMode > 0 ? 1 : e);
  }, DoAsyncifiedWork = function(e) {
    if (callbackId = -1, !workQueue.length) return;
    let o2 = performance.now(), i = o2, t2 = 0, n = 0;
    do {
      DoNextAsyncifiedJob(workQueue.shift()), i = performance.now(), ++t2, n = (i - o2) / t2 * 1.1;
    } while (workQueue.length && (SUPPORTS_RIC && 0 === highThroughputMode && void 0 !== e ? n < e["timeRemaining"]() : i - o2 + n < 12));
    if (-1 === callbackId && workQueue.length) {
      let e2 = i - o2;
      SetNewCallback(Math.max(16 - e2, 4));
    }
  }, DoNextAsyncifiedJob = function(e) {
    let o2;
    try {
      o2 = e.func();
    } catch (o3) {
      return void e.reject(o3);
    }
    e.resolve(o2);
  };
  SetNewCallback2 = SetNewCallback, DoAsyncifiedWork2 = DoAsyncifiedWork, DoNextAsyncifiedJob2 = DoNextAsyncifiedJob;
  const C32 = self.C3, SETTIMEOUT_WORK_DURATION = 12, SETTIMEOUT_INTERVAL = 16, IDLECALLBACK_TIMEOUT = 35, SUPPORTS_RIC = "undefined" != typeof requestIdleCallback;
  let workQueue = [], callbackId = -1, highThroughputMode = 0;
  let asyncifyDisabled = C32.QueryString.Has("disable-asyncify");
  asyncifyDisabled && console.warn("[Asyncify] Asyncify has been disabled due to disable-asyncify in the query string. Some work will now be done synchronously."), C32.Asyncify = function(e) {
    let o2 = null;
    return C32.isDebug && (o2 = C32.GetCallStack()), new Promise((i, t2) => {
      workQueue.push({ func: e, resolve: i, reject: t2, stack: o2 }), asyncifyDisabled ? DoNextAsyncifiedJob(workQueue.pop()) : -1 === callbackId && SetNewCallback(16);
    });
  }, C32.Asyncify.SetHighThroughputMode = function(e) {
    if (e) ++highThroughputMode;
    else if (--highThroughputMode, highThroughputMode < 0) throw new Error("already turned off high throughput mode");
  };
}
var SetNewCallback2;
var DoAsyncifiedWork2;
var DoNextAsyncifiedJob2;
{
  let ClearTimeCache = function() {
    cachedNowTime = -1;
  }, CheckActiveIdleTimeouts = function() {
    timerId = -1, nextDeadline = -1;
    let e = Date.now();
    for (let t2 of activeIdleTimeouts) if (t2._CheckTimeout(e)) {
      let e2 = t2._GetDeadline();
      (-1 === nextDeadline || e2 < nextDeadline) && (nextDeadline = e2);
    } else activeIdleTimeouts.delete(t2);
    if (-1 !== nextDeadline) {
      let t2 = Math.max(nextDeadline - e + 100, 1e3);
      timerId = self.setTimeout(CheckActiveIdleTimeouts, t2);
    }
  };
  ClearTimeCache2 = ClearTimeCache, CheckActiveIdleTimeouts2 = CheckActiveIdleTimeouts;
  const C32 = self.C3, IDLE_CHECK_MIN_INTERVAL = 1e3, IDLE_CHECK_TIMER_OVERSHOOT = 100;
  let cachedNowTime = -1;
  C32.FastGetDateNow = function() {
    return -1 === cachedNowTime && (cachedNowTime = Date.now(), self.setTimeout(ClearTimeCache, 16)), cachedNowTime;
  };
  let timerId = -1, nextDeadline = -1, activeIdleTimeouts = /* @__PURE__ */ new Set();
  C32.IdleTimeout = class {
    constructor(e, t2) {
      this._callback = e, this._timeout = 1e3 * t2, this._deadline = 0, this._isActive = false;
    }
    Reset() {
      let e = C32.FastGetDateNow();
      this._deadline = e + this._timeout, this._isActive || (activeIdleTimeouts.add(this), this._isActive = true), -1 === timerId ? (nextDeadline = this._deadline, timerId = self.setTimeout(CheckActiveIdleTimeouts, this._timeout + 100)) : this._deadline < nextDeadline && nextDeadline > e + 1e3 && (self.clearTimeout(timerId), nextDeadline = this._deadline, timerId = self.setTimeout(CheckActiveIdleTimeouts, this._timeout + 100));
    }
    _CheckTimeout(e) {
      return !(e >= this._deadline) || (this._callback() ? (this._deadline = e + this._timeout, true) : (this._isActive = false, false));
    }
    _GetDeadline() {
      return this._deadline;
    }
    Cancel() {
      this._isActive && (activeIdleTimeouts.delete(this), this._isActive = false, 0 === activeIdleTimeouts.size && -1 !== timerId && (self.clearTimeout(timerId), timerId = -1, nextDeadline = -1));
    }
    Release() {
      this.Cancel(), this._callback = null;
    }
  };
}
var ClearTimeCache2;
var CheckActiveIdleTimeouts2;
{
  const C32 = self.C3;
  C32.Disposable = class s {
    constructor(s2) {
      this._disposed = false, this._disposeAction = s2;
    }
    Dispose() {
      this._disposed || (this._disposed = true, this._disposeAction && (this._disposeAction(), this._disposeAction = null));
    }
    IsDisposed() {
      return this._disposed;
    }
    Release() {
      this.Dispose();
    }
    static Release(e) {
      return new s(() => e.Release());
    }
    static From(s2, e, i, o2, t2) {
      if ("string" != typeof e && !Array.isArray(e)) throw new TypeError("expected string or array");
      if (null == o2) o2 = false;
      else if ("boolean" != typeof o2 && "object" != typeof o2) throw new TypeError("invalid event listener options");
      if (t2 && (i = i.bind(t2)), Array.isArray(e) || e.includes(" ")) {
        "string" == typeof e && (e = e.split(" "));
        const t3 = new C32.CompositeDisposable();
        for (const r2 of e) s2.addEventListener(r2, i, o2), t3.Add(C32.New(C32.Disposable, () => s2.removeEventListener(r2, i, o2)));
        return t3;
      }
      return s2.addEventListener(e, i, o2), C32.New(C32.Disposable, () => s2.removeEventListener(e, i, o2));
    }
  }, C32.StubDisposable = class extends C32.Disposable {
    SetAction(s) {
      this._disposeAction = s;
    }
  }, C32.CompositeDisposable = class extends C32.Disposable {
    constructor(...s) {
      super(), this._disposables = /* @__PURE__ */ new Set();
      for (let e of s) this.Add(e);
    }
    Add(...s) {
      if (this._disposed) throw new Error("already disposed");
      for (let e of s) this._disposables.add(e);
    }
    Remove(s) {
      if (this._disposed) throw new Error("already disposed");
      this._disposables.delete(s);
    }
    RemoveAll() {
      if (this._disposed) throw new Error("already disposed");
      if (this._disposables) {
        for (let s of this._disposables) s.Dispose();
        this._disposables.clear();
      }
    }
    IsDisposed() {
      return this._disposed;
    }
    Dispose() {
      if (this._disposed) throw new Error("already disposed");
      this._disposed = true;
      for (let s of this._disposables) s.Dispose();
      this._disposables.clear(), this._disposables = null;
    }
    Release() {
      this.Dispose();
    }
  };
}
{
  const C32 = self.C3;
  C32.KahanSum = class extends C32.DefendedBase {
    constructor() {
      super(), this._c = 0, this._y = 0, this._t = 0, this._sum = 0;
    }
    Add(s) {
      s = +s, this._y = s - this._c, this._t = this._sum + this._y, this._c = this._t - this._sum - this._y, this._sum = this._t;
    }
    Subtract(s) {
      this._sum -= +s;
    }
    Get() {
      return this._sum;
    }
    Reset() {
      this._c = 0, this._y = 0, this._t = 0, this._sum = 0;
    }
    Set(s) {
      this._c = 0, this._y = 0, this._t = 0, this._sum = +s;
    }
    Copy(s) {
      this._c = s._c, this._y = s._y, this._t = s._t, this._sum = s._sum;
    }
    Release() {
    }
  };
}
{
  const C32 = self.C3, js_cols = {}, RED = true, BLACK = false;
  js_cols.RBnode = function(t2) {
    this.tree = t2, this.right = this.tree.sentinel, this.left = this.tree.sentinel, this.parent = null, this.color = false, this.key = null;
  }, js_cols.RedBlackSet = function(t2) {
    this.size = 0, this.sentinel = new js_cols.RBnode(this), this.sentinel.color = false, this.root = this.sentinel, this.root.parent = this.sentinel, this.compare = t2 || this.default_compare;
  }, js_cols.RedBlackSet.prototype.default_compare = function(t2, e) {
    return t2 < e ? -1 : e < t2 ? 1 : 0;
  }, js_cols.RedBlackSet.prototype.clone = function() {
    var t2 = new js_cols.RedBlackSet(this.compare);
    return t2.insertAll(this), t2;
  }, js_cols.RedBlackSet.prototype.clear = function() {
    this.size = 0, this.sentinel = new js_cols.RBnode(this), this.sentinel.color = false, this.root = this.sentinel, this.root.parent = this.sentinel;
  }, js_cols.RedBlackSet.prototype.leftRotate = function(t2) {
    var e = t2.right;
    t2.right = e.left, e.left != this.sentinel && (e.left.parent = t2), e.parent = t2.parent, t2.parent == this.sentinel ? this.root = e : t2 == t2.parent.left ? t2.parent.left = e : t2.parent.right = e, e.left = t2, t2.parent = e;
  }, js_cols.RedBlackSet.prototype.rightRotate = function(t2) {
    var e = t2.left;
    t2.left = e.right, e.right != this.sentinel && (e.right.parent = t2), e.parent = t2.parent, t2.parent == this.sentinel ? this.root = e : t2 == t2.parent.right ? t2.parent.right = e : t2.parent.left = e, e.right = t2, t2.parent = e;
  }, js_cols.RedBlackSet.prototype.insert = function(t2) {
    if (this.contains(t2)) {
      this.get_(t2).key = t2;
    } else {
      var e = new js_cols.RBnode(this);
      e.key = t2;
      for (var s = this.sentinel, r2 = this.root; r2 != this.sentinel; ) s = r2, r2 = this.compare(e.key, r2.key) < 0 ? r2.left : r2.right;
      e.parent = s, s == this.sentinel ? this.root = e : this.compare(e.key, s.key) < 0 ? s.left = e : s.right = e, e.left = this.sentinel, e.right = this.sentinel, e.color = RED, this.insertFixup(e), this.size++;
    }
  }, js_cols.RedBlackSet.prototype.insertFixup = function(t2) {
    for (; t2 != this.sentinel && t2 != this.root && t2.parent.color == RED; ) {
      var e;
      if (t2.parent == t2.parent.parent.left) (e = t2.parent.parent.right).color == RED ? (t2.parent.color = false, e.color = false, t2.parent.parent.color = RED, t2 = t2.parent.parent) : (t2 == t2.parent.right && (t2 = t2.parent, this.leftRotate(t2)), t2.parent.color = false, t2.parent.parent.color = RED, t2.parent.parent != this.sentinel && this.rightRotate(t2.parent.parent));
      else (e = t2.parent.parent.left).color == RED ? (t2.parent.color = false, e.color = false, t2.parent.parent.color = RED, t2 = t2.parent.parent) : (t2 == t2.parent.left && (t2 = t2.parent, this.rightRotate(t2)), t2.parent.color = false, t2.parent.parent.color = RED, t2.parent.parent != this.sentinel && this.leftRotate(t2.parent.parent));
    }
    this.root.color = false;
  }, js_cols.RedBlackSet.prototype.delete_ = function(t2) {
    var e, s;
    (s = (e = t2.left == this.sentinel || t2.right == this.sentinel ? t2 : this.successor_(t2)).left != this.sentinel ? e.left : e.right).parent = e.parent, e.parent == this.sentinel ? this.root = s : e == e.parent.left ? e.parent.left = s : e.parent.right = s, e != t2 && (t2.key = e.key), false == e.color && this.deleteFixup(s), this.size--;
  }, js_cols.RedBlackSet.prototype.deleteFixup = function(t2) {
    for (; t2 != this.root && false == t2.color; ) {
      var e;
      if (t2 == t2.parent.left) (e = t2.parent.right).color == RED && (e.color = false, t2.parent.color = RED, this.leftRotate(t2.parent), e = t2.parent.right), false == e.left.color && false == e.right.color ? (e.color = RED, t2 = t2.parent) : (false == e.right.color && (e.left.color = false, e.color = RED, this.rightRotate(e), e = t2.parent.right), e.color = t2.parent.color, t2.parent.color = false, e.right.color = false, this.leftRotate(t2.parent), t2 = this.root);
      else (e = t2.parent.left).color == RED && (e.color = false, t2.parent.color = RED, this.rightRotate(t2.parent), e = t2.parent.left), false == e.right.color && false == e.left.color ? (e.color = RED, t2 = t2.parent) : (false == e.left.color && (e.right.color = false, e.color = RED, this.leftRotate(e), e = t2.parent.left), e.color = t2.parent.color, t2.parent.color = false, e.left.color = false, this.rightRotate(t2.parent), t2 = this.root);
    }
    t2.color = false;
  }, js_cols.RedBlackSet.prototype.remove = function(t2) {
    var e = this.get_(t2);
    if (e != this.sentinel) {
      var s = e.key;
      return this.delete_(e), s;
    }
    return null;
  }, js_cols.RedBlackSet.prototype.removeSwapped = function(t2, e) {
    this.remove(e);
  }, js_cols.RedBlackSet.prototype.min = function(t2) {
    for (; t2.left != this.sentinel; ) t2 = t2.left;
    return t2;
  }, js_cols.RedBlackSet.prototype.max = function(t2) {
    for (; t2.right != this.sentinel; ) t2 = t2.right;
    return t2;
  }, js_cols.RedBlackSet.prototype.successor_ = function(t2) {
    if (t2.right != this.sentinel) return this.min(t2.right);
    for (var e = t2.parent; e != this.sentinel && t2 == e.right; ) t2 = e, e = e.parent;
    return e;
  }, js_cols.RedBlackSet.prototype.predeccessor_ = function(t2) {
    if (t2.left != this.sentinel) return this.max(t2.left);
    for (var e = t2.parent; e != this.sentinel && t2 == e.left; ) t2 = e, e = e.parent;
    return e;
  }, js_cols.RedBlackSet.prototype.successor = function(t2) {
    if (this.size > 0) {
      var e = this.get_(t2);
      if (e == this.sentinel) return null;
      if (e.right != this.sentinel) return this.min(e.right).key;
      for (var s = e.parent; s != this.sentinel && e == s.right; ) e = s, s = s.parent;
      return s != this.sentinel ? s.key : null;
    }
    return null;
  }, js_cols.RedBlackSet.prototype.predecessor = function(t2) {
    if (this.size > 0) {
      var e = this.get_(t2);
      if (e == this.sentinel) return null;
      if (e.left != this.sentinel) return this.max(e.left).key;
      for (var s = e.parent; s != this.sentinel && e == s.left; ) e = s, s = s.parent;
      return s != this.sentinel ? s.key : null;
    }
    return null;
  }, js_cols.RedBlackSet.prototype.getMin = function() {
    return this.min(this.root).key;
  }, js_cols.RedBlackSet.prototype.getMax = function() {
    return this.max(this.root).key;
  }, js_cols.RedBlackSet.prototype.get_ = function(t2) {
    for (var e = this.root; e != this.sentinel && 0 != this.compare(e.key, t2); ) e = this.compare(t2, e.key) < 0 ? e.left : e.right;
    return e;
  }, js_cols.RedBlackSet.prototype.contains = function(t2) {
    return null != this.get_(t2).key;
  }, js_cols.RedBlackSet.prototype.getValues = function() {
    var t2 = [];
    return this.forEach(function(e) {
      t2.push(e);
    }), t2;
  }, js_cols.RedBlackSet.prototype.insertAll = function(t2) {
    if ("array" == js_cols.typeOf(t2)) for (var e = 0; e < t2.length; e++) this.insert(t2[e]);
    else if ("function" == js_cols.typeOf(t2.forEach)) t2.forEach(this.insert, this);
    else if ("function" == js_cols.typeOf(t2.getValues)) {
      var s = t2.getValues();
      for (e = 0; e < s.length; e++) this.insert(s[e]);
    } else if ("object" == js_cols.typeOf(t2)) for (var r2 in t2) this.insert(t2[r2]);
  }, js_cols.RedBlackSet.prototype.removeAll = function(t2) {
    if ("array" == js_cols.typeOf(t2)) for (var e = 0; e < t2.length; e++) this.remove(t2[e]);
    else if ("function" == js_cols.typeOf(t2.forEach)) t2.forEach(this.removeSwapped, this);
    else if ("function" == js_cols.typeOf(t2.getValues)) {
      var s = t2.getValues();
      for (e = 0; e < s.length; e++) this.remove(s[e]);
    } else if ("object" == js_cols.typeOf(t2)) for (var r2 in t2) this.remove(t2[r2]);
  }, js_cols.RedBlackSet.prototype.containsAll = function(t2) {
    if ("array" == js_cols.typeOf(t2)) {
      for (var e = 0; e < t2.length; e++) if (!this.contains(t2[e])) return false;
      return true;
    }
    if ("function" == js_cols.typeOf(t2.forEach)) return t2.every(this.contains, this);
    if ("function" == js_cols.typeOf(t2.getValues)) {
      var s = t2.getValues();
      for (e = 0; e < s.length; e++) if (!this.contains(s[e])) return false;
      return true;
    }
    if ("object" == js_cols.typeOf(t2)) {
      for (var r2 in t2) if (!this.contains(t2[r2])) return false;
      return true;
    }
  }, js_cols.RedBlackSet.prototype.range = function(t2, e) {
    var s = [];
    return this.traverseFromTo(function(t3) {
      s.push(t3);
    }, t2, e), s;
  }, js_cols.RedBlackSet.prototype.traverse = function(t2, e) {
    if (!this.isEmpty()) for (var s = this.min(this.root); s != this.sentinel; ) {
      if (t2.call(e, s.key, this)) return;
      s = this.successor_(s);
    }
  }, js_cols.RedBlackSet.prototype.traverseFrom = function(t2, e, s) {
    if (!this.isEmpty()) for (var r2 = this.get_(e); r2 != this.sentinel; ) {
      if (t2.call(s, r2.key, this)) return;
      r2 = this.successor_(r2);
    }
  }, js_cols.RedBlackSet.prototype.traverseTo = function(t2, e, s) {
    if (!this.isEmpty()) for (var r2 = this.min(this.root), i = this.get_(e); r2 != i; ) {
      if (t2.call(s, r2.key, this)) return;
      r2 = this.successor_(r2);
    }
  }, js_cols.RedBlackSet.prototype.traverseFromTo = function(t2, e, s, r2) {
    if (!this.isEmpty()) for (var i = this.get_(e), o2 = this.get_(s); i != o2; ) {
      if (t2.call(r2, i.key, this)) return;
      i = this.successor_(i);
    }
  }, js_cols.RedBlackSet.prototype.traverseBackwards = function(t2, e) {
    if (!this.isEmpty()) for (var s = this.max(this.root); s != this.sentinel; ) {
      if (t2.call(e, s.key, this)) return;
      s = this.predeccessor_(s);
    }
  }, js_cols.RedBlackSet.prototype.forEach = function(t2, e) {
    if (!this.isEmpty()) for (var s = this.min(this.root); s != this.sentinel; s = this.successor_(s)) t2.call(e, s.key, s.key, this);
  }, js_cols.RedBlackSet.prototype.some = function(t2, e) {
    if (this.isEmpty()) return false;
    for (var s = this.min(this.root); s != this.sentinel; s = this.successor_(s)) if (t2.call(e, s.key, s.key, this)) return true;
    return false;
  }, js_cols.RedBlackSet.prototype.every = function(t2, e) {
    if (this.isEmpty()) return false;
    for (var s = this.min(this.root); s != this.sentinel; s = this.successor_(s)) if (!t2.call(e, s.key, s.key, this)) return false;
    return true;
  }, js_cols.RedBlackSet.prototype.map = function(t2, e) {
    var s = [];
    if (this.isEmpty()) return s;
    for (var r2 = this.min(this.root); r2 != this.sentinel; r2 = this.successor_(r2)) s.push(t2.call(e, r2.key, r2.key, this));
    return s;
  }, js_cols.RedBlackSet.prototype.filter = function(t2, e) {
    var s = [];
    if (this.isEmpty()) return s;
    for (var r2 = this.min(this.root); r2 != this.sentinel; r2 = this.successor_(r2)) t2.call(e, r2.key, r2.key, this) && s.push(r2.key);
    return s;
  }, js_cols.RedBlackSet.prototype.getCount = function() {
    return this.size;
  }, js_cols.RedBlackSet.prototype.isEmpty = function() {
    return 0 == this.size;
  }, js_cols.RedBlackSet.prototype.isSubsetOf = function(t2) {
    var e = js_cols.getCount(t2);
    if (this.getCount() > e) return false;
    var s = 0;
    if (this.isEmpty()) return true;
    for (var r2 = this.min(this.root); r2 != this.sentinel; r2 = this.successor_(r2)) js_cols.contains.call(t2, t2, r2.key) && s++;
    return s == this.getCount();
  }, js_cols.RedBlackSet.prototype.intersection = function(t2) {
    var e = new js_cols.RedBlackSet(this.compare);
    if (this.isEmpty()) return e;
    for (var s = this.min(this.root); s != this.sentinel; s = this.successor_(s)) t2.contains.call(t2, s.key, s.key, this) && e.insert(s.key);
    return e;
  }, C32.RedBlackSet = class extends C32.DefendedBase {
    constructor(t2) {
      super(), this._rbSet = new js_cols.RedBlackSet(t2), this._enableQueue = false, this._queueInsert = /* @__PURE__ */ new Set(), this._queueRemove = /* @__PURE__ */ new Set();
    }
    Add(t2) {
      this._enableQueue ? this._rbSet.contains(t2) ? this._queueRemove.delete(t2) : this._queueInsert.add(t2) : this._rbSet.insert(t2);
    }
    Remove(t2) {
      this._enableQueue ? this._rbSet.contains(t2) ? this._queueRemove.add(t2) : this._queueInsert.delete(t2) : this._rbSet.remove(t2);
    }
    Has(t2) {
      return this._enableQueue ? !!this._queueInsert.has(t2) || !this._queueRemove.has(t2) && this._rbSet.contains(t2) : this._rbSet.contains(t2);
    }
    Clear() {
      this._rbSet.clear(), this._queueInsert.clear(), this._queueRemove.clear();
    }
    toArray() {
      if (this._enableQueue) throw new Error("cannot be used in queueing mode");
      return this._rbSet.getValues();
    }
    GetSize() {
      return this._rbSet.getCount() + this._queueInsert.size - this._queueRemove.size;
    }
    IsEmpty() {
      return 0 === this.GetSize();
    }
    Front() {
      if (this.IsEmpty()) throw new Error("empty set");
      if (this._enableQueue) throw new Error("cannot be used in queueing mode");
      const t2 = this._rbSet;
      return t2.min(t2.root).key;
    }
    Shift() {
      if (this.IsEmpty()) throw new Error("empty set");
      if (this._enableQueue) throw new Error("cannot be used in queueing mode");
      const t2 = this.Front();
      return this.Remove(t2), t2;
    }
    SetQueueingEnabled(t2) {
      if (t2 = !!t2, this._enableQueue !== t2 && (this._enableQueue = t2, !t2)) {
        for (const t3 of this._queueRemove) this._rbSet.remove(t3);
        this._queueRemove.clear();
        for (const t3 of this._queueInsert) this._rbSet.insert(t3);
        this._queueInsert.clear();
      }
    }
    ForEach(t2) {
      this._rbSet.forEach(t2);
    }
    *values() {
      if (this.IsEmpty()) return;
      const t2 = this._rbSet;
      for (let e = t2.min(t2.root); e != t2.sentinel; e = t2.successor_(e)) yield e.key;
    }
    [Symbol.iterator]() {
      return this.values();
    }
  };
}
{
  const C32 = self.C3;
  C32.PromiseThrottle = class {
    constructor(e = C32.hardwareConcurrency) {
      this._maxParallel = e, this._queue = [], this._activeCount = 0;
    }
    Add(e, t2) {
      return new Promise((r2, n) => {
        const s = { func: e, resolve: r2, reject: n, opts: t2 };
        t2?.signal && t2.signal.aborted ? n(new Error("abort")) : (t2?.signal && (s.onabort = () => {
          const e2 = this._queue.indexOf(s);
          -1 !== e2 && (this._queue.splice(e2, 1), n(new Error("abort")));
        }, t2.signal.addEventListener("abort", s.onabort)), this._queue.push(s), this._MaybeStartNext());
      });
    }
    _FindInQueue(e) {
      for (let t2 = 0, r2 = this._queue.length; t2 < r2; ++t2) if (this._queue[t2].func === e) return t2;
      return -1;
    }
    RemoveAndResolve(e, t2) {
      const r2 = this._FindInQueue(e);
      if (-1 === r2) throw new Error("cannot find promise to resolve");
      this._queue[r2].resolve(t2), this._queue.splice(r2, 1);
    }
    RemoveAndReject(e, t2) {
      const r2 = this._FindInQueue(e);
      if (-1 === r2) throw new Error("cannot find promise to reject");
      this._queue[r2].reject(t2), this._queue.splice(r2, 1);
    }
    async _MaybeStartNext() {
      if (!this._queue.length) return;
      if (this._activeCount >= this._maxParallel) return;
      this._activeCount++;
      const e = this._queue.shift();
      e.opts?.signal && e.onabort && e.opts.signal.removeEventListener("abort", e.onabort);
      try {
        const t2 = await e.func();
        e.resolve(t2);
      } catch (t2) {
        e.reject(t2);
      }
      this._activeCount--, this._MaybeStartNext();
    }
  };
}
{
  const C32 = self.C3;
  C32.RateLimiter = class {
    constructor(t2, e, i) {
      this._callback = t2, this._interval = e, this._intervalOnBattery = i || 2 * e, this._timerId = -1, this._lastCallTime = -1 / 0, this._timerCallFunc = () => this._OnTimer(), this._ignoreReset = false, this._canRunImmediate = false, this._callbackArguments = null;
    }
    SetCanRunImmediate(t2) {
      this._canRunImmediate = !!t2;
    }
    _GetInterval() {
      return void 0 !== C32.Battery && C32.Battery.IsOnBatteryPower() ? this._intervalOnBattery : this._interval;
    }
    Call(...t2) {
      if (-1 !== this._timerId) return;
      this._callbackArguments = t2;
      let e = C32.FastGetDateNow(), i = e - this._lastCallTime, l = this._GetInterval();
      i >= l && this._canRunImmediate ? (this._lastCallTime = e, this._RunCallback()) : this._timerId = self.setTimeout(this._timerCallFunc, Math.max(l - i, 4));
    }
    _RunCallback() {
      this._ignoreReset = true;
      const t2 = this._callbackArguments;
      this._callbackArguments = null, t2 ? this._callback(...t2) : this._callback(), this._ignoreReset = false;
    }
    Reset() {
      this._ignoreReset || (this._CancelTimer(), this._callbackArguments = null, this._lastCallTime = C32.FastGetDateNow());
    }
    _OnTimer() {
      this._timerId = -1, this._lastCallTime = C32.FastGetDateNow(), this._RunCallback();
    }
    _CancelTimer() {
      -1 !== this._timerId && (self.clearTimeout(this._timerId), this._timerId = -1);
    }
    Release() {
      this._CancelTimer(), this._callback = null, this._callbackArguments = null, this._timerCallFunc = null;
    }
  };
}
{
  const C32 = self.C3;
  C32.SVGRasterManager = class {
    constructor() {
      this._images = /* @__PURE__ */ new Map(), this._allowNpotSurfaces = false, this._getBaseSizeCallback = null, this._rasterAtSizeCallback = null, this._releaseResultCallback = null, this._redrawCallback = null;
    }
    SetNpotSurfaceAllowed(e) {
      this._allowNpotSurfaces = !!e;
    }
    IsNpotSurfaceAllowed() {
      return this._allowNpotSurfaces;
    }
    SetGetBaseSizeCallback(e) {
      this._getBaseSizeCallback = e;
    }
    GetBaseSize(e) {
      if (!this._getBaseSizeCallback) throw new Error("no get base size callback set");
      return this._getBaseSizeCallback(e);
    }
    SetRasterAtSizeCallback(e) {
      this._rasterAtSizeCallback = e;
    }
    RasterAtSize(e, a2, t2, l, s, r2) {
      if (!this._rasterAtSizeCallback) throw new Error("no raster at size callback set");
      return this._rasterAtSizeCallback(e, a2, t2, l, s, r2);
    }
    SetReleaseResultCallback(e) {
      this._releaseResultCallback = e;
    }
    ReleaseResult(e) {
      if (!this._releaseResultCallback) throw new Error("no release result callback set");
      this._releaseResultCallback(e);
    }
    SetRedrawCallback(e) {
      this._redrawCallback = e;
    }
    Redraw() {
      if (!this._redrawCallback) throw new Error("no redraw callback set");
      this._redrawCallback();
    }
    AddImage(e) {
      let a2 = this._images.get(e);
      return a2 || (a2 = C32.New(C32.SVGRasterImage, this, e), this._images.set(e, a2)), a2.IncReference(), a2;
    }
    _RemoveImage(e) {
      this._images.delete(e.GetDataSource());
    }
    OnTexturesChanged() {
      for (const e of this._images.values()) e.ReleaseRasterizedResult(), e.ForceRasterAgain();
    }
  };
}
{
  const C32 = self.C3, MAX_SURFACE_SIZE = 4096;
  C32.SVGRasterImage = class {
    constructor(e, t2) {
      this._manager = e, this._dataSource = t2, this._refCount = 0, this._baseWidth = 0, this._baseHeight = 0, this._getBaseSizePromise = this._manager.GetBaseSize(t2).then((e2) => {
        this._manager && (this._baseWidth = e2[0], this._baseHeight = e2[1], this._manager.Redraw());
      }).catch((e2) => {
        console.error("[SVG] Error loading SVG: ", e2), this._hadError = true, this._manager && this._manager.Redraw();
      }), this._rasterSurfaceWidth = 0, this._rasterSurfaceHeight = 0, this._rasterImageWidth = 0, this._rasterImageHeight = 0, this._isRasterizing = false, this._rasterizedResult = null, this._forceRaster = false, this._hadError = false;
    }
    Release() {
      if (this._refCount <= 0) throw new Error("already released");
      this._refCount--, 0 === this._refCount && this._Release();
    }
    ReleaseRasterizedResult() {
      this._rasterizedResult && (this._manager.ReleaseResult(this._rasterizedResult), this._rasterizedResult = null);
    }
    _Release() {
      this.ReleaseRasterizedResult(), this._manager._RemoveImage(this), this._manager = null;
    }
    GetDataSource() {
      return this._dataSource;
    }
    IncReference() {
      this._refCount++;
    }
    HasReferences() {
      return this._refCount > 0;
    }
    GetRasterizedResult() {
      return this._rasterizedResult;
    }
    ForceRasterAgain() {
      this._forceRaster = true;
    }
    async StartRasterForSize(e, t2, r2) {
      if (0 === t2 || 0 === r2 || this._hadError) return;
      if (this._isRasterizing) return;
      let s = C32.nextHighestPowerOfTwo(Math.ceil(t2)), a2 = C32.nextHighestPowerOfTwo(Math.ceil(r2));
      const i = Math.max(s, a2);
      if (i > 4096) {
        const e2 = 4096 / i;
        t2 *= e2, r2 *= e2, s = Math.min(Math.ceil(s * e2), 4096), a2 = Math.min(Math.ceil(a2 * e2), 4096);
      }
      if (t2 < s && r2 < a2) {
        const e2 = t2 / r2;
        s / a2 > e2 ? (t2 = a2 * e2, r2 = a2) : (t2 = s, r2 = s / e2);
      }
      if (this._manager.IsNpotSurfaceAllowed() && (s = Math.ceil(t2), a2 = Math.ceil(r2)), s <= this._rasterSurfaceWidth && a2 <= this._rasterSurfaceHeight && !this._forceRaster) return;
      this._isRasterizing = true, this._rasterSurfaceWidth = s, this._rasterSurfaceHeight = a2;
      const h2 = await this._manager.RasterAtSize(this._dataSource, e, this._rasterSurfaceWidth, this._rasterSurfaceHeight, t2, r2);
      this._manager && (this.ReleaseRasterizedResult(), this._rasterizedResult = h2, this._rasterImageWidth = t2, this._rasterImageHeight = r2, this._isRasterizing = false, this._forceRaster = false, this._manager.Redraw());
    }
    WhenBaseSizeReady() {
      return this._getBaseSizePromise;
    }
    GetBaseWidth() {
      return this._baseWidth;
    }
    GetBaseHeight() {
      return this._baseHeight;
    }
    GetRasterWidth() {
      return this._rasterImageWidth;
    }
    GetRasterHeight() {
      return this._rasterImageHeight;
    }
    HadError() {
      return this._hadError;
    }
  };
}
{
  let lookupHtmlEntity = function(t2) {
    return HTML_ENTITY_MAP.get(t2);
  };
  lookupHtmlEntity2 = lookupHtmlEntity;
  const C32 = self.C3;
  C32.UTF8_BOM = "\uFEFF";
  const NUMERIC_CHARS = new Set("0123456789");
  C32.IsNumericChar = function(t2) {
    return NUMERIC_CHARS.has(t2);
  };
  const WHITESPACE_CHARS = new Set(" 	\n\r\xA0\x85\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u200B\u2028\u2029\u202F\u205F\u3000");
  C32.IsWhitespaceChar = function(t2) {
    return WHITESPACE_CHARS.has(t2);
  }, C32.FilterWhitespace = function(t2) {
    return [...t2].filter((t3) => !C32.IsWhitespaceChar(t3)).join("");
  }, C32.IsStringAllWhitespace = function(t2) {
    for (const e of t2) if (!C32.IsWhitespaceChar(e)) return false;
    return true;
  }, C32.IsCharArrayAllWhitespace = function(t2) {
    for (const e of t2) if (!C32.IsWhitespaceChar(e)) return false;
    return true;
  }, C32.IsUnprintableChar = function(t2) {
    return 1 === t2.length && t2.charCodeAt(0) < 32;
  }, C32.FilterUnprintableChars = function(t2) {
    return [...t2].filter((t3) => !C32.IsUnprintableChar(t3)).join("");
  };
  let cjkPunctuationRegex = null;
  try {
    cjkPunctuationRegex = new RegExp("\\p{P}(?<=[\\u3000-\\u303F\\uFF00-\\uFFEF])", "u");
  } catch (t2) {
    console.warn("Unable to detect CJK punctuation: ", t2);
  }
  C32.IsCJKPunctuationChar = function(t2) {
    return !C32.IsWhitespaceChar(t2) && cjkPunctuationRegex && cjkPunctuationRegex.test(t2);
  };
  const NUMERIC_STRING_CHARS = new Set("0123456789.+-e");
  C32.IsStringNumber = function(t2) {
    if (!(t2 = t2.trim()).length) return false;
    let e = t2.charAt(0);
    if ("-" !== e && !NUMERIC_CHARS.has(e)) return false;
    for (let e2 of t2) if (!NUMERIC_STRING_CHARS.has(e2)) return false;
    return true;
  }, C32.RemoveTrailingDigits = function(t2) {
    let e = t2.length;
    for (; e > 0; ) {
      let n = t2.charAt(e - 1);
      if (!C32.IsNumericChar(n)) break;
      --e;
    }
    return t2.substr(0, e);
  }, C32.IncrementNumberAtEndOf = function(t2) {
    let e = C32.RemoveTrailingDigits(t2), n = t2.substr(e.length);
    return n = n ? (parseInt(n, 10) + 1).toString() : "2", e + n;
  };
  const HTML_ENTITY_MAP = /* @__PURE__ */ new Map([["&", "&amp;"], ["<", "&lt;"], [">", "&gt;"], ['"', "&quot;"], ["'", "&#39;"]]);
  const HTML_ENTITY_REGEX = /[&<>"']/g;
  C32.EscapeHTML = function(t2) {
    return t2.replace(HTML_ENTITY_REGEX, lookupHtmlEntity);
  }, C32.EscapeJS = function(t2) {
    let e = C32.ReplaceAll(t2, "\\", "\\\\");
    return e = C32.ReplaceAll(e, '"', '\\"'), e = C32.ReplaceAll(e, "	", "\\t"), e = C32.ReplaceAll(e, "\r", ""), C32.ReplaceAll(e, "\n", "\\n");
  }, C32.EscapeXML = function(t2) {
    let e = C32.ReplaceAll(t2, "&", "&amp;");
    return e = C32.ReplaceAll(e, "<", "&lt;"), e = C32.ReplaceAll(e, ">", "&gt;"), C32.ReplaceAll(e, '"', "&quot;");
  };
  const ESCAPE_REGEX = /[-[\]{}()*+?.,\\^$|#\s]/g;
  C32.EscapeRegex = function(t2) {
    return t2.replace(ESCAPE_REGEX, "\\$&");
  }, C32.CountCharsInString = function(t2, e) {
    let n = 0;
    for (const r2 of t2) r2 === e && ++n;
    return n;
  }, C32.StringPosToLineNumber = function(t2, e) {
    let n = 0, r2 = 0;
    for (; n < e; ) {
      if (n = t2.indexOf("\n", n), -1 === n) return r2;
      r2++, n++;
    }
    return r2;
  }, C32.FindAll = function(t2, e, n = false) {
    if (!e) return [];
    n || (t2 = t2.toLowerCase(), e = e.toLowerCase());
    const r2 = e.length;
    let o2 = 0, i = 0, l = [];
    for (; (i = t2.indexOf(e, o2)) > -1; ) l.push(i), o2 = i + r2;
    return l;
  }, C32.ReplaceAll = function(t2, e, n) {
    return t2.replaceAll(e, () => n);
  }, C32.ReplaceAllCaseInsensitive = function(t2, e, n) {
    return t2.replace(new RegExp(C32.EscapeRegex(e), "gi"), () => n);
  }, C32.SetElementContent = function(t2, e) {
    "string" == typeof e ? t2.textContent = e : e.isPlainText() ? t2.textContent = e.toString() : (t2.innerHTML = e.toHTML(), e instanceof C32.BBString && e.attachLinkHandlers(t2));
  }, C32.StringLikeEquals = function(t2, e) {
    return t2 instanceof C32.HtmlString || t2 instanceof C32.BBString ? t2.equals(e) : e instanceof C32.HtmlString || e instanceof C32.BBString ? e.equals(t2) : t2 === e;
  }, C32.StringSubstitute = function(t2, ...e) {
    let n = t2;
    for (let r2 = 0, o2 = e.length; r2 < o2; ++r2) {
      const o3 = `{${r2}}`;
      if (!t2.includes(o3)) throw new Error(`missing placeholder '${o3}' in string substitution`);
      n = n.replace(o3, e[r2].toString());
    }
    return n;
  }, C32.StringSubstituteAllowMissing = function(t2, ...e) {
    let n = t2, r2 = -1, o2 = -1;
    for (let i = 0, l = e.length; i < l; ++i) {
      const l2 = `{${i}}`;
      t2.includes(l2) ? (o2 = i, n = n.replace(l2, e[i].toString())) : -1 === r2 && (r2 = i);
    }
    if (r2 >= 0 && o2 >= 0 && r2 < o2) throw new Error(`missing placeholder '${r2}' in string substitution`);
    return n;
  }, C32.StringSubstituteMap = function(t2, e) {
    let n = t2;
    for (let [t3, r2] of Object.entries(e)) n = n.replaceAll(t3, r2.toString());
    return n;
  }, C32.SortAZ = function(t2, e) {
    return t2 > e ? 1 : t2 < e ? -1 : 0;
  }, C32.SortAZCaseInsensitive = function(t2, e) {
    let n = t2.toLowerCase(), r2 = e.toLowerCase();
    return n > r2 ? 1 : n < r2 ? -1 : 0;
  };
  const intlSegmenter = new self["Intl"]["Segmenter"]();
  C32.SplitGraphemes = function(t2) {
    if (1 === t2.length) return [t2];
    const e = [];
    for (const n of intlSegmenter["segment"](t2)) e.push(n["segment"]);
    return e;
  }, C32.IterateGraphemes = function* (t2) {
    for (const e of intlSegmenter["segment"](t2)) yield e["segment"];
  }, C32.CountGraphemes = function(t2) {
    let e = 0;
    for (const n of intlSegmenter["segment"](t2)) ++e;
    return e;
  };
  const KILOBYTE = 1024, MEGABYTE = 1048576, GIGABYTE = 1073741824, TERABYTE = 1099511627776;
  C32.FormatDataSize = function(t2, e) {
    let n = "common." + (e ? "dataRates" : "dataSizes") + ".";
    const r2 = self.langSub;
    if (t2 < 1024) return r2(n + "bytes", t2);
    if (t2 < 1048576) {
      let e2 = t2 / 1024;
      return e2 = e2 < 10 ? Math.round(10 * e2) / 10 : Math.round(e2), r2(n + "kilobytes", e2);
    }
    if (t2 < GIGABYTE) {
      let e2 = t2 / 1048576;
      return e2 = e2 < 10 ? Math.round(10 * e2) / 10 : Math.round(e2), r2(n + "megabytes", e2);
    }
    if (t2 < TERABYTE) {
      let e2 = t2 / GIGABYTE;
      return e2 = e2 < 10 ? Math.round(10 * e2) / 10 : Math.round(e2), r2(n + "gigabytes", e2);
    }
    {
      let e2 = t2 / TERABYTE;
      return e2 = e2 < 10 ? Math.round(10 * e2) / 10 : Math.round(e2), r2(n + "terabytes", e2);
    }
  };
  const DEFAULT_FORMATTIME_OPTS = { approximate: false, days: true, hours: true, minutes: true, seconds: true };
  C32.FormatTime = function(t2, e) {
    e = Object.assign({}, DEFAULT_FORMATTIME_OPTS, e), C32.Lang.PushContext("common.time");
    const n = [], r2 = self.lang, o2 = self.langPluralSub;
    if (e.days) {
      const e2 = Math.floor(t2 / 86400);
      e2 > 0 && (t2 -= 24 * e2 * 3600, n.push(o2(".days", null, e2)));
    }
    if (e.hours) {
      const e2 = Math.floor(t2 / 3600);
      (e2 > 0 || n.length) && (t2 -= 3600 * e2, n.push(o2(".hours", null, e2)));
    }
    if (e.minutes) {
      const r3 = Math.floor(t2 / 60);
      (r3 > 0 || n.length || !e.seconds) && (t2 -= 60 * r3, n.push(o2(".minutes", null, r3)));
    }
    if (e.seconds) {
      const e2 = Math.floor(t2 % 60);
      n.push(o2(".seconds", null, e2));
    }
    const i = (e.approximate ? r2(".approx-prefix") : "") + n.join(r2(".separator"));
    return C32.Lang.PopContext(), i;
  }, C32.ZeroPad = function(t2, e) {
    let n = t2 < 0 ? "-" : "", r2 = (t2 = Math.abs(t2)).toString(), o2 = e - r2.length;
    for (let t3 = 0; t3 < o2; ++t3) n += "0";
    return n + r2;
  }, C32.StringToTitleCase = function(t2) {
    return t2.toLowerCase().replace(/\b\w/g, (t3) => t3.toUpperCase());
  }, C32.CompareVersionStrings = function(t2, e) {
    let n = t2.split(".").map((t3) => t3.trim()), r2 = e.split(".").map((t3) => t3.trim());
    C32.resizeArray(n, 4, "0"), C32.resizeArray(r2, 4, "0"), n = n.map((t3) => parseInt(t3, 10)), r2 = r2.map((t3) => parseInt(t3, 10));
    for (let t3 = 0; t3 < 4; ++t3) {
      const e2 = n[t3] - r2[t3];
      if (0 !== e2) return e2 < 0 ? -1 : 1;
    }
    return 0;
  }, C32.CreateGUID = function() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (t2) => {
      const e = Math.floor(16 * Math.random());
      return ("x" === t2 ? e : 3 & e | 8).toString(16);
    });
  }, C32.StringHammingDistance = function(t2, e) {
    if (t2.length !== e.length) throw new Error("strings must be same length");
    let n = 0;
    for (let r2 = 0, o2 = t2.length; r2 < o2; ++r2) t2.charAt(r2) !== e.charAt(r2) && ++n;
    return n;
  }, C32.StringLevenshteinDistance = function(t2, e) {
    if (0 === t2.length) return e.length;
    if (0 === e.length) return t2.length;
    let n, r2, o2, i, l, s;
    for (t2.length > e.length && (n = t2, t2 = e, e = n), s = Array(t2.length + 1), r2 = 0; r2 <= t2.length; r2++) s[r2] = r2;
    for (r2 = 1; r2 <= e.length; r2++) {
      for (i = r2, o2 = 1; o2 <= t2.length; o2++) l = e[r2 - 1] === t2[o2 - 1] ? s[o2 - 1] : Math.min(s[o2 - 1] + 1, Math.min(i + 1, s[o2] + 1)), s[o2 - 1] = i, i = l;
      s[t2.length] = i;
    }
    return s[t2.length];
  }, C32.StringByteLengthAsUTF8 = function(t2) {
    return new TextEncoder().encode(t2).length;
  };
}
var lookupHtmlEntity2;
{
  let bbToHtmlReplacerFunc = function(t2, s, i) {
    const n = BB_CODE_MAP.get(i);
    if (!n) return "class" === i ? s ? "</span>" : `<span class="bbclass${classIndex++}">` : t2;
    if ("string" == typeof n) {
      if ("a" === n && 0 === linkActions.length || "abbr" === n && 0 === tipList.length) return t2;
      if ("a" !== n || s) {
        if ("abbr" !== n || s) return "<" + s + n + ">";
        {
          const t3 = parseInt(i.substring(3), 10) - 1;
          if (t3 < 0 || t3 >= tipList.length) throw new Error("invalid bbcode tip substitution");
          const s2 = tipList[t3];
          let n2 = "";
          if ("string" == typeof s2 ? n2 = s2 : "function" == typeof s2 && (n2 = s2()), "string" != typeof n2) throw new TypeError("invalid bbcode tip");
          return `<abbr title="${C32.ReplaceAll(n2, '"', "&quot;")}">`;
        }
      }
      {
        const t3 = parseInt(i.substring(1), 10) - 1;
        if (t3 < 0 || t3 >= linkActions.length) throw new Error("invalid bbcode link substitution");
        const s2 = linkActions[t3];
        if ("string" == typeof s2) return `<a href="${linkActions[t3]}">`;
        if ("function" == typeof s2) return `<a class="bblink${t3}">`;
        throw new TypeError("invalid bbcode link action");
      }
    }
    if (Array.isArray(n)) {
      let t3 = n[0], i2 = n[1];
      return s ? "</" + t3 + ">" : `<${t3} class="${i2}">`;
    }
  };
  bbToHtmlReplacerFunc2 = bbToHtmlReplacerFunc;
  const C32 = self.C3, assert = self.assert, BB_CODE_MAP = /* @__PURE__ */ new Map([["b", "strong"], ["i", "em"], ["s", "s"], ["u", "u"], ["sub", "sub"], ["sup", "sup"], ["small", "small"], ["mark", "mark"], ["code", "code"], ["a1", "a"], ["a2", "a"], ["a3", "a"], ["a4", "a"], ["a5", "a"], ["a6", "a"], ["a7", "a"], ["a8", "a"], ["a9", "a"], ["tip1", "abbr"], ["tip2", "abbr"], ["tip3", "abbr"], ["tip4", "abbr"], ["tip5", "abbr"], ["tip6", "abbr"], ["tip7", "abbr"], ["tip8", "abbr"], ["tip9", "abbr"], ["bad", ["span", "bbCodeBad"]], ["good", ["span", "bbCodeGood"]], ["info", ["span", "bbCodeInfo"]], ["h1", ["span", "bbCodeH1"]], ["h2", ["span", "bbCodeH2"]], ["h3", ["span", "bbCodeH3"]], ["h4", ["span", "bbCodeH4"]], ["item", ["span", "bbCodeItem"]]]), SELF_CLOSING_TAGS = /* @__PURE__ */ new Set(["icon"]), BBREGEX = /\[(\/?)([a-zA-Z0-9]+)\]/g, CUSTOM_BBREGEX = /\[(\/?)([^\[\n]*?)\]/g;
  let linkActions = null, tipList = null, classIndex = 0;
  const LINEBREAK_REGEX = /\n/g;
  C32.BBString = class {
    constructor(t2, s) {
      if (this._bbstr = s && s.noEscape ? t2 : C32.EscapeHTML(t2), this._htmlstr = "", this._convertLineBreaks = false, this._linkActions = [], this._tipList = [], s) {
        if (this._convertLineBreaks = !!s.convertLineBreaks, s.links) {
          if (s.links.length > 9) throw new Error("too many links");
          this._linkActions = s.links;
        }
        if (s.tips) {
          if (s.tips.length > 9) throw new Error("too many tips");
          this._tipList = s.tips;
        }
      }
      this._hasAnyBBtags = this._bbstr.includes("["), this._needsLineBreakConversion = this._convertLineBreaks && this._bbstr.includes("\n"), this._isPlain = !this._hasAnyBBtags && !this._needsLineBreakConversion && !this._bbstr.includes("&"), this._hasParsedFragments = false, this._fragments = [];
    }
    toString() {
      return this._bbstr;
    }
    valueOf() {
      return this._bbstr;
    }
    isPlainText() {
      return this._isPlain;
    }
    toPlainText() {
      return this._hasAnyBBtags ? this._bbstr.replace(BBREGEX, "") : this._bbstr;
    }
    toHTML() {
      if (this._isPlain) return this._bbstr;
      if (!this._htmlstr && this._bbstr) {
        let t2 = this._bbstr;
        this._hasAnyBBtags && (classIndex = 0, linkActions = this._linkActions, tipList = this._tipList, t2 = t2.replace(BBREGEX, bbToHtmlReplacerFunc), linkActions = null, tipList = null), this._needsLineBreakConversion && (t2 = t2.replace(LINEBREAK_REGEX, "<br>")), this._htmlstr = t2;
      }
      return this._htmlstr;
    }
    attachLinkHandlers(t2) {
      if (this._linkActions.length) for (let s = 0, i = this._linkActions.length; s < i; ++s) {
        const i2 = this._linkActions[s];
        if ("function" != typeof i2) continue;
        const n = t2.querySelector(".bblink" + s);
        if (!n) throw new Error("unable to attach BBString link handler");
        n.onclick = i2;
      }
    }
    equals(t2) {
      return t2 instanceof C32.HtmlString ? this.toHTML() === t2.toHTML() : t2 instanceof C32.BBString ? this._bbstr === t2._bbstr : this._bbstr === t2;
    }
    toFragmentList() {
      if (this._hasParsedFragments) return this._fragments;
      const t2 = [], s = this._bbstr, i = [];
      CUSTOM_BBREGEX.lastIndex = 0;
      let n = 0, e = null;
      for (; null !== (e = CUSTOM_BBREGEX.exec(s)); ) {
        const r2 = e.index;
        if (r2 > 0 && "\\" === s.charAt(r2 - 1)) continue;
        const a2 = e[0], o2 = e[1], l = e[2], b2 = s.substring(n, r2);
        if (n = r2 + a2.length, b2 && t2.push({ text: b2, styles: i.slice(0) }), l) if (o2) {
          const t3 = l.toLowerCase();
          for (let s2 = i.length - 1; s2 >= 0; --s2) if (i[s2].tag === t3) {
            i.splice(s2, 1);
            break;
          }
        } else {
          let s2 = l, n2 = null;
          const e2 = l.indexOf("=");
          if (-1 !== e2 ? (s2 = l.substring(0, e2).toLowerCase(), n2 = l.substring(e2 + 1)) : s2 = s2.toLowerCase(), SELF_CLOSING_TAGS.has(s2)) {
            if ("icon" !== s2) throw new Error(`unknown self-closing tag ${s2}`);
            t2.push({ icon: n2, styles: i.slice(0) });
          } else i.push({ tag: s2, param: n2 });
        }
      }
      n < s.length && t2.push({ text: s.substring(n), styles: i.slice(0) });
      for (const s2 of t2) s2.text && (s2.text = this._ProcessBBCodeEscapeSequences(s2.text));
      return this._fragments = t2.map((t3) => t3.icon ? C32.New(C32.IconFragment, { icon: t3.icon, styles: t3.styles }) : C32.New(C32.TextFragment, { chArr: C32.SplitGraphemes(t3.text), styles: t3.styles })), this._hasParsedFragments = true, this._fragments;
    }
    _ProcessBBCodeEscapeSequences(t2) {
      return t2 = C32.ReplaceAll(t2, "\\[", "["), C32.ReplaceAll(t2, "\\\\", "\\");
    }
    static StripTags(t2) {
      return C32.New(C32.BBString, t2, { noEscape: true }).toPlainText();
    }
    static StripAnyTags(t2) {
      return t2.replace(CUSTOM_BBREGEX, "");
    }
  };
}
var bbToHtmlReplacerFunc2;
{
  let IsWordBreakWhiteSpace = function(t2) {
    return "\xA0" !== t2 && "\u202F" !== t2 && C32.IsWhitespaceChar(t2);
  }, IsOpeningCJKPunctiationChar = function(t2) {
    return CJK_OPEN_PUNCTUATION.has(t2);
  }, IsContinuingCJKPunctuationChar = function(t2) {
    return C32.IsCJKPunctuationChar(t2) && !IsOpeningCJKPunctiationChar(t2);
  }, WordBreakTrimEnd = function(t2) {
    for (; t2.length > 0 && IsWordBreakWhiteSpace(t2.at(-1)); ) t2.pop();
  }, IsNewline = function(t2) {
    return "\n" === t2 || "\r\n" === t2;
  };
  IsWordBreakWhiteSpace2 = IsWordBreakWhiteSpace, IsOpeningCJKPunctiationChar2 = IsOpeningCJKPunctiationChar, IsContinuingCJKPunctuationChar2 = IsContinuingCJKPunctuationChar, WordBreakTrimEnd2 = WordBreakTrimEnd, IsNewline2 = IsNewline;
  const C32 = self.C3;
  const CJK_OPEN_PUNCTUATION = new Set("\u3008\u300A\u300C\u300E\u3010\u3014\u3016\u3018\u301A\u301D");
  class CurrentLineState {
    constructor() {
      this.fragments = [], this.width = 0, this.height = 0, this.fontBoundingBoxAscent = 0, this.fontBoundingBoxDescent = 0, this.topToAlphabeticDistance = 0, this.isMeasured = false;
    }
    static FromSingleFragment(t2, e, n, i, s, r2) {
      const h2 = new CurrentLineState();
      return h2.fragments.push(t2), h2.width = e, h2.height = n, h2.fontBoundingBoxAscent = i, h2.fontBoundingBoxDescent = s, h2.topToAlphabeticDistance = r2, h2;
    }
    Copy(t2) {
      this.fragments = t2.fragments.map((t3) => t3._Clone()), this.width = t2.width, this.height = t2.height, this.fontBoundingBoxAscent = t2.fontBoundingBoxAscent, this.fontBoundingBoxDescent = t2.fontBoundingBoxDescent, this.topToAlphabeticDistance = t2.topToAlphabeticDistance, this.isMeasured = t2.isMeasured;
    }
    Reset() {
      this.fragments = [], this.width = 0, this.height = 0, this.fontBoundingBoxAscent = 0, this.fontBoundingBoxDescent = 0, this.topToAlphabeticDistance = 0, this.isMeasured = false;
    }
    SetMetrics(t2, e) {
      e || (this.width = t2.width), this.height = t2.height || 0, this.fontBoundingBoxAscent = t2.fontBoundingBoxAscent || 0, this.fontBoundingBoxDescent = t2.fontBoundingBoxDescent || 0, this.topToAlphabeticDistance = t2.topToAlphabeticDistance || 0, this.isMeasured = true;
    }
    AddWord(t2) {
      const e = this.fragments.length ? this.fragments.at(-1) : null;
      let n = 0;
      e && e.IsText() && t2[0].IsText() && t2[0].GetStyles() === e.GetStyles() && (e._Append(t2[0].GetCharacterArray()), n = 1);
      for (let e2 = t2.length; n < e2; ++n) {
        const e3 = t2[n];
        this.fragments.push(e3._Clone());
      }
      this.isMeasured = false;
    }
  }
  C32.WordWrap = class {
    constructor() {
      this._lines = [], this._iconSet = null, this._lastFitLineState = new CurrentLineState(), this._tryLineState = new CurrentLineState(), this._hitNewline = false;
    }
    GetLines() {
      return this._lines;
    }
    GetLineCount() {
      return this._lines.length;
    }
    SetIconSet(t2) {
      this._iconSet = t2;
    }
    WordWrap(t2, e, n, i, s) {
      if ("string" == typeof t2 && (t2 = [C32.New(C32.TextFragment, { chArr: C32.SplitGraphemes(t2) })]), C32.clearArray(this._lines), !t2.length || 1 === t2.length && t2[0].IsText() && t2[0].IsEmpty() || n < 2) return;
      if (1 === t2.length) {
        const i2 = t2[0];
        if (i2.IsText() && i2.GetLength() <= 100 && !i2.HasNewLine()) {
          let { width: t3, height: r3, fontBoundingBoxAscent: h3, fontBoundingBoxDescent: o2, topToAlphabeticDistance: a2 } = e(i2);
          if (t3 += s, i2.SetWidth(t3), i2.SetHeight(r3), i2.SetFontBoundingBoxAscent(h3 || 0), i2.SetFontBoundingBoxDescent(o2 || 0), i2.SetTopToAlphabeticDistance(a2 || 0), t3 <= n) return void this._AddLine(CurrentLineState.FromSingleFragment(i2, t3, r3, h3, o2, a2));
        }
      }
      let r2, h2 = 4;
      "word" === i ? r2 = this._TokeniseByWord(t2) : "cjk" === i ? (r2 = this._TokeniseByCJK(t2), h2 = 8) : (r2 = this._TokeniseByChar(t2), h2 = 8), this._WrapText(r2, e, n, h2, s);
    }
    _TokeniseByWord(t2) {
      const e = [];
      let n = [], i = false;
      for (const s of t2) {
        const t3 = s.GetStyles();
        if (s.IsIcon()) n.length > 0 && e.push(n), e.push([s]), n = [];
        else for (const r2 of s.GetCharacterArray()) if (IsNewline(r2)) n.length > 0 && e.push(n), e.push([C32.New(C32.TextFragment, { chArr: ["\n"], styles: t3 })]), n = [];
        else if (0 === n.length) n.push(C32.New(C32.TextFragment, { chArr: [r2], styles: t3 })), i = IsWordBreakWhiteSpace(r2);
        else {
          const s2 = IsWordBreakWhiteSpace(r2);
          if (s2 === i) {
            const e2 = n.at(-1);
            e2.GetStyles() === t3 ? e2._AppendChar(r2) : n.push(C32.New(C32.TextFragment, { chArr: [r2], styles: t3 }));
          } else e.push(n), n = [C32.New(C32.TextFragment, { chArr: [r2], styles: t3 })], i = s2;
        }
      }
      return n.length > 0 && e.push(n), e;
    }
    _TokeniseByCJK(t2) {
      const e = [];
      let n = [], i = false;
      for (const s of t2) {
        const t3 = s.GetStyles();
        if (s.IsIcon()) n.length > 0 && e.push(n), e.push([s]), n = [];
        else for (const r2 of s.GetCharacterArray()) if (IsNewline(r2)) n.length > 0 && e.push(n), e.push([C32.New(C32.TextFragment, { chArr: ["\n"], styles: t3 })]), n = [];
        else if (0 === n.length) n.push(C32.New(C32.TextFragment, { chArr: [r2], styles: t3 })), i = IsOpeningCJKPunctiationChar(r2);
        else if (i || IsContinuingCJKPunctuationChar(r2)) {
          const e2 = n.at(-1);
          e2.GetStyles() === t3 ? e2._AppendChar(r2) : n.push(C32.New(C32.TextFragment, { chArr: [r2], styles: t3 })), i = IsOpeningCJKPunctiationChar(r2);
        } else e.push(n), n = [C32.New(C32.TextFragment, { chArr: [r2], styles: t3 })], i = IsOpeningCJKPunctiationChar(r2);
      }
      return n.length > 0 && e.push(n), e;
    }
    _TokeniseByChar(t2) {
      const e = [];
      for (const n of t2) if (n.IsText()) {
        const t3 = n.GetCharacterArray();
        C32.appendArray(e, t3.map((t4) => [C32.New(C32.TextFragment, { chArr: [t4], styles: n.GetStyles() })]));
      } else e.push([n]);
      return e;
    }
    _MeasureLine(t2, e) {
      let n = 0, i = 0, s = 0, r2 = 0, h2 = 0;
      for (const o2 of t2) {
        if (-1 === o2.GetWidth()) {
          const t3 = e(o2);
          o2.SetHeight(t3.height), o2.SetFontBoundingBoxAscent(t3.fontBoundingBoxAscent || 0), o2.SetFontBoundingBoxDescent(t3.fontBoundingBoxDescent || 0), o2.SetTopToAlphabeticDistance(t3.topToAlphabeticDistance || 0), o2.IsText() ? o2.SetWidth(t3.width) : o2.IsIcon() && o2.CalculateWidthFromHeight(this._iconSet);
        }
        n += o2.GetWidth(), i = Math.max(i, o2.GetHeight()), s = Math.max(s, o2.GetFontBoundingBoxAscent()), r2 = Math.max(r2, o2.GetFontBoundingBoxDescent()), h2 = Math.max(h2, o2.GetTopToAlphabeticDistance());
      }
      return { width: n, height: i, fontBoundingBoxAscent: s, fontBoundingBoxDescent: r2, topToAlphabeticDistance: h2 };
    }
    _ResetLineStates() {
      this._lastFitLineState.Reset(), this._tryLineState.Reset();
    }
    _AddLine(t2) {
      this._lines.push(new C32.WordWrap.Line(t2)), this._ResetLineStates();
    }
    _IsWordNewLine(t2) {
      return 1 === t2.length && t2[0].IsText() && 1 === t2[0].GetLength() && IsNewline(t2[0].GetCharacterArray()[0]);
    }
    _IsWordWhitespace(t2) {
      return t2[0].IsText() && C32.IsCharArrayAllWhitespace(t2[0].GetCharacterArray());
    }
    _WrapText(t2, e, n, i, s) {
      let r2 = 0;
      for (; r2 < t2.length; ) r2 = this._WrapText_Chunk(t2, r2, e, n, i);
      if (this._tryLineState.fragments.length > 0) {
        if (!this._tryLineState.isMeasured) {
          const t3 = this._MeasureLine(this._tryLineState.fragments, e);
          this._tryLineState.SetMetrics(t3);
        }
        this._AddLine(this._tryLineState);
      }
      this._TrimLinesTrailingWhitespace(e, s), this._ResetLineStates(), this._hitNewline = false;
    }
    _WrapText_Chunk(t2, e, n, i, s) {
      const r2 = this._lastFitLineState, h2 = this._tryLineState, o2 = t2[e];
      if (this._IsWordNewLine(o2)) {
        if (!h2.isMeasured) {
          const t3 = n(C32.New(C32.TextFragment, { chArr: [" "], styles: o2[0].GetStyles() }));
          h2.SetMetrics(t3, true);
        }
        return this._AddLine(h2), e + 1;
      }
      const a2 = this._WrapText_CollectChunk(t2, e, s), c2 = this._MeasureLine(h2.fragments, n);
      return h2.SetMetrics(c2), c2.width >= i ? this._WrapText_RetryChunk(t2, e, n, i) : (r2.Copy(h2), this._hitNewline && this._AddLine(r2), a2 + 1);
    }
    _WrapText_CollectChunk(t2, e, n) {
      const i = this._tryLineState;
      this._hitNewline = false;
      let s = e, r2 = 0;
      for (let e2 = t2.length; s < e2; ++s) {
        const e3 = t2[s];
        if (this._IsWordNewLine(e3)) {
          this._hitNewline = true;
          break;
        }
        if (i.AddWord(e3), !this._IsWordWhitespace(e3) && (++r2, r2 === n)) break;
      }
      return s;
    }
    _WrapText_RetryChunk(t2, e, n, i) {
      const s = this._lastFitLineState, r2 = this._tryLineState;
      r2.Copy(s);
      let h2 = e;
      for (let e2 = t2.length; h2 < e2; ++h2) {
        const o2 = t2[h2];
        if (this._IsWordNewLine(o2)) return this._AddLine(s), h2 + 1;
        if (r2.AddWord(o2), !this._IsWordWhitespace(o2) || 0 === s.fragments.length) {
          const o3 = this._MeasureLine(r2.fragments, n);
          if (r2.SetMetrics(o3), o3.width >= i) {
            let n2;
            return s.fragments.length > 0 ? n2 = s : (n2 = r2, ++h2, h2 < e2 && this._IsWordWhitespace(t2[h2]) && ++h2), this._AddLine(n2), h2;
          }
          s.Copy(r2);
        }
      }
      return h2;
    }
    _TrimLinesTrailingWhitespace(t2, e) {
      for (const n of this._lines) {
        const i = n._GetFragmentsArray();
        if (!i.length) continue;
        let s = i.at(-1);
        if (s.IsText()) {
          const r2 = s.GetCharacterArray(), h2 = r2.slice(0);
          if (WordBreakTrimEnd(h2), 0 === h2.length) n.OffsetWidth(-s.GetWidth()), i.pop();
          else if (h2.length < r2.length) {
            s.SetCharacterArray(h2);
            const e2 = t2(s).width, i2 = s.GetWidth() - e2;
            s.SetWidth(e2), n.OffsetWidth(-i2);
          }
          0 !== e && i.length > 0 && (s = i.at(-1), s.OffsetWidth(e), n.OffsetWidth(e));
        }
      }
    }
    Clear() {
      C32.clearArray(this._lines);
    }
    GetMaxLineWidth() {
      return this._lines.reduce((t2, e) => Math.max(t2, e.GetWidth()), 0);
    }
    GetTotalLineHeight() {
      return this._lines.reduce((t2, e) => t2 + e.GetHeight(), 0);
    }
  };
}
var IsWordBreakWhiteSpace2;
var IsOpeningCJKPunctiationChar2;
var IsContinuingCJKPunctuationChar2;
var WordBreakTrimEnd2;
var IsNewline2;
{
  const C32 = self.C3;
  C32.WordWrap.Line = class {
    constructor(t2) {
      this._fragments = t2.fragments, this._width = t2.width, this._height = t2.height, this._fontBoundingBoxAscent = t2.fontBoundingBoxAscent, this._fontBoundingBoxDescent = t2.fontBoundingBoxDescent, this._topToAlphabeticDistance = t2.topToAlphabeticDistance, this._posX = 0, this._posY = 0;
    }
    fragments() {
      return this._fragments.values();
    }
    *fragmentsReverse() {
      const t2 = this._fragments;
      for (let e = t2.length - 1; e >= 0; --e) yield t2[e];
    }
    _GetFragmentsArray() {
      return this._fragments;
    }
    OffsetWidth(t2) {
      this._width += t2;
    }
    GetWidth() {
      return this._width;
    }
    GetHeight() {
      return this._height;
    }
    GetFoundBoundingBoxAscent() {
      return this._fontBoundingBoxAscent;
    }
    GetFontBoundingBoxDescent() {
      return this._fontBoundingBoxDescent;
    }
    GetTopToAlphabeticDistance() {
      return this._topToAlphabeticDistance;
    }
    SetPosX(t2) {
      this._posX = t2;
    }
    GetPosX() {
      return this._posX;
    }
    SetPosY(t2) {
      this._posY = t2;
    }
    GetPosY() {
      return this._posY;
    }
  };
}
{
  const C32 = self.C3;
  C32.FragmentBase = class {
    constructor(t2) {
      this._styles = t2.styles || [], this._width = t2.width || -1, this._height = t2.height || -1, this._fontBoundingBoxAscent = t2.fontBoundingBoxAscent || -1, this._fontBoundingBoxDescent = t2.fontBoundingBoxDescent || -1, this._topToAlphabeticDistance = t2.topToAlphabeticDistance || -1, this._posX = 0, this._posY = 0;
    }
    IsText() {
      return false;
    }
    IsIcon() {
      return false;
    }
    GetStyles() {
      return this._styles;
    }
    GetStyleTag(t2) {
      const e = this._styles;
      for (let s = e.length - 1; s >= 0; --s) {
        const n = e[s];
        if (n.tag === t2) return n;
      }
      return null;
    }
    HasStyleTag(t2) {
      return !!this.GetStyleTag(t2);
    }
    GetStyleMap() {
      const t2 = /* @__PURE__ */ new Map();
      for (const e of this._styles) t2.set(e.tag, e.param);
      return t2;
    }
    OffsetWidth(t2) {
      this._width += t2;
    }
    SetWidth(t2) {
      this._width = t2;
    }
    GetWidth() {
      return this._width;
    }
    SetHeight(t2) {
      this._height = t2;
    }
    GetHeight() {
      return this._height;
    }
    SetFontBoundingBoxAscent(t2) {
      this._fontBoundingBoxAscent = t2;
    }
    GetFontBoundingBoxAscent() {
      return this._fontBoundingBoxAscent;
    }
    SetFontBoundingBoxDescent(t2) {
      this._fontBoundingBoxDescent = t2;
    }
    GetFontBoundingBoxDescent() {
      return this._fontBoundingBoxDescent;
    }
    SetTopToAlphabeticDistance(t2) {
      this._topToAlphabeticDistance = t2;
    }
    GetTopToAlphabeticDistance() {
      return this._topToAlphabeticDistance;
    }
    SetPosX(t2) {
      this._posX = t2;
    }
    GetPosX() {
      return this._posX;
    }
    SetPosY(t2) {
      this._posY = t2;
    }
    GetPosY() {
      return this._posY;
    }
  };
}
{
  const C32 = self.C3;
  C32.TextFragment = class extends C32.FragmentBase {
    constructor(t2) {
      super(t2), this._chArr = t2.chArr;
    }
    IsText() {
      return true;
    }
    _Append(t2) {
      C32.appendArray(this._chArr, t2), this._width = -1, this._height = -1, this._fontBoundingBoxAscent = -1, this._fontBoundingBoxDescent = -1, this._topToAlphabeticDistance = -1;
    }
    _AppendChar(t2) {
      this._chArr.push(t2);
    }
    _Clone() {
      return C32.New(C32.TextFragment, { chArr: this._chArr.slice(0), styles: this._styles, width: this._width, height: this._height, fontBoundingBoxAscent: this._fontBoundingBoxAscent, fontBoundingBoxDescent: this._fontBoundingBoxDescent, topToAlphabeticDistance: this._topToAlphabeticDistance });
    }
    GetCharacterArray() {
      return this._chArr;
    }
    SetCharacterArray(t2) {
      this._chArr = t2;
    }
    GetLength() {
      return this._chArr.length;
    }
    IsEmpty() {
      return 0 === this._chArr.length;
    }
    HasNewLine() {
      return this._chArr.includes("\n");
    }
  };
}
{
  const C32 = self.C3;
  C32.IconFragment = class extends C32.FragmentBase {
    constructor(t2) {
      super(t2), this._icon = t2.icon;
    }
    IsIcon() {
      return true;
    }
    GetIconParameter() {
      return this._icon;
    }
    _Clone() {
      return C32.New(C32.IconFragment, { icon: this._icon, styles: this._styles, width: this._width, height: this._height, fontBoundingBoxAscent: this._fontBoundingBoxAscent, fontBoundingBoxDescent: this._fontBoundingBoxDescent, topToAlphabeticDistance: this._topToAlphabeticDistance });
    }
    GetTextIcon(t2) {
      if (!t2) return null;
      let e = Number(this._icon);
      return String(e) === this._icon ? (e = Math.floor(e), t2.GetTextIconByIndex(e)) : t2.GetTextIconByTag(this._icon);
    }
    CalculateWidthFromHeight(t2) {
      const e = this.GetTextIcon(t2);
      this._width = e ? this._height * e.GetWidth() / e.GetHeight() : 0;
    }
    GetDrawable(t2) {
      const e = this.GetTextIcon(t2);
      return e ? e.GetDrawable() : null;
    }
    GetLength() {
      return 1;
    }
  };
}
{
  const C32 = self.C3;
  C32.TextIconManager = class {
    constructor(t2) {
      this._iconSets = /* @__PURE__ */ new Map(), this._getIconSetMetaCallback = t2.getIconSetMeta, this._getIconSetContentCallback = t2.getIconSetContent;
    }
    Release() {
      for (const t2 of this._iconSets.values()) t2.Release();
      this._iconSets.clear();
    }
    GetIconSet(t2) {
      let e = this._iconSets.get(t2);
      if (e) return e;
      const n = this._getIconSetMetaCallback(t2);
      return e = C32.New(C32.TextIconSet, this, { source: t2, iconMeta: n }), this._iconSets.set(t2, e), e;
    }
    HasIconSet(t2) {
      return this._iconSets.has(t2);
    }
    DeleteIconSet(t2) {
      const e = this._iconSets.get(t2);
      e && e.Release(), this._iconSets.delete(t2);
    }
    async _GetIconSetContent(t2) {
      return await this._getIconSetContentCallback(t2);
    }
  };
}
{
  const C32 = self.C3;
  C32.TextIconSet = class {
    constructor(t2, s) {
      this._textIconManager = t2, this._source = s.source, this._iconsArray = [], this._iconsByTag = /* @__PURE__ */ new Map(), this._hasStartedLoad = false, this._isLoading = false, this._loadPromise = null;
      const o2 = s.iconMeta.icons;
      for (let t3 = 0, s2 = o2.length; t3 < s2; ++t3) {
        const s3 = o2[t3], e = C32.New(C32.TextIcon, this, { index: t3, tag: s3.tag, source: s3.source, width: s3.width, height: s3.height });
        this._iconsArray.push(e), s3.tag && this._iconsByTag.set(s3.tag.toLowerCase(), e);
      }
    }
    Release() {
      for (const t2 of this._iconsArray) t2.Release();
      C32.clearArray(this._iconsArray), this._iconsByTag.clear(), this._textIconManager = null, this._source = null;
    }
    HasLoaded() {
      return this._hasStartedLoad;
    }
    IsLoading() {
      return this._isLoading;
    }
    LoadContent() {
      return this._loadPromise || (this._loadPromise = this._DoLoadContent()), this._loadPromise;
    }
    async _DoLoadContent() {
      if (this._hasStartedLoad) return;
      this._hasStartedLoad = true, this._isLoading = true;
      const t2 = await this._textIconManager._GetIconSetContent(this._source);
      if (!this._textIconManager) return;
      const s = t2.icons;
      for (let t3 = 0, o2 = Math.min(s.length, this._iconsArray.length); t3 < o2; ++t3) {
        const o3 = s[t3].drawable;
        this._iconsArray[t3]._SetDrawable(o3);
      }
      this._isLoading = false;
    }
    GetTextIconByIndex(t2) {
      return (t2 = Math.floor(t2)) < 0 || t2 >= this._iconsArray.length ? null : this._iconsArray[t2];
    }
    GetTextIconByTag(t2) {
      return this._iconsByTag.get(t2.toLowerCase()) || null;
    }
  };
}
{
  const C32 = self.C3;
  C32.TextIcon = class {
    constructor(t2, e) {
      this._textIconSet = t2, this._source = e.source || null, this._index = e.index, this._tag = e.tag, this._width = e.width, this._height = e.height, this._drawable = null;
    }
    Release() {
      this._width = 0, this._height = 0, this._textIconSet = null;
    }
    GetSource() {
      return this._source;
    }
    GetWidth() {
      return this._width;
    }
    GetHeight() {
      return this._height;
    }
    _SetDrawable(t2) {
      this._drawable = t2;
    }
    GetDrawable() {
      return this._drawable;
    }
  };
}
{
  let PlaneFromPoints = function(t2, e, r2, n) {
    const a2 = tempVec3c;
    vec3.subtract(tempVec3a, r2, e), vec3.subtract(tempVec3b, t2, e), vec3.cross(a2, tempVec3a, tempVec3b), vec3.normalize(a2, a2), n.set(a2[0], a2[1], a2[2], vec3.dot(t2, a2));
  }, IsInFrontOfPlane = function(t2, e, r2, n, a2, c2, s) {
    const o2 = s.x, i = s.y, l = s.z, f2 = s.w, P2 = s.xF, h2 = s.yF, m2 = s.zF, p2 = 1 - P2, v2 = 1 - h2, u2 = 1 - m2;
    if (o2 * t2 * P2 + o2 * n * p2 + i * e * h2 + i * a2 * v2 + l * r2 * m2 + l * c2 * u2 >= f2) return true;
    return o2 * n * P2 + o2 * t2 * p2 + i * a2 * h2 + i * e * v2 + l * c2 * m2 + l * r2 * u2 > f2;
  }, IsPointInFrontOfPlane = function(t2, e, r2, n) {
    return n.x * t2 + n.y * e + n.z * r2 >= n.w;
  };
  PlaneFromPoints2 = PlaneFromPoints, IsInFrontOfPlane2 = IsInFrontOfPlane, IsPointInFrontOfPlane2 = IsPointInFrontOfPlane;
  const C32 = self.C3, glMatrix = self.glMatrix, vec3 = glMatrix.vec3, vec4 = glMatrix.vec4, mat4 = glMatrix.mat4, tempVec3a = vec3.create(), tempVec3b = vec3.create(), tempVec3c = vec3.create(), tempVec4 = vec4.create(), tempMat4 = mat4.create(), neartl = vec3.create(), neartr = vec3.create(), nearbl = vec3.create(), nearbr = vec3.create(), fartl = vec3.create(), fartr = vec3.create(), farbl = vec3.create(), farbr = vec3.create(), unitViewport = vec4.fromValues(0, 0, 1, 1);
  C32.Gfx = { Project(t2, e, r2, n, a2, c2, s) {
    const o2 = n[0] * t2 + n[4] * e + n[8] * r2 + n[12], i = n[1] * t2 + n[5] * e + n[9] * r2 + n[13], l = n[2] * t2 + n[6] * e + n[10] * r2 + n[14], f2 = n[3] * t2 + n[7] * e + n[11] * r2 + n[15];
    let P2 = a2[0] * o2 + a2[4] * i + a2[8] * l + a2[12] * f2, h2 = a2[1] * o2 + a2[5] * i + a2[9] * l + a2[13] * f2, m2 = a2[2] * o2 + a2[6] * i + a2[10] * l + a2[14] * f2, p2 = a2[3] * o2 + a2[7] * i + a2[11] * l + a2[15] * f2;
    return 0 !== p2 && (p2 = 1 / p2, P2 *= p2, h2 *= p2, m2 *= p2, s[0] = (0.5 * P2 + 0.5) * c2[2] + c2[0], s[1] = (0.5 * h2 + 0.5) * c2[3] + c2[1], s[2] = 0.5 * (1 + m2), true);
  }, Unproject(t2, e, r2, n, a2, c2, s) {
    const o2 = tempMat4, i = tempVec4;
    return mat4.multiply(o2, a2, n), null !== mat4.invert(o2, o2) && (i[0] = (t2 - c2[0]) / c2[2] * 2 - 1, i[1] = (e - c2[1]) / c2[3] * 2 - 1, i[2] = 2 * r2 - 1, i[3] = 1, vec4.transformMat4(i, i, o2), 0 !== i[3] && (i[3] = 1 / i[3], s[0] = i[0] * i[3], s[1] = i[1] * i[3], s[2] = i[2] * i[3], true));
  }, UnprojectScreenToWorldZ(t2, e, r2, n, a2, c2, s) {
    const o2 = tempVec3a, i = tempVec3b;
    if (!C32.Gfx.Unproject(t2, e, 0, n, a2, c2, o2)) return false;
    if (!C32.Gfx.Unproject(t2, e, 1, n, a2, c2, i)) return false;
    const l = tempVec3b;
    vec3.subtract(l, i, o2);
    const f2 = tempVec3c;
    vec3.set(f2, 0, 0, 1);
    const P2 = -r2, h2 = vec3.dot(f2, l);
    let m2 = 0;
    if (0 === h2) {
      if (0 !== vec3.dot(f2, o2) + P2) return false;
    } else if (m2 = -(vec3.dot(o2, f2) + P2) / h2, m2 < 0) return false;
    return vec3.scaleAndAdd(s, o2, l, m2), true;
  } };
  class Plane {
    constructor() {
      this.x = NaN, this.y = NaN, this.z = NaN, this.w = NaN, this.xF = NaN, this.yF = NaN, this.zF = NaN;
    }
    set(t2, e, r2, n) {
      this.x = t2, this.y = e, this.z = r2, this.w = n, this.xF = t2 > 0 ? 1 : 0, this.yF = e > 0 ? 1 : 0, this.zF = r2 > 0 ? 1 : 0;
    }
  }
  C32.Gfx.ViewFrustum = class {
    constructor() {
      this._leftP = new Plane(), this._topP = new Plane(), this._rightP = new Plane(), this._bottomP = new Plane(), this._nearP = new Plane(), this._farP = new Plane();
    }
    CalculatePlanes(t2, e) {
      const r2 = unitViewport;
      C32.Gfx.Unproject(0, 1, 0, t2, e, r2, neartl), C32.Gfx.Unproject(1, 1, 0, t2, e, r2, neartr), C32.Gfx.Unproject(0, 0, 0, t2, e, r2, nearbl), C32.Gfx.Unproject(1, 0, 0, t2, e, r2, nearbr), C32.Gfx.Unproject(0, 1, 1, t2, e, r2, fartl), C32.Gfx.Unproject(1, 1, 1, t2, e, r2, fartr), C32.Gfx.Unproject(0, 0, 1, t2, e, r2, farbl), C32.Gfx.Unproject(1, 0, 1, t2, e, r2, farbr), PlaneFromPoints(nearbl, neartl, fartl, this._leftP), PlaneFromPoints(neartl, neartr, fartr, this._topP), PlaneFromPoints(neartr, nearbr, farbr, this._rightP), PlaneFromPoints(nearbr, nearbl, farbl, this._bottomP), PlaneFromPoints(farbl, fartl, fartr, this._farP), PlaneFromPoints(nearbr, neartr, neartl, this._nearP);
    }
    ContainsAABB(t2, e, r2, n, a2, c2) {
      return IsInFrontOfPlane(t2, e, r2, n, a2, c2, this._leftP) && IsInFrontOfPlane(t2, e, r2, n, a2, c2, this._topP) && IsInFrontOfPlane(t2, e, r2, n, a2, c2, this._rightP) && IsInFrontOfPlane(t2, e, r2, n, a2, c2, this._bottomP) && IsInFrontOfPlane(t2, e, r2, n, a2, c2, this._nearP) && IsInFrontOfPlane(t2, e, r2, n, a2, c2, this._farP);
    }
    IsBehindNearPlane(t2, e, r2) {
      return !IsPointInFrontOfPlane(t2, e, r2, this._nearP);
    }
  };
}
var PlaneFromPoints2;
var IsInFrontOfPlane2;
var IsPointInFrontOfPlane2;
{
  const C32 = self.C3, glMatrix = self.glMatrix, vec3 = glMatrix.vec3, vec4 = glMatrix.vec4, mat4 = glMatrix.mat4, tempMat4 = mat4.create(), tmpVec3a = vec3.fromValues(0, 0, 0), tmpVec3b = vec3.fromValues(0, 0, 0), tmpVec3c = vec3.fromValues(0, 0, 0), defaultUpVector = vec3.fromValues(0, 1, 0), tmpVec4 = vec4.fromValues(0, 0, 0, 0), tmpQuad = new C32.Quad(), tmpRect = new C32.Rect(), defaultTexCoordsQuad = new C32.Quad(0, 0, 1, 0, 1, 1, 0, 1), DEFAULT_RENDERERBASE_OPTS = { nearZ: 1, farZ: 1e4 }, matWebGLtoWebGPU = mat4.fromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0.5, 0, 0, 0, 0.5, 1);
  C32.Gfx.RendererBase = class {
    constructor(e) {
      e = Object.assign({}, DEFAULT_RENDERERBASE_OPTS, e), this._width = 0, this._height = 0, this._fovY = C32.toRadians(45), this._tan_fovY_2 = Math.tan(this._fovY / 2), this._matP = mat4.create(), this._matMV = mat4.create(), this._zAxisScale = false, this._nearZ = e.nearZ, this._farZ = e.farZ, this._allShaderPrograms = [], this._shaderProgramsByName = /* @__PURE__ */ new Map(), this._spTextureFill = null, this._spPoints = null, this._spTilemapFill = null, this._spTileRandomization = null, this._spColorFill = null, this._spLinearGradientFill = null, this._spPenumbraFill = null, this._spHardEllipseFill = null, this._spHardEllipseOutline = null, this._spSmoothEllipseFill = null, this._spSmoothEllipseOutline = null, this._spSmoothLineFill = null, this._stateGroups = /* @__PURE__ */ new Map(), this._currentStateGroup = null, this._blendModeTable = [], this._namedBlendModeMap = /* @__PURE__ */ new Map(), this._baseZ = 0, this._currentZ = 0, this._lineWidth = 1, this._lineWidthStack = [this._lineWidth], this._lineCap = 1, this._lineCapStack = [this._lineCap], this._lineOffset = 0.5, this._lineOffsetStack = [this._lineOffset], this._frameNumber = 0, this._enableMipmaps = true, this._hasMajorPerformanceCaveat = false;
    }
    _ClearState() {
      this._baseZ = 0, this._currentZ = 0, this._spTextureFill = null, this._spPoints = null, this._spTilemapFill = null, this._spTileRandomization = null, this._spColorFill = null, this._spLinearGradientFill = null, this._spPenumbraFill = null, this._spHardEllipseFill = null, this._spHardEllipseOutline = null, this._spSmoothEllipseFill = null, this._spSmoothEllipseOutline = null, this._spSmoothLineFill = null, this._ClearAllShaderPrograms();
    }
    InitState() {
      this._ClearState(), this._currentStateGroup = null;
    }
    OnDeviceOrContextLost() {
      for (const e of this._allShaderPrograms) e.Release();
      this._ClearState();
    }
    GetWidth() {
      return this._width;
    }
    GetHeight() {
      return this._height;
    }
    GetDefaultCameraZ(e) {
      return this.IsZAxisScaleNormalized() ? 100 : e / (2 * this._GetTanFovYDiv2());
    }
    GetZAxisScaleFactor(e) {
      if (this.IsZAxisScaleNormalized()) {
        return e / (2 * this._GetTanFovYDiv2()) / this.GetDefaultCameraZ(e);
      }
      return 1;
    }
    SetNearZ(e) {
      this._nearZ = e;
    }
    GetNearZ() {
      return this._nearZ;
    }
    SetFarZ(e) {
      this._farZ = e;
    }
    GetFarZ() {
      return this._farZ;
    }
    SetFovY(e) {
      this._fovY = e, this._tan_fovY_2 = Math.tan(this._fovY / 2);
    }
    GetFovY() {
      return this._fovY;
    }
    _GetTanFovYDiv2() {
      return this._tan_fovY_2;
    }
    SetZAxisScaleNormalized() {
      this._zAxisScale = false;
    }
    SetZAxisScaleRegular() {
      this._zAxisScale = true;
    }
    IsZAxisScaleNormalized() {
      return !this._zAxisScale;
    }
    IsZAxisScaleRegular() {
      return this._zAxisScale;
    }
    CalculatePerspectiveMatrix(e, t2, i = 0.5, a2 = 0.5) {
      const s = this.GetNearZ(), r2 = this.GetFarZ(), l = this.GetFovY();
      if (0.5 === i && 0.5 === a2) this.IsWebGPU() ? mat4.perspectiveZO(e, l, t2, s, r2) : mat4.perspective(e, l, t2, s, r2);
      else {
        const l2 = 2 * (i = 1 - i) - 2, n = 2 * i, h2 = 2 * a2 - 2, o2 = 2 * a2, p2 = this._GetTanFovYDiv2() * s, _2 = p2 * t2;
        mat4.frustum(e, l2 * _2, n * _2, h2 * p2, o2 * p2, s, r2), this.IsWebGPU() && mat4.mul(e, matWebGLtoWebGPU, e);
      }
    }
    CalculateOrthographicMatrix(e, t2, i, a2 = 1) {
      const s = self.devicePixelRatio, r2 = 2 * this.GetDefaultCameraZ(i) * s * this._GetTanFovYDiv2() / i, l = t2 * r2 / (2 * s * a2), n = i * r2 / (2 * s * a2), h2 = -l, o2 = l, p2 = -n, _2 = n;
      this.IsWebGPU() ? mat4.orthoZO(e, h2, o2, p2, _2, this.GetNearZ(), this.GetFarZ()) : mat4.ortho(e, h2, o2, p2, _2, this.GetNearZ(), this.GetFarZ());
    }
    CalculateLookAtModelView(e, t2, i, a2, s, r2 = 1) {
      let l = 1;
      this.IsZAxisScaleNormalized() && (l = 200 * this._GetTanFovYDiv2() / s);
      const n = tmpVec3c;
      vec3.set(n, l, -l, 1);
      const h2 = tmpVec3a, o2 = tmpVec3b;
      vec3.multiply(h2, t2, n), vec3.multiply(o2, i, n), mat4.lookAt(e, h2, o2, a2 || defaultUpVector), n[2] = r2, mat4.scale(e, e, n);
    }
    CalculateLookAtModelView2(e, t2, i, a2, s, r2, l, n) {
      return vec3.set(tmpVec3a, e, t2, i), vec3.set(tmpVec3b, a2, s, r2), this.CalculateLookAtModelView(tempMat4, tmpVec3a, tmpVec3b, defaultUpVector, l, n), tempMat4;
    }
    _AddShaderProgram(e) {
      this._allShaderPrograms.push(e), this._shaderProgramsByName.set(e.GetName(), e);
    }
    _RemoveShaderProgram(e) {
      const t2 = this._allShaderPrograms.indexOf(e);
      -1 !== t2 && this._allShaderPrograms.splice(t2, 1), this._shaderProgramsByName.delete(e.GetName());
    }
    _ClearAllShaderPrograms() {
      C32.clearArray(this._allShaderPrograms), this._shaderProgramsByName.clear();
    }
    GetShaderProgramByName(e) {
      return this._shaderProgramsByName.get(e) || null;
    }
    GetTextureFillShaderProgram() {
      return this._spTextureFill;
    }
    SetTextureFillMode() {
      this.SetProgram(this._spTextureFill);
    }
    GetPointsRenderingProgram() {
      return this._spPoints;
    }
    SetPointsRenderingProgram() {
      this.SetProgram(this._spPoints);
    }
    SetTilemapFillMode() {
      this.SetProgram(this._spTilemapFill);
    }
    SetTileRandomizationMode() {
      this.SetProgram(this._spTileRandomization);
    }
    SetColorFillMode() {
      this.SetProgram(this._spColorFill);
    }
    SetLinearGradientFillMode() {
      this.SetProgram(this._spLinearGradientFill);
    }
    SetPenumbraFillMode() {
      this.SetProgram(this._spPenumbraFill);
    }
    SetHardEllipseFillMode() {
      this.SetProgram(this._spHardEllipseFill);
    }
    SetHardEllipseOutlineMode() {
      this.SetProgram(this._spHardEllipseOutline);
    }
    SetSmoothEllipseFillMode() {
      this.SetProgram(this._spSmoothEllipseFill);
    }
    SetSmoothEllipseOutlineMode() {
      this.SetProgram(this._spSmoothEllipseOutline);
    }
    SetSmoothLineFillMode() {
      this.SetProgram(this._spSmoothLineFill);
    }
    _SetCurrentStateGroup(e) {
      this._currentStateGroup = e;
    }
    GetCurrentStateGroup() {
      return this._currentStateGroup;
    }
    AcquireStateGroup(e, t2, i, a2, s, r2) {
      const l = C32.Gfx.StateGroup.MakeKey(e, t2, i, a2, s, r2);
      let n = this._stateGroups.get(l);
      return n || (n = C32.New(C32.Gfx.StateGroup, this, e, t2, i, a2, s, r2), this._stateGroups.set(l, n)), n.AddRef(), n;
    }
    ReleaseStateGroup(e) {
      e.DecRef(), 0 === e._GetRefCount() && (this._currentStateGroup === e && (this._currentStateGroup = null), this._stateGroups.delete(e.GetKey()), e.Release());
    }
    _InitBlendModeData(e) {
      C32.clearArray(this._blendModeTable), this._namedBlendModeMap.clear();
      let t2 = 0;
      for (const i of e) {
        const e2 = i[0], a2 = i[1], s = i[2];
        this._blendModeTable.push([a2, s]), this._namedBlendModeMap.set(e2, { number: t2, srcBlend: a2, destBlend: s }), t2++;
      }
    }
    _GetBlendByIndex(e) {
      return this._blendModeTable[e];
    }
    GetSrcBlendByIndex(e) {
      return this._GetBlendByIndex(e)[0];
    }
    GetDestBlendByIndex(e) {
      return this._GetBlendByIndex(e)[1];
    }
    GetNamedBlend(e) {
      const t2 = this._namedBlendModeMap.get(e);
      if (void 0 === t2) throw new Error("invalid blend name");
      return t2;
    }
    NamedBlendToNumber(e) {
      const t2 = this._namedBlendModeMap.get(e);
      if (void 0 === t2) throw new Error("invalid blend name");
      return t2.number;
    }
    SetBaseZ(e) {
      this._baseZ = e;
    }
    GetBaseZ() {
      return this._baseZ;
    }
    SetCurrentZ(e) {
      this._currentZ = e, this._currentStateGroup = null;
    }
    GetCurrentZ() {
      return this._currentZ;
    }
    Line(e, t2, i, a2) {
      const s = C32.angleTo(e, t2, i, a2), r2 = Math.sin(s), l = Math.cos(s), n = 0.5 * this._lineWidth, h2 = r2 * n, o2 = l * n, p2 = this._lineCap;
      2 === p2 ? this.LinePreCalc_LineCap2(e, t2, 0, i, a2, 0, h2, o2) : 1 === p2 ? this.LinePreCalc_LineCap1(e, t2, 0, i, a2, 0, h2, o2) : this.LinePreCalc_LineCap0(e, t2, 0, i, a2, 0, h2, o2);
    }
    Line3D(e, t2, i, a2, s, r2) {
      const l = C32.angleTo(e, t2, a2, s), n = Math.sin(l), h2 = Math.cos(l), o2 = 0.5 * this._lineWidth, p2 = n * o2, _2 = h2 * o2, c2 = this._lineCap;
      2 === c2 ? this.LinePreCalc_LineCap2(e, t2, i, a2, s, r2, p2, _2) : 1 === c2 ? this.LinePreCalc_LineCap1(e, t2, i, a2, s, r2, p2, _2) : this.LinePreCalc_LineCap0(e, t2, i, a2, s, r2, p2, _2);
    }
    LinePreCalc_LineCap2(e, t2, i, a2, s, r2, l, n) {
      const h2 = this._lineOffset, o2 = e + h2 - n, p2 = t2 + h2 - l, _2 = a2 + h2 + n, c2 = s + h2 + l, u2 = 2 * n, d2 = 2 * l, C2 = o2 + l, m2 = p2 - n, L = o2 - l + u2, g2 = p2 + n + d2, S2 = _2 + l, f2 = c2 - n, P2 = _2 - l - u2, G = c2 + n - d2;
      this.Quad3D2(C2, m2, i, S2, f2, r2, P2, G, r2, L, g2, i, defaultTexCoordsQuad);
    }
    LinePreCalc_LineCap1(e, t2, i, a2, s, r2, l, n) {
      const h2 = this._lineOffset, o2 = e + h2 - n, p2 = t2 + h2 - l, _2 = a2 + h2 + n, c2 = s + h2 + l, u2 = o2 + l, d2 = p2 - n, C2 = o2 - l, m2 = p2 + n, L = _2 + l, g2 = c2 - n, S2 = _2 - l, f2 = c2 + n;
      this.Quad3D2(u2, d2, i, L, g2, r2, S2, f2, r2, C2, m2, i, defaultTexCoordsQuad);
    }
    LinePreCalc_LineCap0(e, t2, i, a2, s, r2, l, n) {
      const h2 = this._lineOffset, o2 = e + h2, p2 = t2 + h2, _2 = a2 + h2, c2 = s + h2, u2 = o2 + l, d2 = p2 - n, C2 = o2 - l, m2 = p2 + n, L = _2 + l, g2 = c2 - n, S2 = _2 - l, f2 = c2 + n;
      this.Quad3D2(u2, d2, i, L, g2, r2, S2, f2, r2, C2, m2, i, defaultTexCoordsQuad);
    }
    TexturedLine(e, t2, i, a2, s, r2) {
      const l = C32.angleTo(e, t2, i, a2), n = Math.sin(l), h2 = Math.cos(l), o2 = 0.5 * this._lineWidth, p2 = n * o2, _2 = h2 * o2, c2 = this._lineCap;
      2 === c2 ? this.TexturedLinePreCalc_LineCap2(e, t2, i, a2, p2, _2, s, r2) : 1 === c2 ? this.TexturedLinePreCalc_LineCap1(e, t2, i, a2, p2, _2, s, r2) : this.TexturedLinePreCalc_LineCap0(e, t2, i, a2, p2, _2, s, r2);
    }
    TexturedLinePreCalc_LineCap2(e, t2, i, a2, s, r2, l, n) {
      const h2 = this._lineOffset, o2 = e + h2 - r2, p2 = t2 + h2 - s, _2 = i + h2 + r2, c2 = a2 + h2 + s, u2 = 2 * r2, d2 = 2 * s, C2 = o2 + s, m2 = p2 - r2, L = o2 - s + u2, g2 = p2 + r2 + d2, S2 = _2 + s, f2 = c2 - r2, P2 = _2 - s - u2, G = c2 + r2 - d2;
      tmpQuad.set(C2, m2, S2, f2, P2, G, L, g2), tmpRect.set(l, 0, n, 0), this.Quad3(tmpQuad, tmpRect);
    }
    TexturedLinePreCalc_LineCap1(e, t2, i, a2, s, r2, l, n) {
      const h2 = this._lineOffset, o2 = e + h2 - r2, p2 = t2 + h2 - s, _2 = i + h2 + r2, c2 = a2 + h2 + s, u2 = o2 + s, d2 = p2 - r2, C2 = o2 - s, m2 = p2 + r2, L = _2 + s, g2 = c2 - r2, S2 = _2 - s, f2 = c2 + r2;
      tmpQuad.set(u2, d2, L, g2, S2, f2, C2, m2), tmpRect.set(l, 0, n, 0), this.Quad3(tmpQuad, tmpRect);
    }
    TexturedLinePreCalc_LineCap0(e, t2, i, a2, s, r2, l, n) {
      const h2 = this._lineOffset, o2 = e + h2, p2 = t2 + h2, _2 = i + h2, c2 = a2 + h2, u2 = o2 + s, d2 = p2 - r2, C2 = o2 - s, m2 = p2 + r2, L = _2 + s, g2 = c2 - r2, S2 = _2 - s, f2 = c2 + r2;
      tmpQuad.set(u2, d2, L, g2, S2, f2, C2, m2), tmpRect.set(l, 0, n, 0), this.Quad3(tmpQuad, tmpRect);
    }
    LineRect(e, t2, i, a2) {
      const s = 0.5 * this._lineWidth, r2 = this._lineCap;
      2 === r2 ? this._LineRectPreCalc_LineCap2(e, t2, i, a2, s) : 1 === r2 ? this._LineRectPreCalc_LineCap1(e, t2, i, a2, s) : this._LineRectPreCalc_LineCap0(e, t2, i, a2, s);
    }
    _LineRectPreCalc_LineCap2(e, t2, i, a2, s) {
      this.LinePreCalc_LineCap2(e, t2, 0, i, t2, 0, 0, s), this.LinePreCalc_LineCap2(i, t2, 0, i, a2, 0, s, 0), this.LinePreCalc_LineCap2(i, a2, 0, e, a2, 0, 0, -s), this.LinePreCalc_LineCap2(e, a2, 0, e, t2, 0, -s, 0);
    }
    _LineRectPreCalc_LineCap1(e, t2, i, a2, s) {
      this.LinePreCalc_LineCap1(e, t2, 0, i, t2, 0, 0, s), this.LinePreCalc_LineCap1(i, t2, 0, i, a2, 0, s, 0), this.LinePreCalc_LineCap1(i, a2, 0, e, a2, 0, 0, -s), this.LinePreCalc_LineCap1(e, a2, 0, e, t2, 0, -s, 0);
    }
    _LineRectPreCalc_LineCap0(e, t2, i, a2, s) {
      this.LinePreCalc_LineCap0(e, t2, 0, i, t2, 0, 0, s), this.LinePreCalc_LineCap0(i, t2, 0, i, a2, 0, s, 0), this.LinePreCalc_LineCap0(i, a2, 0, e, a2, 0, 0, -s), this.LinePreCalc_LineCap0(e, a2, 0, e, t2, 0, -s, 0);
    }
    LineRect2(e) {
      this.LineRect(e.getLeft(), e.getTop(), e.getRight(), e.getBottom());
    }
    LineQuad(e) {
      const t2 = C32.angleTo(e.getTlx(), e.getTly(), e.getTrx(), e.getTry()), i = Math.sin(t2), a2 = Math.cos(t2), s = 0.5 * this._lineWidth, r2 = i * s, l = a2 * s, n = this._lineCap;
      2 === n ? this._LineQuadPreCalc_LineCap2(e, r2, l) : 1 === n ? this._LineQuadPreCalc_LineCap1(e, r2, l) : this._LineQuadPreCalc_LineCap0(e, r2, l);
    }
    _LineQuadPreCalc_LineCap2(e, t2, i) {
      this.LinePreCalc_LineCap2(e.getTlx(), e.getTly(), 0, e.getTrx(), e.getTry(), 0, t2, i), this.LinePreCalc_LineCap2(e.getTrx(), e.getTry(), 0, e.getBrx(), e.getBry(), 0, i, -t2), this.LinePreCalc_LineCap2(e.getBrx(), e.getBry(), 0, e.getBlx(), e.getBly(), 0, -t2, -i), this.LinePreCalc_LineCap2(e.getBlx(), e.getBly(), 0, e.getTlx(), e.getTly(), 0, -i, t2);
    }
    _LineQuadPreCalc_LineCap1(e, t2, i) {
      this.LinePreCalc_LineCap1(e.getTlx(), e.getTly(), 0, e.getTrx(), e.getTry(), 0, t2, i), this.LinePreCalc_LineCap1(e.getTrx(), e.getTry(), 0, e.getBrx(), e.getBry(), 0, i, -t2), this.LinePreCalc_LineCap1(e.getBrx(), e.getBry(), 0, e.getBlx(), e.getBly(), 0, -t2, -i), this.LinePreCalc_LineCap1(e.getBlx(), e.getBly(), 0, e.getTlx(), e.getTly(), 0, -i, t2);
    }
    _LineQuadPreCalc_LineCap0(e, t2, i) {
      this.LinePreCalc_LineCap0(e.getTlx(), e.getTly(), 0, e.getTrx(), e.getTry(), 0, t2, i), this.LinePreCalc_LineCap0(e.getTrx(), e.getTry(), 0, e.getBrx(), e.getBry(), 0, i, -t2), this.LinePreCalc_LineCap0(e.getBrx(), e.getBry(), 0, e.getBlx(), e.getBly(), 0, -t2, -i), this.LinePreCalc_LineCap0(e.getBlx(), e.getBly(), 0, e.getTlx(), e.getTly(), 0, -i, t2);
    }
    SetLineWidth(e) {
      this._lineWidth = e, this._lineWidthStack[this._lineWidthStack.length - 1] = e;
    }
    GetLineWidth() {
      return this._lineWidth;
    }
    PushLineWidth(e) {
      if (this._lineWidthStack.length >= 100) throw new Error("pushed too many line widths - check push/pop pairs");
      this._lineWidthStack.push(e), this._lineWidth = e;
    }
    PopLineWidth() {
      if (this._lineWidthStack.length <= 1) throw new Error("cannot pop last line width - check push/pop pairs");
      this._lineWidthStack.pop(), this._lineWidth = this._lineWidthStack.at(-1);
    }
    SetLineCapButt() {
      this._lineCap = 0, this._lineCapStack[this._lineCapStack.length - 1] = 0;
    }
    SetLineCapSquare() {
      this._lineCap = 1, this._lineCapStack[this._lineCapStack.length - 1] = 0;
    }
    SetLineCapZag() {
      this._lineCap = 2, this._lineCapStack[this._lineCapStack.length - 1] = 0;
    }
    PushLineCap(e) {
      if ("butt" === e) this.PushLineCapButt();
      else if ("square" === e) this.PushLineCapSquare();
      else {
        if ("zag" !== e) throw new Error("invalid line cap");
        this.PushLineCapZag();
      }
    }
    PushLineCapButt() {
      if (this._lineCapStack.length >= 100) throw new Error("pushed too many line caps - check push/pop pairs");
      this._lineCapStack.push(0), this._lineCap = 0;
    }
    PushLineCapSquare() {
      if (this._lineCapStack.length >= 100) throw new Error("pushed too many line caps - check push/pop pairs");
      this._lineCapStack.push(1), this._lineCap = 1;
    }
    PushLineCapZag() {
      if (this._lineCapStack.length >= 100) throw new Error("pushed too many line caps - check push/pop pairs");
      this._lineCapStack.push(2), this._lineCap = 2;
    }
    PopLineCap() {
      if (this._lineCapStack.length <= 1) throw new Error("cannot pop last line cap - check push/pop pairs");
      this._lineCapStack.pop(), this._lineCap = this._lineCapStack.at(-1);
    }
    SetLineOffset(e) {
      this._lineOffset = e, this._lineOffsetStack[this._lineOffsetStack.length - 1] = e;
    }
    GetLineOffset() {
      return this._lineOffset;
    }
    PushLineOffset(e) {
      if (this._lineOffsetStack.length >= 100) throw new Error("pushed too many line offsets - check push/pop pairs");
      this._lineOffsetStack.push(e), this._lineOffset = e;
    }
    PopLineOffset() {
      if (this._lineOffsetStack.length <= 1) throw new Error("cannot pop last line offset - check push/pop pairs");
      this._lineOffsetStack.pop(), this._lineOffset = this._lineOffsetStack.at(-1);
    }
    ResetCullState() {
      this.SetCullFaceMode(0), this.SetFrontFaceWinding(0);
    }
    ConvexPoly(e) {
      const t2 = e.length / 2;
      if (t2 < 3) throw new Error("need at least 3 points");
      const i = t2 - 2, a2 = i - 1, s = e[0], r2 = e[1];
      for (let t3 = 0; t3 < i; t3 += 2) {
        const i2 = 2 * t3, l = e[i2 + 2], n = e[i2 + 3], h2 = e[i2 + 4], o2 = e[i2 + 5];
        if (t3 === a2) this.Quad2(s, r2, l, n, h2, o2, h2, o2);
        else {
          const t4 = e[i2 + 6], a3 = e[i2 + 7];
          this.Quad2(s, r2, l, n, h2, o2, t4, a3);
        }
      }
    }
    Finish() {
      this.EndBatch(true), this._frameNumber++;
    }
    GetFrameNumber() {
      return this._frameNumber;
    }
    IncrementFrameNumber() {
      this._frameNumber++;
    }
    SetMipmapsEnabled(e) {
      this._enableMipmaps = !!e;
    }
    AreMipmapsEnabled() {
      return this._enableMipmaps;
    }
    SetHasMajorPerformanceCaveat(e) {
      this._hasMajorPerformanceCaveat = !!e;
    }
    HasMajorPerformanceCaveat() {
      return this._hasMajorPerformanceCaveat;
    }
    IsWebGL() {
      return false;
    }
    IsWebGPU() {
      return false;
    }
    GetEstimatedBackBufferMemoryUsage() {
    }
    GetEstimatedRenderBufferMemoryUsage() {
    }
    GetEstimatedTextureMemoryUsage() {
    }
    GetEstimatedTotalMemoryUsage() {
      return this.GetEstimatedBackBufferMemoryUsage() + this.GetEstimatedRenderBufferMemoryUsage() + this.GetEstimatedTextureMemoryUsage();
    }
    CreateRendererText() {
      return C32.New(C32.Gfx.RendererText, this);
    }
  };
}
{
  const C32 = self.C3;
  C32.Gfx.ShaderProgramBase = class {
    constructor(e, t2) {
      this._name = t2.name, this._renderer = e, this._extendBoxHorizontal = t2.extendBoxHorizontal || 0, this._extendBoxVertical = t2.extendBoxVertical || 0, this._crossSampling = !!t2.crossSampling, this._mustPreDraw = !!t2.mustPreDraw, this._preservesOpaqueness = !!t2.preservesOpaqueness, this._supports3dDirectRendering = !!t2.supports3dDirectRendering, this._animated = !!t2.animated, this._blendsBackground = !!t2.blendsBackground, this._usesDepth = !!t2.usesDepth, this._usesAnySrcRectOrPixelSize = false, this._needsPostDrawOrExtendBox = this._crossSampling || this._blendsBackground || 0 !== this._extendBoxHorizontal || 0 !== this._extendBoxVertical;
    }
    Release() {
      this._renderer = null;
    }
    GetRenderer() {
      return this._renderer;
    }
    GetName() {
      return this._name;
    }
    ExtendsBox() {
      return 0 !== this._extendBoxHorizontal || 0 !== this._extendBoxVertical;
    }
    GetBoxExtendHorizontal() {
      return this._extendBoxHorizontal;
    }
    GetBoxExtendVertical() {
      return this._extendBoxVertical;
    }
    UsesCrossSampling() {
      return this._crossSampling;
    }
    MustPreDraw() {
      return this._mustPreDraw;
    }
    PreservesOpaqueness() {
      return this._preservesOpaqueness;
    }
    Supports3DDirectRendering() {
      return this._supports3dDirectRendering;
    }
    IsAnimated() {
      return this._animated;
    }
    BlendsBackground() {
      return this._blendsBackground;
    }
    UsesDepth() {
      return this._usesDepth;
    }
    UsesAnySrcRectOrPixelSize() {
      return this._usesAnySrcRectOrPixelSize;
    }
    NeedsPostDrawOrExtendsBox() {
      return this._needsPostDrawOrExtendBox;
    }
    UsesIsSrcTexRotated() {
      return false;
    }
  };
}
{
  const C32 = self.C3;
  C32.Gfx.StateGroup = class {
    constructor(e, r2, t2, s, o2, a2, i) {
      this._renderer = e, this._refCount = 0, this._shaderProgram = null, this._shaderProgramName = "", this._blendMode = t2, this._color = C32.New(C32.Color), this._color.set(s), this._zElevation = o2, this._cullFaceMode = a2, this._frontFaceWinding = i, "string" == typeof r2 ? this._shaderProgramName = r2 : (this._shaderProgram = r2, this._shaderProgramName = this._shaderProgram.GetName());
    }
    Release() {
      if (this._refCount > 0) throw new Error("releasing state group still in use");
      this._renderer = null, this._shaderProgram = null, this._shaderProgramName = "";
    }
    Apply() {
      const e = this._renderer;
      e.SetProgram(this._shaderProgram), e.SetBlendMode(this._blendMode), e.SetColor(this._color), e.SetCurrentZ(this._zElevation), e.SetCullFaceMode(this._cullFaceMode), e.SetFrontFaceWinding(this._frontFaceWinding), e._SetCurrentStateGroup(this);
    }
    GetKey() {
      return C32.Gfx.StateGroup.MakeKey(this._shaderProgramName, this._blendMode, this._color, this._zElevation, this._cullFaceMode, this._frontFaceWinding);
    }
    AddRef() {
      ++this._refCount;
    }
    DecRef() {
      --this._refCount;
    }
    _GetRefCount() {
      return this._refCount;
    }
    OnContextLost() {
      this._shaderProgram = null;
    }
    OnContextRestored(e) {
      if (this._shaderProgram = e.GetShaderProgramByName(this._shaderProgramName), !this._shaderProgram) throw new Error("failed to restore shader program");
    }
    static MakeKey(e, r2, t2, s, o2, a2) {
      return ("string" == typeof e ? e : e.GetName()) + "," + r2 + "," + t2.getR() + "," + t2.getG() + "," + t2.getB() + "," + t2.getA() + "," + s + "," + o2 + "," + a2;
    }
  };
}
{
  let interpolateQuad = function(t2, e, s) {
    const i = s.getTlx(), n = s.getTly(), r2 = s.getTrx() - i, h2 = s.getTry() - n;
    return [i + r2 * t2 + (s.getBlx() - i) * e, n + h2 * t2 + (s.getBly() - n) * e];
  };
  interpolateQuad2 = interpolateQuad;
  const C32 = globalThis.C3, assert = globalThis.assert, MAX_VERTICES = 65535;
  C32.Gfx.MeshPoint = class {
    constructor(t2, e, s) {
      this._mesh = t2, this._col = e, this._row = s, this._x = NaN, this._y = NaN, this._zElevation = NaN, this._u = NaN, this._v = NaN, this._x = 0, this._y = 0, this._zElevation = 0, this._u = 0, this._v = 0;
    }
    _Init(t2, e, s, i) {
      this._x = t2, this._y = e, this._u = s, this._v = i;
    }
    GetX() {
      return this._x;
    }
    SetX(t2) {
      this._x !== t2 && (this._x = t2, this._mesh._SetPointsChanged());
    }
    GetY() {
      return this._y;
    }
    SetY(t2) {
      this._y !== t2 && (this._y = t2, this._mesh._SetPointsChanged());
    }
    GetZElevation() {
      return this._zElevation;
    }
    SetZElevation(t2) {
      this._zElevation !== t2 && (this._zElevation = Math.max(t2, 0), this._mesh._SetPointsChanged());
    }
    GetU() {
      return this._u;
    }
    SetU(t2) {
      this._u = t2;
    }
    GetV() {
      return this._v;
    }
    SetV(t2) {
      this._v = t2;
    }
    _Interpolate_TexRect(t2, e, s) {
      [this._x, this._y] = interpolateQuad(t2._x, t2._y, e), this._zElevation = t2._zElevation, this._u = C32.lerp(s.getLeft(), s.getRight(), t2._u), this._v = C32.lerp(s.getTop(), s.getBottom(), t2._v);
    }
    _Interpolate_TexQuad(t2, e, s) {
      [this._x, this._y] = interpolateQuad(t2._x, t2._y, e), this._zElevation = t2._zElevation, [this._u, this._v] = interpolateQuad(t2._u, t2._v, s);
    }
    SaveToJson() {
      return { "x": this.GetX(), "y": this.GetY(), "z": this.GetZElevation(), "u": this.GetU(), "v": this.GetV() };
    }
    LoadFromJson(t2) {
      this.SetX(t2["x"]), this.SetY(t2["y"]), t2.hasOwnProperty("z") && this.SetZElevation(t2["z"]), this.SetU(t2["u"]), this.SetV(t2["v"]);
    }
    GetMesh() {
      return this._mesh;
    }
    GetColumn() {
      return this._col;
    }
    GetRow() {
      return this._row;
    }
  }, C32.Gfx.Mesh = class {
    constructor(t2, e, s) {
      if (t2 < 2 || e < 2) throw new Error("invalid mesh size");
      this._hsize = t2, this._vsize = e, this._owner = s || null, this._pts = [], this._minX = 0, this._minY = 0, this._maxX = 1, this._maxY = 1, this._maxZ = 0, this._bboxChanged = false, this._meshChunks = [], this._lastZOffset = 0, this._dataArrsChanged = true;
      const i = t2 - 1, n = e - 1;
      for (let s2 = 0; s2 < e; ++s2) {
        const e2 = [];
        for (let r2 = 0; r2 < t2; ++r2) {
          const t3 = C32.New(C32.Gfx.MeshPoint, this, r2, s2), h2 = r2 / i, o2 = s2 / n;
          t3._Init(h2, o2, h2, o2), e2.push(t3);
        }
        this._pts.push(e2);
      }
    }
    Release() {
      C32.clearArray(this._pts), C32.clearArray(this._meshChunks);
    }
    GetHSize() {
      return this._hsize;
    }
    GetVSize() {
      return this._vsize;
    }
    GetOwner() {
      return this._owner;
    }
    _GetPoints() {
      return this._pts;
    }
    _SetPointsChanged() {
      this._bboxChanged = true, this._dataArrsChanged = true;
    }
    _MaybeComputeBounds() {
      if (!this._bboxChanged) return;
      let t2 = 1 / 0, e = 1 / 0, s = -1 / 0, i = -1 / 0, n = 0;
      for (const r2 of this._pts) for (const h2 of r2) {
        const r3 = h2.GetX(), o2 = h2.GetY();
        t2 = Math.min(t2, r3), e = Math.min(e, o2), s = Math.max(s, r3), i = Math.max(i, o2), n = Math.max(n, h2.GetZElevation());
      }
      this._minX = t2, this._minY = e, this._maxX = s, this._maxY = i, this._maxZ = n, this._bboxChanged = false;
    }
    GetMinX() {
      return this._MaybeComputeBounds(), this._minX;
    }
    GetMinY() {
      return this._MaybeComputeBounds(), this._minY;
    }
    GetMaxX() {
      return this._MaybeComputeBounds(), this._maxX;
    }
    GetMaxY() {
      return this._MaybeComputeBounds(), this._maxY;
    }
    GetMaxZ() {
      return this._MaybeComputeBounds(), this._maxZ;
    }
    HasAnyZElevation() {
      return this.GetMaxZ() > 0;
    }
    GetMeshPointAt(t2, e) {
      return t2 = Math.floor(t2), e = Math.floor(e), t2 < 0 || t2 >= this._hsize || e < 0 || e >= this._vsize ? null : this._pts[e][t2];
    }
    CalculateTransformedMesh(t2, e, s) {
      const i = s instanceof C32.Rect;
      if (t2.GetHSize() !== this.GetHSize() || t2.GetVSize() !== this.GetVSize()) throw new Error("source mesh wrong size");
      const n = t2._pts, r2 = this._pts;
      for (let t3 = 0, h2 = r2.length; t3 < h2; ++t3) {
        const h3 = n[t3], o2 = r2[t3];
        for (let t4 = 0, n2 = o2.length; t4 < n2; ++t4) {
          const n3 = h3[t4], r3 = o2[t4];
          i ? r3._Interpolate_TexRect(n3, e, s) : r3._Interpolate_TexQuad(n3, e, s);
        }
      }
      this._dataArrsChanged = true;
    }
    _MaybeUpdateDataArrays(t2) {
      if (!this._dataArrsChanged && this._lastZOffset === t2) return;
      const e = this._hsize, s = this._vsize, i = this._meshChunks, n = Math.floor(65535 / e) - 1;
      if (n <= 0) throw new Error("mesh too large");
      const r2 = Math.ceil((s - 1) / n);
      r2 < i.length && (i.length = r2);
      let h2 = 0;
      for (let o2 = 0; o2 < r2; ++o2) {
        const r3 = Math.min(n, s - h2 - 1), a2 = (r3 + 1) * e, l = 3 * a2, _2 = 2 * a2, u2 = (e - 1) * r3 * 6;
        if (o2 === i.length) i.push({ posArr: new Float32Array(l), uvArr: new Float32Array(_2), indexArr: new Uint16Array(u2) });
        else {
          const t3 = i[o2];
          t3.posArr.length !== l && (t3.posArr = new Float32Array(l)), t3.uvArr.length !== _2 && (t3.uvArr = new Float32Array(_2)), t3.indexArr.length !== u2 && (t3.indexArr = new Uint16Array(u2));
        }
        const { posArr: c2, uvArr: G, indexArr: m2 } = i[o2];
        this._WriteChunkDataArrays(h2, r3, t2, c2, G, m2), h2 += n;
      }
      this._lastZOffset = t2, this._dataArrsChanged = false;
    }
    _WriteChunkDataArrays(t2, e, s, i, n, r2) {
      const h2 = this._pts, o2 = this._hsize;
      let a2 = 0, l = 0, _2 = 0;
      for (let u2 = t2, c2 = t2 + e + 1; u2 < c2; ++u2) {
        const e2 = h2[u2], G = u2 + 1, m2 = u2 - t2, C2 = m2 * o2, f2 = (m2 + 1) * o2;
        for (let t3 = 0, h3 = e2.length; t3 < h3; ++t3) {
          const o3 = e2[t3], u3 = t3 + 1;
          if (i[a2++] = o3.GetX(), i[a2++] = o3.GetY(), i[a2++] = o3.GetZElevation() + s, n[l++] = o3.GetU(), n[l++] = o3.GetV(), u3 < h3 && G < c2) {
            const e3 = t3 + C2, s2 = u3 + C2, i2 = u3 + f2, n2 = t3 + f2;
            r2[_2++] = e3, r2[_2++] = s2, r2[_2++] = i2, r2[_2++] = e3, r2[_2++] = i2, r2[_2++] = n2;
          }
        }
      }
    }
    Draw(t2, e) {
      this._MaybeUpdateDataArrays(e);
      for (const { posArr: e2, uvArr: s, indexArr: i } of this._meshChunks) t2.DrawMesh(e2, s, i);
    }
    Outline(t2, e) {
      e || (e = (t3, e2, s2) => [t3, e2, s2]);
      const s = this._pts;
      let i = s[0];
      for (let n = 1, r2 = s.length; n < r2; ++n) {
        const h2 = s[n];
        let o2 = i[0], a2 = h2[0];
        for (let s2 = 1, l = h2.length; s2 < l; ++s2) {
          const _2 = i[s2], u2 = h2[s2], [c2, G, m2] = e(o2.GetX(), o2.GetY(), o2.GetZElevation()), [C2, f2, p2] = e(_2.GetX(), _2.GetY(), _2.GetZElevation()), [g2, y2, d2] = e(u2.GetX(), u2.GetY(), u2.GetZElevation()), [x2, M2, v2] = e(a2.GetX(), a2.GetY(), a2.GetZElevation());
          t2.Line3D(c2, G, m2, C2, f2, p2), t2.Line3D(c2, G, m2, g2, y2, d2), t2.Line3D(c2, G, m2, x2, M2, v2), s2 === l - 1 && t2.Line3D(C2, f2, p2, g2, y2, d2), n === r2 - 1 && t2.Line3D(x2, M2, v2, g2, y2, d2), o2 = _2, a2 = u2;
        }
        i = h2;
      }
    }
    InsertPolyMeshVertices(t2) {
      const e = 1e-3, s = 0.99999999, i = t2.pointsArr(), n = [], r2 = this.GetHSize() - 1, h2 = this.GetVSize() - 1, o2 = 1 / r2, a2 = 1 / h2, l = r2 - 1, _2 = h2 - 1;
      let u2 = i[0], c2 = i[1], G = C32.clamp(Math.floor(u2 * r2), 0, l), m2 = C32.clamp(Math.floor(c2 * h2), 0, _2), C2 = true, f2 = 0, p2 = 0, g2 = 0;
      let y2 = -1;
      const d2 = () => {
        u2 = C32.clamp(C32.lerp(u2, f2, g2), 0, 1), c2 = C32.clamp(C32.lerp(c2, p2, g2), 0, 1), n.push(u2, c2);
      };
      for (let t3 = 0, x2 = i.length; t3 < x2; t3 += 2) {
        u2 = i[t3], c2 = i[t3 + 1], n.push(u2, c2), G = C32.clamp(Math.floor(u2 * r2), 0, l), m2 = C32.clamp(Math.floor(c2 * h2), 0, _2);
        const M2 = (t3 + 2) % x2;
        for (f2 = i[M2], p2 = i[M2 + 1], y2 = -1; ; ) {
          if (n.length > 1e6) throw new Error("Too many mesh poly points");
          const t4 = G * o2, i2 = m2 * a2, r3 = (G + 1) * o2, h3 = (m2 + 1) * a2;
          if (C2 = C32.isPointInTriangleInclusive(u2, c2, t4, i2, r3, i2, r3, h3), 0 !== y2 && (g2 = C32.rayIntersectExtended(u2, c2, f2, p2, t4, i2, r3, h3, -1e-3), g2 >= 0 && g2 <= s)) d2(), C2 = !C2, y2 = 0;
          else if (m2 > 0 && 2 !== y2 && (g2 = C32.rayIntersectExtended(u2, c2, f2, p2, t4, i2, r3, i2, e), g2 >= 0 && g2 <= s)) d2(), m2--, C2 = false, y2 = 4;
          else if (G < l && 3 !== y2 && (g2 = C32.rayIntersectExtended(u2, c2, f2, p2, r3, i2, r3, h3, e), g2 >= 0 && g2 <= s)) d2(), G++, C2 = false, y2 = 1;
          else if (G > 0 && 1 !== y2 && (g2 = C32.rayIntersectExtended(u2, c2, f2, p2, t4, i2, t4, h3, e), g2 >= 0 && g2 <= s)) d2(), G--, C2 = true, y2 = 3;
          else {
            if (!(m2 < _2 && 4 !== y2 && (g2 = C32.rayIntersectExtended(u2, c2, f2, p2, t4, h3, r3, h3, e), g2 >= 0 && g2 <= s))) break;
            d2(), m2++, C2 = true, y2 = 2;
          }
        }
      }
      return C32.New(C32.CollisionPoly, n);
    }
    TransformCollisionPoly(t2, e) {
      const s = this._TransformPolyPoints(t2);
      this._SimplifyPoly(s), e.setPoints(s);
    }
    _TransformPolyPoints(t2) {
      const e = [], s = t2.pointsArr();
      for (let t3 = 0, i = s.length; t3 < i; t3 += 2) {
        const i2 = s[t3], n = s[t3 + 1], [r2, h2] = this.TransformPoint(i2, n);
        e.push(r2, h2);
      }
      return e;
    }
    TransformPoint(t2, e) {
      const s = this.GetHSize() - 1, i = this.GetVSize() - 1, n = 1 / s, r2 = 1 / i, h2 = C32.clamp(Math.floor(t2 * s), 0, s - 1), o2 = C32.clamp(Math.floor(e * i), 0, i - 1), a2 = h2 * n, l = o2 * r2, _2 = (h2 + 1) * n, u2 = (o2 + 1) * r2, c2 = this.GetMeshPointAt(h2, o2), G = this.GetMeshPointAt(h2 + 1, o2 + 1), m2 = C32.isPointInTriangleInclusive(t2, e, a2, l, _2, l, _2, u2), C2 = m2 ? a2 + n : a2, f2 = m2 ? l : l + r2, p2 = this.GetMeshPointAt(h2 + (m2 ? 1 : 0), o2 + (m2 ? 0 : 1)), [g2, y2, d2] = C32.triangleCartesianToBarycentric(t2, e, a2, l, C2, f2, _2, u2);
      return C32.triangleBarycentricToCartesian3d(g2, y2, d2, c2.GetX(), c2.GetY(), c2.GetZElevation(), p2.GetX(), p2.GetY(), p2.GetZElevation(), G.GetX(), G.GetY(), G.GetZElevation());
    }
    _SimplifyPoly(t2) {
      const e = [], s = 1e-7;
      let i = t2[0], n = t2[1], r2 = i - t2.at(-2), h2 = n - t2.at(-1);
      for (let o2 = 0, a2 = t2.length; o2 < a2; o2 += 2) {
        const l = (o2 + 2) % a2, _2 = t2[l], u2 = t2[l + 1], c2 = _2 - i, G = u2 - n, m2 = Math.abs(c2) < s && Math.abs(r2) < s && Math.sign(G) === Math.sign(h2), C2 = Math.abs(G) < s && Math.abs(h2) < s && Math.sign(c2) === Math.sign(r2);
        (!m2 && !C2 && Math.abs(c2 / r2 - G / h2) > 1e-3 || 0 == c2 && 0 === G) && e.push(i, n), i = _2, n = u2, r2 = c2, h2 = G;
      }
      e.length >= 6 && e.length < t2.length && C32.shallowAssignArray(t2, e);
    }
    SaveToJson() {
      return { "cols": this.GetHSize(), "rows": this.GetVSize(), "points": this._pts.map((t2) => t2.map((t3) => t3.SaveToJson())) };
    }
    LoadFromJson(t2) {
      const e = this.GetHSize(), s = this.GetVSize();
      if (t2["cols"] !== e || t2["rows"] !== s) throw new Error("mesh data wrong size");
      const i = t2["points"];
      for (let t3 = 0; t3 < s; ++t3) {
        const s2 = i[t3];
        for (let i2 = 0; i2 < e; ++i2) {
          this.GetMeshPointAt(i2, t3).LoadFromJson(s2[i2]);
        }
      }
    }
  };
}
var interpolateQuad2;
{
  let GetFormatSpecifiers = function(e, t2) {
    let i, r2, a2, s;
    switch (e) {
      case "rgba8":
        i = t2.RGBA8, r2 = t2.RGBA, a2 = t2.RGBA, s = t2.UNSIGNED_BYTE;
        break;
      case "rgb8":
        i = t2.RGB8, r2 = t2.RGB, a2 = t2.RGB, s = t2.UNSIGNED_BYTE;
        break;
      case "rgba4":
        i = t2.RGBA4, r2 = t2.RGBA, a2 = t2.RGBA, s = t2.UNSIGNED_SHORT_4_4_4_4;
        break;
      case "rgb5_a1":
        i = t2.RGB5_A1, r2 = t2.RGBA, a2 = t2.RGBA, s = t2.UNSIGNED_SHORT_5_5_5_1;
        break;
      case "rgb565":
        i = t2.RGB565, r2 = t2.RGB, a2 = t2.RGB, s = t2.UNSIGNED_SHORT_5_6_5;
        break;
      default:
        throw new Error("invalid pixel format");
    }
    return { sizedinternalformat: i, internalformat: r2, format: a2, type: s };
  };
  GetFormatSpecifiers2 = GetFormatSpecifiers;
  const C32 = self.C3, VALID_PIXEL_FORMATS = /* @__PURE__ */ new Set(["rgba8", "rgb8", "rgba4", "rgb5_a1", "rgb565"]), VALID_SAMPLINGS = /* @__PURE__ */ new Set(["nearest", "bilinear", "trilinear"]), VALID_MIPMAP_QUALITIES = /* @__PURE__ */ new Set(["default", "low", "high"]), VALID_WRAP_MODES = /* @__PURE__ */ new Set(["clamp-to-edge", "repeat", "mirror-repeat"]);
  const CREATEFROM_DEFAULT_OPTIONS = { wrapX: "clamp-to-edge", wrapY: "clamp-to-edge", sampling: "trilinear", anisotropy: 0, pixelFormat: "rgba8", mipMap: true, mipMapQuality: "default", premultiplyAlpha: true, isSvg: false, width: -1, height: -1 }, UPDATE_DEFAULT_OPTIONS = { premultiplyAlpha: true, flipY: false }, allTextures = /* @__PURE__ */ new Set();
  C32.Gfx.WebGLRendererTexture = class {
    constructor(e) {
      this._renderer = e, this._texture = null, this._width = 0, this._height = 0, this._isStatic = true, this._wrapX = "clamp-to-edge", this._wrapY = "clamp-to-edge", this._sampling = "trilinear", this._anisotropy = 0, this._pixelFormat = "rgba8", this._isMipMapped = false, this._mipMapQuality = "default", this._refCount = 0;
    }
    _CreateStatic(e, t2) {
      if (!("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap || "undefined" != typeof OffscreenCanvas && e instanceof OffscreenCanvas || e instanceof ImageData || e instanceof ArrayBuffer)) throw new Error("invalid texture source");
      if (t2 = Object.assign({}, CREATEFROM_DEFAULT_OPTIONS, t2), this._texture) throw new Error("already created texture");
      if (this._wrapX = t2.wrapX, this._wrapY = t2.wrapY, this._sampling = t2.sampling, this._anisotropy = t2.anisotropy, this._pixelFormat = t2.pixelFormat, this._isMipMapped = !!t2.mipMap && this._renderer.AreMipmapsEnabled(), this._mipMapQuality = t2.mipMapQuality, !VALID_WRAP_MODES.has(this._wrapX) || !VALID_WRAP_MODES.has(this._wrapY)) throw new Error("invalid wrap mode");
      if (!VALID_SAMPLINGS.has(this._sampling)) throw new Error("invalid sampling");
      if (!VALID_PIXEL_FORMATS.has(this._pixelFormat)) throw new Error("invalid pixel format");
      if (!VALID_MIPMAP_QUALITIES.has(this._mipMapQuality)) throw new Error("invalid mipmap quality");
      if (this._isStatic = true, e instanceof ArrayBuffer || null === e || t2.isSvg) {
        if (this._width = t2.width, this._height = t2.height, e instanceof ArrayBuffer && e.byteLength !== this._width * this._height * 4) throw new Error("ArrayBuffer wrong size");
      } else this._width = e.width, this._height = e.height;
      if (this._width <= 0 || this._height <= 0) throw new Error("invalid texture data size");
      if (t2.isSvg) {
        const t3 = C32.CreateCanvas(this._width, this._height);
        t3.getContext("2d").drawImage(e, 0, 0, this._width, this._height), e = t3;
      }
      const i = C32.isPOT(this._width) && C32.isPOT(this._height), r2 = this._renderer.GetMaxTextureSize();
      if (this._width > r2 || this._height > r2) throw new Error("texture data exceeds maximum texture size");
      const a2 = this._renderer.GetContext(), s = this._renderer.GetWebGLVersionNumber();
      this._texture = a2.createTexture(), a2.bindTexture(a2.TEXTURE_2D, this._texture), a2.pixelStorei(a2["UNPACK_PREMULTIPLY_ALPHA_WEBGL"], t2.premultiplyAlpha), a2.pixelStorei(a2["UNPACK_FLIP_Y_WEBGL"], false);
      const h2 = GetFormatSpecifiers(this._pixelFormat, a2);
      if (this._renderer.SupportsNPOTTextures() || i || !this._IsTiled()) if (s >= 2) {
        let t3;
        t3 = this._isMipMapped ? Math.floor(Math.log2(Math.max(this._width, this._height)) + 1) : 1, a2.texStorage2D(a2.TEXTURE_2D, t3, h2.sizedinternalformat, this._width, this._height), e instanceof ArrayBuffer ? a2.texSubImage2D(a2.TEXTURE_2D, 0, 0, 0, this._width, this._height, h2.format, h2.type, new Uint8Array(e)) : null !== e && a2.texSubImage2D(a2.TEXTURE_2D, 0, 0, 0, h2.format, h2.type, e);
      } else e instanceof ArrayBuffer ? a2.texImage2D(a2.TEXTURE_2D, 0, h2.internalformat, this._width, this._height, 0, h2.format, h2.type, new Uint8Array(e)) : null === e ? a2.texImage2D(a2.TEXTURE_2D, 0, h2.internalformat, this._width, this._height, 0, h2.format, h2.type, null) : a2.texImage2D(a2.TEXTURE_2D, 0, h2.internalformat, h2.format, h2.type, e);
      else {
        if (null === e) throw new Error("cannot pass null data when creating a NPOT tiled texture without NPOT support");
        if (e instanceof ArrayBuffer && (e = new ImageData(new Uint8ClampedArray(e), this._width, this._height)), e instanceof ImageData) {
          const t4 = C32.CreateCanvas(this._width, this._height);
          t4.getContext("2d").putImageData(e, 0, 0), e = t4;
        }
        const t3 = C32.CreateCanvas(C32.nextHighestPowerOfTwo(this._width), C32.nextHighestPowerOfTwo(this._height)), i2 = t3.getContext("2d");
        i2.imageSmoothingEnabled = "nearest" !== this._sampling, i2.drawImage(e, 0, 0, this._width, this._height, 0, 0, t3.width, t3.height), a2.texImage2D(a2.TEXTURE_2D, 0, h2.internalformat, h2.format, h2.type, t3);
      }
      null !== e && this._SetTextureParameters(a2), a2.bindTexture(a2.TEXTURE_2D, null), this._renderer._ResetLastTexture(), this._refCount = 1, allTextures.add(this);
    }
    _CreateDynamic(e, t2, i) {
      if (i = Object.assign({}, CREATEFROM_DEFAULT_OPTIONS, i), this._texture) throw new Error("already created texture");
      if (this._wrapX = i.wrapX, this._wrapY = i.wrapY, this._sampling = i.sampling, this._pixelFormat = i.pixelFormat, this._isMipMapped = !!i.mipMap && this._renderer.AreMipmapsEnabled(), this._mipMapQuality = i.mipMapQuality, !VALID_WRAP_MODES.has(this._wrapX) || !VALID_WRAP_MODES.has(this._wrapY)) throw new Error("invalid wrap mode");
      if (!VALID_SAMPLINGS.has(this._sampling)) throw new Error("invalid sampling");
      if (!VALID_PIXEL_FORMATS.has(this._pixelFormat)) throw new Error("invalid pixel format");
      if (!VALID_MIPMAP_QUALITIES.has(this._mipMapQuality)) throw new Error("invalid mipmap quality");
      this._isStatic = false, this._width = Math.floor(e), this._height = Math.floor(t2);
      const r2 = C32.isPOT(this._width) && C32.isPOT(this._height), a2 = this._renderer.GetMaxTextureSize();
      if (this._width <= 0 || this._height <= 0) throw new Error("invalid texture size");
      if (this._width > a2 || this._height > a2) throw new Error("texture exceeds maximum texture size");
      if (!this._renderer.SupportsNPOTTextures() && this._IsTiled() && !r2) throw new Error("non-power-of-two tiled textures not supported");
      const s = this._renderer.GetContext(), h2 = this._renderer.GetWebGLVersionNumber();
      this._texture = s.createTexture(), s.bindTexture(s.TEXTURE_2D, this._texture), s.pixelStorei(s["UNPACK_PREMULTIPLY_ALPHA_WEBGL"], i.premultiplyAlpha), s.pixelStorei(s["UNPACK_FLIP_Y_WEBGL"], false);
      const n = GetFormatSpecifiers(this._pixelFormat, s), _2 = h2 >= 2 ? n.sizedinternalformat : n.internalformat;
      s.texImage2D(s.TEXTURE_2D, 0, _2, this._width, this._height, 0, n.format, n.type, null), this._SetTextureParameters(s), s.bindTexture(s.TEXTURE_2D, null), this._renderer._ResetLastTexture(), this._refCount = 1, allTextures.add(this);
    }
    _GetMipMapHint(e) {
      if ("default" === this._mipMapQuality) return this._isStatic ? e.NICEST : e.FASTEST;
      if ("low" === this._mipMapQuality) return e.FASTEST;
      if ("high" === this._mipMapQuality) return e.NICEST;
      throw new Error("invalid mipmap quality");
    }
    _IsTiled() {
      return "clamp-to-edge" !== this._wrapX || "clamp-to-edge" !== this._wrapY;
    }
    _GetTextureWrapMode(e, t2) {
      if ("clamp-to-edge" === t2) return e.CLAMP_TO_EDGE;
      if ("repeat" === t2) return e.REPEAT;
      if ("mirror-repeat" === t2) return e.MIRRORED_REPEAT;
      throw new Error("invalid wrap mode");
    }
    _SetTextureParameters(e) {
      const t2 = C32.isPOT(this._width) && C32.isPOT(this._height);
      if (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, this._GetTextureWrapMode(e, this._wrapX)), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, this._GetTextureWrapMode(e, this._wrapY)), "nearest" === this._sampling) e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST), this._isMipMapped = false;
      else if (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR), (t2 || this._renderer.SupportsNPOTTextures()) && this._isMipMapped) {
        e.hint(e.GENERATE_MIPMAP_HINT, this._GetMipMapHint(e)), e.generateMipmap(e.TEXTURE_2D);
        const t3 = "trilinear" === this._sampling && !this._renderer.HasMajorPerformanceCaveat();
        e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t3 ? e.LINEAR_MIPMAP_LINEAR : e.LINEAR_MIPMAP_NEAREST);
      } else e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), this._isMipMapped = false;
      const i = this._renderer._GetAnisotropicExtension();
      i && this._anisotropy > 0 && "nearest" !== this._sampling && e.texParameterf(e.TEXTURE_2D, i["TEXTURE_MAX_ANISOTROPY_EXT"], Math.min(this._anisotropy, this._renderer._GetMaxAnisotropy()));
    }
    _Update(e, t2) {
      if (!("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLVideoElement && e instanceof HTMLVideoElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap || "undefined" != typeof OffscreenCanvas && e instanceof OffscreenCanvas || e instanceof ImageData)) throw new Error("invalid texture source");
      if (!this._texture || this._refCount <= 0) throw new Error("texture not created");
      if (this._isStatic) throw new Error("cannot update static texture");
      t2 = Object.assign({}, UPDATE_DEFAULT_OPTIONS, t2);
      const i = e.width || e.videoWidth, r2 = e.height || e.videoHeight, a2 = this._renderer.GetWebGLVersionNumber(), s = this._renderer.GetContext();
      s.bindTexture(s.TEXTURE_2D, this._texture), s.pixelStorei(s["UNPACK_PREMULTIPLY_ALPHA_WEBGL"], t2.premultiplyAlpha), s.pixelStorei(s["UNPACK_FLIP_Y_WEBGL"], !!t2.flipY);
      const h2 = GetFormatSpecifiers(this._pixelFormat, s), n = a2 >= 2 ? h2.sizedinternalformat : h2.internalformat;
      try {
        if (this._width === i && this._height === r2) {
          const t3 = C32.isPOT(this._width) && C32.isPOT(this._height);
          s.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, h2.format, h2.type, e), (t3 || this._renderer.SupportsNPOTTextures()) && this._isMipMapped && (s.hint(s.GENERATE_MIPMAP_HINT, this._GetMipMapHint(s)), s.generateMipmap(s.TEXTURE_2D));
        } else {
          this._width = i, this._height = r2;
          const t3 = C32.isPOT(this._width) && C32.isPOT(this._height);
          if (!this._renderer.SupportsNPOTTextures() && this._IsTiled() && !t3) throw new Error("non-power-of-two tiled textures not supported");
          s.texImage2D(s.TEXTURE_2D, 0, n, h2.format, h2.type, e), (t3 || this._renderer.SupportsNPOTTextures()) && this._isMipMapped && (s.hint(s.GENERATE_MIPMAP_HINT, this._GetMipMapHint(s)), s.generateMipmap(s.TEXTURE_2D));
        }
      } catch (e2) {
        console.error("Error updating WebGL texture: ", e2);
      }
      s.bindTexture(s.TEXTURE_2D, null), this._renderer._ResetLastTexture();
    }
    _Delete() {
      if (this._refCount > 0) throw new Error("texture still has references");
      if (!this._texture) throw new Error("already deleted texture");
      allTextures.delete(this);
      this._renderer.GetContext().deleteTexture(this._texture), this._texture = null;
    }
    IsValid() {
      return !!this._texture;
    }
    _GetTexture() {
      return this._texture;
    }
    GetRenderer() {
      return this._renderer;
    }
    AddReference() {
      this._refCount++;
    }
    SubtractReference() {
      if (this._refCount <= 0) throw new Error("no more references");
      this._refCount--;
    }
    GetReferenceCount() {
      return this._refCount;
    }
    GetWidth() {
      return this._width;
    }
    GetHeight() {
      return this._height;
    }
    IsStatic() {
      return this._isStatic;
    }
    GetEstimatedMemoryUsage() {
      let e = this._width * this._height;
      switch (this._pixelFormat) {
        case "rgba8":
          e *= 4;
          break;
        case "rgb8":
          e *= 3;
          break;
        case "rgba4":
        case "rgb5_a1":
        case "rgb565":
          e *= 2;
      }
      return this._isMipMapped && (e += Math.floor(e / 3)), e;
    }
    static OnContextLost() {
      allTextures.clear();
    }
    static allTextures() {
      return allTextures.values();
    }
  };
}
var GetFormatSpecifiers2;
{
  const C32 = self.C3, assert = self.assert, glMatrix = self.glMatrix, vec3 = glMatrix.vec3, mat4 = glMatrix.mat4, VALID_SAMPLINGS = /* @__PURE__ */ new Set(["nearest", "bilinear", "trilinear"]), DEFAULT_RENDERTARGET_OPTIONS = { sampling: "trilinear", alpha: true, depth: false, isSampled: true, isDefaultSize: true, multisampling: 0 }, allRenderTargets = /* @__PURE__ */ new Set();
  C32.Gfx.WebGLRenderTarget = class {
    constructor(e) {
      this._renderer = e, this._frameBuffer = null, this._frameBufferNoDepth = null, this._texture = null, this._renderBuffer = null, this._width = 0, this._height = 0, this._isDefaultSize = true, this._sampling = "trilinear", this._alpha = true, this._depth = false, this._isSampled = true, this._multisampling = 0, this._projectionMatrix = mat4.create(), this._lastFov = 0, this._lastNearZ = 0, this._lastFarZ = 0;
    }
    _Create(e, t2, r2) {
      r2 = Object.assign({}, DEFAULT_RENDERTARGET_OPTIONS, r2);
      const i = this._renderer.GetWebGLVersionNumber();
      if (this._texture || this._renderBuffer) throw new Error("already created render target");
      if (this._sampling = r2.sampling, this._alpha = !!r2.alpha, this._depth = !!r2.depth, this._isSampled = !!r2.isSampled, this._isDefaultSize = !!r2.isDefaultSize, this._multisampling = r2.multisampling, !VALID_SAMPLINGS.has(this._sampling)) throw new Error("invalid sampling");
      if (this._multisampling > 0 && (i < 2 || this._isSampled)) throw new Error("invalid use of multisampling");
      if (i < 2 && (this._isSampled = true), this._width = e, this._height = t2, this._width <= 0 || this._height <= 0) throw new Error("invalid render target size");
      this._CalculateProjection();
      const s = this._renderer.GetContext();
      if (this._frameBuffer = s.createFramebuffer(), this._depth && (this._frameBufferNoDepth = s.createFramebuffer()), this._isSampled) {
        this._texture = this._renderer.CreateDynamicTexture(this._width, this._height, { sampling: this._sampling, pixelFormat: this._alpha ? "rgba8" : "rgb8", mipMap: false });
        const e2 = this._texture._GetTexture();
        s.bindFramebuffer(s.FRAMEBUFFER, this._frameBuffer), s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, e2, 0), this._depth && (s.bindFramebuffer(s.FRAMEBUFFER, this._frameBufferNoDepth), s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, e2, 0));
      } else {
        this._renderBuffer = s.createRenderbuffer(), s.bindRenderbuffer(s.RENDERBUFFER, this._renderBuffer);
        const e2 = this._alpha ? s.RGBA8 : s.RGB8;
        if (this._multisampling > 0) {
          const t3 = s.getInternalformatParameter(s.RENDERBUFFER, e2, s.SAMPLES);
          if (t3 && t3[0]) {
            const e3 = t3[0];
            this._multisampling > e3 && (this._multisampling = e3);
          } else this._multisampling = 0;
        }
        0 === this._multisampling ? s.renderbufferStorage(s.RENDERBUFFER, e2, this._width, this._height) : s.renderbufferStorageMultisample(s.RENDERBUFFER, this._multisampling, e2, this._width, this._height), s.bindFramebuffer(s.FRAMEBUFFER, this._frameBuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, this._renderBuffer), this._depth && (s.bindFramebuffer(s.FRAMEBUFFER, this._frameBufferNoDepth), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, this._renderBuffer)), s.bindRenderbuffer(s.RENDERBUFFER, null);
      }
      const h2 = this._renderer._GetDepthBuffer();
      this._depth && h2 && (s.bindFramebuffer(s.FRAMEBUFFER, this._frameBuffer), this._renderer._CanSampleDepth() ? s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, h2, 0) : s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, h2)), s.bindFramebuffer(s.FRAMEBUFFER, null), allRenderTargets.add(this);
    }
    _Resize(e, t2) {
      if (this._width === e && this._height === t2) return;
      this._width = e, this._height = t2, this._CalculateProjection();
      const r2 = this._renderer.GetContext();
      r2.bindFramebuffer(r2.FRAMEBUFFER, this._frameBuffer), this._texture ? this._texture._Update(new ImageData(this._width, this._height)) : (r2.bindRenderbuffer(r2.RENDERBUFFER, this._renderBuffer), r2.renderbufferStorage(r2.RENDERBUFFER, this._alpha ? r2.RGBA8 : r2.RGB8, this._width, this._height), r2.bindRenderbuffer(r2.RENDERBUFFER, null));
      const i = this._renderer._GetDepthBuffer();
      this._depth && i && (this._renderer._CanSampleDepth() ? r2.framebufferTexture2D(r2.FRAMEBUFFER, r2.DEPTH_STENCIL_ATTACHMENT, r2.TEXTURE_2D, i, 0) : r2.framebufferRenderbuffer(r2.FRAMEBUFFER, r2.DEPTH_STENCIL_ATTACHMENT, r2.RENDERBUFFER, i)), r2.bindFramebuffer(r2.FRAMEBUFFER, null);
    }
    _Delete() {
      if (!this._texture && !this._renderBuffer) throw new Error("already deleted render target");
      allRenderTargets.delete(this);
      const e = this._renderer.GetContext();
      this._texture ? (e.bindFramebuffer(e.FRAMEBUFFER, this._frameBuffer), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, null, 0), this._depth && (e.bindFramebuffer(e.FRAMEBUFFER, this._frameBufferNoDepth), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, null, 0)), this._renderer.DeleteTexture(this._texture), this._texture = null) : this._renderBuffer && (e.bindFramebuffer(e.FRAMEBUFFER, this._frameBuffer), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, null), this._depth && (e.bindFramebuffer(e.FRAMEBUFFER, this._frameBufferNoDepth), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, null)), e.deleteRenderbuffer(this._renderBuffer), this._renderBuffer = null), e.bindFramebuffer(e.FRAMEBUFFER, null), this._renderer.GetWebGLVersionNumber() >= 2 && (e.bindFramebuffer(e.READ_FRAMEBUFFER, null), e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null)), e.deleteFramebuffer(this._frameBuffer), this._depth && e.deleteFramebuffer(this._frameBufferNoDepth);
      const t2 = this._renderer.GetBatchState();
      t2.currentFramebuffer = null, t2.currentFramebufferNoDepth = null, this._frameBuffer = null;
    }
    _CalculateProjection() {
      this._renderer.CalculatePerspectiveMatrix(this._projectionMatrix, this._width / this._height), this._lastFov = this._renderer.GetFovY(), this._lastNearZ = this._renderer.GetNearZ(), this._lastFarZ = this._renderer.GetFarZ();
    }
    _GetFramebuffer() {
      return this._frameBuffer;
    }
    _GetFramebufferNoDepth() {
      return this._frameBufferNoDepth;
    }
    GetRenderer() {
      return this._renderer;
    }
    GetTexture() {
      return this._texture;
    }
    GetProjectionMatrix() {
      return this._renderer.GetFovY() === this._lastFov && this._renderer.GetNearZ() === this._lastNearZ && this._renderer.GetFarZ() === this._lastFarZ || this._CalculateProjection(), this._projectionMatrix;
    }
    IsLinearSampling() {
      return "nearest" !== this._sampling;
    }
    HasAlpha() {
      return this._alpha;
    }
    IsSampled() {
      return this._isSampled;
    }
    HasDepthBuffer() {
      return this._depth;
    }
    GetWidth() {
      return this._width;
    }
    GetHeight() {
      return this._height;
    }
    IsDefaultSize() {
      return this._isDefaultSize;
    }
    GetMultisampling() {
      return this._multisampling;
    }
    GetOptions() {
      const e = { sampling: this._sampling, alpha: this._alpha, isSampled: this._isSampled };
      return this._isDefaultSize || (e.width = this._width, e.height = this._height), e;
    }
    IsCompatibleWithOptions(e) {
      return "nearest" !== (e = Object.assign({}, DEFAULT_RENDERTARGET_OPTIONS, e)).sampling === this.IsLinearSampling() && (!!e.alpha === this.HasAlpha() && (!!e.depth === this.HasDepthBuffer() && (!(this._renderer.GetWebGLVersionNumber() >= 2 && !!e.isSampled !== this.IsSampled()) && ("number" == typeof e.width || "number" == typeof e.height ? !this.IsDefaultSize() && this.GetWidth() === Math.floor(e.width) && this.GetHeight() === Math.floor(e.height) : this.IsDefaultSize()))));
    }
    _GetWebGLTexture() {
      return this._texture ? this._texture._GetTexture() : null;
    }
    GetEstimatedMemoryUsage() {
      return this._texture ? this._texture.GetEstimatedMemoryUsage() : this._width * this._height * (this._alpha ? 4 : 3);
    }
    static async DebugReadPixelsToBlob(e, t2) {
      const r2 = await e.ReadBackRenderTargetToImageData(t2, true);
      return await C32.ImageDataToBlob(r2);
    }
    static OnContextLost() {
      allRenderTargets.clear();
    }
    static allRenderTargets() {
      return allRenderTargets.values();
    }
    static ResizeAll(e, t2) {
      for (const r2 of allRenderTargets) r2.IsDefaultSize() && r2._Resize(e, t2);
    }
  };
}
{
  const C32 = self.C3, glMatrix = self.glMatrix, vec3 = glMatrix.vec3, mat4 = glMatrix.mat4, RESERVED_UNIFORM_NAMES = /* @__PURE__ */ new Set(["aPos", "aTex", "aColor", "aPoints", "matP", "matMV", "samplerFront", "samplerBack", "samplerDepth", "destStart", "destEnd", "srcStart", "srcEnd", "srcOriginStart", "srcOriginEnd", "pixelSize", "seconds", "devicePixelRatio", "layerScale", "layerAngle", "layoutStart", "layoutEnd", "color", "color2_", "pointTexStart", "pointTexEnd", "zElevation", "tileSize", "tileSpacing", "outlineThickness", "zNear", "zFar"]);
  C32.Gfx.WebGLShaderProgram = class extends C32.Gfx.ShaderProgramBase {
    static async Compile(e, t2) {
      const i = e.GetContext(), r2 = t2.src, o2 = t2.vertexSrc, n = t2.name, a2 = i.createShader(i.FRAGMENT_SHADER);
      i.shaderSource(a2, r2), i.compileShader(a2);
      const l = i.createShader(i.VERTEX_SHADER);
      i.shaderSource(l, o2), i.compileShader(l);
      const s = i.createProgram();
      i.attachShader(s, a2), i.attachShader(s, l), i.bindAttribLocation(s, 0, "aPos"), i.bindAttribLocation(s, 1, "aTex"), i.bindAttribLocation(s, 2, "aColor"), i.bindAttribLocation(s, 3, "aPoints"), i.linkProgram(s);
      const h2 = e._GetParallelShaderCompileExtension();
      if (h2 ? await e._WaitForObjectReady(() => i.getProgramParameter(s, h2["COMPLETION_STATUS_KHR"])) : await C32.Wait(5), !i.getShaderParameter(a2, i.COMPILE_STATUS)) {
        const e2 = i.getShaderInfoLog(a2);
        throw i.deleteShader(a2), i.deleteShader(l), i.deleteProgram(s), new Error("Error compiling fragment shader: " + e2);
      }
      if (!i.getShaderParameter(l, i.COMPILE_STATUS)) {
        const e2 = i.getShaderInfoLog(l);
        throw i.deleteShader(a2), i.deleteShader(l), i.deleteProgram(s), new Error("Error compiling vertex shader: " + e2);
      }
      if (!i.getProgramParameter(s, i.LINK_STATUS)) {
        const e2 = i.getProgramInfoLog(s);
        throw i.deleteShader(a2), i.deleteShader(l), i.deleteProgram(s), new Error("Error linking shader program: " + e2);
      }
      const c2 = C32.FilterUnprintableChars(i.getProgramInfoLog(s) || "").trim();
      return c2 && !C32.IsStringAllWhitespace(c2) && console.info(`[WebGL] Shader program '${n}' compilation log: `, c2), i.deleteShader(a2), i.deleteShader(l), s;
    }
    static async Create(e, t2) {
      const i = await C32.Gfx.WebGLShaderProgram.Compile(e, t2);
      return new C32.Gfx.WebGLShaderProgram(e, i, t2);
    }
    constructor(e, t2, i) {
      super(e, i);
      const r2 = e.GetContext(), o2 = e.GetBatchState();
      e.EndBatch(), r2.useProgram(t2), this._gl = r2, this._shaderProgram = t2, this._isDeviceTransform = "<default-device-transform>" === i.name;
      const n = r2.getAttribLocation(t2, "aPos"), a2 = r2.getAttribLocation(t2, "aTex"), l = r2.getAttribLocation(t2, "aColor");
      this._locAPoints = r2.getAttribLocation(t2, "aPoints"), -1 !== n && (r2.bindBuffer(r2.ARRAY_BUFFER, e._vertexBuffer), r2.vertexAttribPointer(n, 3, r2.FLOAT, false, 0, 0), r2.enableVertexAttribArray(n)), -1 !== a2 && (r2.bindBuffer(r2.ARRAY_BUFFER, e._texcoordBuffer), r2.vertexAttribPointer(a2, 2, r2.FLOAT, false, 0, 0), r2.enableVertexAttribArray(a2)), -1 !== l && (r2.bindBuffer(r2.ARRAY_BUFFER, e._colorBuffer), r2.vertexAttribPointer(l, 4, e.IsColorDataF16() ? r2["HALF_FLOAT"] : r2.FLOAT, false, 0, 0), r2.enableVertexAttribArray(l)), -1 !== this._locAPoints && (r2.bindBuffer(r2.ARRAY_BUFFER, e._pointBuffer), r2.vertexAttribPointer(this._locAPoints, 4, r2.FLOAT, false, 0, 0), r2.enableVertexAttribArray(this._locAPoints)), r2.bindBuffer(r2.ARRAY_BUFFER, null), this._uMatP = new C32.Gfx.WebGLShaderUniform(this, "matP", "mat4"), this._uMatMV = new C32.Gfx.WebGLShaderUniform(this, "matMV", "mat4"), this._uColor = new C32.Gfx.WebGLShaderUniform(this, "color", "vec4"), this._uSamplerFront = new C32.Gfx.WebGLShaderUniform(this, "samplerFront", "sampler"), this._uPointTexStart = new C32.Gfx.WebGLShaderUniform(this, "pointTexStart", "vec2"), this._uPointTexEnd = new C32.Gfx.WebGLShaderUniform(this, "pointTexEnd", "vec2"), this._uZElevation = new C32.Gfx.WebGLShaderUniform(this, "zElevation", "float"), this._uTileSize = new C32.Gfx.WebGLShaderUniform(this, "tileSize", "vec2"), this._uTileSpacing = new C32.Gfx.WebGLShaderUniform(this, "tileSpacing", "vec2"), this._uColor2 = new C32.Gfx.WebGLShaderUniform(this, "color2_", "vec4"), this._uOutlineThickness = new C32.Gfx.WebGLShaderUniform(this, "outlineThickness", "float"), this._uSamplerBack = new C32.Gfx.WebGLShaderUniform(this, "samplerBack", "sampler"), this._uSamplerDepth = new C32.Gfx.WebGLShaderUniform(this, "samplerDepth", "sampler"), this._uDestStart = new C32.Gfx.WebGLShaderUniform(this, "destStart", "vec2"), this._uDestEnd = new C32.Gfx.WebGLShaderUniform(this, "destEnd", "vec2"), this._uSrcStart = new C32.Gfx.WebGLShaderUniform(this, "srcStart", "vec2"), this._uSrcEnd = new C32.Gfx.WebGLShaderUniform(this, "srcEnd", "vec2"), this._uSrcOriginStart = new C32.Gfx.WebGLShaderUniform(this, "srcOriginStart", "vec2"), this._uSrcOriginEnd = new C32.Gfx.WebGLShaderUniform(this, "srcOriginEnd", "vec2"), this._uPixelSize = new C32.Gfx.WebGLShaderUniform(this, "pixelSize", "vec2"), this._uSeconds = new C32.Gfx.WebGLShaderUniform(this, "seconds", "float"), this._uDevicePixelRatio = new C32.Gfx.WebGLShaderUniform(this, "devicePixelRatio", "float"), this._uLayerScale = new C32.Gfx.WebGLShaderUniform(this, "layerScale", "float"), this._uLayerAngle = new C32.Gfx.WebGLShaderUniform(this, "layerAngle", "float"), this._uLayoutStart = new C32.Gfx.WebGLShaderUniform(this, "layoutStart", "vec2"), this._uLayoutEnd = new C32.Gfx.WebGLShaderUniform(this, "layoutEnd", "vec2"), this._uZNear = new C32.Gfx.WebGLShaderUniform(this, "zNear", "float"), this._uZFar = new C32.Gfx.WebGLShaderUniform(this, "zFar", "float"), this._hasAnyOptionalUniforms = !!(this._uPixelSize.IsUsed() || this._uSeconds.IsUsed() || this._uSamplerBack.IsUsed() || this._uDestStart.IsUsed() || this._uDestEnd.IsUsed() || this._uSrcStart.IsUsed() || this._uSrcEnd.IsUsed() || this._uSrcOriginStart.IsUsed() || this._uSrcOriginEnd.IsUsed() || this._uDevicePixelRatio.IsUsed() || this._uLayerScale.IsUsed() || this._uLayerAngle.IsUsed() || this._uLayoutStart.IsUsed() || this._uLayoutEnd.IsUsed());
      const s = i.parameters || [];
      this._uCustomParameters = [], this._usesAnySrcRectOrPixelSize = this._uPixelSize.IsUsed() || this._uSrcStart.IsUsed() || this._uSrcEnd.IsUsed() || this._uSrcOriginStart.IsUsed() || this._uSrcOriginEnd.IsUsed(), this._hasCurrentMatP = false, this._hasCurrentMatMV = false, this._uColor.Init4f(1, 1, 1, 1), this._uColor2.Init4f(1, 1, 1, 1), this._uSamplerFront.Init1i(0), this._uSamplerBack.Init1i(1), this._uSamplerDepth.Init1i(2), this._uPointTexStart.Init2f(0, 0), this._uPointTexEnd.Init2f(1, 1), this._uZElevation.Init1f(0), this._uTileSize.Init2f(0, 0), this._uTileSpacing.Init2f(0, 0), this._uDestStart.Init2f(0, 0), this._uDestEnd.Init2f(1, 1), this._uSrcStart.Init2f(0, 0), this._uSrcEnd.Init2f(0, 0), this._uSrcOriginStart.Init2f(0, 0), this._uSrcOriginEnd.Init2f(0, 0), this._uPixelSize.Init2f(0, 0), this._uDevicePixelRatio.Init1f(1), this._uZNear.Init1f(e.GetNearZ()), this._uZFar.Init1f(e.GetFarZ()), this._uLayerScale.Init1f(1), this._uLayerAngle.Init1f(0), this._uSeconds.Init1f(0), this._uLayoutStart.Init2f(0, 0), this._uLayoutEnd.Init2f(0, 0), this._uOutlineThickness.Init1f(1);
      for (const e2 of s) {
        const t3 = e2[0], i2 = e2[2], r3 = new C32.Gfx.WebGLShaderUniform(this, t3, i2);
        "color" === i2 ? r3.Init3f(0, 0, 0) : r3.Init1f(0), this._uCustomParameters.push(r3);
      }
      this._isDeviceTransform ? this._UpdateDeviceTransformUniforms(o2.currentMatP) : (this.UpdateMatP(o2.currentMatP, true), this.UpdateMatMV(o2.currentMV, true));
      const h2 = o2.currentShader;
      r2.useProgram(h2 ? h2._shaderProgram : null);
    }
    Release() {
      this._gl.deleteProgram(this._shaderProgram), this._shaderProgram = null, this._renderer._RemoveShaderProgram(this), this._gl = null, super.Release();
    }
    GetWebGLContext() {
      return this._gl;
    }
    GetShaderProgram() {
      return this._shaderProgram;
    }
    GetParameterCount() {
      return this._uCustomParameters.length;
    }
    GetParameterType(e) {
      return e < 0 || e >= this._uCustomParameters.length ? null : this._uCustomParameters[e].GetType();
    }
    AreCustomParametersAlreadySetInBatch(e) {
      for (let t2 = 0, i = e.length; t2 < i; ++t2) if (!this._uCustomParameters[t2].IsSetToCustomInBatch(e[t2])) return false;
      return true;
    }
    SetCustomParametersInBatch(e) {
      for (let t2 = 0, i = e.length; t2 < i; ++t2) this._uCustomParameters[t2].SetBatchValueCustom(e[t2]);
    }
    AreOptionalUniformsAlreadySetInBatch(e, t2, i, r2, o2, n, a2, l, s, h2) {
      return !this._uSamplerBack.IsUsed() && (!(this._uPixelSize.IsUsed() && !this._uPixelSize.IsSetTo2InBatch(o2, n)) && (!(this._uDestStart.IsUsed() && !this._uDestStart.IsSetTo2InBatch(e.getLeft(), e.getTop())) && (!(this._uDestEnd.IsUsed() && !this._uDestEnd.IsSetTo2InBatch(e.getRight(), e.getBottom())) && (!(this._uDevicePixelRatio.IsUsed() && !this._uDevicePixelRatio.IsSetTo1InBatch(a2)) && (!(this._uLayerScale.IsUsed() && !this._uLayerScale.IsSetTo1InBatch(l)) && (!(this._uLayerAngle.IsUsed() && !this._uLayerAngle.IsSetTo1InBatch(s)) && (!(this._uSrcStart.IsUsed() && !this._uSrcStart.IsSetTo2InBatch(t2.getLeft(), t2.getTop())) && (!(this._uSrcEnd.IsUsed() && !this._uSrcEnd.IsSetTo2InBatch(t2.getRight(), t2.getBottom())) && (!(this._uSrcOriginStart.IsUsed() && !this._uSrcOriginStart.IsSetTo2InBatch(i.getLeft(), i.getTop())) && (!(this._uSrcOriginEnd.IsUsed() && !this._uSrcOriginEnd.IsSetTo2InBatch(i.getRight(), i.getBottom())) && (!(this._uLayoutStart.IsUsed() && !this._uLayoutStart.IsSetTo2InBatch(r2.getLeft(), r2.getTop())) && (!(this._uLayoutEnd.IsUsed() && !this._uLayoutEnd.IsSetTo2InBatch(r2.getTop(), r2.getBottom())) && !(this._uSeconds.IsUsed() && !this._uSeconds.IsSetTo1InBatch(h2))))))))))))));
    }
    SetOptionalUniformsInBatch(e, t2, i, r2, o2, n, a2, l, s, h2) {
      this._uSamplerBack.IsUsed() || (this._uPixelSize.IsUsed() && this._uPixelSize.SetBatch2(o2, n), this._uDestStart.IsUsed() && this._uDestStart.SetBatch2(e.getLeft(), e.getTop()), this._uDestEnd.IsUsed() && this._uDestEnd.SetBatch2(e.getRight(), e.getBottom()), this._uDevicePixelRatio.IsUsed() && this._uDevicePixelRatio.SetBatch1(a2), this._uLayerScale.IsUsed() && this._uLayerScale.SetBatch1(l), this._uLayerAngle.IsUsed() && this._uLayerAngle.SetBatch1(s), this._uSrcStart.IsUsed() && this._uSrcStart.SetBatch2(t2.getLeft(), t2.getTop()), this._uSrcEnd.IsUsed() && this._uSrcEnd.SetBatch2(t2.getRight(), t2.getBottom()), this._uSrcOriginStart.IsUsed() && this._uSrcOriginStart.SetBatch2(i.getLeft(), i.getTop()), this._uSrcOriginEnd.IsUsed() && this._uSrcOriginEnd.SetBatch2(i.getRight(), i.getBottom()), this._uLayoutStart.IsUsed() && this._uLayoutStart.SetBatch2(r2.getLeft(), r2.getTop()), this._uLayoutEnd.IsUsed() && this._uLayoutEnd.SetBatch2(r2.getTop(), r2.getBottom()), this._uSeconds.IsUsed() && this._uSeconds.SetBatch1(h2));
    }
    UpdateMatP(e, t2) {
      this._hasCurrentMatP && !t2 || this._isDeviceTransform || (this._uMatP.IsUsed() && this._uMatP.UpdateMatrix4fv(e), this._hasCurrentMatP = true);
    }
    SetMatPStale() {
      this._hasCurrentMatP = false;
    }
    UpdateMatMV(e, t2) {
      this._hasCurrentMatMV && !t2 || this._isDeviceTransform || (this._uMatMV.IsUsed() && this._uMatMV.UpdateMatrix4fv(e), this._hasCurrentMatMV = true);
    }
    SetMatMVStale() {
      this._hasCurrentMatMV = false;
    }
    _UpdateDeviceTransformUniforms(e) {
      if (!this._isDeviceTransform) throw new Error("not device transform shader");
      this._uMatP.UpdateMatrix4fv(e);
      const t2 = this._renderer, i = t2.GetWidth() / 2, r2 = t2.GetHeight() / 2, o2 = t2.CalculateLookAtModelView2(i, r2, t2.GetDefaultCameraZ(t2.GetHeight()), i, r2, 0, t2.GetHeight());
      this._uMatMV.UpdateMatrix4fv(o2);
    }
    UpdateColor(e) {
      this._uColor.IsUsed() && this._uColor.Update4f(e[0], e[1], e[2], e[3]);
    }
    static GetReservedUniformNames() {
      return RESERVED_UNIFORM_NAMES;
    }
    static _GetConservativeDepthShaderPrefix(e) {
      return e ? "\n#extension GL_EXT_conservative_depth : enable\nlayout (depth_greater) out highp float gl_FragDepth;\n	" : "";
    }
    static GetDefaultVertexShaderSource(e) {
      const t2 = e ? "highp" : "mediump";
      return ["attribute highp vec3 aPos;", `attribute ${t2} vec2 aTex;`, `varying ${t2} vec2 vTex;`, "attribute lowp vec4 aColor;", "varying lowp vec4 vColor;", "uniform highp mat4 matP;", "uniform highp mat4 matMV;", "void main(void) {", "	gl_Position = matP * matMV * vec4(aPos, 1.0);", "	vTex = aTex;", "	vColor = aColor;", "}"].join("\n");
    }
    static GetDefaultVertexShaderSource_WebGL2(e) {
      const t2 = e ? "highp" : "mediump";
      return ["#version 300 es", "in highp vec3 aPos;", `in ${t2} vec2 aTex;`, `out ${t2} vec2 vTex;`, "in lowp vec4 aColor;", "out lowp vec4 vColor;", "uniform highp mat4 matP;", "uniform highp mat4 matMV;", "void main(void) {", "	gl_Position = matP * matMV * vec4(aPos, 1.0);", "	vTex = aTex;", "	vColor = aColor;", "}"].join("\n");
    }
    static GetTextureFillFragmentShaderSource_WebGL1_NoFragDepth() {
      return ["varying mediump vec2 vTex;", "varying lowp vec4 vColor;", "uniform lowp sampler2D samplerFront;", "void main(void) {", "	gl_FragColor = texture2D(samplerFront, vTex) * vColor;", "}"].join("\n");
    }
    static GetTextureFillFragmentShaderSource_WebGL1_FragDepthEXT() {
      return ["#extension GL_EXT_frag_depth : enable", "varying mediump vec2 vTex;", "varying lowp vec4 vColor;", "uniform lowp sampler2D samplerFront;", "void main(void) {", "	gl_FragColor = texture2D(samplerFront, vTex) * vColor;", "	gl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\n");
    }
    static GetTextureFillFragmentShaderSource_WebGL2(e) {
      return ["#version 300 es", C32.Gfx.WebGLShaderProgram._GetConservativeDepthShaderPrefix(e), "in mediump vec2 vTex;", "out lowp vec4 outColor;", "in lowp vec4 vColor;", "uniform lowp sampler2D samplerFront;", "void main(void) {", "	outColor = texture(samplerFront, vTex) * vColor;", "	gl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\n");
    }
    static GetTilemapFragmentShaderSource_WebGL1_NoFragDepth() {
      return ["varying highp vec2 vTex;", "varying lowp vec4 vColor;", "uniform lowp sampler2D samplerFront;", "uniform highp vec2 srcStart;", "uniform highp vec2 pixelSize;", "uniform highp vec2 tileSize;", "uniform highp vec2 tileSpacing;", "void main(void) {", "	highp vec2 tile = floor(vTex);", "	highp vec2 tex = fract(vTex);", "	highp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);", "	highp vec2 lowerBound = tileOrigin + pixelSize / 2.0;", "	highp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;", "	gl_FragColor = texture2D(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * vColor;", "}"].join("\n");
    }
    static GetTilemapFragmentShaderSource_WebGL1_FragDepthEXT() {
      return ["#extension GL_EXT_frag_depth : enable", "varying highp vec2 vTex;", "varying lowp vec4 vColor;", "uniform lowp sampler2D samplerFront;", "uniform highp vec2 srcStart;", "uniform highp vec2 pixelSize;", "uniform highp vec2 tileSize;", "uniform highp vec2 tileSpacing;", "void main(void) {", "	highp vec2 tile = floor(vTex);", "	highp vec2 tex = fract(vTex);", "	highp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);", "	highp vec2 lowerBound = tileOrigin + pixelSize / 2.0;", "	highp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;", "	gl_FragColor = texture2D(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * vColor;", "	gl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\n");
    }
    static GetTilemapFragmentShaderSource_WebGL2(e) {
      return ["#version 300 es", C32.Gfx.WebGLShaderProgram._GetConservativeDepthShaderPrefix(e), "in highp vec2 vTex;", "out lowp vec4 outColor;", "in lowp vec4 vColor;", "uniform lowp sampler2D samplerFront;", "uniform highp vec2 srcStart;", "uniform highp vec2 pixelSize;", "uniform highp vec2 tileSize;", "uniform highp vec2 tileSpacing;", "void main(void) {", "	highp vec2 tile = floor(vTex);", "	highp vec2 tex = fract(vTex);", "	highp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);", "	highp vec2 lowerBound = tileOrigin + pixelSize / 2.0;", "	highp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;", "	outColor = texture(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * vColor;", "	gl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\n");
    }
    static GetTileRandomizationFragmentShaderSource(e, t2, i, r2) {
      let o2 = "";
      return e >= 2 ? o2 = "#version 300 es\n" + C32.Gfx.WebGLShaderProgram._GetConservativeDepthShaderPrefix(r2) : (t2 && (o2 = "#extension GL_EXT_frag_depth : enable\n"), i && (o2 += "#extension GL_EXT_shader_texture_lod : enable\n", o2 += "#extension GL_OES_standard_derivatives : enable\n")), o2 + `
precision highp float;
${e >= 2 ? "in" : "varying"} vec2 vTex;
${e >= 2 ? "out lowp vec4 outColor;" : ""}
${e >= 2 ? "in" : "varying"} lowp vec4 vColor;
uniform lowp sampler2D samplerFront;
uniform vec2 pixelSize;

uniform vec2 tileSize;
uniform vec2 tileSpacing;
uniform float outlineThickness;

const float PI = 3.1415926;

lowp vec4 cospVec4(lowp vec4 a, lowp vec4 b, float x)
{
	return (a + b + (a - b) * cos(x * PI)) / 2.0;
}

vec3 randVec3(vec2 seed)
{
	return vec3(fract(sin(dot(seed.xy + vec2(0.1, 0.1), vec2(12.9898,78.233))) * 43758.5453),
				fract(sin(dot(seed.yx + vec2(0.1, 0.1), vec2(12.9898,-78.233))) * 43758.5453),
				fract(sin(dot(seed.xy + vec2(0.1, 0.1), vec2(-12.9898,-78.233))) * 43758.5453));
}

lowp vec4 sampleTile(vec2 tile, vec2 uv, vec2 ddx, vec2 ddy)
{
	vec2 posRandom = tileSize;
	float angleRandom = outlineThickness;
	
	vec3 rand = (randVec3(floor(tile + 0.5)) - 0.5) * 2.0;
	
	float angle = angleRandom * rand.z * PI;
	float sin_a = sin(angle);
	float cos_a = cos(angle);
	float aspect = pixelSize.x / pixelSize.y;

	vec2 mid = tile + vec2(0.5, 0.5);
	vec2 dp = uv - mid;
	dp.x /= aspect;
	vec2 r = vec2(dp.x * cos_a - dp.y * sin_a,
				  dp.y * cos_a + dp.x * sin_a);
	r.x *= aspect;

	vec2 p = mid + r + (posRandom * rand.xy / 2.0);
	
	${e >= 2 ? "return textureGrad(samplerFront, p, ddx, ddy);" : ""}
	${e < 2 && i ? "return texture2DGradEXT(samplerFront, p, ddx, ddy);" : ""}
	${e < 2 && !i ? "return texture2D(samplerFront, p);" : ""}
}

void main(void) {
	
	${e < 2 ? "lowp vec4 outColor;" : ""}
	
	float blendMarginX = tileSpacing.x;
	float blendMarginY = tileSpacing.y;
	
	vec2 tile = floor(vTex);
	vec2 tex = fract(vTex);
	vec2 ddx = ${e >= 2 || i ? "dFdx(vTex)" : "vec2(0.0, 0.0)"};
	vec2 ddy = ${e >= 2 || i ? "dFdy(vTex)" : "vec2(0.0, 0.0)"};
	
	vec4 curTile = sampleTile(tile, vTex, ddx, ddy);
	
	bool inLeftMargin = (tex.x < blendMarginX);
	bool inRightMargin = (tex.x > 1.0 - blendMarginX);
	bool inTopMargin = (tex.y < blendMarginY);
	bool inBottomMargin = (tex.y > 1.0 - blendMarginY);
	
	if (inLeftMargin)
	{
		lowp vec4 leftTile = sampleTile(tile + vec2(-1.0, 0.0), vTex, ddx, ddy);
		float leftMix = (tex.x / (blendMarginX * 2.0)) + 0.5;
		lowp vec4 leftMixedTile = cospVec4(leftTile, curTile, leftMix);
		
		if (inTopMargin)
		{
			lowp vec4 topTile =     sampleTile(tile + vec2(0.0,  -1.0), vTex, ddx, ddy);
			lowp vec4 topLeftTile = sampleTile(tile + vec2(-1.0, -1.0), vTex, ddx, ddy);
			lowp vec4 topLeftMixedTile = cospVec4(topLeftTile, topTile, leftMix);
			
			outColor = cospVec4(topLeftMixedTile, leftMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);
		}
		else if (inBottomMargin)
		{
			lowp vec4 bottomTile =     sampleTile(tile + vec2(0.0,  1.0), vTex, ddx, ddy);
			lowp vec4 bottomLeftTile = sampleTile(tile + vec2(-1.0, 1.0), vTex, ddx, ddy);
			lowp vec4 bottomLeftMixedTile = cospVec4(bottomLeftTile, bottomTile, leftMix);
			
			outColor = cospVec4(leftMixedTile, bottomLeftMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));
		}
		else
		{
			outColor = leftMixedTile;
		}
	}
	else if (inRightMargin)
	{
		lowp vec4 rightTile = sampleTile(tile + vec2(1.0, 0.0), vTex, ddx, ddy);
		float rightMix = (tex.x - (1.0 - blendMarginX)) / (blendMarginX * 2.0);
		lowp vec4 rightMixedTile = cospVec4(curTile, rightTile, rightMix);
		
		if (inTopMargin)
		{
			lowp vec4 topTile =      sampleTile(tile + vec2(0.0, -1.0), vTex, ddx, ddy);
			lowp vec4 topRightTile = sampleTile(tile + vec2(1.0, -1.0), vTex, ddx, ddy);
			lowp vec4 topRightMixedTile = cospVec4(topTile, topRightTile, rightMix);
			
			outColor = cospVec4(topRightMixedTile, rightMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);
		}
		else if (inBottomMargin)
		{
			lowp vec4 bottomTile =      sampleTile(tile + vec2(0.0, 1.0), vTex, ddx, ddy);
			lowp vec4 bottomRightTile = sampleTile(tile + vec2(1.0, 1.0), vTex, ddx, ddy);
			lowp vec4 bottomRightMixedTile = cospVec4(bottomTile, bottomRightTile, rightMix);
			
			outColor = cospVec4(rightMixedTile, bottomRightMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));
		}
		else
		{
			outColor = rightMixedTile;
		}
	}
	else if (inTopMargin)
	{
		lowp vec4 topTile = sampleTile(tile + vec2(0.0, -1.0), vTex, ddx, ddy);
		outColor = cospVec4(topTile, curTile, (tex.y / (blendMarginY * 2.0)) + 0.5);
	}
	else if (inBottomMargin)
	{
		lowp vec4 bottomTile = sampleTile(tile + vec2(0.0, 1.0), vTex, ddx, ddy);
		outColor = cospVec4(curTile, bottomTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));
	}
	else
	{
		outColor = curTile;
	}
	
	outColor *= vColor;
	${e < 2 ? "gl_FragColor = outColor;" : ""}
	${e >= 2 ? "gl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);" : ""}
	${e < 2 && t2 ? "gl_FragDepthEXT = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);" : ""}
}
`;
    }
    static GetPointVertexShaderSource_WebGL1() {
      return ["attribute vec4 aPoints;", "varying float pointOpacity;", "uniform float zElevation;", "uniform mat4 matP;", "uniform mat4 matMV;", "void main(void) {", "	gl_Position = matP * matMV * vec4(aPoints.xy, zElevation, 1.0);", "	gl_PointSize = aPoints.z;", "	pointOpacity = aPoints.w;", "}"].join("\n");
    }
    static GetPointVertexShaderSource_WebGL2() {
      return ["#version 300 es", "in vec4 aPoints;", "out float pointOpacity;", "uniform float zElevation;", "uniform mat4 matP;", "uniform mat4 matMV;", "void main(void) {", "	gl_Position = matP * matMV * vec4(aPoints.xy, zElevation, 1.0);", "	gl_PointSize = aPoints.z;", "	pointOpacity = aPoints.w;", "}"].join("\n");
    }
    static GetPointFragmentShaderSource_WebGL1_NoFragDepth() {
      return ["uniform lowp sampler2D samplerFront;", "varying lowp float pointOpacity;", "uniform mediump vec2 pointTexStart;", "uniform mediump vec2 pointTexEnd;", "uniform lowp vec4 color;", "void main(void) {", "	mediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);", "	mediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);", "	mediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));", "	gl_FragColor = texture2D(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;", "}"].join("\n");
    }
    static GetPointFragmentShaderSource_WebGL1_FragDepthEXT() {
      return ["#extension GL_EXT_frag_depth : enable", "uniform lowp sampler2D samplerFront;", "varying lowp float pointOpacity;", "uniform mediump vec2 pointTexStart;", "uniform mediump vec2 pointTexEnd;", "uniform lowp vec4 color;", "void main(void) {", "	mediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);", "	mediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);", "	mediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));", "	gl_FragColor = texture2D(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;", "	gl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\n");
    }
    static GetPointFragmentShaderSource_WebGL2(e) {
      return ["#version 300 es", C32.Gfx.WebGLShaderProgram._GetConservativeDepthShaderPrefix(e), "uniform lowp sampler2D samplerFront;", "in lowp float pointOpacity;", "uniform mediump vec2 pointTexStart;", "uniform mediump vec2 pointTexEnd;", "uniform lowp vec4 color;", "out lowp vec4 outColor;", "void main(void) {", "	mediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);", "	mediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);", "	mediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));", "	outColor = texture(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;", "	gl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}"].join("\n");
    }
    static GetColorFillFragmentShaderSource() {
      return ["varying lowp vec4 vColor;", "void main(void) {", "	gl_FragColor = vColor;", "}"].join("\n");
    }
    static GetLinearGradientFillFragmentShaderSource() {
      return ["precision lowp float;", "varying mediump vec2 vTex;", "varying vec4 vColor;", "uniform vec4 color2_;", "vec3 fromLinear(vec3 linearRGB)", "{", "	bvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));", "	vec3 higher = vec3(1.055) * pow(abs(linearRGB), vec3(1.0/2.4)) - vec3(0.055);", "	vec3 lower = linearRGB * vec3(12.92);", "	return mix(higher, lower, vec3(cutoff));", "}", "vec3 toLinear(vec3 sRGB)", "{", "	bvec3 cutoff = lessThan(sRGB, vec3(0.04045));", "	vec3 higher = pow(abs((sRGB + vec3(0.055))/vec3(1.055)), vec3(2.4));", "	vec3 lower = sRGB/vec3(12.92);", "	return mix(higher, lower, vec3(cutoff));", "}", "void main(void) {", "	vec3 linearGrad = mix(toLinear(vColor.rgb), toLinear(color2_.rgb), vTex.x);", "	float a = mix(vColor.a, color2_.a, vTex.x);", "	gl_FragColor = vec4(fromLinear(linearGrad) * a, a);", "}"].join("\n");
    }
    static GetPenumbraFillFragmentShaderSource() {
      return ["precision lowp float;", "varying highp vec2 vTex;", "varying vec4 vColor;", "void main(void) {", "	highp float grad = vTex.x / (1.0 - vTex.y);", "	gl_FragColor = vColor * (1.0 - (cos(grad * 3.141592653589793) + 1.0) / 2.0);", "}"].join("\n");
    }
    static GetSmoothLineFillFragmentShaderSource() {
      return ["varying mediump vec2 vTex;", "varying lowp vec4 vColor;", "void main(void) {", "	lowp float f = 1.0 - abs(vTex.y - 0.5) * 2.0;", "	gl_FragColor = vColor * f;", "}"].join("\n");
    }
    static GetHardEllipseFillFragmentShaderSource() {
      return ["varying highp vec2 vTex;", "varying lowp vec4 vColor;", "void main(void) {", "	highp vec2 diff = vTex - vec2(0.5, 0.5);", "	highp vec2 diffSq = diff * diff;", "	highp float f = step(diffSq.x + diffSq.y, 0.25);", "	gl_FragColor = vColor * f;", "}"].join("\n");
    }
    static GetHardEllipseOutlineFragmentShaderSource() {
      return ["varying highp vec2 vTex;", "varying lowp vec4 vColor;", "uniform highp vec2 pixelSize;", "uniform highp float outlineThickness;", "void main(void) {", "	highp vec2 diff = vTex - vec2(0.5, 0.5);", "	highp vec2 diffSq = diff * diff;", "	highp float distSq = diffSq.x + diffSq.y;", "	highp vec2 norm = normalize(diff);", "	highp vec2 halfNorm = norm * 0.5;", "	highp float innerF = step(distSq, 0.25);", "	highp vec2 innerEdge = halfNorm - pixelSize * norm * outlineThickness;", "	highp vec2 innerEdgeSq = innerEdge * innerEdge;", "	highp float outerF = step(innerEdgeSq.x + innerEdgeSq.y, distSq);", "	gl_FragColor = vColor * innerF * outerF;", "}"].join("\n");
    }
    static GetSmoothEllipseFillFragmentShaderSource() {
      return ["varying highp vec2 vTex;", "varying lowp vec4 vColor;", "uniform highp vec2 pixelSize;", "void main(void) {", "	highp vec2 diff = vTex - vec2(0.5, 0.5);", "	highp vec2 diffSq = diff * diff;", "	highp vec2 norm = normalize(diff);", "	highp vec2 halfNorm = norm * 0.5;", "	highp vec2 halfNormSq = halfNorm * halfNorm;", "	highp vec2 innerEdge = halfNorm - pixelSize * norm;", "	highp vec2 innerEdgeSq = innerEdge * innerEdge;", "	highp float f = smoothstep(halfNormSq.x + halfNormSq.y, innerEdgeSq.x + innerEdgeSq.y, diffSq.x + diffSq.y);", "	gl_FragColor = vColor * f;", "}"].join("\n");
    }
    static GetSmoothEllipseOutlineFragmentShaderSource() {
      return ["varying highp vec2 vTex;", "varying lowp vec4 vColor;", "uniform highp vec2 pixelSize;", "uniform highp float outlineThickness;", "void main(void) {", "	highp vec2 diff = vTex - vec2(0.5, 0.5);", "	highp vec2 diffSq = diff * diff;", "	highp float distSq = diffSq.x + diffSq.y;", "	highp vec2 norm = normalize(diff);", "	highp vec2 halfNorm = norm * 0.5;", "	highp vec2 halfNormSq = halfNorm * halfNorm;", "	highp vec2 pxNorm = pixelSize * norm;", "	highp vec2 innerEdge1 = halfNorm - pxNorm;", "	highp vec2 innerEdge1Sq = innerEdge1 * innerEdge1;", "	highp float innerF = smoothstep(halfNormSq.x + halfNormSq.y, innerEdge1Sq.x + innerEdge1Sq.y, distSq);", "	highp vec2 innerEdge2 = halfNorm - pxNorm * outlineThickness;", "	highp vec2 innerEdge2Sq = innerEdge2 * innerEdge2;", "	highp vec2 innerEdge3 = halfNorm - pxNorm * (outlineThickness + 1.0);", "	highp vec2 innerEdge3Sq = innerEdge3 * innerEdge3;", "	highp float outerF = smoothstep(innerEdge3Sq.x + innerEdge3Sq.y, innerEdge2Sq.x + innerEdge2Sq.y, distSq);", "	gl_FragColor = vColor * innerF * outerF;", "}"].join("\n");
    }
  };
}
{
  const C32 = self.C3, glMatrix = self.glMatrix, mat4 = glMatrix.mat4, TYPE_SIZES = /* @__PURE__ */ new Map([["float", 1], ["percent", 1], ["sampler", 1], ["vec2", 2], ["vec3", 3], ["color", 3], ["vec4", 4], ["mat4", 16]]);
  C32.Gfx.WebGLShaderUniform = class {
    constructor(t2, s, a2) {
      if (!TYPE_SIZES.has(a2)) throw new Error("invalid uniform type");
      this._owner = t2, this._gl = this._owner.GetWebGLContext(), this._name = s, this._type = a2, this._isColorType = "color" === this._type, this._location = this._gl.getUniformLocation(this._owner.GetShaderProgram(), s), this._isUsed = !!this._location;
      const i = TYPE_SIZES.get(a2);
      this._lastValue = new Float32Array(i), this._lastBatchValue = new Float32Array(i);
    }
    Release() {
      this._owner = null, this._gl = null, this._location = null;
    }
    IsUsed() {
      return this._isUsed;
    }
    GetType() {
      return this._type;
    }
    IsColorType() {
      return this._isColorType;
    }
    Init1f(t2) {
      this.IsUsed() && (this._lastValue[0] = t2, this._lastBatchValue.set(this._lastValue), this._gl.uniform1f(this._location, t2));
    }
    Init1i(t2) {
      this.IsUsed() && (this._lastValue[0] = t2, this._lastBatchValue.set(this._lastValue), this._gl.uniform1i(this._location, t2));
    }
    Init2f(t2, s) {
      this.IsUsed() && (this._lastValue[0] = t2, this._lastValue[1] = s, this._lastBatchValue.set(this._lastValue), this._gl.uniform2f(this._location, t2, s));
    }
    Init3f(t2, s, a2) {
      this.IsUsed() && (this._lastValue[0] = t2, this._lastValue[1] = s, this._lastValue[2] = a2, this._lastBatchValue.set(this._lastValue), this._gl.uniform3f(this._location, t2, s, a2));
    }
    Init4f(t2, s, a2, i) {
      this.IsUsed() && (this._lastValue[0] = t2, this._lastValue[1] = s, this._lastValue[2] = a2, this._lastValue[3] = i, this._lastBatchValue.set(this._lastValue), this._gl.uniform4f(this._location, t2, s, a2, i));
    }
    Update1f(t2) {
      t2 = Math.fround(t2);
      const s = this._lastValue;
      s[0] !== t2 && (s[0] = t2, this._gl.uniform1f(this._location, t2));
    }
    Update1i(t2) {
      const s = this._lastValue;
      s[0] !== t2 && (s[0] = t2, this._gl.uniform1i(this._location, t2));
    }
    Update2f(t2, s) {
      t2 = Math.fround(t2), s = Math.fround(s);
      const a2 = this._lastValue;
      a2[0] === t2 && a2[1] === s || (a2[0] = t2, a2[1] = s, this._gl.uniform2f(this._location, t2, s));
    }
    Update3f(t2, s, a2) {
      t2 = Math.fround(t2), s = Math.fround(s), a2 = Math.fround(a2);
      const i = this._lastValue;
      i[0] === t2 && i[1] === s && i[2] === a2 || (i[0] = t2, i[1] = s, i[2] = a2, this._gl.uniform3f(this._location, t2, s, a2));
    }
    Update4f(t2, s, a2, i) {
      t2 = Math.fround(t2), s = Math.fround(s), a2 = Math.fround(a2), i = Math.fround(i);
      const l = this._lastValue;
      l[0] === t2 && l[1] === s && l[2] === a2 && l[3] === i || (l[0] = t2, l[1] = s, l[2] = a2, l[3] = i, this._gl.uniform4f(this._location, t2, s, a2, i));
    }
    UpdateMatrix4fv(t2) {
      const s = this._lastValue;
      mat4.exactEquals(s, t2) || (C32.typedArraySet16(s, t2, 0), this._gl.uniformMatrix4fv(this._location, false, t2));
    }
    IsSetToCustomInBatch(t2) {
      const s = this._lastBatchValue;
      return this.IsColorType() ? s[0] === Math.fround(t2.getR()) && s[1] === Math.fround(t2.getG()) && s[2] === Math.fround(t2.getB()) : s[0] === Math.fround(t2);
    }
    SetBatchValueCustom(t2) {
      const s = this._lastBatchValue;
      this.IsColorType() ? (s[0] = t2.getR(), s[1] = t2.getG(), s[2] = t2.getB()) : s[0] = t2;
    }
    IsSetTo1InBatch(t2) {
      return this._lastBatchValue[0] === Math.fround(t2);
    }
    IsSetTo2InBatch(t2, s) {
      const a2 = this._lastBatchValue;
      return a2[0] === Math.fround(t2) && a2[1] === Math.fround(s);
    }
    SetBatch1(t2) {
      this._lastBatchValue[0] = t2;
    }
    SetBatch2(t2, s) {
      const a2 = this._lastBatchValue;
      a2[0] = t2, a2[1] = s;
    }
  };
}
{
  const C32 = self.C3, glMatrix = self.glMatrix, vec4 = glMatrix.vec4, mat4 = glMatrix.mat4, BATCH_NULL = 0, BATCH_DRAW = 1, BATCH_SETTEXTURE = 2, BATCH_SETBLEND = 3, BATCH_SETVIEWPORT = 4, BATCH_SETPROJECTION = 5, BATCH_SETMODELVIEW = 6, BATCH_SETRENDERTARGET = 7, BATCH_CLEARSURFACE = 8, BATCH_POINTS = 9, BATCH_SETPROGRAM = 10, BATCH_SETPROGRAMPARAMETERS = 11, BATCH_SETPROGRAMCUSTOMPARAMETERS = 12, BATCH_INVALIDATEFRAMEBUFFER = 13, BATCH_SETPOINTTEXCOORDS = 14, BATCH_SETTILEMAPINFO = 15, BATCH_BLITFRAMEBUFFER = 16, BATCH_STARTQUERY = 17, BATCH_ENDQUERY = 18, BATCH_SETELLIPSEPARAMS = 19, BATCH_SETGRADIENTCOLOR = 20, BATCH_CLEARDEPTH = 21, BATCH_SETDEPTHENABLED = 22, BATCH_SETDEPTHSAMPLINGENABLED = 23, BATCH_COPLANAR_STARTSTENCILPASS = 24, BATCH_COPLANAR_STARTCOLORPASS = 25, BATCH_COPLANAR_RESTORE = 26, BATCH_SET_SCISSOR = 27, BATCH_SETTILERANDOMIZATIONINFO = 28, BATCH_SETCULLFACEMODE = 29, BATCH_SETFRONTFACEWINDING = 30;
  C32.Gfx.BatchState = class {
    constructor(t2) {
      this.renderer = t2, this.currentMV = mat4.create(), this.currentMatP = mat4.create(), this.currentFramebuffer = null, this.currentFramebufferNoDepth = null, this.isDepthSamplingEnabled = false, this.currentShader = null, this.pointTexCoords = new C32.Rect(), this.clearColor = C32.New(C32.Color, 0, 0, 0, 0);
    }
  }, C32.Gfx.WebGLBatchJob = class {
    constructor(t2) {
      const e = new ArrayBuffer(96);
      this._type = 0, this._batchState = t2, this._gl = t2.renderer.GetContext(), this._startIndex = 0, this._indexCount = 0, this._texParam = null, this._mat4param = new Float32Array(e, 0, 16), this._colorParam = new Float32Array(e, 64, 4), this._srcOriginRect = new Float32Array(e, 80, 4), this._shaderParams = [];
    }
    InitDraw(t2, e) {
      this._type = 1, this._startIndex = t2, this._indexCount = e;
    }
    DoDraw() {
      const t2 = this._gl;
      t2.drawElements(t2.TRIANGLES, this._indexCount, t2.UNSIGNED_SHORT, this._startIndex);
    }
    InitSetTexture(t2) {
      this._type = 2, this._texParam = t2;
    }
    DoSetTexture() {
      const t2 = this._gl, e = this._texParam;
      t2.bindTexture(t2.TEXTURE_2D, e ? e._GetTexture() : null);
    }
    InitSetGradientColor(t2) {
      this._type = 20, t2.writeToTypedArray(this._colorParam, 0);
    }
    DoSetGradientColor() {
      const t2 = this._colorParam, e = this._batchState.currentShader;
      e._uColor2.IsUsed() && e._uColor2.Update4f(t2[0], t2[1], t2[2], t2[3]);
    }
    InitSetBlend(t2, e) {
      this._type = 3, this._startIndex = t2, this._indexCount = e;
    }
    DoSetBlend() {
      this._gl.blendFunc(this._startIndex, this._indexCount);
    }
    InitSetViewport(t2, e, r2, a2) {
      this._type = 4;
      const s = this._colorParam;
      s[0] = t2, s[1] = e, s[2] = r2, s[3] = a2;
    }
    DoSetViewport() {
      const t2 = this._colorParam;
      this._gl.viewport(t2[0], t2[1], t2[2], t2[3]);
    }
    InitSetProjection(t2) {
      this._type = 5, mat4.copy(this._mat4param, t2);
    }
    DoSetProjection() {
      const t2 = this._batchState, e = t2.renderer._allShaderPrograms, r2 = t2.currentShader, a2 = this._mat4param;
      for (let t3 = 0, s = e.length; t3 < s; ++t3) {
        const s2 = e[t3];
        s2 === r2 ? s2.UpdateMatP(a2, true) : s2.SetMatPStale();
      }
      mat4.copy(t2.currentMatP, a2);
    }
    InitSetModelView(t2) {
      this._type = 6, mat4.copy(this._mat4param, t2);
    }
    DoSetModelView() {
      const t2 = this._batchState, e = t2.renderer._allShaderPrograms, r2 = t2.currentShader, a2 = this._mat4param;
      for (let t3 = 0, s = e.length; t3 < s; ++t3) {
        const s2 = e[t3];
        s2 === r2 ? s2.UpdateMatMV(a2, true) : s2.SetMatMVStale();
      }
      mat4.copy(t2.currentMV, a2);
    }
    InitSetRenderTarget(t2) {
      this._type = 7, this._texParam = t2;
    }
    DoSetRenderTarget() {
      const t2 = this._gl, e = this._texParam, r2 = this._batchState;
      e ? (r2.currentFramebuffer = e._GetFramebuffer(), r2.currentFramebufferNoDepth = e._GetFramebufferNoDepth(), r2.isDepthSamplingEnabled && r2.currentFramebufferNoDepth ? t2.bindFramebuffer(t2.FRAMEBUFFER, r2.currentFramebufferNoDepth) : t2.bindFramebuffer(t2.FRAMEBUFFER, r2.currentFramebuffer)) : (r2.currentFramebuffer = null, r2.currentFramebufferNoDepth = null, t2.bindFramebuffer(t2.FRAMEBUFFER, null));
    }
    InitClearSurface(t2) {
      this._type = 8, t2.writeToTypedArray(this._mat4param, 0);
    }
    InitClearSurface2(t2, e, r2, a2) {
      this._type = 8;
      const s = this._mat4param;
      s[0] = t2, s[1] = e, s[2] = r2, s[3] = a2;
    }
    DoClearSurface() {
      const t2 = this._gl, e = this._mat4param, r2 = this._batchState.clearColor, a2 = e[0], s = e[1], i = e[2], n = e[3];
      r2.equalsRgba(a2, s, i, n) || (t2.clearColor(a2, s, i, n), r2.setRgba(a2, s, i, n)), t2.clear(t2.COLOR_BUFFER_BIT);
    }
    InitSetPointTexCoords(t2) {
      this._type = 14, t2.writeToTypedArray(this._mat4param, 0);
    }
    DoSetPointTextureCoords() {
      const t2 = this._mat4param;
      this._batchState.pointTexCoords.set(t2[0], t2[1], t2[2], t2[3]);
    }
    InitPoints(t2, e, r2) {
      this._type = 9, this._startIndex = t2, this._indexCount = 1, this._mat4param[0] = e, r2.writeToTypedArray(this._colorParam, 0);
    }
    DoPoints() {
      const t2 = this._gl, e = this._batchState, r2 = e.renderer._spPoints;
      t2.useProgram(r2._shaderProgram), r2.UpdateMatP(e.currentMatP, false), r2.UpdateMatMV(e.currentMV, false);
      const a2 = e.pointTexCoords;
      r2._uPointTexStart.IsUsed() && r2._uPointTexStart.Update2f(a2.getLeft(), a2.getTop()), r2._uPointTexEnd.IsUsed() && r2._uPointTexEnd.Update2f(a2.getRight(), a2.getBottom());
      const s = this._mat4param[0];
      if (r2._uZElevation.IsUsed() && r2._uZElevation.Update1f(s), r2._uColor.IsUsed()) {
        const t3 = this._colorParam;
        r2._uColor.Update4f(t3[0], t3[1], t3[2], t3[3]);
      }
      t2.drawArrays(t2.POINTS, this._startIndex / 4, this._indexCount), t2.useProgram(e.currentShader._shaderProgram);
    }
    InitSetProgram(t2) {
      this._type = 10, this._texParam = t2;
    }
    DoSetProgram() {
      const t2 = this._gl, e = this._batchState, r2 = this._texParam;
      e.currentShader = r2, t2.useProgram(r2._shaderProgram), r2.UpdateMatP(e.currentMatP, false), r2.UpdateMatMV(e.currentMV, false);
    }
    InitSetProgramParameters() {
      this._type = 11;
    }
    DoSetProgramParameters() {
      const t2 = this._batchState.currentShader, e = this._gl, r2 = this._mat4param, a2 = this._colorParam, s = this._srcOriginRect;
      if (t2._uSamplerBack.IsUsed()) {
        const t3 = this._batchState.renderer, r3 = this._texParam;
        t3._lastTexture1 !== r3 && (e.activeTexture(e.TEXTURE1), e.bindTexture(e.TEXTURE_2D, r3 ? r3._GetTexture() : null), t3._lastTexture1 = r3, e.activeTexture(e.TEXTURE0));
      }
      t2._uPixelSize.IsUsed() && t2._uPixelSize.Update2f(r2[0], r2[1]), t2._uDestStart.IsUsed() && t2._uDestStart.Update2f(r2[2], r2[3]), t2._uDestEnd.IsUsed() && t2._uDestEnd.Update2f(r2[4], r2[5]), t2._uDevicePixelRatio.IsUsed() && t2._uDevicePixelRatio.Update1f(this._indexCount), t2._uLayerScale.IsUsed() && t2._uLayerScale.Update1f(r2[6]), t2._uLayerAngle.IsUsed() && t2._uLayerAngle.Update1f(r2[7]), t2._uSrcStart.IsUsed() && t2._uSrcStart.Update2f(r2[12], r2[13]), t2._uSrcEnd.IsUsed() && t2._uSrcEnd.Update2f(r2[14], r2[15]), t2._uSrcOriginStart.IsUsed() && t2._uSrcOriginStart.Update2f(s[0], s[1]), t2._uSrcOriginEnd.IsUsed() && t2._uSrcOriginEnd.Update2f(s[2], s[3]), t2._uLayoutStart.IsUsed() && t2._uLayoutStart.Update2f(a2[0], a2[1]), t2._uLayoutEnd.IsUsed() && t2._uLayoutEnd.Update2f(a2[2], a2[3]), t2._uSeconds.IsUsed() && t2._uSeconds.Update1f(this._startIndex);
    }
    InitSetProgramCustomParameters() {
      this._type = 12;
    }
    DoSetProgramCustomParameters() {
      const t2 = this._batchState.currentShader._uCustomParameters, e = this._shaderParams;
      for (let r2 = 0, a2 = t2.length; r2 < a2; ++r2) {
        const a3 = t2[r2], s = e[r2];
        a3.IsColorType() ? a3.Update3f(s.getR(), s.getG(), s.getB()) : a3.Update1f(s);
      }
    }
    InitInvalidateFramebuffer(t2) {
      this._type = 13, this._texParam = t2;
    }
    DoInvalidateFramebuffer() {
      const t2 = this._gl, e = this._texParam, r2 = this._batchState.currentFramebuffer;
      e !== r2 && t2.bindFramebuffer(t2.FRAMEBUFFER, e), t2.invalidateFramebuffer(t2.FRAMEBUFFER, [t2.COLOR_ATTACHMENT0]), e !== r2 && t2.bindFramebuffer(t2.FRAMEBUFFER, r2);
    }
    InitBlitFramebuffer(t2, e, r2) {
      this._type = 16;
      const a2 = this._mat4param, s = this._batchState.renderer;
      a2[0] = t2.GetWidth(), a2[1] = t2.GetHeight(), a2[2] = e ? e.GetWidth() : s.GetWidth(), a2[3] = e ? e.GetHeight() : s.GetHeight(), a2[4] = t2.IsLinearSampling() ? 1 : 0, a2[5] = "stretch" === r2;
      const i = this._shaderParams;
      C32.clearArray(i), i.push(t2._GetFramebuffer()), i.push(e ? e._GetFramebuffer() : null);
    }
    DoBlitFramebuffer() {
      const t2 = this._mat4param, e = this._shaderParams, r2 = this._gl, a2 = t2[0], s = t2[1], i = t2[2], n = t2[3], o2 = 0 !== t2[4], _2 = 0 !== t2[5], h2 = e[0], d2 = e[1];
      if (r2.bindFramebuffer(r2.READ_FRAMEBUFFER, h2), r2.bindFramebuffer(r2.DRAW_FRAMEBUFFER, d2), _2) r2.blitFramebuffer(0, 0, a2, s, 0, 0, i, n, r2.COLOR_BUFFER_BIT, o2 ? r2.LINEAR : r2.NEAREST);
      else {
        const t3 = Math.min(a2, i), e2 = Math.min(s, n), o3 = Math.max(s - n, 0), _3 = Math.max(n - s, 0);
        r2.blitFramebuffer(0, o3, t3, e2 + o3, 0, _3, t3, e2 + _3, r2.COLOR_BUFFER_BIT, r2.NEAREST);
      }
    }
    InitStartQuery(t2) {
      this._type = 17, this._texParam = t2;
    }
    DoStartQuery() {
      this._texParam.BeginTimeElapsed(), this._texParam = null;
    }
    InitEndQuery(t2) {
      this._type = 18, this._texParam = t2;
    }
    DoEndQuery() {
      this._texParam.EndTimeElapsed(), this._texParam = null;
    }
    InitSetEllipseParams(t2, e, r2) {
      this._type = 19;
      const a2 = this._mat4param;
      a2[0] = t2, a2[1] = e, a2[2] = r2;
    }
    DoSetEllipseParams() {
      const t2 = this._batchState.currentShader, e = this._mat4param;
      t2._uPixelSize.IsUsed() && t2._uPixelSize.Update2f(e[0], e[1]), t2._uOutlineThickness.IsUsed() && t2._uOutlineThickness.Update1f(e[2]);
    }
    InitSetTilemapInfo(t2, e, r2, a2, s, i, n) {
      this._type = 15;
      const o2 = this._mat4param;
      t2.writeToTypedArray(o2, 0), o2[4] = 1 / e, o2[5] = 1 / r2, o2[6] = a2 / e, o2[7] = s / r2, o2[8] = i / e, o2[9] = n / r2;
    }
    DoSetTilemapInfo() {
      const t2 = this._batchState.currentShader, e = this._mat4param;
      t2._uSrcStart.IsUsed() && t2._uSrcStart.Update2f(e[0], e[1]), t2._uPixelSize.IsUsed() && t2._uPixelSize.Update2f(e[4], e[5]), t2._uTileSize.IsUsed() && t2._uTileSize.Update2f(e[6], e[7]), t2._uTileSpacing.IsUsed() && t2._uTileSpacing.Update2f(e[8], e[9]);
    }
    InitSetTileRandomizationInfo(t2, e, r2, a2, s, i, n) {
      this._type = 28;
      const o2 = this._mat4param;
      o2[0] = 1 / t2, o2[1] = 1 / e, o2[2] = r2, o2[3] = a2, o2[4] = s, o2[5] = i, o2[6] = n;
    }
    DoSetTileRandomizationInfo() {
      const t2 = this._batchState.currentShader, e = this._mat4param;
      t2._uPixelSize.IsUsed() && t2._uPixelSize.Update2f(e[0], e[1]), t2._uTileSize.IsUsed() && t2._uTileSize.Update2f(e[2], e[3]), t2._uOutlineThickness.IsUsed() && t2._uOutlineThickness.Update1f(e[4]), t2._uTileSpacing.IsUsed() && t2._uTileSpacing.Update2f(e[5], e[6]);
    }
    InitClearDepth(t2) {
      this._type = 21, this._startIndex = t2 ? 1 : 0;
    }
    DoClearDepth() {
      const t2 = this._gl, e = 0 !== this._startIndex;
      e || t2.depthMask(true), t2.clear(t2.DEPTH_BUFFER_BIT), e || t2.depthMask(false);
    }
    InitSetDepthEnabled(t2) {
      this._type = 22, this._startIndex = t2 ? 1 : 0;
    }
    DoSetDepthEnabled() {
      const t2 = this._gl;
      0 === this._startIndex ? (t2.disable(t2.DEPTH_TEST), t2.depthMask(false)) : (t2.enable(t2.DEPTH_TEST), t2.depthMask(true));
    }
    InitSetDepthSamplingEnabled(t2) {
      this._type = 23, this._startIndex = t2 ? 1 : 0;
    }
    DoSetDepthSamplingEnabled() {
      const t2 = this._gl, e = this._batchState, r2 = e.renderer, a2 = 0 !== this._startIndex;
      e.isDepthSamplingEnabled = a2, t2.activeTexture(t2.TEXTURE2), a2 ? (e.currentFramebufferNoDepth && t2.bindFramebuffer(t2.FRAMEBUFFER, e.currentFramebufferNoDepth), t2.bindTexture(t2.TEXTURE_2D, r2._GetDepthBuffer())) : (t2.bindTexture(t2.TEXTURE_2D, null), e.currentFramebufferNoDepth && t2.bindFramebuffer(t2.FRAMEBUFFER, e.currentFramebuffer)), t2.activeTexture(t2.TEXTURE0);
    }
    InitCoplanarStartStencilPass() {
      this._type = 24;
    }
    DoCoplanarStartStencilPass() {
      const t2 = this._gl;
      t2.clear(t2.STENCIL_BUFFER_BIT), t2.enable(t2.STENCIL_TEST), t2.stencilFunc(t2.ALWAYS, 1, 1), t2.stencilOp(t2.KEEP, t2.KEEP, t2.REPLACE), t2.colorMask(false, false, false, false);
    }
    InitCoplanarStartColorPass() {
      this._type = 25;
    }
    DoCoplanarStartColorPass() {
      const t2 = this._gl;
      t2.enable(t2.STENCIL_TEST), t2.colorMask(true, true, true, true), t2.stencilFunc(t2.EQUAL, 1, 1), t2.stencilOp(t2.KEEP, t2.KEEP, t2.KEEP);
    }
    InitCoplanarRestore() {
      this._type = 26;
    }
    DoCoplanarRestore() {
      const t2 = this._gl;
      t2.disable(t2.STENCIL_TEST);
    }
    InitSetScissor(t2, e, r2, a2, s) {
      this._type = 27, this._startIndex = t2 ? 1 : 0;
      const i = this._mat4param;
      i[0] = e, i[1] = r2, i[2] = a2, i[3] = s;
    }
    DoSetScissor() {
      const t2 = this._gl, e = this._mat4param;
      1 === this._startIndex ? (t2.enable(t2.SCISSOR_TEST), t2.scissor(e[0], e[1], e[2], e[3])) : t2.disable(t2.SCISSOR_TEST);
    }
    InitSetCullFaceMode(t2) {
      this._type = 29, this._startIndex = t2;
    }
    DoSetCullFaceMode() {
      const t2 = this._gl, e = this._startIndex;
      0 === e ? t2.disable(t2.CULL_FACE) : (t2.enable(t2.CULL_FACE), 1 === e ? t2.cullFace(t2.BACK) : t2.cullFace(t2.FRONT));
    }
    InitSetFrontFaceWinding(t2) {
      this._type = 30, this._startIndex = t2;
    }
    DoSetFrontFaceWinding() {
      const t2 = this._gl;
      t2.frontFace(0 === this._startIndex ? t2.CW : t2.CCW);
    }
    Run() {
      switch (this._type) {
        case 1:
          return void this.DoDraw();
        case 2:
          return void this.DoSetTexture();
        case 3:
          return void this.DoSetBlend();
        case 4:
          return void this.DoSetViewport();
        case 5:
          return void this.DoSetProjection();
        case 6:
          return void this.DoSetModelView();
        case 7:
          return void this.DoSetRenderTarget();
        case 8:
          return void this.DoClearSurface();
        case 9:
          return void this.DoPoints();
        case 10:
          return void this.DoSetProgram();
        case 11:
          return void this.DoSetProgramParameters();
        case 12:
          return void this.DoSetProgramCustomParameters();
        case 13:
          return void this.DoInvalidateFramebuffer();
        case 14:
          return void this.DoSetPointTextureCoords();
        case 15:
          return void this.DoSetTilemapInfo();
        case 16:
          return void this.DoBlitFramebuffer();
        case 17:
          return void this.DoStartQuery();
        case 18:
          return void this.DoEndQuery();
        case 19:
          return void this.DoSetEllipseParams();
        case 20:
          return void this.DoSetGradientColor();
        case 21:
          return void this.DoClearDepth();
        case 22:
          return void this.DoSetDepthEnabled();
        case 23:
          return void this.DoSetDepthSamplingEnabled();
        case 24:
          return void this.DoCoplanarStartStencilPass();
        case 25:
          return void this.DoCoplanarStartColorPass();
        case 26:
          return void this.DoCoplanarRestore();
        case 27:
          return void this.DoSetScissor();
        case 28:
          return void this.DoSetTileRandomizationInfo();
        case 29:
          return void this.DoSetCullFaceMode();
        case 30:
          return void this.DoSetFrontFaceWinding();
      }
    }
  };
}
{
  let fillOrStrokeRect = function(t2, e, i, s, a2, n) {
    e ? t2.strokeRect(i, s, a2, n) : t2.fillRect(i, s, a2, n);
  }, ptToPx = function(t2) {
    return t2 * (4 / 3);
  }, getOffsetParam = function(t2, e) {
    t2 = t2.trim();
    const i = parseFloat(t2);
    return isFinite(i) ? t2.endsWith("%") ? e * i / 100 : i : 0;
  };
  fillOrStrokeRect2 = fillOrStrokeRect, ptToPx2 = ptToPx, getOffsetParam2 = getOffsetParam;
  const C32 = self.C3, MAX_TEXTURE_SIZE = 4096, EXTRA_LINE_HEIGHT = 4, GENERIC_FONT_FAMILIES = /* @__PURE__ */ new Set(["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui", "ui-serif", "ui-sans-serif", "ui-monospace", "ui-rounded", "math", "emoji", "fangsong"]), DEFAULT_OPTS = { timeout: 60 }, tempColor = new C32.Color(0, 0, 0, 1), VALID_HORIZ_ALIGNMENTS = /* @__PURE__ */ new Set(["left", "center", "right"]), VALID_VERT_ALIGNMENTS = /* @__PURE__ */ new Set(["top", "center", "bottom"]), VALID_WORD_WRAP_MODES = /* @__PURE__ */ new Set(["word", "cjk", "character"]), VALID_TEXT_DIRECTIONS = /* @__PURE__ */ new Set(["ltr", "rtl"]), MEASUREMENT_CACHE_MAX_ENTRIES = 1e3, MEASUREMENT_CACHE_DELETE_COUNT = 10, MEASUREMENT_CACHE_TIMEOUT = 2, allRendererTexts = /* @__PURE__ */ new Set();
  C32.FontManager && C32.FontManager.addEventListener("fontload", (t2) => {
    const e = t2.font.GetName();
    for (const t3 of allRendererTexts) (t3.IsBBCodeEnabled() || C32.equalsNoCase(t3.GetFontName(), e)) && (t3._SetWordWrapChanged(), t3._ClearMeasurementCache());
  });
  let didCheckFoundBoundingBoxSupport = false, supportsFontBoundingBoxMeasurements = false;
  C32.Gfx.RendererText = class {
    constructor(t2, e) {
      e = Object.assign({}, DEFAULT_OPTS, e), this._renderer = t2, this._fontName = "Arial", this._fontSize = 16, this._fontSizeScale = 1, this._lineHeight = 0, this._isBold = false, this._isItalic = false, this._colorStr = "black", this._isBBcodeEnabled = false, this._iconSet = null, this._iconSmoothing = true, this.onloadfont = null, this._alreadyLoadedFonts = /* @__PURE__ */ new Set(), this._horizontalAlign = "left", this._verticalAlign = "top", this._text = "", this._bbString = null, this._wrappedText = C32.New(C32.WordWrap), this._wrapMode = "word", this._textDirection = "ltr", this._wordWrapChanged = false, this._textLayoutChanged = false, this._drawChanged = false, this._forceRecreateTexture = false, this._drawMaxCharCount = -1, this._drawCharCount = 0, this._cssWidth = 0, this._cssHeight = 0, this._width = 0, this._height = 0, this._zoom = 1, this._textCanvas = null, this._textContext = null, this._measureContext = null, this._measureContextTop = null, this._lastCanvasWidth = -1, this._lastCanvasHeight = -1, this._lastTextCanvasFont = "", this._lastMeasureCanvasFont = "", this._lastTextCanvasFillStyle = "", this._lastTextCanvasOpacity = 1, this._lastTextCanvasLineWidth = 1, this._measureTextCallback = (t3) => this._MeasureText(t3), this._measurementCache = /* @__PURE__ */ new Map(), this._measurementCacheIdleTimeout = new C32.IdleTimeout(() => this._ClearMeasurementCache(true), 2), this._texture = null, this._enableMipMap = true, this._rcTex = new C32.Rect(), this._scaleFactor = 1, this._textureTimeout = new C32.IdleTimeout(() => {
        this.ReleaseTexture(), this._SetTextCanvasSize(8, 8), this._SetDrawChanged();
      }, e.timeout), this.ontextureupdate = null, this._wasReleased = false, allRendererTexts.add(this);
    }
    Release() {
      this.onloadfont = null, this._alreadyLoadedFonts.clear(), this._iconSet = null, this._bbString = null, this._textCanvas = null, this._textContext = null, this._measureContext = null, this._measureContextTop = null, this._measureTextCallback = null, this._ClearMeasurementCache(), this._measurementCacheIdleTimeout.Release(), this._textureTimeout.Release(), this.ontextureupdate = null, this.ReleaseTexture(), this._wrappedText.Clear(), this._wrappedText = null, this._renderer = null, this._wasReleased = true, allRendererTexts.delete(this);
    }
    _SetDrawChanged() {
      this._drawChanged = true;
    }
    _SetTextLayoutChanged() {
      this._SetDrawChanged(), this._textLayoutChanged = true;
    }
    _SetWordWrapChanged() {
      this._SetTextLayoutChanged(), this._wordWrapChanged = true;
    }
    SetBBCodeEnabled(t2) {
      if (t2 = !!t2, this._isBBcodeEnabled === t2) return;
      this._isBBcodeEnabled = t2;
      const e = this._isBBcodeEnabled ? "alphabetic" : "top";
      this._textContext && (this._textContext.textBaseline = e), this._measureContext && (this._measureContext.textBaseline = e), this._ClearMeasurementCache(), this._SetWordWrapChanged();
    }
    IsBBCodeEnabled() {
      return this._isBBcodeEnabled;
    }
    SetIconSet(t2) {
      this._iconSet !== t2 && (this._iconSet = t2, this._wrappedText.SetIconSet(t2), this._iconSet && this._iconSet.IsLoading() && this._iconSet.LoadContent().then(() => this._SetDrawChanged()), this._SetWordWrapChanged());
    }
    SetIconSmoothing(t2) {
      t2 = !!t2, this._iconSmoothing !== t2 && (this._iconSmoothing = t2, this._SetDrawChanged());
    }
    SetFontName(t2) {
      t2 || (t2 = "serif"), this._fontName !== t2 && (this._fontName = t2, this._ClearMeasurementCache(), this._SetWordWrapChanged());
    }
    GetFontName() {
      return this._fontName;
    }
    SetFontSize(t2) {
      t2 < 0.1 && (t2 = 0.1), this._fontSize !== t2 && (this._fontSize = t2, this._ClearMeasurementCache(), this._SetWordWrapChanged());
    }
    GetFontSize() {
      return this._fontSize;
    }
    SetFontSizeScale(t2) {
      this._fontSizeScale !== t2 && (this._fontSizeScale = t2, this._ClearMeasurementCache(), this._SetWordWrapChanged());
    }
    SetLineHeight(t2) {
      this._lineHeight !== t2 && (this._lineHeight = t2, this._SetTextLayoutChanged());
    }
    GetLineHeight() {
      return this._lineHeight;
    }
    SetBold(t2) {
      t2 = !!t2, this._isBold !== t2 && (this._isBold = t2, this._ClearMeasurementCache(), this._SetWordWrapChanged());
    }
    IsBold() {
      return this._isBold;
    }
    SetItalic(t2) {
      t2 = !!t2, this._isItalic !== t2 && (this._isItalic = t2, this._ClearMeasurementCache(), this._SetWordWrapChanged());
    }
    IsItalic() {
      return this._isItalic;
    }
    SetDrawMaxCharacterCount(t2) {
      t2 = Math.floor(t2), this._drawMaxCharCount !== t2 && (this._drawMaxCharCount = t2, this._SetDrawChanged());
    }
    GetDrawMaxCharacterCount() {
      return this._drawMaxCharCount;
    }
    _GetFontString(t2, e) {
      let i = [];
      (this._isBold || e.HasStyleTag("b")) && i.push("bold"), (this._isItalic || e.HasStyleTag("i")) && i.push("italic");
      const s = e.GetStyleTag("size"), a2 = (s ? parseFloat(s.param) : this._fontSize) * this._fontSizeScale;
      t2 ? i.push(a2 + "pt") : i.push(a2 * this.GetDrawScale() + "pt");
      let n = this._fontName;
      const h2 = e.GetStyleTag("font");
      return h2 && h2.param && (n = h2.param, this.onloadfont && !this._alreadyLoadedFonts.has(n) && (this.onloadfont(n), this._alreadyLoadedFonts.add(n))), n && (GENERIC_FONT_FAMILIES.has(n) ? i.push(n) : i.push('"' + n + '"')), i.join(" ");
    }
    SetColor(t2) {
      t2 instanceof C32.Color && (t2 = t2.getCssRgb()), this._colorStr !== t2 && (this._colorStr = t2, this._SetDrawChanged());
    }
    SetColorRgb(t2, e, i) {
      tempColor.setRgb(t2, e, i), this.SetColor(tempColor);
    }
    SetHorizontalAlignment(t2) {
      if (!VALID_HORIZ_ALIGNMENTS.has(t2)) throw new Error("invalid horizontal alignment");
      this._horizontalAlign !== t2 && (this._horizontalAlign = t2, this._SetTextLayoutChanged());
    }
    GetHorizontalAlignment() {
      return this._horizontalAlign;
    }
    SetVerticalAlignment(t2) {
      if (!VALID_VERT_ALIGNMENTS.has(t2)) throw new Error("invalid vertical alignment");
      this._verticalAlign !== t2 && (this._verticalAlign = t2, this._SetTextLayoutChanged());
    }
    GetVerticalAlignment() {
      return this._verticalAlign;
    }
    SetWordWrapMode(t2) {
      if (!VALID_WORD_WRAP_MODES.has(t2)) throw new Error("invalid word wrap mode");
      this._wrapMode !== t2 && (this._wrapMode = t2, this._ClearMeasurementCache(), this._SetWordWrapChanged());
    }
    GetWordWrapMode() {
      return this._wrapMode;
    }
    SetTextDirection(t2) {
      if (!VALID_TEXT_DIRECTIONS.has(t2)) throw new Error("invalid text direction");
      this._textDirection !== t2 && (this._textDirection = t2, this._textContext && (this._textContext.direction = this._textDirection), this._measureContext && (this._measureContext.direction = this._textDirection), this._ClearMeasurementCache(), this._SetWordWrapChanged());
    }
    GetTextDirection() {
      return this._textDirection;
    }
    SetText(t2) {
      this._text !== t2 && (this._text = t2, this._ClearMeasurementCache(), this._SetWordWrapChanged());
    }
    GetText() {
      return this._text;
    }
    GetDrawScale() {
      return this._scaleFactor * this._zoom * self.devicePixelRatio;
    }
    SetMipMapEnabled(t2) {
      t2 = !!t2, this._enableMipMap !== t2 && (this._enableMipMap = t2, this._forceRecreateTexture = true);
    }
    IsMipMapEnabled() {
      return this._enableMipMap;
    }
    SetSize(t2, e, i) {
      if (void 0 === i && (i = 1), t2 <= 0 || t2 <= 0) return;
      if (this._cssWidth === t2 && this._cssHeight === e && this._zoom === i) return;
      const s = this._cssWidth;
      this._cssWidth = t2, this._cssHeight = e, this._zoom = i;
      const a2 = self.devicePixelRatio;
      this._width = this._cssWidth * this._zoom * a2, this._height = this._cssHeight * this._zoom * a2;
      const n = Math.max(this._width, this._height), h2 = Math.min(this._renderer.GetMaxTextureSize(), 4096);
      let r2 = 1;
      n > h2 && (r2 = h2 / n, this._width = Math.min(this._width * r2, h2), this._height = Math.min(this._height * r2, h2)), this._scaleFactor = r2, this._cssWidth !== s ? this._SetWordWrapChanged() : this._SetTextLayoutChanged();
    }
    GetWidth() {
      return this._width;
    }
    GetHeight() {
      return this._height;
    }
    GetZoom() {
      return this._zoom;
    }
    GetTextWidth() {
      return this._UpdateTextMeasurements(), this._wrappedText.GetMaxLineWidth();
    }
    GetTextHeight() {
      return this._UpdateTextMeasurements(), this._wrappedText.GetTotalLineHeight() + this._wrappedText.GetLineCount() * (this._lineHeight + 4) - this._lineHeight;
    }
    GetLengthInGraphemes() {
      this._UpdateTextMeasurements();
      let t2 = 0;
      for (const e of this._wrappedText.GetLines()) for (const i of e.fragments()) t2 += i.GetLength();
      return t2;
    }
    GetTexture() {
      return this._textureTimeout.Reset(), this._MaybeUpdate(), this._texture;
    }
    HitTestFragment(t2, e) {
      this._UpdateTextMeasurements();
      const i = this.GetDrawScale(), s = this._wrappedText.GetLines();
      for (const a2 of s) {
        const s2 = a2.GetFontBoundingBoxDescent() * i;
        if (e >= a2.GetPosY() - a2.GetHeight() * i + s2 && e < a2.GetPosY() + s2) {
          for (const e2 of a2.fragments()) if (t2 >= e2.GetPosX() && t2 < e2.GetPosX() + e2.GetWidth() * i) return e2;
        }
      }
      return null;
    }
    *fragmentsWithTag(t2) {
      this._UpdateTextMeasurements();
      const e = this._wrappedText.GetLines();
      for (const i of e) for (const e2 of i.fragments()) {
        const i2 = e2.GetStyleTag("tag");
        i2 && C32.equalsNoCase(i2.param, t2) && (yield e2);
      }
    }
    FindFragmentWithTag(t2, e) {
      for (const i of this.fragmentsWithTag(t2)) {
        if (0 === e) return i;
        --e;
      }
      return null;
    }
    CountFragmentsWithTag(t2) {
      let e = 0;
      for (const i of this.fragmentsWithTag(t2)) ++e;
      return e;
    }
    _MaybeUpdate() {
      (!this._texture || this._drawChanged || this._textLayoutChanged || this._wordWrapChanged || this._forceRecreateTexture) && (this._wasReleased || this._width <= 0 || this._height <= 0 || this._DoUpdate());
    }
    _DoUpdate() {
      this._wasReleased || (this._UpdateTextMeasurements(), this._SetTextCanvasSize(Math.max(C32.nextHighestPowerOfTwo(Math.ceil(this._width)), 128), Math.max(C32.nextHighestPowerOfTwo(Math.ceil(this._height)), 64)), this._DrawTextToCanvas(), this._UpdateTexture(), this._textureTimeout.Reset());
    }
    _SetTextCanvasSize(t2, e) {
      this._textCanvas || (this._textCanvas = C32.CreateCanvas(16, 16));
      let i = false;
      this._lastCanvasWidth === t2 && this._lastCanvasHeight === e || (this._lastCanvasWidth = t2, this._lastCanvasHeight = e, this._textCanvas.width = t2, this._textCanvas.height = e, i = true), this._textContext || (this._textContext = this._textCanvas.getContext("2d"), i = true), i ? (this._textContext.textBaseline = this._isBBcodeEnabled ? "alphabetic" : "top", this._textContext.direction = this._textDirection, this._textContext.font = this._lastTextCanvasFont, this._textContext.fillStyle = this._lastTextCanvasFillStyle, this._textContext.strokeStyle = this._lastTextCanvasFillStyle, this._textContext.globalAlpha = this._lastTextCanvasOpacity, this._textContext.lineWidth = this._lastTextCanvasLineWidth) : this._textContext.clearRect(0, 0, t2, e);
    }
    _MaybeCreateMeasureContext() {
      this._measureContext || (this._measureContext = C32.CreateCanvas(16, 16).getContext("2d"), this._measureContextTop = C32.CreateCanvas(16, 16).getContext("2d"), this._measureContext.textBaseline = this._isBBcodeEnabled ? "alphabetic" : "top", this._measureContextTop.textBaseline = "top", this._measureContext.direction = this._textDirection, this._measureContextTop.direction = this._textDirection);
    }
    _SetMeasureFontString(t2) {
      this._lastMeasureCanvasFont !== t2 && (this._lastMeasureCanvasFont = t2, this._measureContext.font = t2, this._measureContextTop.font = t2);
    }
    _SupportsFontBoundingBoxMeasurements() {
      if (!didCheckFoundBoundingBoxSupport) {
        didCheckFoundBoundingBoxSupport = true, this._MaybeCreateMeasureContext();
        const t2 = this._measureContext.measureText("test");
        supportsFontBoundingBoxMeasurements = "number" == typeof t2["fontBoundingBoxAscent"] && "number" == typeof t2["fontBoundingBoxDescent"];
      }
      return supportsFontBoundingBoxMeasurements;
    }
    _UpdateTextMeasurements() {
      this._UpdateWordWrap(), this._UpdateTextLayout();
    }
    _UpdateWordWrap() {
      this._wordWrapChanged && (this._MaybeCreateMeasureContext(), !this._isBBcodeEnabled || this._bbString && this._bbString.toString() === this._text || (this._bbString = new C32.BBString(this._text, { noEscape: true })), this._measurementCacheIdleTimeout.Reset(), this._wrappedText.WordWrap(this._isBBcodeEnabled ? this._bbString.toFragmentList() : this._text, this._measureTextCallback, this._cssWidth, this._wrapMode, 0), this._wordWrapChanged = false);
    }
    _UpdateTextLayout() {
      this._textLayoutChanged && (this._LayoutText(), this._textLayoutChanged = false);
    }
    _ClearMeasurementCache(t2) {
      this._measurementCache.clear(), t2 || this._measurementCacheIdleTimeout.Cancel();
    }
    _AddToMeasurementCache(t2, e) {
      const i = this._measurementCache;
      if (i.set(t2, e), i.size > 1e3) {
        let t3 = 0;
        for (const e2 of i.keys()) if (i.delete(e2), t3++, t3 >= 10) break;
      }
    }
    _MeasureText(t2) {
      const e = t2.IsText() ? t2.GetCharacterArray().join("") : " ", i = this._GetFontString(true, t2), s = i + "|" + e, a2 = this._measurementCache;
      let n = a2.get(s);
      if (n) return a2.delete(s), a2.set(s, n), n;
      this._SetMeasureFontString(i);
      const h2 = this._measureContext.measureText(e);
      let r2 = 0;
      if (this._isBBcodeEnabled && this._SupportsFontBoundingBoxMeasurements()) {
        const t3 = this._measureContextTop.measureText(e);
        r2 = h2["fontBoundingBoxAscent"] - t3["fontBoundingBoxAscent"];
      }
      const o2 = t2.GetStyleTag("size"), _2 = (o2 ? parseFloat(o2.param) : this._fontSize) * this._fontSizeScale;
      return n = { width: h2.width, height: ptToPx(_2), fontBoundingBoxAscent: h2["fontBoundingBoxAscent"] || 0, fontBoundingBoxDescent: h2["fontBoundingBoxDescent"] || 0, topToAlphabeticDistance: r2 }, this._AddToMeasurementCache(s, n), n;
    }
    _SetDrawFontString(t2) {
      this._lastTextCanvasFont !== t2 && (this._lastTextCanvasFont = t2, this._textContext.font = t2);
    }
    _SetDrawCanvasColor(t2) {
      this._lastTextCanvasFillStyle !== t2 && (this._lastTextCanvasFillStyle = t2, this._textContext.fillStyle = t2, this._textContext.strokeStyle = t2);
    }
    _SetDrawCanvasOpacity(t2) {
      this._lastTextCanvasOpacity !== t2 && (this._lastTextCanvasOpacity = t2, this._textContext.globalAlpha = t2);
    }
    _SetDrawCanvasLineWith(t2) {
      this._lastTextCanvasLineWidth !== t2 && (this._lastTextCanvasLineWidth = t2, this._textContext.lineWidth = t2);
    }
    _LayoutText() {
      const t2 = this.GetDrawScale(), e = (4 + this._lineHeight) * t2;
      let i = 0;
      const s = this._wrappedText.GetLines();
      if (0 === s.length) return;
      for (const t3 of s) {
        t3.SetPosX(NaN), t3.SetPosY(NaN);
        for (const e2 of t3.fragments()) e2.SetPosX(NaN), e2.SetPosY(NaN);
      }
      const a2 = this._isBBcodeEnabled && this._SupportsFontBoundingBoxMeasurements();
      let n = s[0].GetHeight() * t2;
      if ("center" === this._verticalAlign) {
        const h2 = s.reduce((i2, s2) => i2 + s2.GetHeight() * t2 + e, 0) - e;
        i = Math.max(this._height / 2 - h2 / 2, 0), a2 && (n = s[0].GetTopToAlphabeticDistance() * t2);
      } else if ("bottom" === this._verticalAlign) {
        const n2 = s.reduce((i2, s2) => i2 + s2.GetHeight() * t2 + e, 0) - this._lineHeight * t2, h2 = a2 ? s.at(-1).GetFontBoundingBoxDescent() * t2 : 0;
        i = this._height - n2 - h2 - 2;
      }
      for (let a3 = 0, h2 = s.length; a3 < h2; ++a3) {
        const h3 = s[a3], r2 = h3.GetHeight() * t2, o2 = i;
        if (this._isBBcodeEnabled) {
          if (i += 0 === a3 ? n : r2, a3 > 0 && i > this._height - 4 * t2) break;
        } else if (a3 > 0 && i >= this._height - r2) break;
        o2 >= 0 && this._LayoutTextLine(h3, i, t2), this._isBBcodeEnabled || (i += r2), i += e;
      }
    }
    _LayoutTextLine(t2, e, i) {
      let s = 0;
      "center" === this._horizontalAlign ? s = Math.floor((this._width - t2.GetWidth() * i) / 2) : "right" === this._horizontalAlign && (s = this._width - t2.GetWidth() * i), t2.SetPosX(s), t2.SetPosY(e);
      for (const a2 of "ltr" === this._textDirection ? t2.fragments() : t2.fragmentsReverse()) this._LayoutFragment(a2, s, e, i), s += a2.GetWidth() * i;
    }
    _LayoutFragment(t2, e, i, s) {
      const a2 = t2.GetStyleTag("offsetx");
      e += a2 ? getOffsetParam(a2.param, t2.GetHeight()) * s : 0;
      const n = t2.GetStyleTag("offsety");
      if (i += n ? getOffsetParam(n.param, t2.GetHeight()) * s : 0, t2.IsIcon()) {
        const e2 = t2.GetStyleTag("iconoffsety");
        i += e2 ? getOffsetParam(e2.param, t2.GetHeight()) * s : 0.2 * t2.GetHeight() * s;
      }
      t2.SetPosX(e), t2.SetPosY(i);
    }
    _DrawTextToCanvas() {
      if (!this._drawChanged) return;
      this._textContext.imageSmoothingEnabled = this._iconSmoothing, this._textContext.imageSmoothingQuality = "high", this._drawCharCount = 0;
      const t2 = this.GetDrawScale(), e = this._wrappedText.GetLines();
      for (const i of e) this._DrawTextLine(i, t2);
      this._drawChanged = false;
    }
    _DrawTextLine(t2, e) {
      const i = t2.GetPosX(), s = t2.GetPosY();
      if (Number.isFinite(i) && Number.isFinite(s)) for (const i2 of "ltr" === this._textDirection ? t2.fragments() : t2.fragmentsReverse()) this._DrawFragment(i2, e, t2.GetHeight());
    }
    _DrawFragment(t2, e, i) {
      const s = this._textContext, a2 = t2.GetPosX(), n = t2.GetPosY();
      if (!Number.isFinite(a2) || !Number.isFinite(n)) return;
      const h2 = i / 16;
      let r2 = t2.GetWidth() * e;
      const o2 = t2.GetHeight() * e, _2 = t2.GetHeight() / 16, l = (4 + this._lineHeight) * e;
      let d2 = t2.IsText() ? t2.GetCharacterArray() : null;
      if (-1 !== this._drawMaxCharCount) {
        if (this._drawCharCount >= this._drawMaxCharCount) return;
        t2.IsText() && this._drawCharCount + d2.length > this._drawMaxCharCount && (d2 = d2.slice(0, this._drawMaxCharCount - this._drawCharCount), r2 = this._MeasureText(t2).width * e), this._drawCharCount += t2.GetLength();
      }
      const x2 = t2.GetStyleTag("background"), C2 = t2.HasStyleTag("u"), u2 = t2.HasStyleTag("s");
      if (t2.IsText() && C32.IsCharArrayAllWhitespace(d2) && !x2 && !C2 && !u2 || t2.HasStyleTag("hide")) return;
      const c2 = t2.GetStyleTag("color"), g2 = t2.GetStyleTag("opacity");
      this._SetDrawCanvasOpacity(g2 ? parseFloat(g2.param) / 100 : 1), x2 && (this._SetDrawCanvasColor(x2.param), s.fillRect(a2, n - o2, r2, o2 + l));
      const S2 = t2.GetStyleTag("linethickness"), T2 = S2 ? parseFloat(S2.param) : 1, m2 = t2.HasStyleTag("stroke");
      if (m2 && this._SetDrawCanvasLineWith(0.5 * _2 * T2 * this.GetDrawScale()), t2.IsText()) {
        const e2 = d2.join("");
        if (this._SetDrawFontString(this._GetFontString(false, t2)), !m2) {
          this._SetDrawCanvasLineWith(0.5 * _2 * T2 * this.GetDrawScale());
          const i2 = t2.GetStyleTag("outlineback");
          i2 && (this._SetDrawCanvasColor(i2.param), this._FillOrStrokeText(true, e2, a2, n, r2));
        }
        if (this._SetDrawCanvasColor(c2 ? c2.param : this._colorStr), this._FillOrStrokeText(m2, e2, a2, n, r2), !m2) {
          this._SetDrawCanvasLineWith(0.5 * _2 * T2 * this.GetDrawScale());
          const i2 = t2.GetStyleTag("outline");
          i2 && (this._SetDrawCanvasColor(i2.param), this._FillOrStrokeText(true, e2, a2, n, r2));
        }
      } else if (t2.IsIcon() && t2.GetWidth() > 0) {
        const e2 = t2.GetDrawable(this._iconSet);
        e2 && s.drawImage(e2, a2, n - o2, r2, o2);
      }
      if (this._SetDrawCanvasColor(c2 ? c2.param : this._colorStr), C2 && fillOrStrokeRect(s, m2, a2, n + e * h2, r2, e * h2 * T2), u2) {
        const t3 = e * _2, i2 = n - o2 / 4 + t3 / 2;
        s.fillRect(a2, i2 - t3 * T2 / 2, r2, t3 * T2);
      }
    }
    _FillOrStrokeText(t2, e, i, s, a2) {
      "rtl" === this._textDirection && (i += a2), t2 ? "Gecko" === C32.Platform.BrowserEngine ? this._textContext.strokeText(e, i, s, a2) : this._textContext.strokeText(e, i, s) : "Gecko" === C32.Platform.BrowserEngine ? this._textContext.fillText(e, i, s, a2) : this._textContext.fillText(e, i, s);
    }
    _UpdateTexture() {
      this._renderer.IsContextLost() || (this._texture && !this._forceRecreateTexture || (this.ReleaseTexture(), this._texture = this._renderer.CreateDynamicTexture(this._textCanvas.width, this._textCanvas.height, { mipMap: this._enableMipMap, mipMapQuality: "high" }), this._forceRecreateTexture = false), this._renderer.UpdateTexture(this._textCanvas, this._texture), this._rcTex.set(0, 0, this._width / this._texture.GetWidth(), this._height / this._texture.GetHeight()), this.ontextureupdate && this.ontextureupdate());
    }
    GetTexRect() {
      return this._rcTex;
    }
    ReleaseTexture() {
      this._texture && (this._renderer.IsContextLost() || this._renderer.DeleteTexture(this._texture), this._texture = null);
    }
    static OnContextLost() {
      for (const t2 of allRendererTexts) t2.ReleaseTexture();
    }
    static GetAll() {
      return allRendererTexts.values();
    }
  };
}
var fillOrStrokeRect2;
var ptToPx2;
var getOffsetParam2;
{
  const C32 = self.C3;
  class WebGLRealTimeElapsedQuery {
    constructor(e) {
      this._gl = e.GetContext(), this._version = e.GetWebGLVersionNumber(), this._timerExt = e._GetDisjointTimerQueryExtension(), this._query = null, this._isActive = false, this._hasResult = false, this._result = 0, 1 === this._version ? this._query = this._timerExt["createQueryEXT"]() : this._query = this._gl["createQuery"]();
    }
    Release() {
      this._DeleteQueryObject(), this._gl = null, this._timerExt = null, this._hasResult = false;
    }
    _DeleteQueryObject() {
      this._query && (1 === this._version ? this._timerExt["deleteQueryEXT"](this._query) : this._gl["deleteQuery"](this._query), this._query = null);
    }
    BeginTimeElapsed() {
      if (this._isActive) throw new Error("query already active");
      1 === this._version ? this._timerExt["beginQueryEXT"](this._timerExt["TIME_ELAPSED_EXT"], this._query) : this._gl["beginQuery"](this._timerExt["TIME_ELAPSED_EXT"], this._query), this._isActive = true;
    }
    EndTimeElapsed() {
      if (!this._isActive) throw new Error("query not active");
      1 === this._version ? this._timerExt["endQueryEXT"](this._timerExt["TIME_ELAPSED_EXT"]) : this._gl["endQuery"](this._timerExt["TIME_ELAPSED_EXT"]), this._isActive = false;
    }
    CheckForResult() {
      if (!this._query || this._hasResult || this._isActive) return;
      let e = false;
      e = 1 === this._version ? this._timerExt["getQueryObjectEXT"](this._query, this._timerExt["QUERY_RESULT_AVAILABLE_EXT"]) : this._gl["getQueryParameter"](this._query, this._gl["QUERY_RESULT_AVAILABLE"]);
      const t2 = this._gl.getParameter(this._timerExt["GPU_DISJOINT_EXT"]);
      e && !t2 && (1 === this._version ? this._result = this._timerExt["getQueryObjectEXT"](this._query, this._timerExt["QUERY_RESULT_EXT"]) : this._result = this._gl["getQueryParameter"](this._query, this._gl["QUERY_RESULT"]), this._result /= 1e9, this._hasResult = true), (e || t2) && this._DeleteQueryObject();
    }
    HasResult() {
      return this._hasResult;
    }
    GetResult() {
      if (!this._hasResult) throw new Error("no result available");
      return this._result;
    }
  }
  C32.Gfx.WebGLTimeElapsedQuery = class {
    constructor(e) {
      this._renderer = e, this._frameNumber = e.GetFrameNumber(), this._isActive = false, this._parentQuery = null, this._isNested = false, this._realQuery = null, this._queries = [];
    }
    Release() {
      for (const e of this._queries) e instanceof WebGLRealTimeElapsedQuery && e.Release();
      C32.clearArray(this._queries), this._parentQuery = null, this._realQuery = null, this._renderer = null;
    }
    BeginTimeElapsed() {
      if (this._isActive) throw new Error("query already active");
      const e = this._renderer._GetTimeQueryStack();
      e.length > 0 ? (this._isNested = true, this._parentQuery = e.at(-1), this._parentQuery._EndReal(), this._parentQuery._queries.push(this)) : (this._isNested = false, this._parentQuery = null), this._isActive = true, e.push(this), this._StartReal();
    }
    EndTimeElapsed() {
      if (!this._isActive) throw new Error("query not active");
      if (this._renderer._GetTimeQueryStack().pop() !== this) throw new Error("can only end most nested query");
      this._isActive = false, this._EndReal(), this._parentQuery && (this._parentQuery._StartReal(), this._parentQuery = null);
    }
    _StartReal() {
      this._realQuery = C32.New(WebGLRealTimeElapsedQuery, this._renderer), this._queries.push(this._realQuery), this._realQuery.BeginTimeElapsed();
    }
    _EndReal() {
      this._realQuery.EndTimeElapsed(), this._realQuery = null;
    }
    CheckForResult() {
      for (const e of this._queries) e.CheckForResult();
    }
    IsNested() {
      return this._isNested;
    }
    HasResult() {
      return this._queries.every((e) => e.HasResult());
    }
    GetResult() {
      return this._queries.reduce((e, t2) => e + t2.GetResult(), 0);
    }
    GetFrameNumber() {
      return this._frameNumber;
    }
  };
}
{
  const C32 = self.C3;
  C32.Gfx.WebGLQueryResultBuffer = class {
    constructor(e, r2 = 1e3) {
      this._renderer = e, this._maxQueries = r2, this._buffer = [], this._renderer._AddQueryResultBuffer(this);
    }
    Release() {
      this.Clear(), this._renderer._RemoveQueryResultBuffer(this), this._renderer = null;
    }
    Clear() {
      for (const e of this._buffer) e.Release();
      C32.clearArray(this._buffer);
    }
    AddTimeElapsedQuery() {
      const e = new C32.Gfx.WebGLTimeElapsedQuery(this._renderer);
      if (this._buffer.push(e), this._buffer.length > this._maxQueries) {
        this._buffer.shift().Release();
      }
      return e;
    }
    CheckForResults(e) {
      for (const r2 of this._buffer) {
        if (r2.GetFrameNumber() >= e) return;
        if (r2.IsNested()) return;
        r2.CheckForResult();
      }
    }
    GetFrameRangeResultSum(e, r2) {
      if (r2 <= e) return NaN;
      let t2 = 0;
      for (const s of this._buffer) {
        if (s.GetFrameNumber() >= r2) break;
        if (!(s.GetFrameNumber() < e)) {
          if (!s.HasResult()) return NaN;
          t2 += s.GetResult();
        }
      }
      return t2;
    }
    DeleteAllBeforeFrameNumber(e) {
      for (let r2 = 0, t2 = this._buffer.length; r2 < t2; ++r2) {
        const t3 = this._buffer[r2];
        if (!(t3.GetFrameNumber() < e)) return void (r2 > 0 && this._buffer.splice(0, r2));
        t3.Release();
      }
    }
  };
}
{
  let CheckPendingPolls = function() {
    pollRafId = -1;
    for (const t2 of pendingPolls) t2.checkFunc() && (t2.resolve(), pendingPolls.delete(t2));
    pendingPolls.size > 0 && (pollRafId = self.requestAnimationFrame(CheckPendingPolls));
  };
  CheckPendingPolls2 = CheckPendingPolls;
  const C32 = self.C3, assert = self.assert, glMatrix = self.glMatrix, vec3 = glMatrix.vec3, vec4 = glMatrix.vec4, mat4 = glMatrix.mat4, DEFAULT_WEBGLRENDERER_OPTS = { powerPreference: "default", enableGpuProfiling: true, alpha: false, depth: false, canSampleDepth: false, maxWebGLVersion: 2, failIfMajorPerformanceCaveat: false }, VALID_POWER_PREFERENCES = /* @__PURE__ */ new Set(["default", "low-power", "high-performance"]), MAX_VERTICES = 65535, MAX_INDICES = 393210, MAX_POINTS = 8e3, LAST_POINT = 7996, defaultTexCoordsQuad = new C32.Quad(0, 0, 1, 0, 1, 1, 0, 1), tmpProjection = mat4.create(), tmpModelView = mat4.create(), tmpQuad = new C32.Quad(), tmpRect = new C32.Rect();
  let loseContextExtension = null;
  C32.isDebug && (self.debug_lose_webgl_context = function() {
    loseContextExtension ? loseContextExtension.loseContext() : console.warn("WEBGL_lose_context not supported");
  }, self.debug_restore_webgl_context = function() {
    loseContextExtension ? loseContextExtension.restoreContext() : console.warn("WEBGL_lose_context not supported");
  });
  const pendingPolls = /* @__PURE__ */ new Set();
  let pollRafId = -1;
  C32.Gfx.WebGLRenderer = class extends C32.Gfx.RendererBase {
    constructor(t2, e) {
      if (super(e), e = Object.assign({}, DEFAULT_WEBGLRENDERER_OPTS, e), !VALID_POWER_PREFERENCES.has(e.powerPreference)) throw new Error("invalid power preference");
      const r2 = { "alpha": !!e.alpha, "depth": false, "antialias": false, "powerPreference": e.powerPreference, "failIfMajorPerformanceCaveat": !!e.failIfMajorPerformanceCaveat };
      let i = null, s = 0;
      if (e.maxWebGLVersion >= 2 && (i = t2.getContext("webgl2", r2), s = 2), i || (i = t2.getContext("webgl", r2), s = 1), !i) throw new Error("renderer-unavailable (could not get WebGL context)");
      this._gl = i, this._attribs = i.getContextAttributes(), this._versionString = i.getParameter(i.VERSION), this._version = s, this._viewport = vec4.create(), this._didChangeTransform = false, this._bbProjectionMatrix = mat4.create(), this._usesDepthBuffer = !!e.depth, this._canSampleDepth = !(!e.depth || !e.canSampleDepth), this._isDepthEnabled = this._usesDepthBuffer, this._isDepthSamplingEnabled = false, this._depthBuffer = null, this._isAutoSizeDepthBuffer = true, this._depthBufferWidth = 0, this._depthBufferHeight = 0, this._vertexBuffer = null, this._texcoordBuffer = null, this._colorBuffer = null, this._indexBuffer = null, this._pointBuffer = null, this._isColorDataF16 = this._version >= 2 && void 0 !== globalThis["Float16Array"], this._vertexData = new Float32Array(196605), this._indexData = new Uint16Array(393210), this._texcoordData = new Float32Array(131070), this._colorData = this._isColorDataF16 ? new globalThis["Float16Array"](262140) : new Float32Array(262140), this._pointData = new Float32Array(32e3), this._vertexPtr = 0, this._indexPtr = 0, this._pointPtr = 0, this._lastProgram = null, this._spDeviceTransformTextureFill = null, this._batch = [], this._batchPtr = 0, this._topOfBatch = 0, this._currentRenderTarget = null, this._lastPointZ = 0, this._batchState = C32.New(C32.Gfx.BatchState, this), this._lastColor = C32.New(C32.Color, 1, 1, 1, 1), this._lastTexture0 = null, this._lastTexture1 = null, this._lastSrcBlend = 0, this._lastDestBlend = 0, this._lastPointTexCoords = new C32.Rect(), this._lastScissorRect = C32.New(C32.Rect, 0, 0, -1, -1), this._coplanarMode = 0, this._lastCullFace = 0, this._lastFrontFaceWinding = 0, this._maxTextureSize = -1, this._minPointSize = 0, this._maxPointSize = 0, this._unmaskedVendor = "(unavailable)", this._unmaskedRenderer = "(unavailable)", this._extensions = [], this._isInitialisingAfterContextRestored = false, this._parallelShaderCompileExt = null, this._anisotropicExt = null, this._conservativeDepthExt = null, this._depthTextureExt = null, this._fragDepthExt = null, this._stdDerivativesExt = null, this._textureLodExt = null, this._maxAnisotropy = 0, this._isGpuProfilingEnabled = !!e.enableGpuProfiling, this._timerExt = null, this._allQueryResultBuffers = /* @__PURE__ */ new Set(), this._timeQueryStack = [];
    }
    IsWebGL() {
      return true;
    }
    async InitState() {
      super.InitState();
      const t2 = this._gl;
      this._lastColor.setRgba(1, 1, 1, 1), this._lastTexture0 = null, this._lastTexture1 = null, this._vertexPtr = 0, this._indexPtr = 0, this._pointPtr = 0, C32.clearArray(this._batch), this._batchPtr = 0, this._topOfBatch = 0, this._lastProgram = null, this._currentRenderTarget = null, this._lastPointTexCoords.set(0, 0, 1, 1), this._lastPointZ = 0;
      const e = this._batchState;
      e.currentShader = null, e.currentFramebuffer = null, e.currentFramebufferNoDepth = null, e.clearColor.setRgba(0, 0, 0, 0), e.pointTexCoords.set(0, 0, 1, 1), t2.clearColor(0, 0, 0, 0), t2.clear(t2.COLOR_BUFFER_BIT), t2.enable(t2.BLEND), t2.blendFunc(t2.ONE, t2.ONE_MINUS_SRC_ALPHA), this._lastSrcBlend = t2.ONE, this._lastDestBlend = t2.ONE_MINUS_SRC_ALPHA, this._InitBlendModes(t2), t2.cullFace(t2.BACK), t2.disable(t2.CULL_FACE), this._lastCullFace = 0, t2.frontFace(t2.CW), this._lastFrontFaceWinding = 0, t2.disable(t2.STENCIL_TEST), t2.disable(t2.DITHER), this._usesDepthBuffer ? (t2.enable(t2.DEPTH_TEST), t2.depthMask(true), t2.depthFunc(t2.LEQUAL)) : (t2.disable(t2.DEPTH_TEST), t2.depthMask(false)), this._isDepthEnabled = this._usesDepthBuffer, this._isDepthSamplingEnabled = false, this._pointBuffer = t2.createBuffer(), t2.bindBuffer(t2.ARRAY_BUFFER, this._pointBuffer), t2.bufferData(t2.ARRAY_BUFFER, this._pointData.byteLength, t2.DYNAMIC_DRAW), this._vertexBuffer = t2.createBuffer(), t2.bindBuffer(t2.ARRAY_BUFFER, this._vertexBuffer), t2.bufferData(t2.ARRAY_BUFFER, this._vertexData.byteLength, t2.DYNAMIC_DRAW), this._texcoordBuffer = t2.createBuffer(), t2.bindBuffer(t2.ARRAY_BUFFER, this._texcoordBuffer), t2.bufferData(t2.ARRAY_BUFFER, this._texcoordData.byteLength, t2.DYNAMIC_DRAW), this._colorBuffer = t2.createBuffer(), t2.bindBuffer(t2.ARRAY_BUFFER, this._colorBuffer), t2.bufferData(t2.ARRAY_BUFFER, this._colorData.byteLength, t2.DYNAMIC_DRAW), this._indexBuffer = t2.createBuffer(), t2.bindBuffer(t2.ELEMENT_ARRAY_BUFFER, this._indexBuffer), t2.bufferData(t2.ELEMENT_ARRAY_BUFFER, this._indexData.byteLength, t2.DYNAMIC_DRAW), t2.activeTexture(t2.TEXTURE0), t2.bindTexture(t2.TEXTURE_2D, null), this._maxTextureSize = t2.getParameter(t2.MAX_TEXTURE_SIZE);
      const r2 = t2.getParameter(t2.ALIASED_POINT_SIZE_RANGE);
      this._minPointSize = r2[0], this._maxPointSize = r2[1], this._maxPointSize > 2048 && (this._maxPointSize = 2048), this._extensions = t2.getSupportedExtensions();
      const i = t2.getExtension("WEBGL_debug_renderer_info");
      if (i && (this._unmaskedVendor = t2.getParameter(i["UNMASKED_VENDOR_WEBGL"]), this._unmaskedRenderer = t2.getParameter(i["UNMASKED_RENDERER_WEBGL"])), this._parallelShaderCompileExt = t2.getExtension("KHR_parallel_shader_compile"), this._version >= 2 && ("Chromium" !== C32.Platform.BrowserEngine || C32.Platform.BrowserVersionNumber >= 135) && (this._conservativeDepthExt = t2.getExtension("EXT_conservative_depth")), C32.isDebug && (loseContextExtension = t2.getExtension("WEBGL_lose_context")), this._isGpuProfilingEnabled && (1 === this.GetWebGLVersionNumber() ? this._timerExt = t2.getExtension("EXT_disjoint_timer_query") : this._timerExt = t2.getExtension("EXT_disjoint_timer_query_webgl2") || t2.getExtension("EXT_disjoint_timer_query")), this._anisotropicExt = t2.getExtension("EXT_texture_filter_anisotropic"), this._anisotropicExt ? this._maxAnisotropy = t2.getParameter(this._anisotropicExt["MAX_TEXTURE_MAX_ANISOTROPY_EXT"]) : this._maxAnisotropy = 0, this.GetWebGLVersionNumber() < 2 && this._usesDepthBuffer && this._canSampleDepth && (this._depthTextureExt = t2.getExtension("WEBGL_depth_texture"), !this._depthTextureExt)) throw new Error("no depth texture support");
      this.GetWebGLVersionNumber() < 2 && (this._fragDepthExt = t2.getExtension("EXT_frag_depth"), this._stdDerivativesExt = t2.getExtension("OES_standard_derivatives"), this._textureLodExt = t2.getExtension("EXT_shader_texture_lod"));
      const s = C32.Gfx.WebGLShaderProgram, a2 = s.GetDefaultVertexShaderSource(false);
      let h2 = s.GetTextureFillFragmentShaderSource_WebGL1_NoFragDepth(), n = a2, o2 = s.GetPointFragmentShaderSource_WebGL1_NoFragDepth(), l = s.GetPointVertexShaderSource_WebGL1(), _2 = s.GetTilemapFragmentShaderSource_WebGL1_NoFragDepth(), u2 = s.GetDefaultVertexShaderSource(true), d2 = false;
      this._usesDepthBuffer && (this.GetWebGLVersionNumber() < 2 ? this._fragDepthExt && (h2 = s.GetTextureFillFragmentShaderSource_WebGL1_FragDepthEXT(), o2 = s.GetPointFragmentShaderSource_WebGL1_FragDepthEXT(), _2 = s.GetTilemapFragmentShaderSource_WebGL1_FragDepthEXT(), d2 = true) : (n = s.GetDefaultVertexShaderSource_WebGL2(), h2 = s.GetTextureFillFragmentShaderSource_WebGL2(this._SupportsConservativeDepth()), o2 = s.GetPointFragmentShaderSource_WebGL2(this._SupportsConservativeDepth()), l = s.GetPointVertexShaderSource_WebGL2(), _2 = s.GetTilemapFragmentShaderSource_WebGL2(this._SupportsConservativeDepth()), u2 = s.GetDefaultVertexShaderSource_WebGL2(true)));
      const c2 = s.GetTileRandomizationFragmentShaderSource(this.GetWebGLVersionNumber(), d2, this._stdDerivativesExt && this._textureLodExt, this._SupportsConservativeDepth()), f2 = this.GetWebGLVersionNumber() >= 2 ? s.GetDefaultVertexShaderSource_WebGL2() : a2, p2 = [[h2, n, "<default>"], [h2, n, "<default-device-transform>"], [o2, l, "<point>"], [s.GetColorFillFragmentShaderSource(), a2, "<fill>"], [s.GetLinearGradientFillFragmentShaderSource(), a2, "<lineargradient>"], [s.GetPenumbraFillFragmentShaderSource(), a2, "<penumbra>"], [s.GetHardEllipseFillFragmentShaderSource(), a2, "<hardellipse>"], [s.GetHardEllipseOutlineFragmentShaderSource(), a2, "<hardellipseoutline>"], [s.GetSmoothEllipseFillFragmentShaderSource(), a2, "<smoothellipse>"], [s.GetSmoothEllipseOutlineFragmentShaderSource(), a2, "<smoothellipseoutline>"], [s.GetSmoothLineFillFragmentShaderSource(), a2, "<smoothline>"], [_2, u2, "<tilemap>"], [c2, f2, "<tilerandomization>"]], x2 = await Promise.all(p2.map((t3) => this.CreateShaderProgram({ src: t3[0], vertexSrc: t3[1], name: t3[2] })));
      this._spTextureFill = x2[0], this._spDeviceTransformTextureFill = x2[1], this._spPoints = x2[2], this._spColorFill = x2[3], this._spLinearGradientFill = x2[4], this._spPenumbraFill = x2[5], this._spHardEllipseFill = x2[6], this._spHardEllipseOutline = x2[7], this._spSmoothEllipseFill = x2[8], this._spSmoothEllipseOutline = x2[9], this._spSmoothLineFill = x2[10], this._spTilemapFill = x2[11], this._spTileRandomization = x2[12], this.SetTextureFillMode();
    }
    async CreateShaderProgram(t2) {
      const e = await C32.Gfx.WebGLShaderProgram.Create(this, t2);
      return this._AddShaderProgram(e), e;
    }
    ResetLastProgram() {
      this._lastProgram = null;
    }
    SetSize(t2, e, r2) {
      if (this._width === t2 && this._height === e && !r2) return;
      this.EndBatch();
      const i = this._gl, s = this._batchState;
      this._width = t2, this._height = e, this._SetViewport(0, 0, t2, e), this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, t2 / e), this.SetProjectionMatrix(this._bbProjectionMatrix), this._spDeviceTransformTextureFill && (i.useProgram(this._spDeviceTransformTextureFill.GetShaderProgram()), this._spDeviceTransformTextureFill._UpdateDeviceTransformUniforms(this._matP), this._lastProgram = this._spDeviceTransformTextureFill, this._batchState.currentShader = this._spDeviceTransformTextureFill), i.bindTexture(i.TEXTURE_2D, null), i.activeTexture(i.TEXTURE1), i.bindTexture(i.TEXTURE_2D, null), i.activeTexture(i.TEXTURE0), this._lastTexture0 = null, this._lastTexture1 = null, this._usesDepthBuffer && this._isAutoSizeDepthBuffer && this._SetDepthBufferSize(this._width, this._height), this._currentRenderTarget && this._currentRenderTarget._Resize(this._width, this._height), i.bindFramebuffer(i.FRAMEBUFFER, null), this._currentRenderTarget = null, s.currentFramebuffer = null, s.currentFramebufferNoDepth = null;
    }
    _SetDepthBufferSize(t2, e) {
      const r2 = this._gl;
      this._depthBuffer && this._depthBufferWidth === t2 && this._depthBufferHeight === e || (this._canSampleDepth ? (this._depthBuffer && r2.deleteTexture(this._depthBuffer), this._depthBuffer = r2.createTexture(), r2.bindTexture(r2.TEXTURE_2D, this._depthBuffer), r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_MAG_FILTER, r2.NEAREST), r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_MIN_FILTER, r2.NEAREST), r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_WRAP_S, r2.CLAMP_TO_EDGE), r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_WRAP_T, r2.CLAMP_TO_EDGE), this.GetWebGLVersionNumber() >= 2 ? r2.texImage2D(r2.TEXTURE_2D, 0, r2.DEPTH24_STENCIL8, t2, e, 0, r2.DEPTH_STENCIL, r2.UNSIGNED_INT_24_8, null) : this._depthTextureExt && r2.texImage2D(r2.TEXTURE_2D, 0, r2.DEPTH_STENCIL, t2, e, 0, r2.DEPTH_STENCIL, this._depthTextureExt["UNSIGNED_INT_24_8_WEBGL"], null), r2.bindTexture(r2.TEXTURE_2D, null)) : (this._depthBuffer && r2.deleteRenderbuffer(this._depthBuffer), this._depthBuffer = r2.createRenderbuffer(), r2.bindRenderbuffer(r2.RENDERBUFFER, this._depthBuffer), r2.renderbufferStorage(r2.RENDERBUFFER, this._version >= 2 ? r2.DEPTH24_STENCIL8 : r2.DEPTH_STENCIL, t2, e), r2.bindRenderbuffer(r2.RENDERBUFFER, null)), this._depthBufferWidth = t2, this._depthBufferHeight = e);
    }
    SetFixedSizeDepthBuffer(t2, e) {
      this._usesDepthBuffer && (this._isAutoSizeDepthBuffer = false, this._SetDepthBufferSize(t2, e));
    }
    SetAutoSizeDepthBuffer() {
      this._usesDepthBuffer && (this._isAutoSizeDepthBuffer = true, this._SetDepthBufferSize(this._width, this._height));
    }
    _SetViewport(t2, e, r2, i) {
      const s = this._viewport;
      if (s[0] === t2 && s[1] === e && s[2] === r2 && s[3] === i) return;
      this.PushBatch().InitSetViewport(t2, e, r2, i), vec4.set(s, t2, e, r2, i), this._topOfBatch = 0;
    }
    SetFovY(t2) {
      super.SetFovY(t2), this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, this._width / this._height);
    }
    SetNearZ(t2) {
      super.SetNearZ(t2), this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, this._width / this._height);
    }
    SetFarZ(t2) {
      super.SetFarZ(t2), this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, this._width / this._height);
    }
    SetProjectionMatrix(t2) {
      if (mat4.exactEquals(this._matP, t2)) return;
      this.PushBatch().InitSetProjection(t2), mat4.copy(this._matP, t2), this._topOfBatch = 0, this._didChangeTransform = true;
    }
    SetDefaultRenderTargetProjectionState() {
      let t2, e, r2;
      const i = this._currentRenderTarget;
      null === i ? (t2 = this._bbProjectionMatrix, e = this.GetWidth(), r2 = this.GetHeight()) : (t2 = i.GetProjectionMatrix(), e = i.GetWidth(), r2 = i.GetHeight()), this.SetProjectionMatrix(t2), this._SetViewport(0, 0, e, r2);
    }
    SetModelViewMatrix(t2) {
      if (mat4.exactEquals(this._matMV, t2)) return;
      this.PushBatch().InitSetModelView(t2), mat4.copy(this._matMV, t2), this._topOfBatch = 0, this._didChangeTransform = true;
    }
    ResetDidChangeTransformFlag() {
      this._didChangeTransform = false;
    }
    DidChangeTransform() {
      return this._didChangeTransform;
    }
    GetBatchState() {
      return this._batchState;
    }
    PushBatch() {
      const t2 = this._batch;
      return this._batchPtr === t2.length && t2.push(new C32.Gfx.WebGLBatchJob(this._batchState)), t2[this._batchPtr++];
    }
    EndBatch() {
      0 !== this._batchPtr && (this.IsContextLost() || (this._WriteBuffers(), this._ExecuteBatch(), this._batchPtr = 0, this._vertexPtr = 0, this._indexPtr = 0, this._pointPtr = 0, this._topOfBatch = 0));
    }
    _WriteBuffers() {
      const t2 = this._gl;
      this._vertexPtr > 0 && (t2.bindBuffer(t2.ARRAY_BUFFER, this._vertexBuffer), t2.bufferSubData(t2.ARRAY_BUFFER, 0, this._vertexData.subarray(0, 3 * this._vertexPtr)), t2.bindBuffer(t2.ARRAY_BUFFER, this._texcoordBuffer), t2.bufferSubData(t2.ARRAY_BUFFER, 0, this._texcoordData.subarray(0, 2 * this._vertexPtr)), t2.bindBuffer(t2.ARRAY_BUFFER, this._colorBuffer), t2.bufferSubData(t2.ARRAY_BUFFER, 0, this._colorData.subarray(0, 4 * this._vertexPtr))), this._indexPtr > 0 && (t2.bindBuffer(t2.ELEMENT_ARRAY_BUFFER, this._indexBuffer), t2.bufferSubData(t2.ELEMENT_ARRAY_BUFFER, 0, this._indexData.subarray(0, this._indexPtr))), this._pointPtr > 0 && (t2.bindBuffer(t2.ARRAY_BUFFER, this._pointBuffer), t2.bufferSubData(t2.ARRAY_BUFFER, 0, this._pointData.subarray(0, this._pointPtr)));
    }
    _ExecuteBatch() {
      const t2 = this._batch;
      for (let e = 0, r2 = this._batchPtr; e < r2; ++e) t2[e].Run();
    }
    GetOpacity() {
      return this._lastColor.getA();
    }
    SetColorRgba(t2, e, r2, i) {
      const s = this._lastColor;
      s.equalsRgba(t2, e, r2, i) || (s.setRgba(t2, e, r2, i), this._currentStateGroup = null, 2 === this._topOfBatch && (this._topOfBatch = 0));
    }
    SetOpacity(t2) {
      const e = this._lastColor;
      e.getA() !== t2 && (e.setA(t2), this._currentStateGroup = null, 2 === this._topOfBatch && (this._topOfBatch = 0));
    }
    SetColor(t2) {
      const e = this._lastColor;
      e.equals(t2) || (e.set(t2), this._currentStateGroup = null, 2 === this._topOfBatch && (this._topOfBatch = 0));
    }
    ResetColor() {
      this.SetColorRgba(1, 1, 1, 1);
    }
    GetColor() {
      return this._lastColor;
    }
    SetTexture(t2) {
      if (t2 === this._lastTexture0) return;
      this.PushBatch().InitSetTexture(t2), this._lastTexture0 = t2, this._topOfBatch = 0;
    }
    _ResetLastTexture() {
      this._lastTexture0 = null;
    }
    SetBlendMode(t2) {
      const e = this._GetBlendByIndex(t2);
      this._SetBlend(e[0], e[1]);
    }
    SetNamedBlendMode(t2) {
      const e = this.GetNamedBlend(t2);
      this._SetBlend(e.srcBlend, e.destBlend);
    }
    _SetBlend(t2, e) {
      if (t2 === this._lastSrcBlend && e === this._lastDestBlend) return;
      this.PushBatch().InitSetBlend(t2, e), this._lastSrcBlend = t2, this._lastDestBlend = e, this._topOfBatch = 0, this._currentStateGroup = null;
    }
    IsPremultipliedAlphaBlend() {
      return this._lastSrcBlend === this._gl.ONE && this._lastDestBlend === this._gl.ONE_MINUS_SRC_ALPHA;
    }
    SetAlphaBlend() {
      this._SetBlend(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);
    }
    SetNoPremultiplyAlphaBlend() {
      this._SetBlend(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA);
    }
    SetCullFaceMode(t2) {
      if (this._lastCullFace === t2) return;
      this.PushBatch().InitSetCullFaceMode(t2), this._lastCullFace = t2, this._topOfBatch = 0, this._currentStateGroup = null;
    }
    GetCullFaceMode() {
      return this._lastCullFace;
    }
    SetFrontFaceWinding(t2) {
      if (this._lastFrontFaceWinding === t2) return;
      this.PushBatch().InitSetFrontFaceWinding(t2), this._lastFrontFaceWinding = t2, this._topOfBatch = 0, this._currentStateGroup = null;
    }
    GetFrontFaceWinding() {
      return this._lastFrontFaceWinding;
    }
    SetCopyBlend() {
      this._SetBlend(this._gl.ONE, this._gl.ZERO);
    }
    Rect(t2) {
      this.Rect2(t2.getLeft(), t2.getTop(), t2.getRight(), t2.getBottom());
    }
    Rect2(t2, e, r2, i) {
      this.Quad2(t2, e, r2, e, r2, i, t2, i);
    }
    _AddToDrawBatch(t2, e) {
      if ((this._vertexPtr + t2 > 65535 || this._indexPtr + e > 393210) && this.EndBatch(), 1 === this._topOfBatch) this._batch[this._batchPtr - 1]._indexCount += e;
      else {
        this.PushBatch().InitDraw(2 * this._indexPtr, e), this._topOfBatch = 1;
      }
    }
    _AddIndicesForQuad() {
      const t2 = this._vertexPtr;
      let e = this._indexPtr;
      this._indexPtr += 6;
      const r2 = this._indexData;
      r2[e++] = t2, r2[e++] = t2 + 1, r2[e++] = t2 + 2, r2[e++] = t2, r2[e++] = t2 + 2, r2[e] = t2 + 3;
    }
    Quad(t2) {
      this.Quad4(t2, defaultTexCoordsQuad);
    }
    Quad2(t2, e, r2, i, s, a2, h2, n) {
      this._AddToDrawBatch(4, 6), this._AddIndicesForQuad();
      const o2 = this._vertexData, l = this._vertexPtr;
      this._vertexPtr += 4;
      let _2 = 3 * l;
      const u2 = this._baseZ + this._currentZ;
      o2[_2++] = t2, o2[_2++] = e, o2[_2++] = u2, o2[_2++] = r2, o2[_2++] = i, o2[_2++] = u2, o2[_2++] = s, o2[_2++] = a2, o2[_2++] = u2, o2[_2++] = h2, o2[_2++] = n, o2[_2] = u2, defaultTexCoordsQuad.writeToTypedArray(this._texcoordData, 2 * l), this._lastColor.writeToTypedArrayx4(this._colorData, 4 * l);
    }
    Quad3(t2, e) {
      this._AddToDrawBatch(4, 6), this._AddIndicesForQuad();
      const r2 = this._vertexPtr;
      this._vertexPtr += 4, t2.writeToTypedArray3D(this._vertexData, 3 * r2, this._baseZ + this._currentZ), e.writeAsQuadToTypedArray(this._texcoordData, 2 * r2), this._lastColor.writeToTypedArrayx4(this._colorData, 4 * r2);
    }
    Quad4(t2, e) {
      this._AddToDrawBatch(4, 6), this._AddIndicesForQuad();
      const r2 = this._vertexPtr;
      this._vertexPtr += 4, t2.writeToTypedArray3D(this._vertexData, 3 * r2, this._baseZ + this._currentZ), e.writeToTypedArray(this._texcoordData, 2 * r2), this._lastColor.writeToTypedArrayx4(this._colorData, 4 * r2);
    }
    Quad5(t2, e, r2) {
      this._AddToDrawBatch(4, 6), this._AddIndicesForQuad();
      const i = this._vertexPtr;
      this._vertexPtr += 4, t2.writeToTypedArray3D(this._vertexData, 3 * i, this._baseZ + this._currentZ), e.writeToTypedArray(this._texcoordData, 2 * i), this._colorData.set(r2, 4 * i);
    }
    Quad3D(t2, e, r2, i, s, a2, h2, n, o2, l, _2, u2, d2) {
      this._AddToDrawBatch(4, 6), this._AddIndicesForQuad();
      const c2 = this._vertexData, f2 = this._vertexPtr;
      this._vertexPtr += 4;
      let p2 = 3 * f2;
      const x2 = this._baseZ + this._currentZ;
      c2[p2++] = t2, c2[p2++] = e, c2[p2++] = x2 + r2, c2[p2++] = i, c2[p2++] = s, c2[p2++] = x2 + a2, c2[p2++] = h2, c2[p2++] = n, c2[p2++] = x2 + o2, c2[p2++] = l, c2[p2++] = _2, c2[p2] = x2 + u2, d2.writeAsQuadToTypedArray(this._texcoordData, 2 * f2), this._lastColor.writeToTypedArrayx4(this._colorData, 4 * f2);
    }
    Quad3D2(t2, e, r2, i, s, a2, h2, n, o2, l, _2, u2, d2) {
      this._AddToDrawBatch(4, 6), this._AddIndicesForQuad();
      const c2 = this._vertexData, f2 = this._vertexPtr;
      this._vertexPtr += 4;
      let p2 = 3 * f2;
      const x2 = this._baseZ + this._currentZ;
      c2[p2++] = t2, c2[p2++] = e, c2[p2++] = x2 + r2, c2[p2++] = i, c2[p2++] = s, c2[p2++] = x2 + a2, c2[p2++] = h2, c2[p2++] = n, c2[p2++] = x2 + o2, c2[p2++] = l, c2[p2++] = _2, c2[p2] = x2 + u2, d2.writeToTypedArray(this._texcoordData, 2 * f2), this._lastColor.writeToTypedArrayx4(this._colorData, 4 * f2);
    }
    Quad3D3(t2, e, r2, i, s, a2, h2, n, o2, l, _2, u2, d2, c2) {
      this._AddToDrawBatch(4, 6), this._AddIndicesForQuad();
      const f2 = this._vertexData, p2 = this._vertexPtr;
      this._vertexPtr += 4;
      let x2 = 3 * p2;
      const E2 = this._baseZ + this._currentZ;
      f2[x2++] = t2, f2[x2++] = e, f2[x2++] = E2 + r2, f2[x2++] = i, f2[x2++] = s, f2[x2++] = E2 + a2, f2[x2++] = h2, f2[x2++] = n, f2[x2++] = E2 + o2, f2[x2++] = l, f2[x2++] = _2, f2[x2] = E2 + u2, d2.writeToTypedArray(this._texcoordData, 2 * p2), this._colorData.set(c2, 4 * p2);
    }
    DrawMesh(t2, e, r2, i) {
      if (t2.length % 3 != 0) throw new Error("vertex buffer length not multiple of 3");
      if (t2.length > 196605) throw new Error(`too many vertices (${t2.length / 3}, limit 65535)`);
      if (r2.length % 3 != 0) throw new Error("index buffer length not multiple of 3");
      if (r2.length > 393210) throw new Error(`too many indices (${r2.length}, limit 393210)`);
      this._AddToDrawBatch(t2.length, r2.length);
      const s = this._vertexPtr;
      this._vertexData.set(t2, 3 * s), this._texcoordData.set(e, 2 * s);
      const a2 = this._indexData;
      if (0 === s) a2.set(r2, this._indexPtr);
      else {
        let t3 = this._indexPtr;
        for (let e2 = 0, i2 = r2.length; e2 < i2; ++e2) a2[t3++] = r2[e2] + s;
      }
      const h2 = this._colorData;
      if (null != i) h2.set(i, 4 * s);
      else {
        const e2 = this._lastColor, r3 = e2.getR(), i2 = e2.getG(), a3 = e2.getB(), n = e2.getA();
        let o2 = 4 * s;
        for (let e3 = 0, s2 = t2.length; e3 < s2; ++e3) h2[o2++] = r3, h2[o2++] = i2, h2[o2++] = a3, h2[o2++] = n;
      }
      this._vertexPtr += t2.length / 3, this._indexPtr += r2.length;
    }
    FullscreenQuad(t2, e) {
      this.SetCurrentZ(0), mat4.copy(tmpProjection, this._matP), mat4.copy(tmpModelView, this._matMV), this.SetDefaultRenderTargetProjectionState();
      const [r2, i] = this.GetRenderTargetSize(this._currentRenderTarget), s = this.CalculateLookAtModelView2(0, 0, this.GetDefaultCameraZ(i), 0, 0, 0, i);
      if (this.SetModelViewMatrix(s), "crop" === t2 && this._currentRenderTarget && e) {
        const t3 = this._width / 2, r3 = this._height / 2, i2 = e.GetWidth(), s2 = e.GetHeight(), a2 = this._currentRenderTarget.GetWidth(), h2 = this._currentRenderTarget.GetHeight(), n = Math.min(a2, i2), o2 = Math.min(h2, s2), l = Math.max(s2 - h2, 0), _2 = Math.max(h2 - s2, 0);
        tmpRect.set(-t3, r3 - _2, -t3 + n, r3 - o2 - _2), tmpQuad.setFromRect(tmpRect), tmpRect.set(0, l, n, o2 + l), tmpRect.divide(i2, s2), this.Quad3(tmpQuad, tmpRect);
      } else {
        const t3 = r2 / 2, e2 = i / 2;
        this.Rect2(-t3, e2, t3, -e2);
      }
      this.SetProjectionMatrix(tmpProjection), this.SetModelViewMatrix(tmpModelView);
    }
    StartRenderingPoints(t2) {
      if (this._lastPointTexCoords.equals(t2)) return;
      this._lastPointTexCoords.copy(t2);
      this.PushBatch().InitSetPointTexCoords(t2), this._topOfBatch = 0;
    }
    FinishRenderingPoints() {
    }
    Point(t2, e, r2, i) {
      this._pointPtr >= 7996 && this.EndBatch();
      let s = this._pointPtr;
      const a2 = this._baseZ + this._currentZ;
      if (2 === this._topOfBatch && this._lastPointZ === a2) this._batch[this._batchPtr - 1]._indexCount++;
      else {
        this.PushBatch().InitPoints(s, a2, this._lastColor), this._topOfBatch = 2, this._lastPointZ = a2;
      }
      const h2 = this._pointData;
      h2[s++] = t2, h2[s++] = e, h2[s++] = r2, h2[s++] = i, this._pointPtr = s;
    }
    SetProgram(t2) {
      if (this._lastProgram === t2) return;
      this.PushBatch().InitSetProgram(t2), this._lastProgram = t2, this._topOfBatch = 0, this._currentStateGroup = null;
    }
    GetProgram() {
      return this._lastProgram;
    }
    SetDeviceTransformTextureFillMode() {
      this.SetProgram(this._spDeviceTransformTextureFill);
    }
    SetGradientColor(t2) {
      this.PushBatch().InitSetGradientColor(t2), this._topOfBatch = 0;
    }
    SetEllipseParams(t2, e, r2 = 1) {
      this.PushBatch().InitSetEllipseParams(t2, e, r2), this._topOfBatch = 0;
    }
    SetTilemapInfo(t2, e, r2, i, s, a2, h2) {
      if (this._lastProgram !== this._spTilemapFill) throw new Error("must set tilemap fill mode first");
      this.PushBatch().InitSetTilemapInfo(t2, e, r2, i, s, a2, h2), this._topOfBatch = 0;
    }
    SetTileRandomizationInfo(t2, e, r2, i, s, a2, h2) {
      if (this._lastProgram !== this._spTileRandomization) throw new Error("must set tile randomization mode first");
      this.PushBatch().InitSetTileRandomizationInfo(t2, e, r2, i, s, a2, h2), this._topOfBatch = 0;
    }
    SetProgramParameters(t2, e, r2, i, s, a2, h2, n, o2, l, _2) {
      const u2 = this._lastProgram;
      if (_2 %= 10800, !u2._hasAnyOptionalUniforms || u2.AreOptionalUniformsAlreadySetInBatch(e, r2, i, s, a2, h2, n, o2, l, _2)) return;
      const d2 = this.PushBatch();
      d2.InitSetProgramParameters(), u2.SetOptionalUniformsInBatch(e, r2, i, s, a2, h2, n, o2, l, _2);
      const c2 = d2._mat4param;
      c2[0] = a2, c2[1] = h2, e.writeToTypedArray(c2, 2), c2[6] = o2, c2[7] = l, r2.writeToTypedArray(c2, 12);
      const f2 = d2._colorParam;
      s.writeToTypedArray(f2, 0);
      const p2 = f2[1];
      f2[1] = f2[3], f2[3] = p2, i.writeToTypedArray(d2._srcOriginRect, 0), d2._startIndex = _2, d2._indexCount = n, u2._uSamplerBack.IsUsed() ? d2._texParam = t2 ? t2.GetTexture() : null : d2._texParam = null, this._topOfBatch = 0;
    }
    SetProgramCustomParameters(t2) {
      const e = this._lastProgram;
      if (0 === t2.length || e.AreCustomParametersAlreadySetInBatch(t2)) return;
      const r2 = this.PushBatch();
      r2.InitSetProgramCustomParameters(), e.SetCustomParametersInBatch(t2), C32.shallowAssignArray(r2._shaderParams, t2), this._topOfBatch = 0;
    }
    ClearRgba(t2, e, r2, i) {
      this.PushBatch().InitClearSurface2(t2, e, r2, i), this._topOfBatch = 0;
    }
    Clear(t2) {
      this.PushBatch().InitClearSurface(t2), this._topOfBatch = 0;
    }
    Start() {
    }
    Finish() {
      super.Finish(), this._gl.flush();
    }
    ClearDepth() {
      if (!this._usesDepthBuffer || !this._currentRenderTarget || !this._currentRenderTarget.HasDepthBuffer()) return;
      this.PushBatch().InitClearDepth(this._isDepthEnabled), this._topOfBatch = 0;
    }
    SetDepthEnabled(t2) {
      if (t2 = !!t2, this._isDepthEnabled === t2) return;
      if (!this._usesDepthBuffer) return;
      this._isDepthEnabled = t2;
      this.PushBatch().InitSetDepthEnabled(t2), this._topOfBatch = 0;
    }
    IsDepthEnabled() {
      return this._isDepthEnabled;
    }
    _GetDepthBuffer() {
      return this._depthBuffer;
    }
    _CanSampleDepth() {
      return this._canSampleDepth;
    }
    SetDepthSamplingEnabled(t2) {
      if (t2 = !!t2, !this._canSampleDepth) return;
      if (this._isDepthSamplingEnabled === t2) return;
      if (t2 && this.IsDepthEnabled()) throw new Error("depth still enabled");
      this._isDepthSamplingEnabled = t2;
      this.PushBatch().InitSetDepthSamplingEnabled(t2), this._topOfBatch = 0;
    }
    SetScissorRect(t2, e, r2, i, s = 0) {
      if (t2 = Math.floor(t2), e = Math.floor(e), r2 = Math.floor(r2), i = Math.floor(i), this._lastScissorRect.equalsWH(t2, e, r2, i)) return;
      this._lastScissorRect.setWH(t2, e, r2, i);
      e = (s || this.GetRenderTargetSize(this.GetRenderTarget())[1]) - e - i;
      this.PushBatch().InitSetScissor(true, t2, e, r2, i), this._topOfBatch = 0;
    }
    RemoveScissorRect() {
      if (-1 === this._lastScissorRect.getRight()) return;
      this._lastScissorRect.set(0, 0, -1, -1);
      this.PushBatch().InitSetScissor(false, 0, 0, 0, 0), this._topOfBatch = 0;
    }
    CheckForQueryResults() {
      for (const t2 of this._allQueryResultBuffers) t2.CheckForResults(this._frameNumber);
    }
    IsContextLost() {
      return !this._gl || this._gl.isContextLost() || this._isInitialisingAfterContextRestored;
    }
    OnContextLost() {
      super.OnDeviceOrContextLost(), C32.Gfx.WebGLRendererTexture.OnContextLost(), C32.Gfx.WebGLRenderTarget.OnContextLost(), C32.Gfx.RendererText.OnContextLost();
      for (const t2 of this._allQueryResultBuffers) t2.Clear();
      this._extensions = [], this._timerExt = null, this._parallelShaderCompileExt = null, this._conservativeDepthExt = null, this._anisotropicExt = null, this._depthTextureExt = null, this._fragDepthExt = null, this._stdDerivativesExt = null, this._textureLodExt = null, this._maxAnisotropy = 0, this._unmaskedVendor = "(unavailable)", this._unmaskedRenderer = "(unavailable)", this._lastProgram = null, this._spDeviceTransformTextureFill = null, this._depthBuffer = null;
      for (const t2 of this._stateGroups.values()) t2.OnContextLost();
    }
    async OnContextRestored() {
      this._isInitialisingAfterContextRestored = true, await this.InitState(), this._isInitialisingAfterContextRestored = false;
      for (const t2 of this._stateGroups.values()) t2.OnContextRestored(this);
      this.SetSize(this._width, this._height, true);
    }
    CreateStaticTexture(t2, e) {
      if (this.IsContextLost()) throw new Error("context lost");
      this.EndBatch();
      const r2 = C32.New(C32.Gfx.WebGLRendererTexture, this);
      return r2._CreateStatic(t2, e), r2;
    }
    async CreateStaticTextureAsync(t2, e) {
      if (this.IsContextLost()) throw new Error("context lost");
      if (e = Object.assign({}, e), C32.Supports.ImageBitmapOptions) {
        let r2 = await createImageBitmap(t2, { "premultiplyAlpha": "premultiply" });
        const i = e.wrapX && "clamp-to-edge" !== e.wrapX || e.wrapY && "clamp-to-edge" !== e.wrapY, s = C32.isPOT(r2.width) && C32.isPOT(r2.height);
        return this.SupportsNPOTTextures() || s || !i ? e.premultiplyAlpha = false : C32.Supports.ImageBitmapOptionsResize ? (r2 = await createImageBitmap(t2, { "premultiplyAlpha": "premultiply", "resizeWidth": C32.nextHighestPowerOfTwo(r2.width), "resizeHeight": C32.nextHighestPowerOfTwo(r2.height) }), e.premultiplyAlpha = false) : r2 = await createImageBitmap(t2, { "premultiplyAlpha": "none" }), await C32.Asyncify(() => this.CreateStaticTexture(r2, e));
      }
      if (t2 instanceof Blob) {
        if ("undefined" == typeof Image) throw new Error("texture upload variant not supported in worker");
        const e2 = await C32.BlobToImage(t2);
        t2 = e2;
      }
      return await C32.Asyncify(() => this.CreateStaticTexture(t2, e));
    }
    CreateDynamicTexture(t2, e, r2) {
      this.EndBatch();
      const i = C32.New(C32.Gfx.WebGLRendererTexture, this);
      return i._CreateDynamic(t2, e, r2), i;
    }
    UpdateTexture(t2, e, r2) {
      this.EndBatch(), e._Update(t2, r2);
    }
    DeleteTexture(t2) {
      t2 && (t2.SubtractReference(), t2.GetReferenceCount() > 0 || (this.EndBatch(), t2 === this._lastTexture0 && (this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._lastTexture0 = null), t2 === this._lastTexture1 && (this._gl.activeTexture(this._gl.TEXTURE1), this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._gl.activeTexture(this._gl.TEXTURE0), this._lastTexture1 = null), t2._Delete()));
    }
    CreateRenderTarget(t2) {
      let e = this._width, r2 = this._height, i = true;
      if (t2 && ("number" == typeof t2.width && (e = Math.floor(t2.width), i = false), "number" == typeof t2.height && (r2 = Math.floor(t2.height), i = false)), e <= 0 || r2 <= 0) throw new Error("invalid size");
      this.EndBatch();
      const s = C32.New(C32.Gfx.WebGLRenderTarget, this);
      return s._Create(e, r2, Object.assign({ isDefaultSize: i }, t2)), this._currentRenderTarget = null, this._batchState.currentFramebuffer = null, this._batchState.currentFramebufferNoDepth = null, s;
    }
    SetRenderTarget(t2, e = true) {
      if (t2 === this._currentRenderTarget) return;
      t2 && t2.IsDefaultSize() && t2._Resize(this._width, this._height);
      this.PushBatch().InitSetRenderTarget(t2), this._currentRenderTarget = t2, this._topOfBatch = 0, e && this.SetDefaultRenderTargetProjectionState();
    }
    GetRenderTarget() {
      return this._currentRenderTarget;
    }
    GetRenderTargetSize(t2) {
      return t2 ? [t2.GetWidth(), t2.GetHeight()] : [this._width, this._height];
    }
    CopyRenderTarget(t2, e = "stretch") {
      if (this._version < 2 || this._currentRenderTarget && this._currentRenderTarget.GetMultisampling() > 0) this.SetCopyBlend(), this.ResetColor(), this.DrawRenderTarget(t2, e);
      else {
        this.PushBatch().InitBlitFramebuffer(t2, this._currentRenderTarget, e), this._topOfBatch = 0;
      }
    }
    DrawRenderTarget(t2, e = "stretch") {
      const r2 = t2.GetTexture();
      if (!r2) throw new Error("not a texture-backed render target");
      this.SetTexture(r2), this.FullscreenQuad(e, r2);
    }
    InvalidateRenderTarget(t2) {
      if (this._version < 2) return;
      this.PushBatch().InitInvalidateFramebuffer(t2._GetFramebuffer()), this._topOfBatch = 0;
    }
    DeleteRenderTarget(t2) {
      this.SetRenderTarget(null), this.EndBatch();
      const e = t2.GetTexture();
      e === this._lastTexture0 && (this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._lastTexture0 = null), e === this._lastTexture1 && (this._gl.activeTexture(this._gl.TEXTURE1), this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._gl.activeTexture(this._gl.TEXTURE0), this._lastTexture1 = null), t2._Delete();
    }
    async ReadBackRenderTargetToImageData(t2, e, r2) {
      this.EndBatch();
      const i = this._currentRenderTarget;
      let s, a2, h2;
      t2 ? (s = t2.GetWidth(), a2 = t2.GetHeight(), h2 = t2._GetFramebuffer()) : (s = this.GetWidth(), a2 = this.GetHeight(), h2 = null);
      let n = 0, o2 = 0, l = s, _2 = a2;
      if (r2) {
        n = C32.clamp(Math.floor(r2.getLeft()), 0, s - 1), o2 = C32.clamp(Math.floor(r2.getTop()), 0, a2 - 1);
        let t3 = r2.width();
        t3 = 0 === t3 ? s - n : C32.clamp(Math.floor(t3), 0, s - n);
        let e2 = r2.height();
        e2 = 0 === e2 ? a2 - o2 : C32.clamp(Math.floor(e2), 0, a2 - o2), l = t3, _2 = e2, o2 = a2 - (o2 + _2);
      }
      const u2 = this._gl;
      u2.bindFramebuffer(u2.FRAMEBUFFER, h2);
      const d2 = () => {
        u2.bindFramebuffer(u2.FRAMEBUFFER, null), this._currentRenderTarget = null, this._batchState.currentFramebuffer = null, this._batchState.currentFramebufferNoDepth = null, this.SetRenderTarget(i);
      };
      let c2;
      if (!e && this.GetWebGLVersionNumber() >= 2) {
        u2.bindFramebuffer(u2.READ_FRAMEBUFFER, h2);
        const t3 = u2.createBuffer(), e2 = l * _2 * 4, r3 = u2["PIXEL_PACK_BUFFER"];
        u2.bindBuffer(r3, t3), u2.bufferData(r3, e2, u2["STREAM_READ"]), u2.readPixels(n, o2, l, _2, u2.RGBA, u2.UNSIGNED_BYTE, 0), u2.bindFramebuffer(u2.READ_FRAMEBUFFER, null), u2.bindBuffer(r3, null), d2();
        const i2 = u2["fenceSync"](u2["SYNC_GPU_COMMANDS_COMPLETE"], 0);
        await this._WaitForObjectReady(() => u2["getSyncParameter"](i2, u2["SYNC_STATUS"]) === u2["SIGNALED"]), u2["deleteSync"](i2), c2 = new ImageData(l, _2), u2.bindBuffer(r3, t3), u2["getBufferSubData"](r3, 0, new Uint8Array(c2.data.buffer), 0, e2), u2.bindBuffer(r3, null), u2.deleteBuffer(t3);
      } else c2 = new ImageData(l, _2), u2.readPixels(n, o2, l, _2, u2.RGBA, u2.UNSIGNED_BYTE, new Uint8Array(c2.data.buffer)), d2();
      return c2;
    }
    CoplanarStartStencilPass() {
      this.SetDepthEnabled(true);
      this.PushBatch().InitCoplanarStartStencilPass(), this._topOfBatch = 0, this._coplanarMode = 1;
    }
    CoplanarStartColorPass(t2 = false) {
      this.SetDepthEnabled(t2);
      this.PushBatch().InitCoplanarStartColorPass(), this._topOfBatch = 0, this._coplanarMode = 2;
    }
    IsCoplanarColorPass() {
      return 2 === this._coplanarMode;
    }
    CoplanarRestoreStandardRendering(t2 = true) {
      this.SetDepthEnabled(t2);
      this.PushBatch().InitCoplanarRestore(), this._topOfBatch = 0, this._coplanarMode = 0;
    }
    StartQuery(t2) {
      if (!this.SupportsGPUProfiling()) return;
      this.PushBatch().InitStartQuery(t2), this._topOfBatch = 0;
    }
    EndQuery(t2) {
      if (!this.SupportsGPUProfiling()) return;
      this.PushBatch().InitEndQuery(t2), this._topOfBatch = 0;
    }
    _WaitForObjectReady(t2) {
      const e = new Promise((e2) => pendingPolls.add({ resolve: e2, checkFunc: t2 }));
      return -1 === pollRafId && (pollRafId = self.requestAnimationFrame(CheckPendingPolls)), e;
    }
    GetEstimatedBackBufferMemoryUsage() {
      return this._width * this._height * (this._attribs["alpha"] ? 4 : 3);
    }
    GetEstimatedRenderBufferMemoryUsage() {
      let t2 = 0;
      for (const e of C32.Gfx.WebGLRenderTarget.allRenderTargets()) e.GetTexture() || (t2 += e.GetEstimatedMemoryUsage());
      return t2;
    }
    GetEstimatedTextureMemoryUsage() {
      let t2 = 0;
      for (const e of C32.Gfx.WebGLRendererTexture.allTextures()) t2 += e.GetEstimatedMemoryUsage();
      return t2;
    }
    GetWebGLVersionString() {
      return this._versionString;
    }
    GetWebGLVersionNumber() {
      return this._version;
    }
    IsColorDataF16() {
      return this._isColorDataF16;
    }
    GetDisplayName() {
      return "webgl" + this.GetWebGLVersionNumber();
    }
    SupportsNPOTTextures() {
      return this.GetWebGLVersionNumber() >= 2;
    }
    GetMaxTextureSize() {
      return this._maxTextureSize;
    }
    GetMinPointSize() {
      return this._minPointSize;
    }
    GetMaxPointSize() {
      return this._maxPointSize;
    }
    GetUnmaskedVendor() {
      return this._unmaskedVendor;
    }
    GetUnmaskedRenderer() {
      return this._unmaskedRenderer;
    }
    GetWebGLExtensionsAnalyticsString() {
      if (this.GetWebGLVersionNumber() >= 2) return "webgl2";
      {
        const t2 = [];
        return this._fragDepthExt && t2.push("EXT_frag_depth"), this._stdDerivativesExt && t2.push("OES_standard_derivatives"), this._textureLodExt && t2.push("EXT_shader_texture_lod"), t2.length > 0 ? "webgl1:" + t2.join(",") : "webgl1:none";
      }
    }
    GetExtensions() {
      return this._extensions;
    }
    SupportsGPUProfiling() {
      return !!this._timerExt;
    }
    _GetDisjointTimerQueryExtension() {
      return this._timerExt;
    }
    _GetParallelShaderCompileExtension() {
      return this._parallelShaderCompileExt;
    }
    _SupportsConservativeDepth() {
      return !!this._conservativeDepthExt;
    }
    _GetAnisotropicExtension() {
      return this._anisotropicExt;
    }
    _GetMaxAnisotropy() {
      return this._maxAnisotropy;
    }
    _AddQueryResultBuffer(t2) {
      this._allQueryResultBuffers.add(t2);
    }
    _RemoveQueryResultBuffer(t2) {
      this._allQueryResultBuffers.delete(t2);
    }
    _GetTimeQueryStack() {
      return this._timeQueryStack;
    }
    GetContext() {
      return this._gl;
    }
    _InitBlendModes(t2) {
      this._InitBlendModeData([["normal", t2.ONE, t2.ONE_MINUS_SRC_ALPHA], ["additive", t2.ONE, t2.ONE], ["xor", t2.ONE, t2.ONE_MINUS_SRC_ALPHA], ["copy", t2.ONE, t2.ZERO], ["destination-over", t2.ONE_MINUS_DST_ALPHA, t2.ONE], ["source-in", t2.DST_ALPHA, t2.ZERO], ["destination-in", t2.ZERO, t2.SRC_ALPHA], ["source-out", t2.ONE_MINUS_DST_ALPHA, t2.ZERO], ["destination-out", t2.ZERO, t2.ONE_MINUS_SRC_ALPHA], ["source-atop", t2.DST_ALPHA, t2.ONE_MINUS_SRC_ALPHA], ["destination-atop", t2.ONE_MINUS_DST_ALPHA, t2.SRC_ALPHA]]);
    }
    CreateWebGLText() {
      return this.CreateRendererText();
    }
  };
}
var CheckPendingPolls2;
{
  const C32 = self.C3, glMatrix = self.glMatrix, vec3 = glMatrix.vec3, mat4 = glMatrix.mat4, assert = self.assert, GPUBufferUsage = self["GPUBufferUsage"], GPUShaderStage = self["GPUShaderStage"], GPUMapMode = self["GPUMapMode"], GPUTextureUsage = self["GPUTextureUsage"], DEFAULT_WEBGPURENDERER_OPTS = { powerPreference: "default", depth: false, failIfMajorPerformanceCaveat: false, canSampleBackbuffer: false, backTextureSampling: "bilinear", usesBackgroundBlending: false, canSampleDepth: false, isMultiTexturingAllowed: true }, MAX_VERTICES = 65535, MAX_INDICES = 393210, MAX_POINTS = Math.floor(65535 / 4), MAX_COLORS = 65535, LAST_POINT_PTR = 4 * MAX_POINTS - 16, FLAG_IN_DRAW = 1, FLAG_DRAWING_POINTS = 2, FLAG_SCISSOR_ENABLED = 4, FLAG_SCISSOR_CHANGED = 8, FLAG_DRAW_STATE_CHANGED = 16, FLAG_PIPELINE_CHANGED = 32, FLAG_TEX_BINDGROUP_CHANGED = 64, FLAG_BACKTEX_BINDGROUP_CHANGED = 128, FLAG_DEPTHTEX_BINDGROUP_CHANGED = 256, FLAG_TRANSFORM_CHANGED = 512, FLAG_VERTEX_UNIFORM_CHANGED = 1024, FLAG_FRAG_UNIFORM_CHANGED = 2048, FLAG_FRAG_C3PARAMS_CHANGED = 4096, FLAG_BUFFER_BINDGROUP_CHANGED = 8192, FLAG_DID_ADD_COMMAND = 16384, FLAG_CONTEXT_LOST = 32768, FLAG_MULTITEXTURE_ALLOWED = 65536, FLAG_MULTITEXTURE_ENABLED = 1 << 17, FLAG_MULTITEXTURE_ACTIVE = 1 << 18, FLAG_USE_DEPTH_BUFFER = 1 << 19, FLAG_DEPTH_ENABLED = 1 << 20, FLAG_RENDERTARGET_HAS_DEPTH = 1 << 21, FLAG_CLEAR_DEPTH = 1 << 22, FLAG_COPLANAR_STENCIL_PASS = 1 << 23, FLAG_COPLANAR_COLOR_PASS = 1 << 24, FLAG_CLEAR_STENCIL = 1 << 25, FLAG_AUTOSIZE_DEPTH_BUFFER = 1 << 26, FLAG_SUPPORTS_TIMESTAMP_QUERY = 1 << 27, FLAG_SUPPORTS_F16 = 1 << 28, FLAG_COLOR_DATA_F16 = 1 << 29, FLAG_USE_NORMALIZED_COORDS = 1 << 30, FLAG_DID_CHANGE_TRANSFORM = 1, CHANGED_FLAGS_MASK = 8688, END_DRAW_FLAGS_MASK = 8697, NEW_RENDERPASS_FLAGS = 25072, CHANGED_UNIFORM_BUFFER_MASK = 7680, SIZEOF_U16 = 2, SIZEOF_U32 = 4, SIZEOF_F16 = 2, SIZEOF_F32 = 4, defaultTexCoordsQuad = new C32.Quad(0, 0, 1, 0, 1, 1, 0, 1), tempVec2 = C32.New(C32.Vector2), tempRect = C32.New(C32.Rect), tempRect2 = C32.New(C32.Rect), tempQuad = C32.New(C32.Quad);
  C32.Gfx.WebGPURenderer = class extends C32.Gfx.RendererBase {
    constructor(e) {
      super(e), this._adapterOpts = null, this._adapter = null, this._adapterInfo = null, this._device = null, this._canvas = null, this._presentCtx = null, this._swapChainFormat = "", this._swapChainTexture = null, this._swapChainTexView = null, this._viewportWidth = 0, this._viewportHeight = 0, this._matTransform = mat4.create(), this._depthBuffer = null, this._nullDepthBuffer = null, this._depthBufferView = null, this._nullDepthBufferView = null, this._depthBufferBindGroup = null, this._nullDepthBufferBindGroup = null, this._depthBufferWidth = 0, this._depthBufferHeight = 0, this._vertexUniformBuffer = null, this._fragmentUniformBuffer = null, this._fragmentC3ParamsBuffer = null, this._fragmentDefaultCustomParamsBuffer = null, this._vertexBuffer = null, this._texcoordBuffer = null, this._texIndexBuffer = null, this._colorBuffer = null, this._indexBuffer = null, this._pointsIndexBuffer = null, this._pointBuffer = null, this._vertexUniformBufferLayout = C32.Gfx.WebGPUShaderProgram.GetVertexUniformBufferLayout(), this._vertexUniformBufferSize = C32.Gfx.WebGPUShaderProgram.GetVertexUniformBufferSize(), this._vertexUniformArrayBuffer = null, this._vertexUniformf32 = null, this._fragUniformBufferLayout = C32.Gfx.WebGPUShaderProgram.GetFragmentUniformBufferLayout(), this._fragUniformBufferSize = C32.Gfx.WebGPUShaderProgram.GetFragmentUniformBufferSize(), this._fragUniformArrayBuffer = null, this._fragUniformf32 = null, this._fragC3ParamsLayout = C32.Gfx.WebGPUShaderProgram.GetFragmentC3ParamsBufferLayout(), this._fragC3ParamsSize = C32.Gfx.WebGPUShaderProgram.GetFragmentC3ParamsBufferSize(), this._fragC3ParamsArrayBuffer = null, this._fragC3Paramsf32 = null, this._fragC3Paramsu32 = null, this._vertexData = new Float32Array(196605), this._texcoordData = new Float32Array(131070), this._texIndexData = new Uint32Array(65535), this._colorData = null, this._indexData = new Uint16Array(393210), this._pointData = new Float32Array(4 * MAX_POINTS), this._vertexPtr = 0, this._indexPtr = 0, this._currentMultiTextureIndex = 0, this._currentColor = C32.New(C32.Color, 1, 1, 1, 1), this._pointPtr = 0, this._bufferManager = C32.New(C32.Gfx.WebGPUBufferManager, this), this._flags = 32768, this._flags2 = 0, this._drawFirstIndex = 0, this._drawIndexCount = 0, this._vertexUniformUpdateStart = 0, this._vertexUniformUpdateEnd = 0, this._fragUniformUpdateStart = 0, this._fragUniformUpdateEnd = 0, this._fragC3ParamsUpdateStart = 0, this._fragC3ParamsUpdateEnd = 0, this._scissorRect = C32.New(C32.Rect, 0, 0, 0, 0), this._currentColor2 = C32.New(C32.Color, 1, 1, 1, 1), this._currentPointColor = C32.New(C32.Color, 1, 1, 1, 1), this._currentPointTexCoords = C32.New(C32.Rect, 0, 0, 0, 0), this._currentVertexZElevation = 0, this._textureFormat = "", this._bufferBindGroupLayout = null, this._defaultBufferBindGroup = null, this._textureBindGroupLayout = null, this._backTextureBindGroupLayout = null, this._depthTextureBindGroupLayout = null, this._nullTexture = null, this._currentTexture = null, this._currentTextureBindGroup = null, this._currentBackTexture = null, this._currentBackTextureBindGroup = null, this._currentDepthTextureBindGroup = null, this._currentBufferBindGroup = null, this._mipmapGeneratorPipeline = null, this._availableMultiTextures = /* @__PURE__ */ new Set(), this._nonFullMultiTexGroups = /* @__PURE__ */ new Set(), this._maxTextureSize = 8192, this._pipelineLayout = null, this._defaultVertexModule = null, this._normVertexModule = null, this._currentProgram = null, this._currentBlendMode = 0, this._currentMultisampleCount = 0, this._currentCullFace = 0, this._currentFrontFaceWinding = 0, this._mipmapGeneratorProgram = null, this._spSingleTextureFill = null, this._samplerMap = /* @__PURE__ */ new Map(), this._commandEncoder = null, this._currentRenderPass = null, this._commandBuffers = [], this._backbufferRenderTarget = null, this._currentRenderTarget = null, this._canSampleBackbuffer = false, this._backTextureSampling = "bilinear", this._usesBackgroundBlending = false, this._canSampleDepth = false, this._frameTimeQuerySet = null, this._timestampIsMeasuring = false, this._timestampStartIndex = -1, this._timestampEndIndex = -1, this._timestampStartedIndices = /* @__PURE__ */ new Set(), this.ondevicelost = null, this.ondevicerestored = null, this._InitBlendModes();
    }
    IsWebGPU() {
      return true;
    }
    _SetFlag(e, t2) {
      t2 ? this._flags |= e : this._flags &= ~e;
    }
    _IsFlagSet(e) {
      return 0 !== (this._flags & e);
    }
    _SetFlag2(e, t2) {
      t2 ? this._flags2 |= e : this._flags2 &= ~e;
    }
    _IsFlagSet2(e) {
      return 0 !== (this._flags2 & e);
    }
    async Create(e, t2) {
      if (t2 = Object.assign({}, DEFAULT_WEBGPURENDERER_OPTS, t2), !navigator["gpu"]) throw new Error("renderer-unavailable (WebGPU not supported)");
      t2.depth && (this._flags |= 524288), t2.isMultiTexturingAllowed && (this._flags |= 65536), this._canSampleBackbuffer = !!t2.canSampleBackbuffer, this._backTextureSampling = t2.backTextureSampling, this._usesBackgroundBlending = !!t2.usesBackgroundBlending, this._adapterOpts = {}, this._canSampleDepth = !(!t2.depth || !t2.canSampleDepth), "default" !== t2.powerPreference && (this._adapterOpts["powerPreference"] = t2.powerPreference), this._canvas = e, await this._InitDevice(t2.failIfMajorPerformanceCaveat);
    }
    async _InitDevice(e) {
      for (this._device = null, await this._TryGetDeviceOnCurrentAdapter(e); !this._device; ) this._adapter = null, await this._TryGetDeviceOnCurrentAdapter(e);
      await this.InitState();
    }
    async _TryGetDeviceOnCurrentAdapter(e) {
      if (!this._adapter) {
        if (this._adapter = await navigator["gpu"]["requestAdapter"](this._adapterOpts), !this._adapter) throw new Error("renderer-unavailable (no WebGPU adapter available)");
        if (e && (this._adapter["isFallbackAdapter"] || this._adapter["info"]["isFallbackAdapter"])) throw new Error("renderer-unavailable (WebGPU provided fallback adapter)");
        if ("adreno-7xx" === this._adapter["info"]["architecture"]) throw new Error("WebGPU disabled on adreno-7xx devices - see https://issues.chromium.org/issues/329702056");
      }
      const t2 = [];
      if (this._adapter["features"].has("timestamp-query") && t2.push("timestamp-query"), this._adapter["features"].has("shader-f16") && t2.push("shader-f16"), this._device = await this._adapter["requestDevice"]({ "requiredFeatures": t2, "requiredLimits": { "maxTextureDimension2D": this._adapter["limits"]["maxTextureDimension2D"] } }), !this._device) return null;
      this._maxTextureSize = this._device["limits"]["maxTextureDimension2D"], this._SetFlag(134217728, this._device["features"].has("timestamp-query")), this._SetFlag(268435456, this._device["features"].has("shader-f16")), this._SetFlag(536870912, this._IsFlagSet(268435456) && void 0 !== globalThis["Float16Array"]), this._device["lost"].then((e2) => this._OnDeviceLost(e2)), this._SetFlag(32768, false);
    }
    async _OnDeviceLost(e) {
      console.log("[WebGPU] Device lost: ", e), super.OnDeviceOrContextLost(), this._bufferManager.OnContextLost(), C32.Gfx.WebGPURendererTexture.OnContextLost(), C32.Gfx.WebGPURenderTarget.OnContextLost(), C32.Gfx.RendererText.OnContextLost(), this._swapChainFormat = "", this._swapChainTexture = null, this._swapChainTexView = null, this._depthBuffer = null, this._depthBufferView = null, this._nullDepthBuffer = null, this._nullDepthBufferView = null, this._depthBufferBindGroup = null, this._nullDepthBufferBindGroup = null, this._vertexBuffer = null, this._texcoordBuffer = null, this._texIndexBuffer = null, this._colorBuffer = null, this._indexBuffer = null, this._pointsIndexBuffer = null, this._pointBuffer = null, this._vertexUniformBuffer = null, this._fragmentUniformBuffer = null, this._fragmentC3ParamsBuffer = null, this._fragmentDefaultCustomParamsBuffer = null, this._defaultBufferBindGroup = null, this._bufferBindGroupLayout = null, this._currentBufferBindGroup = null, this._textureBindGroupLayout = null, this._backTextureBindGroupLayout = null, this._depthTextureBindGroupLayout = null, this._pipelineLayout = null, this._currentProgram = null, this._nullTexture = null, this._currentTexture = null, this._currentTextureBindGroup = null, this._currentBackTexture = null, this._currentBackTextureBindGroup = null, this._currentDepthTextureBindGroup = null, this._defaultVertexModule = null, this._normVertexModule = null, this._backbufferRenderTarget = null, this._currentRenderTarget = null, this._mipmapGeneratorPipeline = null, this._frameTimeQuerySet = null, this._mipmapGeneratorProgram = null, this._spSingleTextureFill = null, this._availableMultiTextures.clear(), this._nonFullMultiTexGroups.clear(), this._samplerMap.clear();
      for (const e2 of this._stateGroups.values()) e2.OnContextLost();
      this._device = null, this._adapter = null, this._adapterInfo = null, this._flags |= 32768, this.ondevicelost && this.ondevicelost(), await this._InitDevice();
      for (const e2 of this._stateGroups.values()) e2.OnContextRestored(this);
      this.SetSize(this._width, this._height, true), this.ondevicerestored && this.ondevicerestored();
    }
    async InitState() {
      super.InitState();
      const e = this._device;
      this._swapChainFormat = navigator["gpu"]["getPreferredCanvasFormat"](), this._swapChainTexture = null, this._swapChainTexView = null;
      let t2 = GPUTextureUsage["RENDER_ATTACHMENT"];
      this._canSampleBackbuffer && (t2 |= GPUTextureUsage["TEXTURE_BINDING"]), this._usesBackgroundBlending && (t2 |= GPUTextureUsage["COPY_SRC"]), this._swapChainFormat.startsWith("rgba8") || this._swapChainFormat.startsWith("bgra8") ? this._textureFormat = this._swapChainFormat : this._textureFormat = "rgba8unorm", this._flags &= 940113920, this._flags |= 7680, this._flags2 = 0, this._IsFlagSet(524288) && (this._flags |= 70254592), this._vertexPtr = 0, this._indexPtr = 0, this._currentBlendMode = 0, this._currentCullFace = 0, this._currentFrontFaceWinding = 0, this._currentMultisampleCount = 0, this._currentColor.setRgba(1, 1, 1, 1), this._currentColor2.setRgba(1, 1, 1, 1), this._currentPointColor.setRgba(1, 1, 1, 1), this._colorData = this.IsColorDataF16() ? new globalThis["Float16Array"](262140) : new Float32Array(262140), this._vertexUniformArrayBuffer = new ArrayBuffer(this._vertexUniformBufferSize), this._vertexUniformf32 = new Float32Array(this._vertexUniformArrayBuffer), this._fragUniformArrayBuffer = new ArrayBuffer(this._fragUniformBufferSize), this._fragUniformf32 = new Float32Array(this._fragUniformArrayBuffer), this._fragC3ParamsArrayBuffer = new ArrayBuffer(this._fragC3ParamsSize), this._fragC3Paramsf32 = new Float32Array(this._fragC3ParamsArrayBuffer), this._fragC3Paramsu32 = new Uint32Array(this._fragC3ParamsArrayBuffer), this._vertexBuffer = e["createBuffer"]({ "label": "vertexbuffer", "size": this._vertexData.byteLength, "usage": GPUBufferUsage["VERTEX"] | GPUBufferUsage["COPY_DST"] }), this._texcoordBuffer = e["createBuffer"]({ "label": "texcoordbuffer", "size": this._texcoordData.byteLength, "usage": GPUBufferUsage["VERTEX"] | GPUBufferUsage["COPY_DST"] }), this._texIndexBuffer = e["createBuffer"]({ "label": "texindexbuffer", "size": this._texIndexData.byteLength, "usage": GPUBufferUsage["VERTEX"] | GPUBufferUsage["COPY_DST"] }), this._colorBuffer = e["createBuffer"]({ "label": "colorbuffer", "size": this._colorData.byteLength, "usage": GPUBufferUsage["VERTEX"] | GPUBufferUsage["COPY_DST"] }), this._indexBuffer = e["createBuffer"]({ "label": "indexbuffer", "size": this._indexData.byteLength, "usage": GPUBufferUsage["INDEX"] | GPUBufferUsage["COPY_DST"] }), this._pointsIndexBuffer = e["createBuffer"]({ "label": "pointsindexbuffer", "size": 6 * MAX_POINTS * 2, "usage": GPUBufferUsage["INDEX"], "mappedAtCreation": true });
      const r2 = this._pointsIndexBuffer["getMappedRange"]();
      this._FillPointsIndexBuffer(r2), this._pointsIndexBuffer["unmap"](), this._pointBuffer = e["createBuffer"]({ "label": "pointbuffer", "size": this._pointData.byteLength, "usage": GPUBufferUsage["VERTEX"] | GPUBufferUsage["STORAGE"] | GPUBufferUsage["COPY_DST"] }), this._bufferBindGroupLayout = e["createBindGroupLayout"]({ "label": "bufferbindgrouplayout", "entries": [{ "binding": 0, "visibility": GPUShaderStage["VERTEX"], "buffer": { "type": "uniform", "minBindingSize": this._vertexUniformBufferSize } }, { "binding": 1, "visibility": GPUShaderStage["FRAGMENT"], "buffer": { "type": "uniform", "minBindingSize": this._fragUniformBufferSize } }, { "binding": 3, "visibility": GPUShaderStage["VERTEX"], "buffer": { "type": "read-only-storage", "minBindingSize": this._pointData.byteLength } }, { "binding": 4, "visibility": GPUShaderStage["FRAGMENT"], "buffer": { "type": "uniform", "minBindingSize": this._fragC3ParamsSize } }, { "binding": 5, "visibility": GPUShaderStage["FRAGMENT"], "buffer": { "type": "uniform" } }] });
      const i = [], a2 = C32.Gfx.WebGPUMultiTextureGroup.GetMultiTextureLimit();
      for (let e2 = 0; e2 < a2; ++e2) i.push({ "binding": 2 * e2, "visibility": GPUShaderStage["FRAGMENT"], "sampler": { "type": "filtering" } }, { "binding": 2 * e2 + 1, "visibility": GPUShaderStage["FRAGMENT"], "texture": { "sampleType": "float", "viewDimension": "2d" } });
      this._textureBindGroupLayout = e["createBindGroupLayout"]({ "label": "texturebindgrouplayout", "entries": i }), this._backTextureBindGroupLayout = e["createBindGroupLayout"]({ "label": "backtexturebindgrouplayout", "entries": [{ "binding": 0, "visibility": GPUShaderStage["FRAGMENT"], "sampler": { "type": "nearest" === this._backTextureSampling ? "non-filtering" : "filtering" } }, { "binding": 1, "visibility": GPUShaderStage["FRAGMENT"], "texture": { "sampleType": "float", "viewDimension": "2d" } }] }), this._depthTextureBindGroupLayout = e["createBindGroupLayout"]({ "label": "depthtexturebindgrouplayout", "entries": [{ "binding": 0, "visibility": GPUShaderStage["FRAGMENT"], "sampler": { "type": "non-filtering" } }, { "binding": 1, "visibility": GPUShaderStage["FRAGMENT"], "texture": { "sampleType": "depth", "viewDimension": "2d" } }] }), this._pipelineLayout = e["createPipelineLayout"]({ "bindGroupLayouts": [this._bufferBindGroupLayout, this._textureBindGroupLayout, this._backTextureBindGroupLayout, this._depthTextureBindGroupLayout] });
      const s = C32.Gfx.WebGPUShaderProgram, n = this.SupportsF16(), u2 = this.IsColorDataF16();
      this._defaultVertexModule = e["createShaderModule"]({ "label": "<default vertex module>", "code": s._PreprocessVertexShaderCode(s.GetDefaultVertexShaderSource(u2), n) }), this._defaultVertexModule["getCompilationInfo"]().then((e2) => s.ReportShaderCompilationInfo("<default>", "vertex", e2)), this._normVertexModule = e["createShaderModule"]({ "label": "<normalized vertex module>", "code": s._PreprocessVertexShaderCode(s.GetNormalizedVertexShaderSource(u2), n) }), this._normVertexModule["getCompilationInfo"]().then((e2) => s.ReportShaderCompilationInfo("<normalized>", "vertex", e2));
      const h2 = await Promise.all([s.Create(this, { name: "<default>", src: s.GetMultiTextureFillFragmentShaderSource(false, u2), srcFragDepth: s.GetMultiTextureFillFragmentShaderSource(true, u2), vertexSrc: s.GetTextureFillVertexShaderSource(u2), normVertexSrc: s.GetNormalizedTextureFillVertexShaderSource(u2) }), s.Create(this, { name: "<single-texture-fill>", src: s.GetSingleTextureFillFragmentShaderSource(false, u2), srcFragDepth: s.GetSingleTextureFillFragmentShaderSource(true, u2), vertexSrc: s.GetTextureFillVertexShaderSource(u2), normVertexSrc: s.GetNormalizedTextureFillVertexShaderSource(u2) }), s.Create(this, { name: "<generate-mipmap>", src: s._GetMipmapGeneratorFragmentSource(), vertexSrc: s._GetMipmapGeneratorVertexSource() }), s.Create(this, { name: "<point>", src: s._GetPointFragmentSource(false), srcFragDepth: s._GetPointFragmentSource(true), vertexSrc: s._GetPointVertexSource() }), s.Create(this, { name: "<tilemap>", src: s._GetTilemapFragmentShaderSource(false), srcFragDepth: s._GetTilemapFragmentShaderSource(true) }), s.Create(this, { name: "<fill>", src: s._GetColorFillFragmentShaderSource() }), s.Create(this, { name: "<lineargradient>", src: s._GetLinearGradientFillFragmentShaderSource() }), s.Create(this, { name: "<penumbra>", src: s._GetPenumbraFillFragmentShaderSource() }), s.Create(this, { name: "<hardellipse>", src: s._GetHardEllipseFillFragmentShaderSource() }), s.Create(this, { name: "<hardellipseoutline>", src: s._GetHardEllipseOutlineFragmentShaderSource() }), s.Create(this, { name: "<smoothellipse>", src: s._GetSmoothEllipseFillFragmentShaderSource() }), s.Create(this, { name: "<smoothellipseoutline>", src: s._GetSmoothEllipseOutlineFragmentShaderSource() }), s.Create(this, { name: "<tilerandomization>", src: s.GetTileRandomizationFragmentShaderSource(false), srcFragDepth: s.GetTileRandomizationFragmentShaderSource(true) }), s.Create(this, { name: "<smoothline>", src: s._GetSmoothLineFillFragmentShaderSource() })]);
      this._spTextureFill = h2[0], this._spSingleTextureFill = h2[1], this._mipmapGeneratorProgram = h2[2], this._spPoints = h2[3], this._spTilemapFill = h2[4], this._spColorFill = h2[5], this._spLinearGradientFill = h2[6], this._spPenumbraFill = h2[7], this._spHardEllipseFill = h2[8], this._spHardEllipseOutline = h2[9], this._spSmoothEllipseFill = h2[10], this._spSmoothEllipseOutline = h2[11], this._spTileRandomization = h2[12], this._spSmoothLineFill = h2[13];
      for (const e2 of h2) this._AddShaderProgram(e2);
      65536 & this._flags ? (this._flags |= 393216, this._currentProgram = this._spTextureFill) : this._currentProgram = this._spSingleTextureFill, this._mipmapGeneratorPipeline = this._mipmapGeneratorProgram._GetMipmapGeneratorPipeline(), this._vertexUniformBuffer = e["createBuffer"]({ "label": "vertexuniformbuffer", "size": this._vertexUniformBufferSize, "usage": GPUBufferUsage["UNIFORM"] | GPUBufferUsage["COPY_DST"] }), this._fragmentUniformBuffer = e["createBuffer"]({ "label": "fragmentuniformbuffer", "size": this._fragUniformBufferSize, "usage": GPUBufferUsage["UNIFORM"] | GPUBufferUsage["COPY_DST"] }), this._fragmentC3ParamsBuffer = e["createBuffer"]({ "label": "fragmentc3paramsuniformbuffer", "size": this._fragC3ParamsSize, "usage": GPUBufferUsage["UNIFORM"] | GPUBufferUsage["COPY_DST"] }), this._fragmentDefaultCustomParamsBuffer = e["createBuffer"]({ "label": "fragmentdefaultcustomparamsbuffer", "size": 16, "usage": GPUBufferUsage["UNIFORM"] | GPUBufferUsage["COPY_DST"] }), this._vertexUniformUpdateStart = 0, this._vertexUniformUpdateEnd = this._vertexUniformBufferSize, this._UpdateTransformUniform(), this._UpdatePointTexCoordsUniform(), this._UpdateZElevationUniform(), this._fragUniformUpdateStart = 0, this._fragUniformUpdateEnd = this._fragUniformBufferSize, this._UpdateColor2Uniform(), this._UpdatePointColorUniform(), this._defaultBufferBindGroup = this._CreateBufferBindGroup(this._fragmentDefaultCustomParamsBuffer), this._currentBufferBindGroup = this._defaultBufferBindGroup;
      const o2 = C32.CreateCanvas(32, 32);
      o2.getContext("2d"), this._nullTexture = await this.CreateStaticTextureAsync(o2), this._currentTexture = null, this._currentTextureBindGroup = this._nullTexture._GetOwnTextureBindGroup(), this._currentMultiTextureIndex = 0, this._currentBackTexture = null, this._currentBackTextureBindGroup = this._nullTexture._GetBackTextureBindGroup(), this._nullTexture._DisableMultiTexture(), this._nullDepthBuffer = this._device["createTexture"]({ "label": "nulldepthbuffer", "size": [8, 8, 1], "format": this._GetDepthBufferFormat(), "usage": GPUTextureUsage["TEXTURE_BINDING"] }), this._nullDepthBufferView = this._nullDepthBuffer["createView"]({ "label": "nulldepthbufferview", "aspect": "depth-only" }), this._nullDepthBufferBindGroup = this._device["createBindGroup"]({ "label": "nulldepthbufferbindgroup", "layout": this._depthTextureBindGroupLayout, "entries": [{ "binding": 0, "resource": this._GetSampler({ sampling: "nearest" }) }, { "binding": 1, "resource": this._nullDepthBufferView }] }), this._currentDepthTextureBindGroup = this._nullDepthBufferBindGroup, this._backbufferRenderTarget = C32.New(C32.Gfx.WebGPURenderTarget, this, true), this._backbufferRenderTarget.GetTexture()._BackbufferTextureSetProperties(t2, this._swapChainFormat), this._currentRenderTarget = this._backbufferRenderTarget, this._CreateCommandEncoder(), this._adapterInfo = this._adapter["info"], this._presentCtx || (this._presentCtx = this._canvas.getContext("webgpu")), this._presentCtx["configure"]({ "device": e, "format": this._swapChainFormat, "usage": t2, "alphaMode": "premultiplied" });
    }
    _CreateBufferBindGroup(e) {
      return this._device["createBindGroup"]({ "layout": this._bufferBindGroupLayout, "entries": [{ "binding": 0, "resource": { "buffer": this._vertexUniformBuffer } }, { "binding": 1, "resource": { "buffer": this._fragmentUniformBuffer } }, { "binding": 3, "resource": { "buffer": this._pointBuffer } }, { "binding": 4, "resource": { "buffer": this._fragmentC3ParamsBuffer } }, { "binding": 5, "resource": { "buffer": e } }] });
    }
    _FillPointsIndexBuffer(e) {
      const t2 = new Uint16Array(e);
      let r2 = 0, i = t2.length, a2 = 0;
      for (; r2 < i; ) t2[r2++] = a2, t2[r2++] = a2 + 1, t2[r2++] = a2 + 2, t2[r2++] = a2, t2[r2++] = a2 + 2, t2[r2++] = a2 + 3, a2 += 4;
    }
    _GetDevice() {
      return this._device;
    }
    _GetDefaultVertexModule() {
      return this._defaultVertexModule;
    }
    _GetNormalizedVertexModule() {
      return this._normVertexModule;
    }
    async CreateShaderProgram(e) {
      const t2 = await C32.Gfx.WebGPUShaderProgram.Create(this, e);
      return this._AddShaderProgram(t2), t2;
    }
    GetDisplayName() {
      return "webgpu";
    }
    GetSwapChainFormat() {
      return this._swapChainFormat;
    }
    _GetDepthBufferFormat() {
      return "depth24plus-stencil8";
    }
    _GetSwapChainTexture() {
      return this._swapChainTexture;
    }
    _GetSwapChainTexView() {
      return this._swapChainTexView;
    }
    _CanSampleBackbuffer() {
      return this._canSampleBackbuffer;
    }
    UsesBackgroundBlending() {
      return this._usesBackgroundBlending;
    }
    _GetPipelineLayout() {
      return this._pipelineLayout;
    }
    _GetTextureBindGroupLayout() {
      return this._textureBindGroupLayout;
    }
    _GetBackTextureBindGroupLayout() {
      return this._backTextureBindGroupLayout;
    }
    _GetBackTextureSampling() {
      return this._backTextureSampling;
    }
    GetTextureFormat() {
      return this._textureFormat;
    }
    GetMaxTextureSize() {
      return this._maxTextureSize;
    }
    IsContextLost() {
      return this._IsFlagSet(32768);
    }
    SupportsGPUProfiling() {
      return this._IsFlagSet(134217728);
    }
    SupportsF16() {
      return this._IsFlagSet(268435456);
    }
    IsColorDataF16() {
      return this._IsFlagSet(536870912);
    }
    GetEstimatedBackBufferMemoryUsage() {
      const e = this.GetWidth() * this.GetHeight();
      let t2 = e * C32.Gfx.WebGPURendererTexture.GetFormatByteSize(this._swapChainFormat);
      return this.UsesDepthBuffer() && (t2 += e * C32.Gfx.WebGPURendererTexture.GetFormatByteSize(this._GetDepthBufferFormat())), t2;
    }
    GetEstimatedRenderBufferMemoryUsage() {
      let e = 0;
      for (const t2 of C32.Gfx.WebGPURenderTarget.allRenderTargets()) t2.IsBackBuffer() || (e += t2.GetTexture().GetEstimatedMemoryUsage());
      return e;
    }
    GetEstimatedTextureMemoryUsage() {
      let e = 0;
      for (const t2 of C32.Gfx.WebGPURendererTexture.allTextures()) t2.IsRenderTarget() || (e += t2.GetEstimatedMemoryUsage());
      return e;
    }
    SupportsNPOTTextures() {
      return true;
    }
    GetBufferManager() {
      return this._bufferManager;
    }
    SetSize(e, t2, r2) {
      (this._width !== e || this._height !== t2 || r2) && (this.EndBatch(), this._width = e, this._height = t2, this._viewportWidth = e, this._viewportHeight = t2, this._backbufferRenderTarget._CalculateProjection(), this.SetProjectionMatrix(this._backbufferRenderTarget.GetProjectionMatrix()), this._currentRenderTarget && this._currentRenderTarget._Resize(this._width, this._height), this._IsFlagSet(524288) && this._IsFlagSet(67108864) && this._SetDepthBufferSize(e, t2));
    }
    _SetDepthBufferSize(e, t2) {
      if (this._depthBuffer) {
        if (this._depthBufferWidth === e && this._depthBufferHeight === t2) return;
        this._depthBuffer["destroy"]();
      }
      let r2 = GPUTextureUsage["RENDER_ATTACHMENT"];
      this._canSampleDepth && (r2 |= GPUTextureUsage["TEXTURE_BINDING"]), this._depthBuffer = this._device["createTexture"]({ "label": "depthbuffer", "size": [e, t2, 1], "format": this._GetDepthBufferFormat(), "usage": r2 }), this._depthBufferView = this._depthBuffer["createView"]({ "label": "depthbufferview" }), this._canSampleDepth && (this._depthBufferBindGroup = this._device["createBindGroup"]({ "label": "depthbufferbindgroup", "layout": this._depthTextureBindGroupLayout, "entries": [{ "binding": 0, "resource": this._GetSampler({ sampling: "nearest" }) }, { "binding": 1, "resource": this._depthBuffer["createView"]({ "label": "depthbufferview", "aspect": "depth-only" }) }] })), this._depthBufferWidth = e, this._depthBufferHeight = t2;
    }
    SetFixedSizeDepthBuffer(e, t2) {
      this.UsesDepthBuffer() && (this._SetFlag(67108864, false), this._SetDepthBufferSize(e, t2));
    }
    SetAutoSizeDepthBuffer() {
      this.UsesDepthBuffer() && (this._SetFlag(67108864, true), this._SetDepthBufferSize(this._width, this._height));
    }
    SetProjectionMatrix(e) {
      mat4.exactEquals(this._matP, e) || (mat4.copy(this._matP, e), this._UpdateTransformUniform());
    }
    SetDefaultRenderTargetProjectionState() {
      this.SetProjectionMatrix(this._currentRenderTarget.GetProjectionMatrix());
    }
    SetModelViewMatrix(e) {
      mat4.exactEquals(this._matMV, e) || (mat4.copy(this._matMV, e), this._UpdateTransformUniform());
    }
    ResetDidChangeTransformFlag() {
      this._SetFlag2(1, false);
    }
    DidChangeTransform() {
      return this._IsFlagSet2(1);
    }
    CreateStaticTexture(e, t2) {
      if (e && !C32.Gfx.WebGPURendererTexture.IsGPUImageCopyExternalImageSource(e)) {
        const t3 = e.width || e.videoWidth, r3 = e.height || e.videoHeight, i = C32.CreateCanvas(t3, r3);
        i.getContext("2d").drawImage(e, 0, 0, t3, r3), e = i;
      }
      this.EndBatch();
      const r2 = C32.New(C32.Gfx.WebGPURendererTexture, this);
      return r2._Create(e, t2), r2;
    }
    async CreateStaticTextureAsync(e, t2) {
      if (C32.Gfx.WebGPURendererTexture.IsGPUImageCopyExternalImageSource(e)) return this.CreateStaticTexture(e, t2);
      {
        if (!C32.Supports.ImageBitmapOptions) throw new Error("no support for ImageBitmapOptions");
        const r2 = await createImageBitmap(e, { "premultiplyAlpha": "premultiply" });
        return this.CreateStaticTexture(r2, t2);
      }
    }
    _GetSampler(e) {
      const t2 = e.wrapX || "clamp-to-edge", r2 = e.wrapY || "clamp-to-edge", i = e.sampling;
      let a2 = e.anisotropy || 0;
      "trilinear" !== i && (a2 = 0);
      const s = `${t2},${r2},${i},${a2}`;
      let n = this._samplerMap.get(s);
      if (n) return n;
      const u2 = { "addressModeU": t2, "addressModeV": r2, "magFilter": "nearest", "minFilter": "nearest", "mipmapFilter": "nearest" };
      return "bilinear" !== i && "trilinear" !== i || (u2["magFilter"] = "linear", u2["minFilter"] = "linear"), "trilinear" === i && (u2["mipmapFilter"] = "linear", a2 > 1 && (u2["maxAnisotropy"] = a2)), n = this._device["createSampler"](u2), this._samplerMap.set(s, n), n;
    }
    _GetMipmapGeneratorPipeline() {
      return this._mipmapGeneratorPipeline;
    }
    CreateDynamicTexture(e, t2, r2) {
      this.EndBatch();
      const i = C32.New(C32.Gfx.WebGPURendererTexture, this);
      return i._CreateDynamic(e, t2, r2), i;
    }
    UpdateTexture(e, t2, r2) {
      return t2._Update(e, r2);
    }
    DeleteTexture(e) {
      e && (e.SubtractReference(), e.GetReferenceCount() > 0 || (this.IsContextLost() || (this.EndBatch(), this._currentTexture === e && this.SetTexture(null), this._currentBackTexture === e && this.SetBackTexture(null)), e._Delete()));
    }
    _SetMultiTextureAvailable(e, t2) {
      this.IsContextLost() || (t2 ? this._availableMultiTextures.add(e) : this._availableMultiTextures.delete(e));
    }
    _SetMultiTextureGroupNonFull(e, t2) {
      t2 ? this._nonFullMultiTexGroups.add(e) : this._nonFullMultiTexGroups.delete(e);
    }
    _TryCreateMultiTextureGroup(e) {
      const t2 = [e], r2 = C32.Gfx.WebGPUMultiTextureGroup.GetMultiTextureLimit();
      for (const e2 of this._nonFullMultiTexGroups) e2.Release();
      for (const i of this._availableMultiTextures) {
        if (t2.length >= r2) break;
        i !== e && t2.push(i);
      }
      t2.length < 2 || C32.New(C32.Gfx.WebGPUMultiTextureGroup, this, t2);
    }
    Start() {
      this._UpdateSwapChainTexture();
    }
    Restart() {
      this._UpdateSwapChainTexture();
    }
    _UpdateSwapChainTexture() {
      this._swapChainTexture = this._presentCtx["getCurrentTexture"](), this._swapChainTexView = this._swapChainTexture["createView"]({ "label": "swapchaintextureview" }), this._backbufferRenderTarget.GetTexture()._BackbufferTextureStartFrame();
    }
    Finish() {
      null === this._currentRenderPass && this._backbufferRenderTarget._IsAwaitingClear() && this._BeginRenderPass(), super.Finish(), this._bufferManager.MaybeCollectUnusedBuffers(this._frameNumber), this._backbufferRenderTarget.GetTexture()._BackbufferTextureEndFrame(), this._swapChainTexture = null, this._swapChainTexView = null;
    }
    _CreateCommandEncoder() {
      this._commandEncoder = this._device["createCommandEncoder"](), this._flags &= -16385;
    }
    StartFrameTiming(e) {
      if (!this.SupportsGPUProfiling()) throw new Error("GPU profiling not supported");
      if (this._frameTimeQuerySet) throw new Error("already started frame timing");
      return this._timestampIsMeasuring = false, this._timestampStartedIndices.clear(), this._frameTimeQuerySet = C32.New(C32.Gfx.WebGPUTimeQuerySet, this, e), this._frameTimeQuerySet;
    }
    StartMeasuringRenderPassTime(e, t2) {
      if (this.SupportsGPUProfiling()) {
        if (!this._frameTimeQuerySet) throw new Error("not started frame timing");
        if (e < 0 || t2 < 0 || e === t2) throw new Error("invalid timestamp index");
        this._MaybeEndRenderPass(), this._timestampIsMeasuring = true, this._timestampStartIndex = e, this._timestampEndIndex = t2;
      }
    }
    StopMeasuringRenderPassTime() {
      this._timestampIsMeasuring && (this._MaybeEndRenderPass(), this._timestampIsMeasuring = false);
    }
    _AddToDrawBatch(e, t2) {
      if (this._vertexPtr + e > 65535 || this._indexPtr + t2 > 393210) this.EndBatch();
      else if (1 & this._flags) return void (this._drawIndexCount += t2);
      null === this._currentRenderPass && this._BeginRenderPass(), this._flags |= 1, this._drawFirstIndex = this._indexPtr, this._drawIndexCount = t2;
    }
    _AddIndicesForQuad() {
      const e = this._vertexPtr;
      let t2 = this._indexPtr;
      this._indexPtr += 6;
      const r2 = this._indexData;
      r2[t2++] = e, r2[t2++] = e + 1, r2[t2++] = e + 2, r2[t2++] = e, r2[t2++] = e + 2, r2[t2] = e + 3;
    }
    _MaybeEndDrawBatch() {
      const e = this._flags;
      if (!(1 & e)) return;
      const t2 = this._currentRenderPass;
      if (16 & e) {
        const r2 = this._currentRenderTarget;
        t2["setViewport"](0, 0, r2.GetWidth(), r2.GetHeight(), 0, 1), 2 & e ? t2["setIndexBuffer"](this._pointsIndexBuffer, "uint16") : t2["setIndexBuffer"](this._indexBuffer, "uint16"), t2["setVertexBuffer"](0, this._vertexBuffer), t2["setVertexBuffer"](1, this._texcoordBuffer), t2["setVertexBuffer"](2, this._colorBuffer), t2["setVertexBuffer"](3, this._texIndexBuffer), 25165824 & e && t2["setStencilReference"](1), 4 & e && this._DoSetRenderPassScissorRect(t2, this._scissorRect, r2);
      }
      if (32 & e) {
        let r2 = 0;
        1073741824 & e ? r2 = 4 : 8388608 & e ? r2 = 2 : 16777216 & e ? r2 = 3 : 3145728 & ~e || (r2 = 1), t2["setPipeline"](this._currentProgram.GetRenderPipelineForState(this._currentBlendMode, r2, this._currentCullFace, this._currentFrontFaceWinding, this._currentMultisampleCount));
      }
      if (8192 & e && t2["setBindGroup"](0, this._currentBufferBindGroup), 64 & e && t2["setBindGroup"](1, this._currentTextureBindGroup), 128 & e && t2["setBindGroup"](2, this._currentBackTextureBindGroup), 256 & e && t2["setBindGroup"](3, this._currentDepthTextureBindGroup), 8 & e) {
        const r2 = this._currentRenderTarget;
        4 & e ? this._DoSetRenderPassScissorRect(t2, this._scissorRect, r2) : t2["setScissorRect"](0, 0, r2.GetWidth(), r2.GetHeight());
      }
      t2["drawIndexed"](this._drawIndexCount, 1, this._drawFirstIndex, 0, 0), this._flags &= -8698;
    }
    _DoSetRenderPassScissorRect(e, t2, r2) {
      const i = r2.GetWidth(), a2 = r2.GetHeight();
      let s = C32.clamp(t2.getLeft(), 0, i), n = C32.clamp(t2.getTop(), 0, a2), u2 = C32.clamp(t2.getRight(), s, i), h2 = C32.clamp(t2.getBottom(), n, a2);
      Number.isNaN(s) && (s = 0), Number.isNaN(n) && (n = 0), Number.isNaN(u2) && (u2 = i), Number.isNaN(h2) && (h2 = a2), e["setScissorRect"](s, n, u2 - s, h2 - n);
    }
    _BeginRenderPass() {
      const e = this._flags;
      7680 & e && this._WriteUniformBuffers();
      let t2 = null;
      t2 = 8388608 & e ? this._GetCoplanarStencilRenderPassOpts() : 16777216 & e ? this._GetCoplanarColorRenderPassOpts() : this._GetStandardRenderPassOpts(), this._currentRenderPass = this._commandEncoder["beginRenderPass"](t2), this._flags |= 25072;
    }
    _GetStandardRenderPassOpts() {
      const e = this._flags, t2 = this._currentRenderTarget, r2 = { "colorAttachments": [{ "view": t2._GetTextureView(), "loadOp": t2._IsAwaitingClear() ? "clear" : "load", "clearValue": t2._GetClearColor().toJSON(), "storeOp": "store" }] };
      return this._MaybeSetTimestampRenderPassOption(r2), t2._SetIsAwaitingClear(false), 3145728 & ~e || (r2["depthStencilAttachment"] = { "view": this._depthBufferView, "depthLoadOp": 4194304 & e ? "clear" : "load", "depthClearValue": 1, "depthStoreOp": "store", "stencilLoadOp": "clear", "stencilClearValue": 0, "stencilStoreOp": "discard" }, this._flags &= -4194305), r2;
    }
    _GetCoplanarStencilRenderPassOpts() {
      const e = this._flags, t2 = { "colorAttachments": [], "depthStencilAttachment": { "view": this._depthBufferView, "depthLoadOp": 4194304 & e ? "clear" : "load", "depthClearValue": 1, "depthStoreOp": "store", "stencilLoadOp": 33554432 & e ? "clear" : "load", "stencilClearValue": 0, "stencilStoreOp": "store" } };
      return this._MaybeSetTimestampRenderPassOption(t2), this._flags &= -37748737, t2;
    }
    _GetCoplanarColorRenderPassOpts() {
      const e = this._currentRenderTarget, t2 = { "colorAttachments": [{ "view": e._GetTextureView(), "loadOp": e._IsAwaitingClear() ? "clear" : "load", "clearValue": e._GetClearColor().toJSON(), "storeOp": "store" }], "depthStencilAttachment": { "view": this._depthBufferView, "depthReadOnly": true, "stencilReadOnly": true } };
      return this._MaybeSetTimestampRenderPassOption(t2), e._SetIsAwaitingClear(false), t2;
    }
    _MaybeSetTimestampRenderPassOption(e) {
      if (!this._timestampIsMeasuring) return;
      const t2 = { "querySet": this._frameTimeQuerySet._GetQuerySet(), "endOfPassWriteIndex": this._timestampEndIndex };
      this._timestampStartedIndices.has(this._timestampStartIndex) || (t2["beginningOfPassWriteIndex"] = this._timestampStartIndex, this._timestampStartedIndices.add(this._timestampStartIndex)), e["timestampWrites"] = t2;
    }
    _MaybeDoPendingClearRenderPass(e) {
      if (!e._IsAwaitingClear()) return;
      this._MaybeEndRenderPass();
      this._commandEncoder["beginRenderPass"]({ "colorAttachments": [{ "view": e._GetTextureView(), "loadOp": "clear", "clearValue": e._GetClearColor().toJSON(), "storeOp": "store" }] })["end"](), this._flags |= 16384, e._SetIsAwaitingClear(false);
    }
    _MaybeEndRenderPass() {
      null !== this._currentRenderPass && (this._MaybeEndDrawBatch(), this._currentRenderPass["end"](), this._currentRenderPass = null);
    }
    EndBatch(e = false) {
      this._MaybeEndRenderPass(), this._frameTimeQuerySet && e && (this._frameTimeQuerySet.Resolve(this._commandEncoder), this._flags |= 16384), 16384 & this._flags && (this._commandBuffers.push(this._commandEncoder["finish"]()), this._CreateCommandEncoder()), 0 !== this._commandBuffers.length && (this._WriteBuffers(), this._device["queue"]["submit"](this._commandBuffers), C32.clearArray(this._commandBuffers), this._bufferManager.AfterSubmit(), this._frameTimeQuerySet && e && (this._frameTimeQuerySet.ReadResult(), this._frameTimeQuerySet = null));
    }
    _WriteBuffers() {
      const e = this._device["queue"];
      if (this._vertexPtr > 0) {
        const t2 = this._vertexPtr;
        e["writeBuffer"](this._vertexBuffer, 0, this._vertexData.buffer, 0, 3 * t2 * 4), e["writeBuffer"](this._texcoordBuffer, 0, this._texcoordData.buffer, 0, 2 * t2 * 4), 65536 & this._flags && e["writeBuffer"](this._texIndexBuffer, 0, this._texIndexData.buffer, 0, 4 * t2);
        const r2 = this.IsColorDataF16() ? 2 : 4;
        e["writeBuffer"](this._colorBuffer, 0, this._colorData.buffer, 0, 4 * t2 * r2), this._vertexPtr = 0;
      }
      this._indexPtr > 0 && (this._indexPtr % 2 != 0 && (this._indexData[this._indexPtr++] = 0), e["writeBuffer"](this._indexBuffer, 0, this._indexData.buffer, 0, 2 * this._indexPtr), this._indexPtr = 0), this._pointPtr > 0 && (e["writeBuffer"](this._pointBuffer, 0, this._pointData.buffer, 0, 4 * this._pointPtr), this._pointPtr = 0);
    }
    _UpdateTransformUniform() {
      this._flags |= 512, this._flags2 |= 1, this._MarkVertexUniformBufferRangeChanged(this._vertexUniformBufferLayout.transform);
    }
    _UpdatePointTexCoordsUniform() {
      const e = this._vertexUniformBufferLayout.pointTex;
      this._currentPointTexCoords.writeToTypedArray(this._vertexUniformf32, e.offset / 4), this._MarkVertexUniformBufferRangeChanged(e);
    }
    _UpdateZElevationUniform() {
      const e = this._vertexUniformBufferLayout.zElevation;
      this._vertexUniformf32[e.offset / 4] = this._currentVertexZElevation, this._MarkVertexUniformBufferRangeChanged(e);
    }
    _MarkVertexUniformBufferRangeChanged(e) {
      const t2 = e.offset, r2 = e.end;
      1024 & this._flags ? (this._vertexUniformUpdateStart = Math.min(this._vertexUniformUpdateStart, t2), this._vertexUniformUpdateEnd = Math.max(this._vertexUniformUpdateEnd, r2)) : (this._flags |= 1024, this._vertexUniformUpdateStart = t2, this._vertexUniformUpdateEnd = r2, this._MaybeEndRenderPass());
    }
    _UpdateColor2Uniform() {
      this._UpdateFragmentUniformColor(this._currentColor2, this._fragUniformBufferLayout.color2);
    }
    _UpdatePointColorUniform() {
      this._UpdateFragmentUniformColor(this._currentPointColor, this._fragUniformBufferLayout.pointColor);
    }
    _UpdateFragmentUniformColor(e, t2) {
      e.writeToTypedArray(this._fragUniformf32, t2.offset / 4), this._MarkFragUniformBufferRangeChanged(t2);
    }
    _UpdateFragmentUniformVec2(e, t2) {
      e.writeToTypedArray(this._fragUniformf32, t2.offset / 4), this._MarkFragUniformBufferRangeChanged(t2);
    }
    _MarkFragUniformBufferRangeChanged(e) {
      const t2 = e.offset, r2 = e.end;
      2048 & this._flags ? (this._fragUniformUpdateStart = Math.min(this._fragUniformUpdateStart, t2), this._fragUniformUpdateEnd = Math.max(this._fragUniformUpdateEnd, r2)) : (this._flags |= 2048, this._fragUniformUpdateStart = t2, this._fragUniformUpdateEnd = r2, this._MaybeEndRenderPass());
    }
    _MaybeUpdateFragmentC3ParamsFloat(e, t2) {
      this._fragC3Paramsf32[t2.offset / 4] !== Math.fround(e) && (this._fragC3Paramsf32[t2.offset / 4] = e, this._MarkFragC3ParamsRangeChanged(t2));
    }
    _MaybeUpdateFragmentC3ParamsUint(e, t2) {
      this._fragC3Paramsu32[t2.offset / 4] !== e && (this._fragC3Paramsu32[t2.offset / 4] = e, this._MarkFragC3ParamsRangeChanged(t2));
    }
    _MaybeUpdateFragmentC3ParamsRect(e, t2) {
      e.equalsF32Array(this._fragC3Paramsf32, t2.offset / 4) || (e.writeToTypedArray(this._fragC3Paramsf32, t2.offset / 4), this._MarkFragC3ParamsRangeChanged(t2));
    }
    _MarkFragC3ParamsRangeChanged(e) {
      const t2 = e.offset, r2 = e.end;
      4096 & this._flags ? (this._fragC3ParamsUpdateStart = Math.min(this._fragC3ParamsUpdateStart, t2), this._fragC3ParamsUpdateEnd = Math.max(this._fragC3ParamsUpdateEnd, r2)) : (this._flags |= 4096, this._fragC3ParamsUpdateStart = t2, this._fragC3ParamsUpdateEnd = r2, this._MaybeEndRenderPass());
    }
    _WriteUniformBuffers() {
      const e = this._flags;
      512 & e && (mat4.multiply(this._matTransform, this._matP, this._matMV), this._vertexUniformf32.set(this._matTransform, this._vertexUniformBufferLayout.transform.offset / 4)), 1024 & e && this._bufferManager.UpdateBufferSubData(this._commandEncoder, this._vertexUniformBuffer, this._vertexUniformArrayBuffer, this._vertexUniformUpdateStart, this._vertexUniformUpdateEnd - this._vertexUniformUpdateStart), 2048 & e && this._bufferManager.UpdateBufferSubData(this._commandEncoder, this._fragmentUniformBuffer, this._fragUniformArrayBuffer, this._fragUniformUpdateStart, this._fragUniformUpdateEnd - this._fragUniformUpdateStart), 4096 & e && this._bufferManager.UpdateBufferSubData(this._commandEncoder, this._fragmentC3ParamsBuffer, this._fragC3ParamsArrayBuffer, this._fragC3ParamsUpdateStart, this._fragC3ParamsUpdateEnd - this._fragC3ParamsUpdateStart), this._flags = -7681 & e | 16384;
    }
    CreateRenderTarget(e) {
      let t2 = this._width, r2 = this._height, i = true;
      if (e && ("number" == typeof e.width && (t2 = Math.floor(e.width), i = false), "number" == typeof e.height && (r2 = Math.floor(e.height), i = false)), t2 <= 0 || r2 <= 0) throw new Error("invalid size");
      this.EndBatch();
      const a2 = C32.New(C32.Gfx.WebGPURenderTarget, this);
      return a2._Create(t2, r2, Object.assign({ isDefaultSize: i }, e)), a2;
    }
    SetRenderTarget(e, t2 = true) {
      null === e && (e = this._backbufferRenderTarget), this._currentRenderTarget !== e && (this._MaybeEndRenderPass(), this._currentRenderTarget = e, this._SetFlag(2097152, e.HasDepthBuffer()), e.IsDefaultSize() && !e.IsBackBuffer() && e._Resize(this._width, this._height), t2 && this.SetDefaultRenderTargetProjectionState());
    }
    InvalidateRenderTarget(e) {
    }
    GetRenderTarget() {
      return this._currentRenderTarget === this._backbufferRenderTarget ? null : this._currentRenderTarget;
    }
    GetRenderTargetSize(e) {
      return null === e ? [this._width, this._height] : [e.GetWidth(), e.GetHeight()];
    }
    GetBackbufferRenderTarget() {
      return this._backbufferRenderTarget;
    }
    DeleteRenderTarget(e) {
      this.EndBatch(), this._currentRenderTarget === e && this.SetRenderTarget(null);
      const t2 = e.GetTexture();
      this._currentTexture === t2 && this.SetTexture(null), this._currentBackTexture === t2 && this.SetBackTexture(null), e._Delete();
    }
    async ReadBackRenderTargetToImageData(e, t2, r2) {
      this._MaybeDoPendingClearRenderPass(e), this.EndBatch(), null === e && (e = this._backbufferRenderTarget);
      const i = this._device, a2 = e.GetWidth(), s = e.GetHeight();
      let n = 0, u2 = 0, h2 = a2, o2 = s;
      if (r2) {
        n = C32.clamp(Math.floor(r2.getLeft()), 0, a2 - 1), u2 = C32.clamp(Math.floor(r2.getTop()), 0, s - 1);
        let e2 = r2.width();
        e2 = 0 === e2 ? a2 - n : C32.clamp(Math.floor(e2), 0, a2 - n);
        let t3 = r2.height();
        t3 = 0 === t3 ? s - u2 : C32.clamp(Math.floor(t3), 0, s - u2), h2 = e2, o2 = t3;
      }
      const l = i["createCommandEncoder"](), _2 = e.GetTexture();
      let f2 = _2._GetTexture(), d2 = null;
      "rgba8unorm" === _2._GetFormat() ? _2.CanReadPixels() || C32.NotYetImplemented() : (d2 = this._ConvertTextureFormat(_2, "rgba8unorm", l), f2 = d2);
      const c2 = 4 * h2, p2 = 256 * Math.ceil(c2 / 256), m2 = i["createBuffer"]({ "size": p2 * o2, "usage": GPUBufferUsage["MAP_READ"] | GPUBufferUsage["COPY_DST"] });
      l["copyTextureToBuffer"]({ "texture": f2, "origin": [n, u2, 0] }, { "buffer": m2, "bytesPerRow": p2 }, [h2, o2, 1]);
      const g2 = l["finish"]();
      i["queue"]["submit"]([g2]), d2 && d2["destroy"](), await m2["mapAsync"](self["GPUMapMode"]["READ"]);
      const x2 = m2["getMappedRange"]().slice(0);
      let T2;
      if (p2 === c2) T2 = new ImageData(new Uint8ClampedArray(x2), h2, o2);
      else {
        const e2 = new ArrayBuffer(c2 * o2), t3 = new Uint8Array(e2);
        for (let e3 = 0; e3 < o2; ++e3) {
          const r3 = e3 * p2, i2 = e3 * c2;
          t3.set(new Uint8Array(x2, r3, c2), i2);
        }
        T2 = new ImageData(new Uint8ClampedArray(e2), h2, o2);
      }
      return m2["destroy"](), T2;
    }
    _ConvertTextureFormat(e, t2, r2) {
      const i = this._device, a2 = e.GetWidth(), s = e.GetHeight();
      if (e._GetFormat() === t2) throw new Error("no conversion necessary");
      e.IsSampled() || C32.NotYetImplemented();
      const n = i["createTexture"]({ "size": [a2, s, 1], "format": t2, "usage": GPUTextureUsage["COPY_SRC"] | GPUTextureUsage["RENDER_ATTACHMENT"] }), u2 = this._mipmapGeneratorProgram._GetMipmapGeneratorPipeline(t2), h2 = u2["getBindGroupLayout"](0), o2 = this._GetSampler({ sampling: "nearest" }), l = e._GetTexture()["createView"]({ "baseMipLevel": 0, "mipLevelCount": 1 }), _2 = n["createView"]({ "baseMipLevel": 0, "mipLevelCount": 1 }), f2 = r2["beginRenderPass"]({ "colorAttachments": [{ "view": _2, "loadOp": "clear", "clearValue": [0, 0, 0, 0], "storeOp": "store" }] }), d2 = i["createBindGroup"]({ "layout": h2, "entries": [{ "binding": 0, "resource": o2 }, { "binding": 1, "resource": l }] });
      return f2["setPipeline"](u2), f2["setBindGroup"](0, d2), f2["draw"](4), f2["end"](), n;
    }
    SetDepthEnabled(e) {
      524288 & this._flags && (e = !!e, !!(1048576 & this._flags) !== e && (2097152 & this._flags && this._MaybeEndRenderPass(), this._SetFlag(1048576, e)));
    }
    IsDepthEnabled() {
      return this._IsFlagSet(1048576);
    }
    UsesDepthBuffer() {
      return this._IsFlagSet(524288);
    }
    SetDepthSamplingEnabled(e) {
      if (!this._canSampleDepth) return;
      if (e && this.IsDepthEnabled()) throw new Error("depth still enabled");
      const t2 = e ? this._depthBufferBindGroup : this._nullDepthBufferBindGroup;
      this._currentDepthTextureBindGroup !== t2 && (this._MaybeEndDrawBatch(), this._currentDepthTextureBindGroup = t2, this._flags |= 256);
    }
    Clear(e) {
      this._MaybeEndRenderPass(), this._currentRenderTarget._SetIsAwaitingClear(true), this._currentRenderTarget._GetClearColor().set(e);
    }
    ClearRgba(e, t2, r2, i) {
      this._MaybeEndRenderPass(), this._currentRenderTarget._SetIsAwaitingClear(true), this._currentRenderTarget._GetClearColor().setRgba(e, t2, r2, i);
    }
    ClearDepth() {
      2621440 & ~this._flags || (this._MaybeEndRenderPass(), this._flags |= 4194304);
    }
    SetScissorRect(e, t2, r2, i) {
      e = Math.floor(e), t2 = Math.floor(t2), r2 = Math.floor(r2), i = Math.floor(i), 4 & this._flags && this._scissorRect.equalsWH(e, t2, r2, i) || (this._MaybeEndDrawBatch(), this._flags |= 12, this._scissorRect.setWH(e, t2, r2, i));
    }
    RemoveScissorRect() {
      4 & this._flags && (this._MaybeEndDrawBatch(), this._flags &= -5, this._flags |= 8);
    }
    GetTextureFillShaderProgram() {
      return 65536 & this._flags ? this._spTextureFill : this._spSingleTextureFill;
    }
    SetTextureFillMode() {
      this.SetProgram(this.GetTextureFillShaderProgram());
    }
    SetProgram(e) {
      if (this._currentProgram !== e) {
        if (e === this._spTextureFill && !(65536 & this._flags)) throw new Error("cannot set multitexture fill program when multitexturing not allowed");
        this._MaybeEndDrawBatch(), this._currentProgram = e, this._currentStateGroup = null, this._flags |= 32, this._SetMultiTexturingEnabled(e === this._spTextureFill);
      }
    }
    GetProgram() {
      return this._currentProgram;
    }
    _SetMultiTexturingEnabled(e) {
      if (e = !!e, !!(131072 & this._flags) === e) return;
      this._SetFlag(131072, e);
      const t2 = null === this._currentTexture ? this._nullTexture : this._currentTexture;
      this._ApplyTextureBindGroup(t2);
    }
    _SetMultiTexturingActive(e) {
      e = !!e, !!(262144 & this._flags) !== e && (this._MaybeEndDrawBatch(), this._SetFlag(262144, e), this._SetFlag(32, true));
    }
    SetNormalizedCoordsProgramVariant(e) {
      e = !!e, !!(1073741824 & this._flags) !== e && (this._MaybeEndDrawBatch(), this._SetFlag(1073741824, e), this._flags |= 32);
    }
    IsNormalizedCoordsProgramVariant() {
      return this._IsFlagSet(1073741824);
    }
    SetTexture(e) {
      e !== this._currentTexture && (this._currentTexture = e, null === e && (e = this._nullTexture), this._ApplyTextureBindGroup(e));
    }
    _ApplyTextureBindGroup(e) {
      if (131072 & this._flags) {
        const t2 = e._GetMultiTextureBindGroup();
        if (null !== t2) return this._SetTextureBindGroup(t2), this._currentMultiTextureIndex = e._GetMultiTextureIndex(), void this._SetMultiTexturingActive(true);
      }
      this._SetTextureBindGroup(e._GetOwnTextureBindGroup()), this._currentMultiTextureIndex = 0, this._SetMultiTexturingActive(false);
    }
    _SetTextureBindGroup(e) {
      e !== this._currentTextureBindGroup && (this._MaybeEndDrawBatch(), this._currentTextureBindGroup = e, this._flags |= 64);
    }
    _OnTextureBindGroupChanged(e) {
      this._currentTexture === e && (this._MaybeEndDrawBatch(), this._currentTextureBindGroup = e._GetOwnTextureBindGroup(), this._flags |= 64);
    }
    _OnMultiTextureBindGroupReleased(e) {
      if (this._currentTextureBindGroup !== e) return;
      this._MaybeEndDrawBatch();
      const t2 = null === this._currentTexture ? this._nullTexture : this._currentTexture;
      this._currentTextureBindGroup = t2._GetOwnTextureBindGroup(), this._currentMultiTextureIndex = 0, this._flags |= 64;
    }
    SetBackTexture(e) {
      e !== this._currentBackTexture && (this._currentBackTexture = e, null === e && (e = this._nullTexture), this._MaybeEndDrawBatch(), this._currentBackTextureBindGroup = e._GetBackTextureBindGroup(), this._flags |= 128);
    }
    CopyTextureToTexture(e, t2, r2, i, a2, s) {
      const n = e._GetUsage(), u2 = t2._GetUsage();
      if (0 === (n & GPUTextureUsage["COPY_SRC"])) throw new Error("source texture missing COPY_SRC usage");
      if (0 === (u2 & GPUTextureUsage["COPY_DST"])) throw new Error("destination texture missing COPY_DST usage");
      if (e === t2) throw new Error("invalid destination");
      const h2 = Math.min(e.GetWidth(), t2.GetWidth()), o2 = Math.min(e.GetHeight(), t2.GetHeight());
      a2 = Math.min(a2, h2 - r2), s = Math.min(s, o2 - i), a2 <= 0 || s <= 0 || (this._MaybeEndRenderPass(), this._commandEncoder["copyTextureToTexture"]({ "texture": e._GetTexture(), "origin": [r2, i] }, { "texture": t2._GetTexture(), "origin": [r2, i] }, [a2, s]), this._flags |= 16384);
    }
    _ClampToSupportedMultisampleValues(e) {
      return e >= 2 ? 4 : 1;
    }
    SetRenderingToMultisampleCount(e) {
      e = this._ClampToSupportedMultisampleValues(e), this._currentMultisampleCount !== e && (this._MaybeEndDrawBatch(), this._currentMultisampleCount = e, this._flags |= 32);
    }
    SetBlendMode(e) {
      e !== this._currentBlendMode && (this._MaybeEndDrawBatch(), this._currentBlendMode = e, this._currentStateGroup = null, this._flags |= 32);
    }
    SetNamedBlendMode(e) {
      this.SetBlendMode(this.NamedBlendToNumber(e));
    }
    SetAlphaBlend() {
      this.SetBlendMode(0);
    }
    SetCopyBlend() {
      this.SetBlendMode(3);
    }
    SetColorRgba(e, t2, r2, i) {
      const a2 = this._currentColor;
      a2.equalsRgba(e, t2, r2, i) || (a2.setRgba(e, t2, r2, i), this._currentStateGroup = null);
    }
    SetOpacity(e) {
      const t2 = this._currentColor;
      t2.getA() !== e && (t2.setA(e), this._currentStateGroup = null);
    }
    GetOpacity() {
      return this._currentColor.getA();
    }
    SetColor(e) {
      const t2 = this._currentColor;
      t2.equals(e) || (t2.set(e), this._currentStateGroup = null);
    }
    ResetColor() {
      this.SetColorRgba(1, 1, 1, 1);
    }
    GetColor() {
      return this._currentColor;
    }
    SetCullFaceMode(e) {
      e !== this._currentCullFace && (this._MaybeEndDrawBatch(), this._currentCullFace = e, this._currentStateGroup = null, this._flags |= 32);
    }
    GetCullFaceMode() {
      return this._currentCullFace;
    }
    SetFrontFaceWinding(e) {
      e !== this._currentFrontFaceWinding && (this._MaybeEndDrawBatch(), this._currentFrontFaceWinding = e, this._currentStateGroup = null, this._flags |= 32);
    }
    GetFrontFaceWinding() {
      return this._currentFrontFaceWinding;
    }
    Rect(e) {
      this.Rect2(e.getLeft(), e.getTop(), e.getRight(), e.getBottom());
    }
    Rect2(e, t2, r2, i) {
      this.Quad2(e, t2, r2, t2, r2, i, e, i);
    }
    _WriteQuadTexIndices(e) {
      const t2 = this._texIndexData, r2 = this._currentMultiTextureIndex;
      t2[e++] = r2, t2[e++] = r2, t2[e++] = r2, t2[e] = r2;
    }
    Quad(e) {
      this.Quad4(e, defaultTexCoordsQuad);
    }
    Quad2(e, t2, r2, i, a2, s, n, u2) {
      this._AddToDrawBatch(4, 6), this._AddIndicesForQuad();
      const h2 = this._vertexData, o2 = this._vertexPtr;
      this._vertexPtr += 4;
      let l = 3 * o2;
      const _2 = this._baseZ + this._currentZ;
      h2[l++] = e, h2[l++] = t2, h2[l++] = _2, h2[l++] = r2, h2[l++] = i, h2[l++] = _2, h2[l++] = a2, h2[l++] = s, h2[l++] = _2, h2[l++] = n, h2[l++] = u2, h2[l] = _2, defaultTexCoordsQuad.writeToTypedArray(this._texcoordData, 2 * o2), 262144 & this._flags && this._WriteQuadTexIndices(o2), this._currentColor.writeToTypedArrayx4(this._colorData, 4 * o2);
    }
    Quad3(e, t2) {
      this._AddToDrawBatch(4, 6), this._AddIndicesForQuad();
      const r2 = this._vertexPtr;
      this._vertexPtr += 4, e.writeToTypedArray3D(this._vertexData, 3 * r2, this._baseZ + this._currentZ), t2.writeAsQuadToTypedArray(this._texcoordData, 2 * r2), 262144 & this._flags && this._WriteQuadTexIndices(r2), this._currentColor.writeToTypedArrayx4(this._colorData, 4 * r2);
    }
    Quad4(e, t2) {
      this._AddToDrawBatch(4, 6), this._AddIndicesForQuad();
      const r2 = this._vertexPtr;
      this._vertexPtr += 4, e.writeToTypedArray3D(this._vertexData, 3 * r2, this._baseZ + this._currentZ), t2.writeToTypedArray(this._texcoordData, 2 * r2), 262144 & this._flags && this._WriteQuadTexIndices(r2), this._currentColor.writeToTypedArrayx4(this._colorData, 4 * r2);
    }
    Quad5(e, t2, r2) {
      this._AddToDrawBatch(4, 6), this._AddIndicesForQuad();
      const i = this._vertexPtr;
      this._vertexPtr += 4, e.writeToTypedArray3D(this._vertexData, 3 * i, this._baseZ + this._currentZ), t2.writeToTypedArray(this._texcoordData, 2 * i), 262144 & this._flags && this._WriteQuadTexIndices(i), this._colorData.set(r2, 4 * i);
    }
    Quad3D(e, t2, r2, i, a2, s, n, u2, h2, o2, l, _2, f2) {
      this._AddToDrawBatch(4, 6), this._AddIndicesForQuad();
      const d2 = this._vertexData, c2 = this._vertexPtr;
      this._vertexPtr += 4;
      let p2 = 3 * c2;
      const m2 = this._baseZ + this._currentZ;
      d2[p2++] = e, d2[p2++] = t2, d2[p2++] = m2 + r2, d2[p2++] = i, d2[p2++] = a2, d2[p2++] = m2 + s, d2[p2++] = n, d2[p2++] = u2, d2[p2++] = m2 + h2, d2[p2++] = o2, d2[p2++] = l, d2[p2] = m2 + _2, f2.writeAsQuadToTypedArray(this._texcoordData, 2 * c2), 262144 & this._flags && this._WriteQuadTexIndices(c2), this._currentColor.writeToTypedArrayx4(this._colorData, 4 * c2);
    }
    Quad3D2(e, t2, r2, i, a2, s, n, u2, h2, o2, l, _2, f2) {
      this._AddToDrawBatch(4, 6), this._AddIndicesForQuad();
      const d2 = this._vertexData, c2 = this._vertexPtr;
      this._vertexPtr += 4;
      let p2 = 3 * c2;
      const m2 = this._baseZ + this._currentZ;
      d2[p2++] = e, d2[p2++] = t2, d2[p2++] = m2 + r2, d2[p2++] = i, d2[p2++] = a2, d2[p2++] = m2 + s, d2[p2++] = n, d2[p2++] = u2, d2[p2++] = m2 + h2, d2[p2++] = o2, d2[p2++] = l, d2[p2] = m2 + _2, f2.writeToTypedArray(this._texcoordData, 2 * c2), 262144 & this._flags && this._WriteQuadTexIndices(c2), this._currentColor.writeToTypedArrayx4(this._colorData, 4 * c2);
    }
    Quad3D3(e, t2, r2, i, a2, s, n, u2, h2, o2, l, _2, f2, d2) {
      this._AddToDrawBatch(4, 6), this._AddIndicesForQuad();
      const c2 = this._vertexData, p2 = this._vertexPtr;
      this._vertexPtr += 4;
      let m2 = 3 * p2;
      const g2 = this._baseZ + this._currentZ;
      c2[m2++] = e, c2[m2++] = t2, c2[m2++] = g2 + r2, c2[m2++] = i, c2[m2++] = a2, c2[m2++] = g2 + s, c2[m2++] = n, c2[m2++] = u2, c2[m2++] = g2 + h2, c2[m2++] = o2, c2[m2++] = l, c2[m2] = g2 + _2, f2.writeToTypedArray(this._texcoordData, 2 * p2), 262144 & this._flags && this._WriteQuadTexIndices(p2), this._colorData.set(d2, 4 * p2);
    }
    DrawMesh(e, t2, r2, i) {
      if (e.length % 3 != 0) throw new Error("vertex buffer length not multiple of 3");
      if (e.length > 196605) throw new Error(`too many vertices (${e.length / 3}, limit 65535)`);
      if (r2.length % 3 != 0) throw new Error("index buffer length not multiple of 3");
      if (r2.length > 393210) throw new Error(`too many indices (${r2.length}, limit 393210)`);
      this._AddToDrawBatch(e.length, r2.length);
      const a2 = this._vertexPtr;
      this._vertexData.set(e, 3 * a2), this._texcoordData.set(t2, 2 * a2), 262144 & this._flags && this._texIndexData.fill(this._currentMultiTextureIndex, a2, a2 + e.length);
      const s = this._indexData;
      if (0 === a2) s.set(r2, this._indexPtr);
      else {
        let e2 = this._indexPtr;
        for (let t3 = 0, i2 = r2.length; t3 < i2; ++t3) s[e2++] = r2[t3] + a2;
      }
      const n = this._colorData;
      if (null != i) n.set(i, 4 * a2);
      else {
        const t3 = this._currentColor, r3 = t3.getR(), i2 = t3.getG(), s2 = t3.getB(), u2 = t3.getA();
        let h2 = 4 * a2;
        for (let t4 = 0, a3 = e.length; t4 < a3; ++t4) n[h2++] = r3, n[h2++] = i2, n[h2++] = s2, n[h2++] = u2;
      }
      this._vertexPtr += e.length / 3, this._indexPtr += r2.length;
    }
    StartRenderingPoints(e) {
      this._currentPointTexCoords.equals(e) || (this._currentPointTexCoords.copy(e), this._UpdatePointTexCoordsUniform());
      const t2 = this._baseZ + this._currentZ;
      this._currentVertexZElevation !== t2 && (this._currentVertexZElevation = t2, this._UpdateZElevationUniform()), this._currentPointColor.equals(this._currentColor) || (this._currentPointColor.copy(this._currentColor), this._UpdatePointColorUniform()), this.SetProgram(this.GetPointsRenderingProgram()), this._drawIndexCount = 0, this._flags |= 18;
    }
    FinishRenderingPoints() {
      this._drawIndexCount > 0 && this._MaybeEndDrawBatch(), this._flags &= -3, this._flags |= 16;
    }
    Point(e, t2, r2, i) {
      let a2 = this._pointPtr;
      a2 > LAST_POINT_PTR && (this.EndBatch(), a2 = 0), 1 & this._flags ? this._drawIndexCount += 6 : (null === this._currentRenderPass && this._BeginRenderPass(), this._flags |= 1, this._drawFirstIndex = a2 / 4 * 6, this._drawIndexCount = 6);
      const s = this._pointData;
      s[a2++] = e, s[a2++] = t2, s[a2++] = r2, s[a2++] = i, this._pointPtr = a2;
    }
    SetGradientColor(e) {
      this._currentColor2.equals(e) || (this._currentColor2.copy(e), this._UpdateColor2Uniform());
    }
    SetEllipseParams(e, t2, r2 = 1) {
      const i = this._fragUniformBufferLayout, a2 = this._fragUniformf32;
      tempVec2.set(e, t2), tempVec2.equalsF32Array(a2, i.pixelSize.offset / 4) || this._UpdateFragmentUniformVec2(tempVec2, i.pixelSize), a2[i.outlineThickness.offset / 4] !== Math.fround(r2) && (a2[i.outlineThickness.offset / 4] = r2, this._MarkFragUniformBufferRangeChanged(i.outlineThickness));
    }
    SetTilemapInfo(e, t2, r2, i, a2, s, n) {
      const u2 = this._fragUniformBufferLayout, h2 = this._fragUniformf32;
      e.equalsF32Array(h2, u2.srcRect.offset / 4) || (e.writeToTypedArray(h2, u2.srcRect.offset / 4), this._MarkFragUniformBufferRangeChanged(u2.srcRect)), tempVec2.set(i / t2, a2 / r2), tempVec2.equalsF32Array(h2, u2.tileSize.offset / 4) || this._UpdateFragmentUniformVec2(tempVec2, u2.tileSize), tempVec2.set(s / t2, n / r2), tempVec2.equalsF32Array(h2, u2.tileSpacing.offset / 4) || this._UpdateFragmentUniformVec2(tempVec2, u2.tileSpacing);
    }
    SetTileRandomizationInfo(e, t2, r2, i, a2, s, n) {
      const u2 = this._fragUniformBufferLayout, h2 = this._fragUniformf32;
      tempVec2.set(r2, i), tempVec2.equalsF32Array(h2, u2.tileSize.offset / 4) || this._UpdateFragmentUniformVec2(tempVec2, u2.tileSize), h2[u2.outlineThickness.offset / 4] !== Math.fround(a2) && (h2[u2.outlineThickness.offset / 4] = a2, this._MarkFragUniformBufferRangeChanged(u2.outlineThickness)), tempVec2.set(s, n), tempVec2.equalsF32Array(h2, u2.tileSpacing.offset / 4) || this._UpdateFragmentUniformVec2(tempVec2, u2.tileSpacing);
    }
    SetProgramParameters(e, t2, r2, i, a2, s, n, u2, h2, o2, l) {
      const _2 = this._fragC3ParamsLayout, f2 = this._currentProgram;
      l %= 10800, f2.BlendsBackground() && this.SetBackTexture(e), f2.UsesAnyC3ParamRect() && (this._MaybeUpdateFragmentC3ParamsRect(t2, _2.destRect), this._MaybeUpdateFragmentC3ParamsRect(r2, _2.srcRect), this._MaybeUpdateFragmentC3ParamsRect(i, _2.srcOriginRect), this._MaybeUpdateFragmentC3ParamsRect(a2, _2.layoutRect)), this._MaybeUpdateFragmentC3ParamsFloat(u2, _2.devicePixelRatio), this._MaybeUpdateFragmentC3ParamsFloat(h2, _2.layerScale), this._MaybeUpdateFragmentC3ParamsFloat(o2, _2.layerAngle), this._MaybeUpdateFragmentC3ParamsFloat(l, _2.seconds), this._MaybeUpdateFragmentC3ParamsFloat(this.GetNearZ(), _2.zNear), this._MaybeUpdateFragmentC3ParamsFloat(this.GetFarZ(), _2.zFar);
    }
    SetProgramCustomParameters(e) {
      e && (e.IsChanged() && (this._MaybeEndRenderPass(), e.UpdateBuffer(this._commandEncoder)), this._SetBufferBindGroup(e.GetBufferBindGroup()));
    }
    SetProgramParameter_IsSrcTexRotated(e) {
      this._MaybeUpdateFragmentC3ParamsUint(e ? 1 : 0, this._fragC3ParamsLayout.isSrcTexRotated);
    }
    _SetBufferBindGroup(e) {
      e !== this._currentBufferBindGroup && (this._MaybeEndDrawBatch(), this._currentBufferBindGroup = e, this._flags |= 8192);
    }
    _OnBufferBindGroupDestroyed(e) {
      this._currentBufferBindGroup === e && this._SetBufferBindGroup(this._defaultBufferBindGroup);
    }
    CopyRenderTarget(e) {
      if (e._IsAwaitingClear()) return this._currentRenderTarget._SetIsAwaitingClear(true), void this._currentRenderTarget._GetClearColor().set(e._GetClearColor());
      e.GetMultisampling() >= 2 && this._currentRenderTarget.GetMultisampling() < 2 ? this._ResolveMultisampledRenderTarget(e) : (this.ClearRgba(0, 0, 0, 0), this.SetCopyBlend(), this.ResetColor(), this.DrawRenderTarget(e));
    }
    DrawRenderTarget(e) {
      this._MaybeDoPendingClearRenderPass(e);
      const t2 = e.GetTexture();
      this.SetTexture(t2), this.FullscreenQuad();
    }
    FullscreenQuad() {
      const e = this.IsNormalizedCoordsProgramVariant();
      e || this.SetNormalizedCoordsProgramVariant(true), this.SetCurrentZ(0);
      const t2 = tempQuad, r2 = tempRect;
      t2.set(0, -1, 0, -1, 2, 1, 0, 1), r2.set(0, -1, 2, 1), this.Quad3(t2, r2), e || this.SetNormalizedCoordsProgramVariant(false);
    }
    _ResolveMultisampledRenderTarget(e) {
      this._MaybeDoPendingClearRenderPass(e), this._MaybeEndRenderPass();
      this._commandEncoder["beginRenderPass"]({ "colorAttachments": [{ "view": e.GetTexture()._GetTextureView(), "resolveTarget": this._currentRenderTarget.GetTexture()._GetTextureView(), "loadOp": "load", "storeOp": "store" }] })["end"](), this._flags |= 16384;
    }
    CoplanarStartStencilPass() {
      this._MaybeEndRenderPass(), this.SetDepthEnabled(true), this._flags |= 41943040;
    }
    CoplanarStartColorPass(e = false) {
      this._MaybeEndRenderPass(), this.SetDepthEnabled(e), this._flags &= -8388609, this._flags |= 16777216;
    }
    IsCoplanarColorPass() {
      return this._IsFlagSet(16777216);
    }
    CoplanarRestoreStandardRendering(e = true) {
      this._MaybeEndRenderPass(), this.SetDepthEnabled(e), this._flags &= -16777217;
    }
    _InitBlendModes() {
      this._InitBlendModeData([["normal", "one", "one-minus-src-alpha"], ["additive", "one", "one"], ["xor", "one", "one-minus-src-alpha"], ["copy", "one", "zero"], ["destination-over", "one-minus-dst-alpha", "one"], ["source-in", "dst-alpha", "zero"], ["destination-in", "zero", "src-alpha"], ["source-out", "one-minus-dst-alpha", "zero"], ["destination-out", "zero", "one-minus-src-alpha"], ["source-atop", "dst-alpha", "one-minus-src-alpha"], ["destination-atop", "one-minus-dst-alpha", "src-alpha"]]);
    }
    GetAvailableAdapterFeatures() {
      return this._adapter ? [...this._adapter["features"]] : [];
    }
    GetAdapterInfo() {
      return this._adapterInfo;
    }
    GetAdapterInfoString() {
      const e = this._adapterInfo;
      if (!e) return "unknown/unknown";
      const t2 = e["vendor"] || "unknown", r2 = e["architecture"] || "unknown", i = [];
      e["device"] && i.push(e["device"]), e["description"] && i.push(e["description"]), e["type"] && i.push(e["type"]), e["backend"] && i.push(e["backend"]);
      return t2 + "/" + r2 + (i.length > 0 ? ` (${i.join(", ")})` : "");
    }
  };
}
{
  const C32 = self.C3, ENABLE_RECYCLING = true;
  C32.Gfx.WebGPUBufferManager = class {
    constructor(e) {
      this._renderer = e, this._buffers = /* @__PURE__ */ new Map(), this._recycleAfterSubmit = [], this._releaseAfterSubmit = [], this._destroyAfterSubmit = [], this._totalBufferCount = 0, this._totalBufferSize = 0, this._totalCreated = 0, this._totalReleased = 0, this._totalReturned = 0, this._totalRecycled = 0;
    }
    GetRenderer() {
      return this._renderer;
    }
    OnContextLost() {
      this._buffers.clear(), C32.clearArray(this._recycleAfterSubmit), C32.clearArray(this._releaseAfterSubmit), C32.clearArray(this._destroyAfterSubmit);
    }
    _RoundBufferSizeClass(e) {
      return Math.max(C32.nextHighestPowerOfTwo(e), 16);
    }
    GetRecyclableBuffer(e) {
      this._totalReturned++;
      const t2 = this._RoundBufferSizeClass(e);
      {
        const e2 = this._buffers.get(t2);
        if (void 0 !== e2 && e2.length > 0) {
          const r2 = e2.pop();
          return r2.MarkInUse(), 0 === e2.length && this._buffers.delete(t2), r2;
        }
      }
      return this._totalBufferCount++, this._totalBufferSize += t2, this._totalCreated++, C32.New(C32.Gfx.WebGPURecyclableBuffer, this, t2);
    }
    _AddRecycledBuffer(e) {
      this._totalRecycled++;
      const t2 = e.GetSize(), r2 = this._buffers.get(t2);
      void 0 === r2 ? this._buffers.set(t2, [e]) : r2.push(e);
    }
    _DestroyAfterSubmit(e) {
      this._destroyAfterSubmit.push(e);
    }
    AfterSubmit() {
      for (const e of this._recycleAfterSubmit) e.Recycle();
      C32.clearArray(this._recycleAfterSubmit);
      for (const e of this._releaseAfterSubmit) this._totalBufferCount--, this._totalBufferSize -= e.GetSize(), e.Release();
      C32.clearArray(this._releaseAfterSubmit);
      for (const e of this._destroyAfterSubmit) e["destroy"]();
      C32.clearArray(this._destroyAfterSubmit);
    }
    MaybeCollectUnusedBuffers(e) {
      e % 30 == 0 && this._CollectUnusedBuffers(e);
    }
    _CollectUnusedBuffers(e) {
      for (const [t2, r2] of this._buffers.entries()) {
        let s = 0;
        for (let t3 = 0, f2 = r2.length; t3 < f2; ++t3) {
          const f3 = r2[t3];
          f3._ShouldCollect(e) ? (this._totalBufferCount--, this._totalBufferSize -= f3.GetSize(), f3.Release(), this._totalReleased++) : (r2[s] = f3, ++s);
        }
        0 === s ? this._buffers.delete(t2) : C32.truncateArray(r2, s);
      }
      this._DebugLogBufferMap();
    }
    UpdateBufferSubData(e, t2, r2, s, f2) {
      const i = this.GetRecyclableBuffer(f2), u2 = i.GetBuffer(), l = u2["getMappedRange"](0, f2);
      new Uint8Array(l).set(new Uint8Array(r2, s, f2)), u2["unmap"](), e["copyBufferToBuffer"](u2, 0, t2, s, f2), this._recycleAfterSubmit.push(i);
    }
    _DebugLogBufferMap() {
      this._totalCreated = 0, this._totalReleased = 0, this._totalReturned = 0, this._totalRecycled = 0;
    }
  };
}
{
  const C32 = self.C3, GPUBufferUsage = self["GPUBufferUsage"], GPUMapMode = self["GPUMapMode"], assert = self.assert, STATE_AVAILABLE = 0, STATE_IN_USE = 1, STATE_RECYCLING = 2;
  C32.Gfx.WebGPURecyclableBuffer = class {
    constructor(e, t2) {
      this._bufferManager = e, this._state = 1, this._size = t2, this._buffer = this.GetRenderer()._GetDevice()["createBuffer"]({ "mappedAtCreation": true, "size": t2, "usage": GPUBufferUsage["COPY_SRC"] | GPUBufferUsage["MAP_WRITE"] }), this._recycledFrameNumber = 0;
    }
    GetRenderer() {
      return this._bufferManager.GetRenderer();
    }
    GetState() {
      return this._state;
    }
    GetSize() {
      return this._size;
    }
    GetBuffer() {
      return this._buffer;
    }
    MarkInUse() {
      this._state = 1;
    }
    async Recycle() {
      this._state = 2;
      try {
        await this._buffer["mapAsync"](GPUMapMode["WRITE"]);
      } catch (e) {
        return void console.warn("[WebGPU] Error recycling buffer, assuming device was lost: ", e);
      }
      this.GetRenderer().IsContextLost() || (this._state = 0, this._recycledFrameNumber = this.GetRenderer().GetFrameNumber(), this._bufferManager._AddRecycledBuffer(this));
    }
    Discard() {
      this._state = 0;
    }
    _ShouldCollect(e) {
      return this._recycledFrameNumber <= e - 25;
    }
    Release() {
      this._buffer["destroy"](), this._buffer = null, this._bufferManager = null;
    }
  };
}
{
  const C32 = self.C3, assert = self.assert, GPUBufferUsage = self["GPUBufferUsage"];
  C32.Gfx.WebGPUEffectCustomParamsBuffer = class {
    constructor(e) {
      const r2 = e.GetRenderer();
      this._shaderProgram = e, this._byteSize = e.GetCustomParametersByteSize(), this._arrayBuffer = new ArrayBuffer(this._byteSize), this._f32arr = new Float32Array(this._arrayBuffer), this._isChanged = false, this._buffer = r2._GetDevice()["createBuffer"]({ "size": this._byteSize, "usage": GPUBufferUsage["UNIFORM"] | GPUBufferUsage["COPY_DST"] }), this._bufferBindGroup = r2._CreateBufferBindGroup(this._buffer);
    }
    Release() {
      this.GetRenderer()._OnBufferBindGroupDestroyed(this._bufferBindGroup), this.GetRenderer().GetBufferManager()._DestroyAfterSubmit(this._buffer), this._buffer = null, this._shaderProgram = null, this._arrayBuffer = null, this._f32arr = null, this._bufferBindGroup = null;
    }
    GetRenderer() {
      return this._shaderProgram.GetRenderer();
    }
    GetShaderProgram() {
      return this._shaderProgram;
    }
    GetBufferBindGroup() {
      return this._bufferBindGroup;
    }
    SetParameterValue(e, r2) {
      const t2 = this._shaderProgram._GetCustomParameterInfo(e), s = t2.type, f2 = t2.offset / 4, a2 = this._f32arr;
      if ("color" === s) {
        if (r2.equalsRGBF32Array(a2, f2)) return;
        r2.writeRGBToTypedArray(a2, f2), this._isChanged = true;
      } else {
        if ("float" !== s && "percent" !== s) throw new Error(`unexpected shader param type '${s}'`);
        if (a2[f2] === Math.fround(r2)) return;
        a2[f2] = r2, this._isChanged = true;
      }
    }
    IsChanged() {
      return this._isChanged;
    }
    UpdateBuffer(e) {
      this.GetRenderer().GetBufferManager().UpdateBufferSubData(e, this._buffer, this._arrayBuffer, 0, this._byteSize), this._isChanged = false;
    }
  };
}
{
  let UpdateLayoutEndValues = function(t2) {
    for (const e of Object.values(t2)) e.end = e.offset + e.size;
  }, makeNullFilledArray = function(t2) {
    const e = [];
    for (let n = 0; n < t2; ++n) e.push(null);
    return e;
  }, GetFragmentInputStructDeclaration = function(t2) {
    return `
struct FragmentInput {
	@location(1) fragUV : vec2<f32>,
	@location(2) fragColor : vec4<${t2 ? "f16" : "f32"}>,
	@builtin(position) fragPos : vec4<f32>
};

fn c3_getBackUV(fragPos : vec2<f32>, texBack : texture_2d<f32>) -> vec2<f32>
{
	return fragPos / vec2<f32>(textureDimensions(texBack));
}

fn c3_getDepthUV(fragPos : vec2<f32>, texDepth : texture_depth_2d) -> vec2<f32>
{
	return fragPos / vec2<f32>(textureDimensions(texDepth));
}
`;
  }, HashPipelineState = function(t2, e, n, r2, a2) {
    return t2 << 10 | e << 7 | n << 5 | r2 << 4 | a2;
  };
  UpdateLayoutEndValues2 = UpdateLayoutEndValues, makeNullFilledArray2 = makeNullFilledArray, GetFragmentInputStructDeclaration2 = GetFragmentInputStructDeclaration, HashPipelineState2 = HashPipelineState;
  const C32 = self.C3, SIZEOF_F32 = 4, SIZEOF_F16 = 2, SIZEOF_U32 = 4, SIZEOF_VEC2_F32 = 8, SIZEOF_VEC4_F32 = 16, SIZEOF_MAT4_F32 = 64;
  const vertexUniformBufferDeclaration = "\nstruct Uniforms {\n	transform		: mat4x4<f32>,\n	pointTexStart	: vec2<f32>,\n	pointTexEnd		: vec2<f32>,\n	zElevation		: f32\n};\n@binding(0) @group(0) var<uniform> uniforms : Uniforms;\n", vubLayout = { transform: { offset: 0, size: 64, end: 0 }, pointTex: { offset: 64, size: 16, end: 0 }, pointTexStart: { offset: 64, size: 8, end: 0 }, pointTexEnd: { offset: 72, size: 8, end: 0 }, zElevation: { offset: 80, size: 4, end: 0 } };
  UpdateLayoutEndValues(vubLayout);
  const vubSize = vubLayout.zElevation.end, fragmentUniformBufferDeclaration = "\nstruct Uniforms {\n	color2				: vec4<f32>,\n	pointColor 			: vec4<f32>,\n	tileSize			: vec2<f32>,\n	tileSpacing			: vec2<f32>,\n	srcRectStart		: vec2<f32>,\n	srcRectEnd			: vec2<f32>,\n	pixelSize			: vec2<f32>,\n	outlineThickness	: f32\n};\n@binding(1) @group(0) var<uniform> uniforms : Uniforms;\n", fubLayout = { color2: { offset: 0, size: 16, end: 0 }, pointColor: { offset: 16, size: 16, end: 0 }, tileSize: { offset: 32, size: 8, end: 0 }, tileSpacing: { offset: 40, size: 8, end: 0 }, srcRect: { offset: 48, size: 16, end: 0 }, srcRectStart: { offset: 48, size: 8, end: 0 }, srcRectEnd: { offset: 56, size: 8, end: 0 }, pixelSize: { offset: 64, size: 8, end: 0 }, outlineThickness: { offset: 72, size: 4, end: 0 } };
  UpdateLayoutEndValues(fubLayout);
  const fubSize = fubLayout.outlineThickness.end, c3ParamsUniformBufferDeclaration = "\nstruct C3Params {\n	srcStart			: vec2<f32>,\n	srcEnd				: vec2<f32>,\n	srcOriginStart		: vec2<f32>,\n	srcOriginEnd		: vec2<f32>,\n	layoutStart			: vec2<f32>,\n	layoutEnd			: vec2<f32>,\n	destStart			: vec2<f32>,\n	destEnd				: vec2<f32>,\n	devicePixelRatio	: f32,\n	layerScale			: f32,\n	layerAngle			: f32,\n	seconds				: f32,\n	zNear				: f32,\n	zFar				: f32,\n	isSrcTexRotated		: u32\n};\n@binding(4) @group(0) var<uniform> c3Params : C3Params;\n\nfn c3_srcToNorm(p : vec2<f32>) -> vec2<f32>\n{\n	return (p - c3Params.srcStart) / (c3Params.srcEnd - c3Params.srcStart);\n}\n\nfn c3_normToSrc(p : vec2<f32>) -> vec2<f32>\n{\n	return fma(p, c3Params.srcEnd - c3Params.srcStart, c3Params.srcStart);\n}\n\nfn c3_clampToSrc(p : vec2<f32>) -> vec2<f32>\n{\n	return clamp(p, min(c3Params.srcStart, c3Params.srcEnd), max(c3Params.srcStart, c3Params.srcEnd));\n}\n\nfn c3_srcOriginToNorm(p : vec2<f32>) -> vec2<f32>\n{\n	return (p - c3Params.srcOriginStart) / (c3Params.srcOriginEnd - c3Params.srcOriginStart);\n}\n\nfn c3_normToSrcOrigin(p : vec2<f32>) -> vec2<f32>\n{\n	return fma(p, c3Params.srcOriginEnd - c3Params.srcOriginStart, c3Params.srcOriginStart);\n}\n\nfn c3_clampToSrcOrigin(p : vec2<f32>) -> vec2<f32>\n{\n	return clamp(p, min(c3Params.srcOriginStart, c3Params.srcOriginEnd), max(c3Params.srcOriginStart, c3Params.srcOriginEnd));\n}\n\nfn c3_getLayoutPos(p : vec2<f32>) -> vec2<f32>\n{\n	return fma(p - c3Params.srcOriginStart, (c3Params.layoutEnd - c3Params.layoutStart) / (c3Params.srcOriginEnd - c3Params.srcOriginStart), c3Params.layoutStart);\n}\n\nfn c3_srcToDest(p : vec2<f32>) -> vec2<f32>\n{\n	return fma(p - c3Params.srcStart, (c3Params.destEnd - c3Params.destStart) / (c3Params.srcEnd - c3Params.srcStart), c3Params.destStart);\n}\n\nfn c3_clampToDest(p : vec2<f32>) -> vec2<f32>\n{\n	return clamp(p, min(c3Params.destStart, c3Params.destEnd), max(c3Params.destStart, c3Params.destEnd));\n}\n\nfn c3_linearizeDepth(depthSample : f32) -> f32\n{\n	return c3Params.zNear * c3Params.zFar / (c3Params.zFar + depthSample * (c3Params.zNear - c3Params.zFar));\n}\n", C3PARAMS_TERMS_REFERENCING_SRC_RECTS = ["srcStart", "srcEnd", "srcOriginStart", "srcOriginEnd", "c3_srcToNorm", "c3_normToSrc", "c3_clampToSrc", "c3_srcOriginToNorm", "c3_normToSrcOrigin", "c3_clampToSrcOrigin", "c3_getLayoutPos", "c3_srcToDest"], C3PARAMS_TERMS_REFERENCING_OTHER_RECTS = ["layoutStart", "layoutEnd", "destStart", "destEnd", "c3_clampToDest"], c3ParamsLayout = { srcRect: { offset: 0, size: 16, end: 0 }, srcStart: { offset: 0, size: 8, end: 0 }, srcEnd: { offset: 8, size: 8, end: 0 }, srcOriginRect: { offset: 16, size: 16, end: 0 }, srcOriginStart: { offset: 16, size: 8, end: 0 }, srcOriginEnd: { offset: 24, size: 8, end: 0 }, layoutRect: { offset: 32, size: 16, end: 0 }, layoutStart: { offset: 32, size: 8, end: 0 }, layoutEnd: { offset: 40, size: 8, end: 0 }, destRect: { offset: 48, size: 16, end: 0 }, destStart: { offset: 48, size: 8, end: 0 }, destEnd: { offset: 56, size: 8, end: 0 }, devicePixelRatio: { offset: 64, size: 4, end: 0 }, layerScale: { offset: 68, size: 4, end: 0 }, layerAngle: { offset: 72, size: 4, end: 0 }, seconds: { offset: 76, size: 4, end: 0 }, zNear: { offset: 80, size: 4, end: 0 }, zFar: { offset: 84, size: 4, end: 0 }, isSrcTexRotated: { offset: 88, size: 4, end: 0 } };
  UpdateLayoutEndValues(c3ParamsLayout);
  const c3ParamsSize = c3ParamsLayout.isSrcTexRotated.end;
  const fragmentOutputStructDeclaration = "\nstruct FragmentOutput {\n	@location(0) color : vec4<f32>\n};\n", shaderCustomParamSizes = /* @__PURE__ */ new Map([["float", 4], ["percent", 4], ["color", 12]]), shaderCustomParamAlignSizes = /* @__PURE__ */ new Map([["float", 4], ["percent", 4], ["color", 16]]), c3WGSLUtilityFunctionsLib = "\nfn c3_premultiply(c : vec4<f32>) -> vec4<f32>\n{\n	return vec4<f32>(c.rgb * c.a, c.a);\n}\n\nfn c3_unpremultiply(c : vec4<f32>) -> vec4<f32>\n{\n	if (c.a == 0.0)\n	{\n		return vec4<f32>(0.0);\n	}\n	\n	return vec4<f32>(c.rgb / c.a, c.a);\n}\n\nfn c3_grayscale(rgb : vec3<f32>) -> f32\n{\n	return dot(rgb, vec3<f32>(0.299, 0.587, 0.114));\n}\n\nfn c3_getPixelSize(t : texture_2d<f32>) -> vec2<f32>\n{\n	return vec2<f32>(1.0) / vec2<f32>(textureDimensions(t));\n}\n\nfn c3_clamp2(v : vec2<f32>, l : f32, u : f32) -> vec2<f32>\n{\n	return clamp(v, vec2<f32>(l), vec2<f32>(u));\n}\n\nfn c3_mod(x : f32, y : f32) -> f32\n{\n	return x - y * floor(x / y);\n}\n\nfn c3_mod2(x : vec2<f32>, y : vec2<f32>) -> vec2<f32>\n{\n	return x - y * floor(x / y);\n}\n\nfn c3_RGBtoHSL(color : vec3<f32>) -> vec3<f32>\n{\n	var hsl : vec3<f32> = vec3<f32>(0.0);\n	\n	var fmin : f32 = min(min(color.r, color.g), color.b);\n	var fmax : f32 = max(max(color.r, color.g), color.b);\n	var delta : f32 = fmax - fmin;\n\n	hsl.z = (fmax + fmin) / 2.0;\n\n	if (delta == 0.0)\n	{\n		hsl.x = 0.0;\n		hsl.y = 0.0;\n	}\n	else \n	{\n		if (hsl.z < 0.5)\n		{\n			hsl.y = delta / (fmax + fmin);\n		}\n		else\n		{\n			hsl.y = delta / (2.0 - fmax - fmin);\n		}\n		\n		var dR : f32 = (((fmax - color.r) / 6.0) + (delta / 2.0)) / delta;\n		var dG : f32 = (((fmax - color.g) / 6.0) + (delta / 2.0)) / delta;\n		var dB : f32 = (((fmax - color.b) / 6.0) + (delta / 2.0)) / delta;\n\n		if (color.r == fmax)\n		{\n			hsl.x = dB - dG;\n		}\n		else if (color.g == fmax)\n		{\n			hsl.x = (1.0 / 3.0) + dR - dB;\n		}\n		else if (color.b == fmax)\n		{\n			hsl.x = (2.0 / 3.0) + dG - dR;\n		}\n\n		if (hsl.x < 0.0)\n		{\n			hsl.x = hsl.x + 1.0;\n		}\n		else if (hsl.x > 1.0)\n		{\n			hsl.x = hsl.x - 1.0;\n		}\n	}\n\n	return hsl;\n}\n\nfn c3_hueToRGB(f1 : f32, f2 : f32, hue_ : f32) -> f32\n{\n	var hue : f32 = hue_;\n	if (hue < 0.0)\n	{\n		hue = hue + 1.0;\n	}\n	else if (hue > 1.0)\n	{\n		hue = hue - 1.0;\n	}\n		\n	var ret : f32;\n	\n	if ((6.0 * hue) < 1.0)\n	{\n		ret = f1 + (f2 - f1) * 6.0 * hue;\n	}\n	else if ((2.0 * hue) < 1.0)\n	{\n		ret = f2;\n	}\n	else if ((3.0 * hue) < 2.0)\n	{\n		ret = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\n	}\n	else\n	{\n		ret = f1;\n	}\n	\n	return ret;\n}\n\nfn c3_HSLtoRGB(hsl : vec3<f32>) -> vec3<f32>\n{\n	var rgb : vec3<f32> = vec3<f32>(hsl.z);\n	\n	if (hsl.y != 0.0)\n	{\n		var f2 : f32;\n		\n		if (hsl.z < 0.5)\n		{\n			f2 = hsl.z * (1.0 + hsl.y);\n		}\n		else\n		{\n			f2 = (hsl.z + hsl.y) - (hsl.y * hsl.z);\n		}\n			\n		var f1 : f32 = 2.0 * hsl.z - f2;\n		\n		rgb.r = c3_hueToRGB(f1, f2, hsl.x + (1.0 / 3.0));\n		rgb.g = c3_hueToRGB(f1, f2, hsl.x);\n		rgb.b = c3_hueToRGB(f1, f2, hsl.x - (1.0 / 3.0));\n	}\n	\n	return rgb;\n}\n";
  C32.Gfx.WebGPUShaderProgram = class extends C32.Gfx.ShaderProgramBase {
    constructor(t2, e) {
      if (super(t2, e), this._fragmentModule = e.fragmentModule, this._fragmentModuleFragDepth = e.fragmentModuleFragDepth, this._vertexModule = e.vertexModule, this._normVertexModule = e.normVertexModule, this._renderPipelineMap = /* @__PURE__ */ new Map(), this._mipmapPipelineMap = /* @__PURE__ */ new Map(), this._usesAnyC3ParamRect = false, this._usesIsSrcTexRotated = false, this._parameters = [], this._customParamsByteSize = 0, e.parameters) {
        let t3 = 0;
        for (const n of e.parameters) {
          const e2 = n[2];
          if (!shaderCustomParamSizes.has(e2)) throw new Error(`unrecognized effect param type '${e2}'`);
          const r2 = shaderCustomParamSizes.get(e2), a2 = shaderCustomParamAlignSizes.get(e2), i = t3 % a2;
          0 !== i && (t3 += a2 - i), this._parameters.push({ type: e2, offset: t3, size: r2, end: t3 + r2 }), t3 += r2;
        }
        this._customParamsByteSize = 16 * Math.ceil(t3 / 16);
      }
    }
    static async Create(t2, e) {
      const n = t2._GetDevice(), r2 = e.name, a2 = t2.SupportsF16(), i = t2.IsColorDataF16(), o2 = e.src, u2 = C32.Gfx.WebGPUShaderProgram._PreprocessFragmentShaderCode(o2, a2, i), f2 = n["createShaderModule"]({ "label": r2, "code": u2 });
      let c2, s = null;
      if (e.srcFragDepth) {
        const t3 = C32.Gfx.WebGPUShaderProgram._PreprocessFragmentShaderCode(e.srcFragDepth, a2, i);
        s = n["createShaderModule"]({ "label": r2, "code": t3 });
      }
      f2["getCompilationInfo"]().then((t3) => C32.Gfx.WebGPUShaderProgram.ReportShaderCompilationInfo(r2, "fragment", t3));
      const l = C32.Gfx.WebGPUShaderProgram._PreprocessVertexShaderCode(e.vertexSrc, a2);
      let p2;
      l ? (c2 = n["createShaderModule"]({ "label": r2, "code": l }), c2["getCompilationInfo"]().then((t3) => C32.Gfx.WebGPUShaderProgram.ReportShaderCompilationInfo(r2, "vertex", t3))) : c2 = t2._GetDefaultVertexModule();
      const d2 = C32.Gfx.WebGPUShaderProgram._PreprocessVertexShaderCode(e.normVertexSrc, a2);
      d2 ? (p2 = n["createShaderModule"]({ "label": r2, "code": d2 }), p2["getCompilationInfo"]().then((t3) => C32.Gfx.WebGPUShaderProgram.ReportShaderCompilationInfo(r2, "vertex (norm)", t3))) : p2 = t2._GetNormalizedVertexModule();
      const m2 = C32.New(C32.Gfx.WebGPUShaderProgram, t2, Object.assign({ fragmentModule: f2, fragmentModuleFragDepth: s, vertexModule: c2, normVertexModule: p2 }, e));
      if (m2._usesAnySrcRectOrPixelSize = o2.includes("%%C3PARAMS_STRUCT%%") && C3PARAMS_TERMS_REFERENCING_SRC_RECTS.some((t3) => o2.includes(t3)), m2._usesAnyC3ParamRect = m2._usesAnySrcRectOrPixelSize || o2.includes("%%C3PARAMS_STRUCT%%") && C3PARAMS_TERMS_REFERENCING_OTHER_RECTS.some((t3) => o2.includes(t3)), m2._usesIsSrcTexRotated = o2.includes("%%C3PARAMS_STRUCT%%") && o2.includes("isSrcTexRotated"), "<generate-mipmap>" !== r2) {
        const e2 = m2._CreateRenderPipelineAsync(0, 0, 0, 0, 0);
        let n2 = null;
        t2.UsesDepthBuffer() && (n2 = m2._CreateRenderPipelineAsync(0, 1, 0, 0, 0));
        const [r3, a3] = await Promise.all([e2, n2]);
        m2._renderPipelineMap.set(HashPipelineState(0, 0, 0, 0, 0), r3), a3 && m2._renderPipelineMap.set(HashPipelineState(0, 1, 0, 0, 0), a3);
      }
      return m2;
    }
    static _PreprocessShaderCode(t2, e) {
      if (!t2) return t2;
      let n = "";
      return n = e ? "enable f16;\nalias f16or32 = f16;\n" : "alias f16or32 = f32;\n", n + t2;
    }
    static _PreprocessFragmentShaderCode(t2, e, n) {
      return t2 = C32.Gfx.WebGPUShaderProgram._PreprocessShaderCode(t2, e), C32.StringSubstituteMap(t2, { "%%SAMPLERFRONT_BINDING%%": "@binding(0) @group(1)", "%%TEXTUREFRONT_BINDING%%": "@binding(1) @group(1)", "%%SAMPLERBACK_BINDING%%": "@binding(0) @group(2)", "%%TEXTUREBACK_BINDING%%": "@binding(1) @group(2)", "%%SAMPLERDEPTH_BINDING%%": "@binding(0) @group(3)", "%%TEXTUREDEPTH_BINDING%%": "@binding(1) @group(3)", "%%SHADERPARAMS_BINDING%%": "@binding(5) @group(0)", "%%FRAGMENTINPUT_STRUCT%%": GetFragmentInputStructDeclaration(n), "%%FRAGMENTOUTPUT_STRUCT%%": fragmentOutputStructDeclaration, "%%C3PARAMS_STRUCT%%": c3ParamsUniformBufferDeclaration, "%%C3_UTILITY_FUNCTIONS%%": c3WGSLUtilityFunctionsLib });
    }
    static _PreprocessVertexShaderCode(t2, e) {
      return C32.Gfx.WebGPUShaderProgram._PreprocessShaderCode(t2, e);
    }
    static ReportShaderCompilationInfo(t2, e, n) {
      for (const r2 of n["messages"]) {
        const n2 = `[WebGPU] Message (${r2["type"]}) compiling ${e} shader '${t2}': ${r2["message"]} (line ${r2["lineNum"]}, pos ${r2["linePos"]})`;
        "error" === r2.type ? console.error(n2) : "warning" === r2.type ? console.warn(n2) : console.log(n2);
      }
    }
    Release() {
      this._fragmentModule = null, this._fragmentModuleFragDepth = null, this._vertexModule = null, this._normVertexModule = null, this._renderPipelineMap.clear(), this._mipmapPipelineMap.clear(), super.Release();
    }
    _GetDevice() {
      return this._renderer._GetDevice();
    }
    _GetPipelineLayout() {
      return this._renderer._GetPipelineLayout();
    }
    GetRenderer() {
      return this._renderer;
    }
    UsesAnyC3ParamRect() {
      return this._usesAnyC3ParamRect;
    }
    UsesIsSrcTexRotated() {
      return this._usesIsSrcTexRotated;
    }
    GetParameterCount() {
      return this._parameters.length;
    }
    GetParameterType(t2) {
      return t2 < 0 || t2 >= this._parameters.length ? null : this._parameters[t2].type;
    }
    GetCustomParametersByteSize() {
      return this._customParamsByteSize;
    }
    _GetCustomParameterInfo(t2) {
      return this._parameters[t2];
    }
    _GetRenderPipelineDescriptor(t2, e, n, r2, a2) {
      const i = this._renderer, o2 = i.IsColorDataF16(), [u2, f2] = i._GetBlendByIndex(t2);
      let c2 = "none";
      switch (n) {
        case 1:
          c2 = "back";
          break;
        case 2:
          c2 = "front";
      }
      const s = { "label": `${this.GetName()} blendMode ${t2} variant ${e} multisampleCount ${a2}`, "layout": this._GetPipelineLayout(), "primitive": { "cullMode": c2, "frontFace": 0 === r2 ? "cw" : "ccw" }, "vertex": { "module": 4 === e ? this._normVertexModule : this._vertexModule, "entryPoint": "main", "buffers": [{ "arrayStride": 12, "attributes": [{ "shaderLocation": 0, "offset": 0, "format": "float32x3" }] }, { "arrayStride": 8, "attributes": [{ "shaderLocation": 1, "offset": 0, "format": "float32x2" }] }, { "arrayStride": 4 * (o2 ? 2 : 4), "attributes": [{ "shaderLocation": 2, "offset": 0, "format": o2 ? "float16x4" : "float32x4" }] }, { "arrayStride": 4, "attributes": [{ "shaderLocation": 3, "offset": 0, "format": "uint32" }] }] }, "fragment": { "module": this._fragmentModule, "entryPoint": "main", "targets": [{ "format": i.GetSwapChainFormat(), "blend": { "color": { "srcFactor": u2, "dstFactor": f2 }, "alpha": { "srcFactor": u2, "dstFactor": f2 } } }] } };
      if (a2 >= 2 && (s["multisample"] = { "count": a2 }), 1 === e) s["fragment"]["module"] = this._fragmentModuleFragDepth || this._fragmentModule, s["depthStencil"] = { "format": i._GetDepthBufferFormat(), "depthWriteEnabled": true, "depthCompare": "less-equal" };
      else if (2 === e) {
        s["fragment"]["module"] = this._fragmentModuleFragDepth || this._fragmentModule, s["fragment"]["targets"] = [];
        const t3 = { "compare": "always", "failOp": "keep", "depthFailOp": "keep", "passOp": "replace" };
        s["depthStencil"] = { "format": i._GetDepthBufferFormat(), "depthWriteEnabled": true, "depthCompare": "less-equal", "stencilFront": t3, "stencilBack": t3, "stencilReadMask": 1, "stencilWriteMask": 1 };
      } else if (3 === e) {
        s["fragment"]["module"] = this._fragmentModuleFragDepth || this._fragmentModule;
        const t3 = { "compare": "equal", "failOp": "keep", "depthFailOp": "keep", "passOp": "keep" };
        s["depthStencil"] = { "format": i._GetDepthBufferFormat(), "depthWriteEnabled": false, "depthCompare": "always", "stencilFront": t3, "stencilBack": t3, "stencilReadMask": 1, "stencilWriteMask": 0 };
      }
      return s;
    }
    _CreateRenderPipeline(t2, e, n, r2, a2) {
      return this._GetDevice()["createRenderPipeline"](this._GetRenderPipelineDescriptor(t2, e, n, r2, a2));
    }
    _CreateRenderPipelineAsync(t2, e, n, r2, a2) {
      return this._GetDevice()["createRenderPipelineAsync"](this._GetRenderPipelineDescriptor(t2, e, n, r2, a2));
    }
    GetRenderPipelineForState(t2, e, n, r2, a2) {
      const i = HashPipelineState(t2, e, n, r2, a2);
      let o2 = this._renderPipelineMap.get(i);
      return o2 || (o2 = this._CreateRenderPipeline(t2, e, n, r2, a2), this._renderPipelineMap.set(i, o2), o2);
    }
    static GetVertexUniformBufferLayout() {
      return vubLayout;
    }
    static GetVertexUniformBufferSize() {
      return 16 * Math.ceil(vubSize / 16);
    }
    static GetFragmentUniformBufferLayout() {
      return fubLayout;
    }
    static GetFragmentUniformBufferSize() {
      return 16 * Math.ceil(fubSize / 16);
    }
    static GetFragmentC3ParamsBufferLayout() {
      return c3ParamsLayout;
    }
    static GetFragmentC3ParamsBufferSize() {
      return 16 * Math.ceil(c3ParamsSize / 16);
    }
    static GetDefaultVertexShaderSource(t2) {
      const e = t2 ? "f16" : "f32";
      return `
		${vertexUniformBufferDeclaration}

		struct VertexInput {
			@location(0) position : vec3<f32>,
			@location(1) uv : vec2<f32>,
			@location(2) color : vec4<${e}>,
			@location(3) texIndex : u32
		};

		struct VertexOutput {
			@builtin(position) Position : vec4<f32>,
			@location(1) fragUV : vec2<f32>,
			@location(2) fragColor : vec4<${e}>,
			@location(3) @interpolate(flat, either) texIndex : u32
		};

		@vertex
		fn main(input : VertexInput) -> VertexOutput {
			var output : VertexOutput;
			output.Position = uniforms.transform * vec4<f32>(input.position, 1.0);
			output.fragUV = input.uv;
			output.fragColor = input.color;
			output.texIndex = input.texIndex;
			return output;
		}`;
    }
    static GetNormalizedVertexShaderSource(t2) {
      const e = t2 ? "f16" : "f32";
      return `
		struct VertexInput {
			@location(0) position : vec3<f32>,
			@location(1) uv : vec2<f32>,
			@location(2) color : vec4<${e}>,
			@location(3) texIndex : u32
		};

		struct VertexOutput {
			@builtin(position) Position : vec4<f32>,
			@location(1) fragUV : vec2<f32>,
			@location(2) fragColor : vec4<${e}>,
			@location(3) @interpolate(flat, either) texIndex : u32
		};

		@vertex
		fn main(input : VertexInput) -> VertexOutput {
			var output : VertexOutput;
			var p = input.position;
			p.y = 1.0 - p.y;
			output.Position = vec4<f32>(p.xy * 2.0 - 1.0, p.z, 1.0);
			output.fragUV = input.uv;
			output.texIndex = input.texIndex;
			output.fragColor = input.color;
			return output;
		}`;
    }
    static GetTextureFillVertexShaderSource(t2) {
      const e = t2 ? "f16" : "f32";
      return `
		${vertexUniformBufferDeclaration}

		struct VertexInput {
			@location(0) position : vec3<f32>,
			@location(1) uv : vec2<f32>,
			@location(2) color : vec4<${e}>,
			@location(3) texIndex : u32
		};

		struct VertexOutput {
			@builtin(position) Position : vec4<f32>,
			@location(1) fragUV : vec2<f32>,
			@location(2) fragColor : vec4<${e}>,
			@location(3) @interpolate(flat, either) texIndex : u32
		};

		@vertex
		fn main(input : VertexInput) -> VertexOutput {
			var output : VertexOutput;
			output.Position = uniforms.transform * vec4<f32>(input.position, 1.0);
			output.fragUV = input.uv;
			output.fragColor = input.color;
			output.texIndex = input.texIndex;
			return output;
		}`;
    }
    static GetNormalizedTextureFillVertexShaderSource(t2) {
      const e = t2 ? "f16" : "f32";
      return `
		struct VertexInput {
			@location(0) position : vec3<f32>,
			@location(1) uv : vec2<f32>,
			@location(2) color : vec4<${e}>,
			@location(3) texIndex : u32
		};

		struct VertexOutput {
			@builtin(position) Position : vec4<f32>,
			@location(1) fragUV : vec2<f32>,
			@location(2) fragColor : vec4<${e}>,
			@location(3) @interpolate(flat, either) texIndex : u32
		};

		@vertex
		fn main(input : VertexInput) -> VertexOutput {
			var output : VertexOutput;
			var p = input.position;
			p.y = 1.0 - p.y;
			output.Position = vec4<f32>(p.xy * 2.0 - 1.0, p.z, 1.0);
			output.fragUV = input.uv;
			output.fragColor = input.color;
			output.texIndex = input.texIndex;
			return output;
		}`;
    }
    static GetMultiTextureFillFragmentShaderSource(t2, e) {
      return `
		@binding(0) @group(1) var sampler0 : sampler;
		@binding(1) @group(1) var texture0 : texture_2d<f32>;
		@binding(2) @group(1) var sampler1 : sampler;
		@binding(3) @group(1) var texture1 : texture_2d<f32>;
		@binding(4) @group(1) var sampler2 : sampler;
		@binding(5) @group(1) var texture2 : texture_2d<f32>;
		@binding(6) @group(1) var sampler3 : sampler;
		@binding(7) @group(1) var texture3 : texture_2d<f32>;
		@binding(8) @group(1) var sampler4 : sampler;
		@binding(9) @group(1) var texture4 : texture_2d<f32>;
		@binding(10) @group(1) var sampler5 : sampler;
		@binding(11) @group(1) var texture5 : texture_2d<f32>;
		@binding(12) @group(1) var sampler6 : sampler;
		@binding(13) @group(1) var texture6 : texture_2d<f32>;
		@binding(14) @group(1) var sampler7 : sampler;
		@binding(15) @group(1) var texture7 : texture_2d<f32>;
		@binding(16) @group(1) var sampler8 : sampler;
		@binding(17) @group(1) var texture8 : texture_2d<f32>;
		@binding(18) @group(1) var sampler9 : sampler;
		@binding(19) @group(1) var texture9 : texture_2d<f32>;
		@binding(20) @group(1) var sampler10 : sampler;
		@binding(21) @group(1) var texture10 : texture_2d<f32>;
		@binding(22) @group(1) var sampler11 : sampler;
		@binding(23) @group(1) var texture11 : texture_2d<f32>;
		@binding(24) @group(1) var sampler12 : sampler;
		@binding(25) @group(1) var texture12 : texture_2d<f32>;
		@binding(26) @group(1) var sampler13 : sampler;
		@binding(27) @group(1) var texture13 : texture_2d<f32>;

		struct FragmentInput {
			@location(1) fragUV : vec2<f32>,
			@location(2) fragColor : vec4<${e ? "f16" : "f32"}>,
			@location(3) @interpolate(flat, either) texIndex : u32,
			${t2 ? "@builtin(position) fragPos: vec4<f32>" : ""}
		};

		struct FragmentOutput {
			@location(0) color : vec4<f32>,
			${t2 ? "@builtin(frag_depth) fragDepth: f32" : ""} 
		};

		@fragment
		fn main(input : FragmentInput) -> FragmentOutput {
			var output : FragmentOutput;
			var texXy : vec2<f32> = input.fragUV.xy;
			var texIndex : u32 = input.texIndex;
			var c : vec4<f32>;

			let dx = dpdx(texXy);
			let dy = dpdy(texXy);
			
			if (texIndex <= 6)
			{
				if (texIndex <= 2)
				{
					if (texIndex == 0)			{	c = textureSampleGrad(texture0, sampler0, texXy, dx, dy);	}
					else
					{
						if (texIndex == 1)		{	c = textureSampleGrad(texture1, sampler1, texXy, dx, dy);	}
						else					{	c = textureSampleGrad(texture2, sampler2, texXy, dx, dy);	}
					}						
				}
				else
				{
					if (texIndex <= 4)
					{
						if (texIndex == 3)		{	c = textureSampleGrad(texture3, sampler3, texXy, dx, dy);	}
						else					{	c = textureSampleGrad(texture4, sampler4, texXy, dx, dy);	}
					}
					else
					{
						if (texIndex <= 5)		{	c = textureSampleGrad(texture5, sampler5, texXy, dx, dy);	}
						else					{	c = textureSampleGrad(texture6, sampler6, texXy, dx, dy);	}
					}
				}
			}
			else
			{
				if (texIndex <= 9)
				{
					if (texIndex == 7)			{	c = textureSampleGrad(texture7, sampler7, texXy, dx, dy);	}
					else
					{
						if (texIndex == 8)		{	c = textureSampleGrad(texture8, sampler8, texXy, dx, dy);	}
						else					{	c = textureSampleGrad(texture9, sampler9, texXy, dx, dy);	}
					}						
				}
				else
				{
					if (texIndex <= 11)
					{
						if (texIndex == 10)		{	c = textureSampleGrad(texture10, sampler10, texXy, dx, dy);	}
						else					{	c = textureSampleGrad(texture11, sampler11, texXy, dx, dy);	}
					}
					else
					{
						if (texIndex == 12)		{	c = textureSampleGrad(texture12, sampler12, texXy, dx, dy);	}
						else					{	c = textureSampleGrad(texture13, sampler13, texXy, dx, dy);	}
					}
				}
			}

			output.color = c * vec4<f32>(input.fragColor);
			${t2 ? "output.fragDepth = select(input.fragPos.z, 1.0, output.color.a == 0.0);" : ""}
			return output;
		}`;
    }
    static GetSingleTextureFillFragmentShaderSource(t2, e) {
      return `
		@binding(0) @group(1) var sampler0 : sampler;
		@binding(1) @group(1) var texture0 : texture_2d<f32>;

		struct FragmentInput {
			@location(1) fragUV : vec2<f32>,
			@location(2) fragColor : vec4<${e ? "f16" : "f32"}>,
			${t2 ? "@builtin(position) fragPos: vec4<f32>" : ""}
		};

		struct FragmentOutput {
			@location(0) color : vec4<f32>,
			${t2 ? "@builtin(frag_depth) fragDepth: f32" : ""} 
		};

		@fragment
		fn main(input : FragmentInput) -> FragmentOutput {
			var output : FragmentOutput;
			output.color = textureSample(texture0, sampler0, input.fragUV) * vec4<f32>(input.fragColor);
			${t2 ? "output.fragDepth = select(input.fragPos.z, 1.0, output.color.a == 0.0);" : ""}
			return output;
		}`;
    }
    static _GetMipmapGeneratorVertexSource() {
      return "\n		struct VertexInput {\n			@builtin(vertex_index) VertexIndex : u32\n		};\n		\n		struct VertexOutput {\n			@builtin(position) Position : vec4<f32>,\n			@location(0) fragUV : vec2<f32>\n		};\n\n		@vertex\n		fn main(input : VertexInput) -> VertexOutput {\n\n			var pos : array<vec2<f32>, 4> = array<vec2<f32>, 4>(\n				vec2<f32>(-1.0, 1.0),\n				vec2<f32>(1.0, 1.0),\n				vec2<f32>(-1.0, -1.0),\n				vec2<f32>(1.0, -1.0));\n			\n			var output : VertexOutput;\n			var p : vec2<f32> = pos[input.VertexIndex];\n			output.Position = vec4<f32>(p, 0.0, 1.0);\n			output.fragUV = p / 2.0 + 0.5;\n			return output;\n		}";
    }
    static _GetMipmapGeneratorFragmentSource() {
      return "\n		@binding(0) @group(0) var sampler0 : sampler;\n		@binding(1) @group(0) var texture0 : texture_2d<f32>;\n\n		struct FragmentInput {\n			@location(0) fragUV : vec2<f32>\n		};\n\n		struct FragmentOutput {\n			@location(0) color : vec4<f32>\n		};\n\n		@fragment\n		fn main(input : FragmentInput) -> FragmentOutput {\n			var output : FragmentOutput;\n			output.color = textureSample(texture0, sampler0, vec2<f32>(input.fragUV.x, 1.0 - input.fragUV.y));\n			return output;\n		}";
    }
    _GetMipmapGeneratorPipeline(t2) {
      t2 || (t2 = this._renderer.GetTextureFormat());
      let e = this._mipmapPipelineMap.get(t2);
      return e || (e = this._GetDevice()["createRenderPipeline"]({ "label": "<mipmap generator>", "layout": "auto", "vertex": { "module": this._vertexModule, "entryPoint": "main" }, "primitive": { "topology": "triangle-strip", "stripIndexFormat": "uint16" }, "fragment": { "module": this._fragmentModule, "entryPoint": "main", "targets": [{ "format": t2, "blend": { "color": { "srcFactor": "one", "dstFactor": "zero" }, "alpha": { "srcFactor": "one", "dstFactor": "zero" } } }] } }), this._mipmapPipelineMap.set(t2, e)), e;
    }
    static _GetPointVertexSource() {
      return `
		${vertexUniformBufferDeclaration}

		struct PointData {
			data : array<vec4<f32>>
		};
		@binding(3) @group(0) var<storage> pointBuffer : PointData;

		struct VertexInput {
			@builtin(vertex_index) VertexIndex : u32
		};

		struct VertexOutput {
			@builtin(position) Position : vec4<f32>,
			@location(0) fragUV : vec2<f32>,
			@location(1) pointOpacity : f32
		};

		@vertex
		fn main(input : VertexInput) -> VertexOutput {

			var normPos : array<vec2<f32>, 4> = array<vec2<f32>, 4>(
				vec2<f32>(-0.5, -0.5),
				vec2<f32>(0.5, -0.5),
				vec2<f32>(0.5, 0.5),
				vec2<f32>(-0.5, 0.5));
			
			var output : VertexOutput;
			var p : vec2<f32> = normPos[input.VertexIndex % u32(4)];
			var pointData : vec4<f32> = pointBuffer.data[input.VertexIndex / u32(4)];

			var size : f32 = pointData.z;
			output.Position = uniforms.transform * vec4<f32>(p * size + pointData.xy, uniforms.zElevation, 1.0);
			output.pointOpacity = pointData.w;

			var pointTexMin : vec2<f32> = min(uniforms.pointTexStart, uniforms.pointTexEnd);
			var pointTexMax : vec2<f32> = max(uniforms.pointTexStart, uniforms.pointTexEnd);
			var pn : vec2<f32> = p + vec2<f32>(0.5, 0.5);
			var pointCoord : vec2<f32> = select(vec2<f32>(1.0 - pn.y, pn.x), pn, uniforms.pointTexEnd.x > uniforms.pointTexStart.x);

			output.fragUV = mix(pointTexMin, pointTexMax, pointCoord);
			return output;
		}`;
    }
    static _GetPointFragmentSource(t2) {
      return `
		${fragmentUniformBufferDeclaration}

		%%SAMPLERFRONT_BINDING%% var sampler0 : sampler;
		%%TEXTUREFRONT_BINDING%% var texture0 : texture_2d<f32>;

		struct FragmentInput {
			@location(0) fragUV : vec2<f32>,
			@location(1) pointOpacity : f32,
			@builtin(position) fragPos : vec4<f32>
		};
		
		struct FragmentOutput {
			@location(0) color : vec4<f32>,
			${t2 ? "@builtin(frag_depth) fragDepth: f32" : ""} 
		};

		@fragment
		fn main(input : FragmentInput) -> FragmentOutput {
			var output : FragmentOutput;
			output.color = textureSample(texture0, sampler0, input.fragUV) * uniforms.pointColor * input.pointOpacity;
			${t2 ? "output.fragDepth = select(input.fragPos.z, 1.0, output.color.a == 0.0);" : ""}
			return output;
		}`;
    }
    static _GetTilemapFragmentShaderSource(t2) {
      return `
		${fragmentUniformBufferDeclaration}

		%%SAMPLERFRONT_BINDING%% var sampler0 : sampler;
		%%TEXTUREFRONT_BINDING%% var texture0 : texture_2d<f32>;

		%%FRAGMENTINPUT_STRUCT%%
		
		struct FragmentOutput {
			@location(0) color : vec4<f32>,
			${t2 ? "@builtin(frag_depth) fragDepth: f32" : ""} 
		};

		@fragment
		fn main(input : FragmentInput) -> FragmentOutput {
			var output : FragmentOutput;
			var halfPixelSize : vec2<f32> = vec2<f32>(0.5, 0.5) / vec2<f32>(textureDimensions(texture0));

			var tile : vec2<f32> = floor(input.fragUV);
			var tex : vec2<f32> = fract(input.fragUV);
			var tileOrigin : vec2<f32> = uniforms.srcRectStart + tile * (uniforms.tileSize + uniforms.tileSpacing);
			var lowerBound : vec2<f32> = tileOrigin + halfPixelSize;
			var upperBound : vec2<f32> = tileOrigin + uniforms.tileSize - halfPixelSize;

			output.color = textureSampleLevel(texture0, sampler0, clamp(tex, lowerBound, upperBound), 0.0) * vec4<f32>(input.fragColor);
			${t2 ? "output.fragDepth = select(input.fragPos.z, 1.0, output.color.a == 0.0);" : ""}
			return output;
		}`;
    }
    static GetTileRandomizationFragmentShaderSource(t2) {
      return `
${fragmentUniformBufferDeclaration}

%%SAMPLERFRONT_BINDING%% var sampler0 : sampler;
%%TEXTUREFRONT_BINDING%% var texture0 : texture_2d<f32>;

%%FRAGMENTINPUT_STRUCT%%

struct FragmentOutput {
	@location(0) color : vec4<f32>,
	${t2 ? "@builtin(frag_depth) fragDepth: f32" : ""} 
};

%%C3_UTILITY_FUNCTIONS%%

const PI : f32 = 3.1415926;

fn cospVec4(a : vec4<f32>, b : vec4<f32>, x : f32) -> vec4<f32>
{
	return (a + b + (a - b) * cos(x * PI)) / 2.0;
}

fn randVec3(seed : vec2<f32>) -> vec3<f32>
{
	return vec3<f32>(
		fract(sin(dot(seed.xy, vec2<f32>(12.9898,78.233))) * 43758.5453),
		fract(sin(dot(seed.yx, vec2<f32>(12.9898,-78.233))) * 43758.5453),
		fract(sin(dot(seed.xy, vec2<f32>(-12.9898,-78.233))) * 43758.5453));
}

fn sampleTile(tile : vec2<f32>, uv : vec2<f32>, ddx : vec2<f32>, ddy : vec2<f32>) -> vec4<f32>
{
	var posRandom = uniforms.tileSize;
	var angleRandom = uniforms.outlineThickness;
	var pixelSize = c3_getPixelSize(texture0);
	
	var rand = (randVec3(round(tile)) - 0.5) * 2.0;
	
	var angle = angleRandom * rand.z * PI;
	var sin_a = sin(angle);
	var cos_a = cos(angle);
	var aspect = pixelSize.x / pixelSize.y;

	var mid = tile + vec2<f32>(0.5, 0.5);
	var dp = uv - mid;
	dp.x /= aspect;
	var r = vec2<f32>(dp.x * cos_a - dp.y * sin_a,
					  dp.y * cos_a + dp.x * sin_a);
	r.x *= aspect;

	var p = mid + r + (posRandom * rand.xy / 2.0);
	
	return textureSampleGrad(texture0, sampler0, p, ddx, ddy);
}

@fragment
fn main(input : FragmentInput) -> FragmentOutput
{
	var output : FragmentOutput;
	
	var blendMarginX = uniforms.tileSpacing.x;
	var blendMarginY = uniforms.tileSpacing.y;
	
	var tile = floor(input.fragUV);
	var tex = fract(input.fragUV);
	var ddx = dpdx(input.fragUV);
	var ddy = dpdy(input.fragUV);
	
	var curTile = sampleTile(tile, input.fragUV, ddx, ddy);
	
	var inLeftMargin = (tex.x < blendMarginX);
	var inRightMargin = (tex.x > 1.0 - blendMarginX);
	var inTopMargin = (tex.y < blendMarginY);
	var inBottomMargin = (tex.y > 1.0 - blendMarginY);
	
	if (inLeftMargin)
	{
		var leftTile = sampleTile(tile + vec2<f32>(-1.0, 0.0), input.fragUV, ddx, ddy);
		var leftMix = (tex.x / (blendMarginX * 2.0)) + 0.5;
		var leftMixedTile = cospVec4(leftTile, curTile, leftMix);
		
		if (inTopMargin)
		{
			var topTile =     sampleTile(tile + vec2<f32>(0.0,  -1.0), input.fragUV, ddx, ddy);
			var topLeftTile = sampleTile(tile + vec2<f32>(-1.0, -1.0), input.fragUV, ddx, ddy);
			var topLeftMixedTile = cospVec4(topLeftTile, topTile, leftMix);
			
			output.color = cospVec4(topLeftMixedTile, leftMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);
		}
		else if (inBottomMargin)
		{
			var bottomTile =     sampleTile(tile + vec2<f32>(0.0,  1.0), input.fragUV, ddx, ddy);
			var bottomLeftTile = sampleTile(tile + vec2<f32>(-1.0, 1.0), input.fragUV, ddx, ddy);
			var bottomLeftMixedTile = cospVec4(bottomLeftTile, bottomTile, leftMix);
			
			output.color = cospVec4(leftMixedTile, bottomLeftMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));
		}
		else
		{
			output.color = leftMixedTile;
		}
	}
	else if (inRightMargin)
	{
		var rightTile = sampleTile(tile + vec2(1.0, 0.0), input.fragUV, ddx, ddy);
		var rightMix = (tex.x - (1.0 - blendMarginX)) / (blendMarginX * 2.0);
		var rightMixedTile = cospVec4(curTile, rightTile, rightMix);
		
		if (inTopMargin)
		{
			var topTile =      sampleTile(tile + vec2<f32>(0.0, -1.0), input.fragUV, ddx, ddy);
			var topRightTile = sampleTile(tile + vec2<f32>(1.0, -1.0), input.fragUV, ddx, ddy);
			var topRightMixedTile = cospVec4(topTile, topRightTile, rightMix);
			
			output.color = cospVec4(topRightMixedTile, rightMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);
		}
		else if (inBottomMargin)
		{
			var bottomTile =      sampleTile(tile + vec2<f32>(0.0, 1.0), input.fragUV, ddx, ddy);
			var bottomRightTile = sampleTile(tile + vec2<f32>(1.0, 1.0), input.fragUV, ddx, ddy);
			var bottomRightMixedTile = cospVec4(bottomTile, bottomRightTile, rightMix);
			
			output.color = cospVec4(rightMixedTile, bottomRightMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));
		}
		else
		{
			output.color = rightMixedTile;
		}
	}
	else if (inTopMargin)
	{
		var topTile = sampleTile(tile + vec2<f32>(0.0, -1.0), input.fragUV, ddx, ddy);
		output.color = cospVec4(topTile, curTile, (tex.y / (blendMarginY * 2.0)) + 0.5);
	}
	else if (inBottomMargin)
	{
		var bottomTile = sampleTile(tile + vec2<f32>(0.0, 1.0), input.fragUV, ddx, ddy);
		output.color = cospVec4(curTile, bottomTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));
	}
	else
	{
		output.color = curTile;
	}
	
	output.color *= vec4<f32>(input.fragColor);
	${t2 ? "output.fragDepth = select(input.fragPos.z, 1.0, output.color.a == 0.0);" : ""}
	return output;
}
`;
    }
    static _GetColorFillFragmentShaderSource() {
      return "\n		%%FRAGMENTINPUT_STRUCT%%\n		%%FRAGMENTOUTPUT_STRUCT%%\n\n		@fragment\n		fn main(input : FragmentInput) -> FragmentOutput {\n			var output : FragmentOutput;\n			output.color = vec4<f32>(input.fragColor);\n			return output;\n		}";
    }
    static _GetLinearGradientFillFragmentShaderSource() {
      return `
		${fragmentUniformBufferDeclaration}

		%%FRAGMENTINPUT_STRUCT%%
		%%FRAGMENTOUTPUT_STRUCT%%

		fn fromLinear(linearRGB : vec3<f32>) -> vec3<f32>
		{
			var cutoff : vec3<bool> = (linearRGB < vec3<f32>(0.0031308));
			var higher : vec3<f32> = vec3<f32>(1.055) * pow(abs(linearRGB), vec3<f32>(1.0/2.4)) - 0.055;
			var lower : vec3<f32> = linearRGB * 12.92;
			return select(higher, lower, cutoff);
		}

		fn toLinear(sRGB : vec3<f32>) -> vec3<f32>
		{
			var cutoff : vec3<bool> = (sRGB < vec3<f32>(0.04045));
			var higher : vec3<f32> = pow(abs((sRGB + 0.055) / 1.055), vec3<f32>(2.4));
			var lower : vec3<f32> = sRGB / 12.92;
			return select(higher, lower, cutoff);
		}

		@fragment
		fn main(input : FragmentInput) -> FragmentOutput {
			var output : FragmentOutput;
			var linearGrad : vec3<f32> = mix(toLinear(vec3<f32>(input.fragColor.rgb)), toLinear(uniforms.color2.rgb), vec3<f32>(input.fragUV.x));

			var a : f32 = mix(f32(input.fragColor.a), uniforms.color2.a, input.fragUV.x);
			output.color = vec4<f32>(fromLinear(linearGrad) * a, a);
			return output;
		}
		`;
    }
    static _GetPenumbraFillFragmentShaderSource() {
      return `
		${fragmentUniformBufferDeclaration}

		%%FRAGMENTINPUT_STRUCT%%
		%%FRAGMENTOUTPUT_STRUCT%%

		@fragment
		fn main(input : FragmentInput) -> FragmentOutput {
			var output : FragmentOutput;
			var grad : f32 = input.fragUV.x / (1.0 - input.fragUV.y);
			output.color = vec4<f32>(input.fragColor) * (1.0 - (cos(grad * 3.141592653589793) + 1.0) / 2.0);
			return output;
		}
		`;
    }
    static _GetHardEllipseFillFragmentShaderSource() {
      return "\n		%%FRAGMENTINPUT_STRUCT%%\n		%%FRAGMENTOUTPUT_STRUCT%%\n\n		@fragment\n		fn main(input : FragmentInput) -> FragmentOutput {\n			var output : FragmentOutput;\n			var diff : vec2<f32> = input.fragUV - 0.5;\n			var diffSq : vec2<f32> = diff * diff;\n\n			var f : f32 = step(diffSq.x + diffSq.y, 0.25);\n\n			output.color = vec4<f32>(input.fragColor) * f;\n			return output;\n		}";
    }
    static _GetHardEllipseOutlineFragmentShaderSource() {
      return `
		${fragmentUniformBufferDeclaration}

		%%FRAGMENTINPUT_STRUCT%%
		%%FRAGMENTOUTPUT_STRUCT%%

		@fragment
		fn main(input : FragmentInput) -> FragmentOutput {
			var output : FragmentOutput;
			var diff : vec2<f32> = input.fragUV - 0.5;
			var diffSq : vec2<f32> = diff * diff;
			var distSq : f32 = diffSq.x + diffSq.y;
			var norm : vec2<f32> = normalize(diff);
			var halfNorm : vec2<f32> = norm * 0.5;

			var innerF : f32 = step(distSq, 0.25);

			var innerEdge : vec2<f32> = halfNorm - uniforms.pixelSize * norm * uniforms.outlineThickness;
			var innerEdgeSq : vec2<f32> = innerEdge * innerEdge;
			var outerF : f32 = step(innerEdgeSq.x + innerEdgeSq.y, distSq);
			
			output.color = vec4<f32>(input.fragColor) * innerF * outerF;
			return output;
		}`;
    }
    static _GetSmoothEllipseFillFragmentShaderSource() {
      return `
		${fragmentUniformBufferDeclaration}

		%%FRAGMENTINPUT_STRUCT%%
		%%FRAGMENTOUTPUT_STRUCT%%

		@fragment
		fn main(input : FragmentInput) -> FragmentOutput {
			var output : FragmentOutput;
			var diff : vec2<f32> = input.fragUV - 0.5;
			var diffSq : vec2<f32> = diff * diff;
			var norm : vec2<f32> = normalize(diff);
			var halfNorm : vec2<f32> = norm * 0.5;
			var halfNormSq : vec2<f32> = halfNorm * halfNorm;

			var innerEdge : vec2<f32> = halfNorm - uniforms.pixelSize * norm;
			var innerEdgeSq : vec2<f32> = innerEdge * innerEdge;

			var f : f32 = smoothstep(halfNormSq.x + halfNormSq.y, innerEdgeSq.x + innerEdgeSq.y, diffSq.x + diffSq.y);

			output.color = vec4<f32>(input.fragColor) * f;
			return output;
		}`;
    }
    static _GetSmoothEllipseOutlineFragmentShaderSource() {
      return `
		${fragmentUniformBufferDeclaration}

		%%FRAGMENTINPUT_STRUCT%%
		%%FRAGMENTOUTPUT_STRUCT%%

		@fragment
		fn main(input : FragmentInput) -> FragmentOutput {
			var output : FragmentOutput;
			var diff : vec2<f32> = input.fragUV - 0.5;
			var diffSq : vec2<f32> = diff * diff;
			var distSq : f32 = diffSq.x + diffSq.y;
			var norm : vec2<f32> = normalize(diff);
			var halfNorm : vec2<f32> = norm * 0.5;
			var halfNormSq : vec2<f32> = halfNorm * halfNorm;

			var pxNorm : vec2<f32> = uniforms.pixelSize * norm;
			var innerEdge1 : vec2<f32> = halfNorm - pxNorm;
			var innerEdge1Sq : vec2<f32> = innerEdge1 * innerEdge1;

			var innerF : f32 = smoothstep(halfNormSq.x + halfNormSq.y, innerEdge1Sq.x + innerEdge1Sq.y, distSq);

			var innerEdge2 : vec2<f32> = halfNorm - pxNorm * uniforms.outlineThickness;
			var innerEdge2Sq : vec2<f32> = innerEdge2 * innerEdge2;
			var innerEdge3 : vec2<f32> = halfNorm - pxNorm * (uniforms.outlineThickness + 1.0);
			var innerEdge3Sq : vec2<f32> = innerEdge3 * innerEdge3;

			var outerF : f32 = smoothstep(innerEdge3Sq.x + innerEdge3Sq.y, innerEdge2Sq.x + innerEdge2Sq.y, distSq);
			
			output.color = vec4<f32>(input.fragColor) * innerF * outerF;
			return output;
		}`;
    }
    static _GetSmoothLineFillFragmentShaderSource() {
      return "\n		%%FRAGMENTINPUT_STRUCT%%\n		%%FRAGMENTOUTPUT_STRUCT%%\n\n		@fragment\n		fn main(input : FragmentInput) -> FragmentOutput {\n			var output : FragmentOutput;\n			var f : f32 = 1.0 - abs(input.fragUV.y - 0.5) * 2.0;\n			output.color = vec4<f32>(input.fragColor) * f;\n			return output;\n		}";
    }
  };
}
var UpdateLayoutEndValues2;
var makeNullFilledArray2;
var GetFragmentInputStructDeclaration2;
var HashPipelineState2;
{
  const C32 = self.C3, VALID_SAMPLINGS = /* @__PURE__ */ new Set(["nearest", "bilinear", "trilinear"]), VALID_WRAP_MODES = /* @__PURE__ */ new Set(["clamp-to-edge", "repeat", "mirror-repeat"]), GPUTextureUsage = self["GPUTextureUsage"], DEFAULT_CREATE_OPTIONS = { wrapX: "clamp-to-edge", wrapY: "clamp-to-edge", sampling: "trilinear", anisotropy: 0, mipMap: true, isRenderTarget: false, isSampled: false, canReadPixels: false, canUpdate: false, multisampling: 0, width: -1, height: -1 }, TEXTURE_FORMAT_SIZE_DATA = [[1, ["r8unorm", "r8snorm", "r8uint", "r8sint", "stencil8"]], [2, ["r16uint", "r16sint", "r16float", "rg8unorm", "rg8snorm", "rg8uint", "rg8sint", "depth16unorm"]], [3, ["depth24plus"]], [4, ["r32uint", "r32sint", "r32float", "rg16uint", "rg16sint", "rg16float", "rgba8unorm", "rgba8unorm-srgb", "rgba8snorm", "rgba8uint", "rgba8sint", "bgra8unorm", "bgra8unorm-srgb", "rgb9e5ufloat", "rgb10a2uint", "rgb10a2unorm", "rg11b10ufloat", "depth24plus-stencil8", "depth32float"]], [8, ["rg32uint", "rg32sint", "rg32float", "rgba16uint", "rgba16sint", "rgba16float"]], [16, ["rgba32uint", "rgba32sint", "rgba32float"]], [5, ["depth32float-stencil8"]]], TEXTURE_FORMAT_SIZE_MAP = /* @__PURE__ */ new Map();
  for (const [e, t2] of TEXTURE_FORMAT_SIZE_DATA) for (const r2 of t2) TEXTURE_FORMAT_SIZE_MAP.set(r2, e);
  const allTextures = /* @__PURE__ */ new Set(), UPDATE_DEFAULT_OPTIONS = { premultiplyAlpha: true, flipY: false };
  C32.Gfx.WebGPURendererTexture = class {
    constructor(e, t2) {
      this._renderer = e, this._texture = null, this._format = "", this._textureView = null, this._sampler = null, this._ownTextureBindGroup = null, this._backTextureBindGroup = null, this._width = 0, this._height = 0, this._isStatic = true, this._wrapX = "clamp-to-edge", this._wrapY = "clamp-to-edge", this._sampling = "trilinear", this._anisotropy = 0, this._isMipMapped = false, this._refCount = 0, this._isRenderTarget = false, this._isSampled = false, this._canReadPixels = false, this._canUpdate = false, this._multisampling = 0, this._usage = 0, this._multiTextureEnabled = true, this._multiTextureGroup = null, this._multiTextureIndex = 0, this._isForBackbuffer = !!t2, this._isForBackbuffer && (this._format = this._renderer.GetSwapChainFormat(), this._isRenderTarget = true, this._isSampled = this._renderer._CanSampleBackbuffer(), this._sampling = this._renderer._GetBackTextureSampling(), this._sampler = this._renderer._GetSampler({ sampling: this._sampling }));
    }
    _InitFromOpts(e) {
      if (this._wrapX = e.wrapX, this._wrapY = e.wrapY, this._sampling = e.sampling, this._anisotropy = e.anisotropy, this._isMipMapped = !!e.mipMap && this._renderer.AreMipmapsEnabled() && "nearest" !== e.sampling, this._isRenderTarget = !!e.isRenderTarget, this._isSampled = !!e.isSampled, this._canReadPixels = !!e.canReadPixels, this._canUpdate = !!e.canUpdate, this._multisampling = this._renderer._ClampToSupportedMultisampleValues(e.multisampling), !VALID_SAMPLINGS.has(this._sampling)) throw new Error("invalid sampling");
      if (!VALID_WRAP_MODES.has(this._wrapX) || !VALID_WRAP_MODES.has(this._wrapY)) throw new Error("invalid wrap mode");
      if (this._multisampling >= 2 && this._isSampled) throw new Error("invalid use of multisampling");
      "nearest" === this._sampling && (this._anisotropy = 0), this._sampler = this._renderer._GetSampler({ wrapX: this._wrapX, wrapY: this._wrapY, sampling: this._sampling, anisotropy: this._anisotropy }), this._CreateGPUResources(), this._refCount = 1;
    }
    _CreateGPUResources() {
      const e = this._renderer, t2 = e._GetDevice();
      this._usage = 0, this._isRenderTarget ? (this._usage = GPUTextureUsage["RENDER_ATTACHMENT"], this._isSampled && (this._usage |= GPUTextureUsage["TEXTURE_BINDING"]), this._canUpdate && (this._usage |= GPUTextureUsage["COPY_DST"]), this._format = this._renderer.GetSwapChainFormat()) : (this._usage = GPUTextureUsage["COPY_DST"] | GPUTextureUsage["TEXTURE_BINDING"], this._format = this._renderer.GetTextureFormat()), this._canReadPixels && (this._usage |= GPUTextureUsage["COPY_SRC"]), this._texture = t2["createTexture"]({ "size": [this._width, this._height, 1], "mipLevelCount": this._GetMipLevelCount(), "format": this._format, "usage": this._usage, "sampleCount": this._multisampling >= 2 ? this._multisampling : 1 }), this._textureView = this._texture["createView"]();
      const r2 = [], i = C32.Gfx.WebGPUMultiTextureGroup.GetMultiTextureLimit();
      for (let e2 = 0; e2 < i; ++e2) r2.push({ "binding": 2 * e2, "resource": this._sampler }, { "binding": 2 * e2 + 1, "resource": this._textureView });
      this._isRenderTarget && !this._isSampled || (this._ownTextureBindGroup = t2["createBindGroup"]({ "layout": e._GetTextureBindGroupLayout(), "entries": r2 }), this._backTextureBindGroup = t2["createBindGroup"]({ "layout": e._GetBackTextureBindGroupLayout(), "entries": [{ "binding": 0, "resource": this._renderer._GetSampler({ sampling: this._renderer._GetBackTextureSampling() }) }, { "binding": 1, "resource": this._textureView }] })), this._CanMultiTexture() && this._SetMultiTextureAvailable(true), allTextures.add(this);
    }
    _DeleteGPUResources() {
      allTextures.delete(this), this._multiTextureGroup && this._multiTextureGroup.Release(), this._SetMultiTextureAvailable(false), this._texture["destroy"](), this._texture = null, this._textureView = null, this._ownTextureBindGroup = null, this._backTextureBindGroup = null;
    }
    static IsGPUImageCopyExternalImageSource(e) {
      return e instanceof ImageBitmap || "undefined" != typeof HTMLVideoElement && e instanceof HTMLVideoElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof OffscreenCanvas && e instanceof OffscreenCanvas;
    }
    static IsCreateImageBitmapDataSource(e) {
      return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || e instanceof ImageData;
    }
    _GetDataSize(e) {
      return [e.width || e.videoWidth, e.height || e.videoHeight];
    }
    _Create(e, t2) {
      if (e && !C32.Gfx.WebGPURendererTexture.IsGPUImageCopyExternalImageSource(e)) throw new TypeError("invalid texture source");
      if (t2 = Object.assign({}, DEFAULT_CREATE_OPTIONS, t2), this._texture) throw new Error("already created texture");
      if (this._isStatic = true, e) {
        const [t3, r2] = this._GetDataSize(e);
        this._width = t3, this._height = r2;
      } else if (this._width = t2.width, this._height = t2.height, this._width <= 0 || this._height <= 0) throw new Error("invalid texture size");
      if (this._InitFromOpts(t2), this._isRenderTarget || this._isSampled) throw new Error("static texture cannot be render target");
      e && this._UploadImage(e);
    }
    _UploadImage(e, t2 = true) {
      if (this._isMipMapped) this._GenerateMipmaps(e, this._GetMipLevelCount(), t2);
      else {
        const r2 = this._renderer._GetDevice(), i = r2["createCommandEncoder"](), s = r2["createTexture"]({ "size": [this._width, this._height, 1], "mipLevelCount": 1, "format": this._format, "usage": GPUTextureUsage["COPY_SRC"] | GPUTextureUsage["COPY_DST"] | GPUTextureUsage["RENDER_ATTACHMENT"] });
        this._CopyImageToMipLevel(s, e, 0, t2), i["copyTextureToTexture"]({ "texture": s, "mipLevel": 0 }, { "texture": this._texture, "mipLevel": 0 }, [this._width, this._height, 1]), r2["queue"]["submit"]([i["finish"]()]), s["destroy"]();
      }
    }
    _CopyImageToMipLevel(e, t2, r2, i = true) {
      const [s, a2] = this._GetDataSize(t2);
      this._renderer._GetDevice()["queue"]["copyExternalImageToTexture"]({ "source": t2 }, { "texture": e, "mipLevel": r2, "premultipliedAlpha": !!i }, [s, a2, 1]);
    }
    _GetMipLevelCount() {
      return this._isMipMapped ? Math.floor(Math.log2(Math.max(this._width, this._height)) + 1) : 1;
    }
    _GenerateMipmaps(e, t2, r2 = true) {
      const i = this._renderer._GetDevice(), s = i["createTexture"]({ "size": [this._width, this._height, 1], "mipLevelCount": this._GetMipLevelCount(), "format": this._format, "usage": GPUTextureUsage["COPY_DST"] | GPUTextureUsage["COPY_SRC"] | GPUTextureUsage["TEXTURE_BINDING"] | GPUTextureUsage["RENDER_ATTACHMENT"] }), a2 = this._renderer._GetMipmapGeneratorPipeline(), n = a2["getBindGroupLayout"](0), u2 = this._renderer._GetSampler({ sampling: "bilinear" }), h2 = i["createCommandEncoder"]();
      this._CopyImageToMipLevel(s, e, 0, r2), h2["copyTextureToTexture"]({ "texture": s, "mipLevel": 0 }, { "texture": this._texture, "mipLevel": 0 }, [this._width, this._height, 1]);
      const _2 = [];
      for (let e2 = 0; e2 < t2; ++e2) _2.push(s["createView"]({ "baseMipLevel": e2, "mipLevelCount": 1 }));
      let l = this._width, o2 = this._height;
      for (let e2 = 1; e2 < t2; ++e2) {
        l /= 2, o2 /= 2;
        const t3 = Math.max(Math.floor(l), 1), r3 = Math.max(Math.floor(o2), 1), p2 = h2["beginRenderPass"]({ "colorAttachments": [{ "view": _2[e2], "loadOp": "clear", "clearValue": [0, 0, 0, 0], "storeOp": "store" }] }), d2 = i["createBindGroup"]({ "layout": n, "entries": [{ "binding": 0, "resource": u2 }, { "binding": 1, "resource": _2[e2 - 1] }] });
        p2["setPipeline"](a2), p2["setBindGroup"](0, d2), p2["draw"](4), p2["end"](), h2["copyTextureToTexture"]({ "texture": s, "mipLevel": e2 }, { "texture": this._texture, "mipLevel": e2 }, [t3, r3, 1]);
      }
      i["queue"]["submit"]([h2["finish"]()]), s["destroy"]();
    }
    _CreateDynamic(e, t2, r2) {
      if (r2 = Object.assign({}, DEFAULT_CREATE_OPTIONS, r2), this._texture) throw new Error("already created texture");
      this._isStatic = false, this._width = e, this._height = t2, this._InitFromOpts(r2);
    }
    async _Update(e, t2) {
      if (!C32.Gfx.WebGPURendererTexture.IsGPUImageCopyExternalImageSource(e) && !C32.Gfx.WebGPURendererTexture.IsCreateImageBitmapDataSource(e)) throw new Error("invalid texture source");
      if (!this._texture || this._refCount <= 0) throw new Error("texture not created");
      if (this._isStatic) throw new Error("cannot update static texture");
      if (t2 = Object.assign({}, UPDATE_DEFAULT_OPTIONS, t2), (C32.Gfx.WebGPURendererTexture.IsCreateImageBitmapDataSource(e) || t2.flipY || !t2.premultiplyAlpha) && (e = await createImageBitmap(e, { "premultiplyAlpha": t2.premultiplyAlpha ? "premultiply" : "none", "imageOrientation": t2.flipY ? "flipY" : "none" }), !this._texture)) return;
      this._renderer.EndBatch();
      const [r2, i] = this._GetDataSize(e);
      this._width === r2 && this._height === i || (this._DeleteGPUResources(), this._width = r2, this._height = i, this._CreateGPUResources(), this._renderer._OnTextureBindGroupChanged(this)), this._UploadImage(e, t2.premultiplyAlpha);
    }
    _Delete() {
      if (this._refCount > 0) throw new Error("texture still has references");
      if (!this._texture) throw new Error("already deleted texture");
      this._DeleteGPUResources();
    }
    _DisableMultiTexture() {
      this._multiTextureEnabled = false, this._SetMultiTextureAvailable(false);
    }
    _CanMultiTexture() {
      return this._isStatic && this._multiTextureEnabled && !this._isRenderTarget;
    }
    _SetMultiTextureAvailable(e) {
      this._renderer._SetMultiTextureAvailable(this, e);
    }
    _SetMultiTextureGroup(e, t2) {
      if (this._multiTextureGroup) throw new Error("already in a group");
      this._multiTextureGroup = e, this._multiTextureIndex = t2, this._SetMultiTextureAvailable(false);
    }
    _ClearMultiTextureGroup() {
      this._multiTextureGroup = null, this._multiTextureIndex = 0, this._CanMultiTexture() && this._SetMultiTextureAvailable(true);
    }
    _GetOwnTextureBindGroup() {
      return this._ownTextureBindGroup;
    }
    _GetBackTextureBindGroup() {
      return this._backTextureBindGroup;
    }
    _GetMultiTextureBindGroup() {
      return null !== this._multiTextureGroup ? this._multiTextureGroup._GetBindGroup() : this._CanMultiTexture() ? (this._renderer._TryCreateMultiTextureGroup(this), null !== this._multiTextureGroup ? this._multiTextureGroup._GetBindGroup() : null) : null;
    }
    _GetMultiTextureIndex() {
      return this._multiTextureIndex;
    }
    GetWidth() {
      return this._isForBackbuffer ? this._renderer.GetWidth() : this._width;
    }
    GetHeight() {
      return this._isForBackbuffer ? this._renderer.GetHeight() : this._height;
    }
    GetRenderer() {
      return this._renderer;
    }
    _GetTexture() {
      return this._texture;
    }
    _GetTextureView() {
      return this._textureView;
    }
    _GetFormat() {
      return this._format;
    }
    _GetSampler() {
      return this._sampler;
    }
    GetSampling() {
      return this._sampling;
    }
    IsLinearSampling() {
      return "nearest" !== this._sampling;
    }
    IsRenderTarget() {
      return this._isRenderTarget;
    }
    IsSampled() {
      return this._isSampled;
    }
    CanReadPixels() {
      return this._canReadPixels;
    }
    AddReference() {
      this._refCount++;
    }
    SubtractReference() {
      if (this._refCount <= 0) throw new Error("no more references");
      this._refCount--;
    }
    GetReferenceCount() {
      return this._refCount;
    }
    _GetUsage() {
      return this._usage;
    }
    _BackbufferTextureSetProperties(e, t2) {
      this._usage = e, this._format = t2;
    }
    _BackbufferTextureStartFrame() {
      const e = this._renderer, t2 = e._GetDevice();
      this._texture = e._GetSwapChainTexture(), this._textureView = e._GetSwapChainTexView(), e._CanSampleBackbuffer() && (this._backTextureBindGroup = t2["createBindGroup"]({ "layout": e._GetBackTextureBindGroupLayout(), "entries": [{ "binding": 0, "resource": this._sampler }, { "binding": 1, "resource": this._textureView }] }));
    }
    _BackbufferTextureEndFrame() {
      this._texture = null, this._textureView = null, this._backTextureBindGroup = null;
    }
    GetEstimatedMemoryUsage() {
      let e = this.GetWidth() * this.GetHeight() * C32.Gfx.WebGPURendererTexture.GetFormatByteSize(this._GetFormat());
      return this._isMipMapped && (e += Math.floor(e / 3)), e;
    }
    static OnContextLost() {
    }
    static allTextures() {
      return allTextures.values();
    }
    static GetFormatByteSize(e) {
      const t2 = TEXTURE_FORMAT_SIZE_MAP.get(e);
      return "number" == typeof t2 ? t2 : NaN;
    }
  };
}
{
  const C32 = self.C3;
  C32.Gfx.WebGPUMultiTextureGroup = class {
    constructor(e, t2) {
      if (t2.length < 2) throw new Error("invalid multi-texture group");
      this._renderer = e, this._textures = t2, this._multiTextureBindGroup = null;
      for (let e2 = 0, r2 = t2.length; e2 < r2; ++e2) t2[e2]._SetMultiTextureGroup(this, e2);
      t2.length < C32.Gfx.WebGPUMultiTextureGroup.GetMultiTextureLimit() && this._renderer._SetMultiTextureGroupNonFull(this, true), this._CreateBindGroup();
    }
    Release() {
      this._renderer._SetMultiTextureGroupNonFull(this, false);
      for (const e of this._textures) e._ClearMultiTextureGroup();
      this._DeleteBindGroup(), C32.clearArray(this._textures), this._renderer = null;
    }
    _CreateBindGroup() {
      this._DeleteBindGroup();
      const e = this._renderer._GetDevice(), t2 = [], r2 = C32.Gfx.WebGPUMultiTextureGroup.GetMultiTextureLimit();
      for (let e2 = 0; e2 < r2; ++e2) {
        const r3 = this._textures[Math.min(e2, this._textures.length - 1)];
        t2.push({ "binding": 2 * e2, "resource": r3._GetSampler() }, { "binding": 2 * e2 + 1, "resource": r3._GetTextureView() });
      }
      this._multiTextureBindGroup = e["createBindGroup"]({ "layout": this._renderer._GetTextureBindGroupLayout(), "entries": t2 });
    }
    _DeleteBindGroup() {
      null !== this._multiTextureBindGroup && this._renderer._OnMultiTextureBindGroupReleased(this._multiTextureBindGroup), this._multiTextureBindGroup = null;
    }
    _GetBindGroup() {
      return this._multiTextureBindGroup;
    }
    static GetMultiTextureLimit() {
      return 14;
    }
  };
}
{
  const C32 = self.C3, glMatrix = self.glMatrix, vec3 = glMatrix.vec3, mat4 = glMatrix.mat4, DEFAULT_RENDERTARGET_OPTIONS = { sampling: "trilinear", alpha: true, depth: false, isSampled: true, canReadPixels: false, canUpdate: false, isDefaultSize: true, multisampling: 0 }, allRenderTargets = /* @__PURE__ */ new Set();
  C32.Gfx.WebGPURenderTarget = class {
    constructor(e, t2) {
      this._renderer = e, this._isBackBuffer = !!t2, this._depth = !!t2 && e.UsesDepthBuffer(), this._rendererTexture = null, this._isDefaultSize = true, this._multisampling = 0, this._isAwaitingClear = false, this._clearColor = C32.New(C32.Color), this._projectionMatrix = mat4.create(), this._lastFov = 0, this._lastNearZ = 0, this._lastFarZ = 0, this._isBackBuffer && (this._rendererTexture = C32.New(C32.Gfx.WebGPURendererTexture, e, true));
    }
    _Create(e, t2, r2) {
      if (r2 = Object.assign({}, DEFAULT_RENDERTARGET_OPTIONS, r2), this._rendererTexture) throw new Error("already created render target");
      if (this._depth = !!r2.depth, this._isDefaultSize = !!r2.isDefaultSize, this._multisampling = this._renderer._ClampToSupportedMultisampleValues(r2.multisampling), this._multisampling >= 2 && r2.isSampled) throw new Error("invalid use of multisampling");
      this._rendererTexture = this._renderer.CreateDynamicTexture(e, t2, { sampling: r2.sampling, mipMap: false, isRenderTarget: true, isSampled: r2.isSampled, canReadPixels: r2.canReadPixels, canUpdate: r2.canUpdate, multisampling: this._multisampling }), this._CalculateProjection(), allRenderTargets.add(this);
    }
    _Delete() {
      allRenderTargets.delete(this), this._rendererTexture._DeleteGPUResources(), this._rendererTexture = null, this._renderer = null;
    }
    _Resize(e, t2) {
      if (e === this.GetWidth() && t2 === this.GetHeight()) return;
      const r2 = this._rendererTexture.GetSampling(), i = this._rendererTexture.IsSampled(), s = this._rendererTexture.CanReadPixels();
      this._rendererTexture._DeleteGPUResources(), this._rendererTexture = null, this._rendererTexture = this._renderer.CreateDynamicTexture(e, t2, { sampling: r2, mipMap: false, isRenderTarget: true, isSampled: i, canReadPixels: s }), this._CalculateProjection();
    }
    _GetTextureView() {
      return this._isBackBuffer ? this._renderer._GetSwapChainTexView() : this._rendererTexture._GetTextureView();
    }
    _CalculateProjection() {
      this._renderer.CalculatePerspectiveMatrix(this._projectionMatrix, this.GetWidth() / this.GetHeight()), this._lastFov = this._renderer.GetFovY(), this._lastNearZ = this._renderer.GetNearZ(), this._lastFarZ = this._renderer.GetFarZ();
    }
    IsDefaultSize() {
      return this._isDefaultSize;
    }
    IsBackBuffer() {
      return this._isBackBuffer;
    }
    HasDepthBuffer() {
      return this._depth;
    }
    GetWidth() {
      return this._isBackBuffer ? this._renderer.GetWidth() : this._rendererTexture.GetWidth();
    }
    GetHeight() {
      return this._isBackBuffer ? this._renderer.GetHeight() : this._rendererTexture.GetHeight();
    }
    GetTexture() {
      if (this._rendererTexture) return this._rendererTexture;
      throw new Error("no texture");
    }
    GetRenderer() {
      return this._renderer;
    }
    GetMultisampling() {
      return this._multisampling;
    }
    GetProjectionMatrix() {
      return this._renderer.GetFovY() === this._lastFov && this._renderer.GetNearZ() === this._lastNearZ && this._renderer.GetFarZ() === this._lastFarZ || this._CalculateProjection(), this._projectionMatrix;
    }
    IsLinearSampling() {
      return this._rendererTexture.IsLinearSampling();
    }
    IsSampled() {
      return this._rendererTexture.IsSampled();
    }
    CanReadPixels() {
      return this._rendererTexture.CanReadPixels();
    }
    IsCompatibleWithOptions(e) {
      return "nearest" !== (e = Object.assign({}, DEFAULT_RENDERTARGET_OPTIONS, e)).sampling === this.IsLinearSampling() && (!!e.isSampled === this.IsSampled() && (!!e.canReadPixels === this.CanReadPixels() && (!!e.depth === this.HasDepthBuffer() && ("number" == typeof e.width || "number" == typeof e.height ? !this.IsDefaultSize() && this.GetWidth() === Math.floor(e.width) && this.GetHeight() === Math.floor(e.height) : this.IsDefaultSize()))));
    }
    _SetIsAwaitingClear(e) {
      this._isAwaitingClear = !!e;
    }
    _IsAwaitingClear() {
      return this._isAwaitingClear;
    }
    _GetClearColor() {
      return this._clearColor;
    }
    static OnContextLost() {
    }
    static allRenderTargets() {
      return allRenderTargets.values();
    }
  };
}
{
  const C32 = self.C3;
  C32.Gfx.WebGPUTimeQuerySet = class {
    constructor(e, t2) {
      this._renderer = e, this._frameNumber = this._renderer.GetFrameNumber(), this._queryCount = t2;
      const r2 = this._renderer._GetDevice();
      this._querySet = r2["createQuerySet"]({ "count": this._queryCount, "type": "timestamp" });
      const s = self["GPUBufferUsage"];
      this._resolveBuffer = r2["createBuffer"]({ "size": this._GetBufferSize(), "usage": s["QUERY_RESOLVE"] | s["COPY_SRC"] }), this._readbackBuffer = r2["createBuffer"]({ "size": this._GetBufferSize(), "usage": s["COPY_DST"] | s["MAP_READ"] }), this._result = null;
    }
    _GetBufferSize() {
      return 8 * this._queryCount;
    }
    _GetQuerySet() {
      return this._querySet;
    }
    Resolve(e) {
      e["resolveQuerySet"](this._querySet, 0, this._queryCount, this._resolveBuffer, 0), e["copyBufferToBuffer"](this._resolveBuffer, 0, this._readbackBuffer, 0, this._GetBufferSize());
    }
    async ReadResult() {
      const e = this._GetBufferSize();
      await this._readbackBuffer["mapAsync"](self["GPUMapMode"]["READ"], 0, e);
      const t2 = this._readbackBuffer["getMappedRange"](0, e);
      this._result = new BigUint64Array(t2.slice(0)), this._readbackBuffer["destroy"](), this._readbackBuffer = null, this._resolveBuffer["destroy"](), this._resolveBuffer = null, this._querySet["destroy"](), this._querySet = null;
    }
    HasResult() {
      return null !== this._result;
    }
    GetResult() {
      if (!this._result) throw new Error("not yet got result");
      return this._result;
    }
    GetFrameNumber() {
      return this._frameNumber;
    }
  };
}
{
  const C32 = self.C3, DEFAULT_CTOR_OPTS = { getDrawSize: null, getRenderTarget: null, releaseRenderTarget: null, getTime: null, redraw: null };
  C32.Gfx.EffectChainManager = class {
    constructor(e) {
      e = Object.assign({}, DEFAULT_CTOR_OPTS, e), this._cbGetDrawSize = e.getDrawSize, this._cbGetRenderTarget = e.getRenderTarget, this._cbReleaseRenderTarget = e.releaseRenderTarget, this._cbGetTime = e.getTime, this._cbRedraw = e.redraw, this._webgpuBackTexture = null, this._allEffectChains = /* @__PURE__ */ new Set();
    }
    _AddEffectChain(e) {
      this._allEffectChains.add(e);
    }
    _RemoveEffectChain(e) {
      this._allEffectChains.delete(e);
    }
    OnContextLost() {
      this._webgpuBackTexture = null;
      for (const e of this._allEffectChains) e.OnContextLost();
    }
    GetDrawSize(e) {
      return this._cbGetDrawSize ? this._cbGetDrawSize(e) : [e.GetWidth(), e.GetHeight()];
    }
    GetRenderTarget(e) {
      return this._cbGetRenderTarget(e);
    }
    ReleaseRenderTarget(e, t2) {
      this._cbReleaseRenderTarget(e, t2);
    }
    GetTime() {
      return this._cbGetTime();
    }
    Redraw(e) {
      this._cbRedraw(e);
    }
    _GetWebGPUBackTexture(e, t2, r2) {
      return t2 = Math.floor(t2), r2 = Math.floor(r2), !this._webgpuBackTexture || this._webgpuBackTexture.GetWidth() === t2 && this._webgpuBackTexture.GetHeight() === r2 || (e.DeleteTexture(this._webgpuBackTexture), this._webgpuBackTexture = null), null === this._webgpuBackTexture && (this._webgpuBackTexture = e.CreateStaticTexture(null, { width: t2, height: r2, sampling: "nearest", mipMap: false })), this._webgpuBackTexture;
    }
  };
}
{
  const C32 = self.C3, assert = self.assert, glMatrix = self.glMatrix, mat4 = glMatrix.mat4, tempRect = C32.New(C32.Rect), tempRect2 = C32.New(C32.Rect), tempRect3 = C32.New(C32.Rect), tempRect4 = C32.New(C32.Rect), tempMat4a = mat4.create(), tempMat4b = mat4.create(), DEFAULT_CTOR_OPTS = { drawContent: null, getSourceTextureInfo: null, getShaderParameters: null, invalidateRenderTargets: false }, DEFAULT_BUILDSTEPS_OPTS = { indexMap: null, forcePreDraw: false, forcePostDraw: false, is3D: false, isSourceTextureRotated: false, isRotatedOrNegativeSizeInstance: false, useFullSurface: false };
  C32.Gfx.EffectChain = class {
    constructor(e, t2) {
      t2 = Object.assign({}, DEFAULT_CTOR_OPTS, t2), this._manager = e, this._cbDrawContent = t2.drawContent, this._cbGetSourceTextureInfo = t2.getSourceTextureInfo, this._cbGetShaderParameters = t2.getShaderParameters, this._cbDrawContentHook = null, this._shaderProgramList = [], this._shaderProgramIndices = [], this._steps = [], this._needsRebuild = false, this._blendMode = 0, this._isAnyShaderAnimated = false, this._isAnyShaderDepthSampling = false, this._isAnyShaderBackgroundBlending = false, this._isAnyShaderCrossSampling = false, this._isAnyIsSrcTexRotated = false, this._useCopyTextureBackgroundSampling = false, this._didChangeTransform = false, this._depthEnabledAtStart = false, this._coplanarColorPassAtStart = false, this._canUseFastPath = false, this._useFullSurface = false, this._isSourceTextureRotated = false, this._numTempSurfacesRequired = 0, this._renderTargets = [null, null, null], this._invalidateRenderTargets = !!t2.invalidateRenderTargets, this._boxExtendHorizontal = 0, this._boxExtendVertical = 0, this._drawWidth = 0, this._drawHeight = 0, this._contentObject = null, this._contextObject = null, this._layoutRect = C32.New(C32.Rect), this._drawSurfaceRect = C32.New(C32.Rect), this._rcTexOriginal = C32.New(C32.Rect), this._rcTexBounce = C32.New(C32.Rect), this._rcTexDest = C32.New(C32.Rect), this._devicePixelRatio = 1, this._layerScale = 1, this._layerAngle = 0, this._time = 0, this._destRenderTarget = null, this._backTex = null, this._compositOffX = 0, this._compositOffY = 0, this._compositRtWidth = 0, this._compositRtHeight = 0, this._updateOwnProjection = false, this._projectionMatrix = mat4.create(), this._modelViewMatrix = mat4.create(), this._manager._AddEffectChain(this);
    }
    Release() {
      this._manager._RemoveEffectChain(this), C32.clearArray(this._steps), C32.clearArray(this._shaderProgramList), C32.clearArray(this._shaderProgramIndices), this._contentObject = null, this._contextObject = null, this._cbDrawContent = null, this._cbGetSourceTextureInfo = null, this._cbGetShaderParameters = null;
    }
    OnContextLost() {
      this._needsRebuild = true, C32.clearArray(this._steps), C32.clearArray(this._shaderProgramList), C32.clearArray(this._shaderProgramIndices);
    }
    NeedsRebuild() {
      return this._needsRebuild;
    }
    BuildSteps(e, t2) {
      if (t2 = Object.assign({}, DEFAULT_BUILDSTEPS_OPTS, t2), C32.clearArray(this._steps), this._boxExtendHorizontal = 0, this._boxExtendVertical = 0, this._isAnyShaderAnimated = false, this._isAnyShaderDepthSampling = false, this._isAnyShaderBackgroundBlending = false, this._isAnyShaderCrossSampling = false, this._isAnyIsSrcTexRotated = false, this._useCopyTextureBackgroundSampling = false, this._numTempSurfacesRequired = 0, this._isSourceTextureRotated = !!t2.isSourceTextureRotated, this._useFullSurface = !!t2.useFullSurface, this._needsRebuild = false, C32.shallowAssignArray(this._shaderProgramList, e), 0 === e.length) return;
      if (t2.indexMap) {
        if (t2.indexMap.length !== e.length) throw new Error("incorrect indexMap length");
        C32.shallowAssignArray(this._shaderProgramIndices, t2.indexMap);
      } else {
        C32.clearArray(this._shaderProgramIndices);
        for (let t3 = 0, r3 = e.length; t3 < r3; ++t3) this._shaderProgramIndices.push(t3);
      }
      for (const t3 of e) this._boxExtendHorizontal += t3.GetBoxExtendHorizontal(), this._boxExtendVertical += t3.GetBoxExtendVertical(), t3.IsAnimated() && (this._isAnyShaderAnimated = true), t3.UsesDepth() && (this._isAnyShaderDepthSampling = true), t3.BlendsBackground() && (this._isAnyShaderBackgroundBlending = true), t3.UsesCrossSampling() && (this._isAnyShaderCrossSampling = true), t3.UsesIsSrcTexRotated() && (this._isAnyIsSrcTexRotated = true);
      this._useCopyTextureBackgroundSampling = this._ShouldUseCopyTextureBackgroundSampling(e[0].GetRenderer());
      const r2 = this._ShouldPreDraw(e[0], t2), s = this._ShouldPostDraw(e.at(-1), t2);
      if (1 === e.length && !r2 && !s) return void (this._canUseFastPath = true);
      this._canUseFastPath = false;
      let i = 0;
      r2 && (this._numTempSurfacesRequired = 1, this._steps.push(C32.New(C32.Gfx.EffectChain.Step.PreDraw, this, -1, 1)), i = 1);
      for (let t3 = 0, a2 = e.length; t3 < a2; ++t3) if (0 !== t3 || r2) {
        let e2 = 1 === i ? 2 : 1;
        t3 !== a2 - 1 || s || (e2 = 0), this._numTempSurfacesRequired = Math.max(this._numTempSurfacesRequired, e2), this._steps.push(C32.New(C32.Gfx.EffectChain.Step.Bounce, this, i, e2, t3)), i = e2;
      } else this._numTempSurfacesRequired = 1, this._steps.push(C32.New(C32.Gfx.EffectChain.Step.FirstBounce, this, -1, 1, t3)), i = 1;
      s && this._steps.push(C32.New(C32.Gfx.EffectChain.Step.PostDraw, this, i, 0));
    }
    _ShouldPreDraw(e, t2) {
      return !!(t2.forcePreDraw || e.MustPreDraw() || t2.is3D && !e.Supports3DDirectRendering() || e.UsesDepth() && !this._useFullSurface || 0 !== this._boxExtendHorizontal || 0 !== this._boxExtendVertical) || (e.GetRenderer().IsWebGL() ? e.BlendsBackground() && (t2.isRotatedOrNegativeSizeInstance || t2.isSourceTextureRotated) || e.UsesAnySrcRectOrPixelSize() && t2.isSourceTextureRotated : e.BlendsBackground() && !this._useCopyTextureBackgroundSampling && t2.isRotatedOrNegativeSizeInstance);
    }
    _ShouldPostDraw(e, t2) {
      return !!t2.forcePostDraw || (e.GetRenderer().IsWebGL() ? e.BlendsBackground() || e.UsesCrossSampling() : (e.BlendsBackground() || e.UsesCrossSampling()) && this._UseRenderTargetBackgroundSampling());
    }
    _ShouldUseCopyTextureBackgroundSampling(e) {
      return e.IsWebGPU() && this._isAnyShaderBackgroundBlending && !this._isAnyShaderCrossSampling;
    }
    Render(e, t2, r2) {
      e.IsWebGPU() && null === t2 && (t2 = e.GetBackbufferRenderTarget()), this._destRenderTarget = t2, this._contentObject = r2.contentObject || null, this._contextObject = r2.contextObject || null, this._blendMode = r2.blendMode || 0, this._devicePixelRatio = r2.devicePixelRatio || 1, this._layerScale = r2.layerScale || 1, this._layerAngle = r2.layerAngle || 0, this._time = "number" == typeof r2.time ? r2.time : this._manager.GetTime(), this._didChangeTransform = false, e.ResetDidChangeTransformFlag(), this._isAnyShaderAnimated && this._Redraw();
      let s = false;
      if (this._UseCopyTextureBackgroundSampling() && (this._CalculateDrawSizeAndRectangles(e, r2), s = true, this._backTex = this._manager._GetWebGPUBackTexture(e, this._drawWidth, this._drawHeight), tempRect.copy(this._drawSurfaceRect), tempRect.roundOuter(), e.IsWebGPU() && e._MaybeDoPendingClearRenderPass(this._destRenderTarget), e.CopyTextureToTexture(this._destRenderTarget.GetTexture(), this._backTex, tempRect.getLeft(), tempRect.getTop(), tempRect.width(), tempRect.height())), this._canUseFastPath) this._Render_FastPath(e, r2);
      else if (s || this._CalculateDrawSizeAndRectangles(e, r2), 0 !== this._rcTexOriginal.width() || 0 !== this._rcTexOriginal.height()) {
        e.SetAlphaBlend(), e.ResetCullState(), e.ResetColor(), e.SetBaseZ(0), e.SetCurrentZ(0), this._cbDrawContentHook = r2.drawContentHook || null, this._compositOffX = r2.compositOffX || 0, this._compositOffY = r2.compositOffY || 0, this._compositRtWidth = r2.compositRtWidth || 0, this._compositRtHeight = r2.compositRtHeight || 0, this._updateOwnProjection = !!r2.updateOwnProjection, this._OnBeforeStartEffectChain(e), this._renderTargets[0] = t2, this._renderTargets[1] = this._numTempSurfacesRequired >= 1 ? this._GetRenderTarget() : null, this._renderTargets[2] = 2 === this._numTempSurfacesRequired ? this._GetRenderTarget() : null;
        for (const t3 of this._steps) {
          const r3 = this._GetRenderTargetForId(t3.GetSrcTargetId()), s2 = this._GetRenderTargetForId(t3.GetDestTargetId());
          e.IsWebGPU() ? t3.Run_WebGPU(e, r3, s2) : t3.Run_WebGL(e, r3, s2);
        }
        e.SetTexture(null), this._renderTargets[1] && this._ReleaseRenderTarget(this._renderTargets[1]), this._renderTargets[2] && this._ReleaseRenderTarget(this._renderTargets[2]), this._renderTargets.fill(null), this._OnAfterEndEffectChain(e), this._destRenderTarget = null, this._backTex = null, this._contentObject = null, this._contextObject = null, this._cbDrawContentHook = null;
      }
    }
    _CalculateDrawSizeAndRectangles(e, t2) {
      const [r2, s] = this._manager.GetDrawSize(e);
      this._SetDrawSize(e, r2, s), this._CalculateRectangles(t2);
    }
    _SetDrawSize(e, t2, r2) {
      if (t2 <= 0 || r2 <= 0) throw new Error("invalid draw size");
      this._drawWidth === t2 && this._drawHeight === r2 || this._CalculateDeviceTransformMatrices(e, t2, r2, 0, 0, this._projectionMatrix, this._modelViewMatrix), this._drawWidth = t2, this._drawHeight = r2;
    }
    _CalculateDeviceTransformMatrices(e, t2, r2, s, i, a2, n) {
      const h2 = t2 / 2 + s, c2 = r2 / 2 + i;
      e.CalculatePerspectiveMatrix(a2, t2 / r2);
      const o2 = e.CalculateLookAtModelView2(h2, c2, e.GetDefaultCameraZ(r2), h2, c2, 0, r2);
      mat4.copy(n, o2);
    }
    _CalculateRectangles(e) {
      if (this._layoutRect.copy(e.layoutRect), e.drawSurfaceRect ? this._drawSurfaceRect.copy(e.drawSurfaceRect) : this._drawSurfaceRect.set(0, 0, this._drawWidth, this._drawHeight), this._canUseFastPath) {
        const t3 = e.compositOffX ?? 0, r2 = e.compositOffY ?? 0;
        this._drawSurfaceRect.offset(-t3, -r2);
      }
      this._rcTexOriginal.copy(this._drawSurfaceRect), this._rcTexOriginal.divide(this._drawWidth, this._drawHeight);
      const t2 = this._layerScale * this._devicePixelRatio;
      this._drawSurfaceRect.inflate(this._boxExtendHorizontal * t2, this._boxExtendVertical * t2), this._rcTexDest.copy(this._drawSurfaceRect), this._rcTexDest.divide(this._drawWidth, this._drawHeight), this._drawSurfaceRect.clampBoth(0, 0, this._drawWidth, this._drawHeight), this._rcTexBounce.copy(this._drawSurfaceRect), this._rcTexBounce.divide(this._drawWidth, this._drawHeight);
    }
    _OnBeforeStartEffectChain(e) {
      if (this._depthEnabledAtStart = e.IsDepthEnabled(), this._coplanarColorPassAtStart = e.IsCoplanarColorPass(), this._useFullSurface) e.SetDepthEnabled(false), this._isAnyShaderDepthSampling && e.SetDepthSamplingEnabled(true);
      else {
        if (tempRect.copy(this._drawSurfaceRect), e.IsWebGL()) {
          const e2 = this._layerScale * this._devicePixelRatio;
          tempRect.inflate(Math.max(this._boxExtendHorizontal, 1) * e2, Math.max(this._boxExtendVertical, 1) * e2), tempRect.roundOuter(), tempRect.clamp(0, 0, this._drawWidth, this._drawHeight);
        } else tempRect.roundOuter();
        e.SetScissorRect(tempRect.getLeft(), tempRect.getTop(), tempRect.width(), tempRect.height(), this._drawHeight);
      }
    }
    _OnAfterEffectChainDrawContent(e) {
      e.ResetColor(), this._useFullSurface || (this._coplanarColorPassAtStart ? e.CoplanarRestoreStandardRendering(false) : e.SetDepthEnabled(false), this._isAnyShaderDepthSampling && e.SetDepthSamplingEnabled(true)), e.IsWebGPU() && e.SetNormalizedCoordsProgramVariant(true);
    }
    _OnAfterEndEffectChain(e) {
      e.SetDepthSamplingEnabled(false), this._coplanarColorPassAtStart ? e.CoplanarStartColorPass(this._depthEnabledAtStart) : e.SetDepthEnabled(this._depthEnabledAtStart), this._useFullSurface || e.RemoveScissorRect(), e.IsWebGPU() && e.SetNormalizedCoordsProgramVariant(false), this._didChangeTransform = e.DidChangeTransform();
    }
    _ClampRcTexDest() {
      this._rcTexDest.clamp(0, 0, 1, 1);
    }
    _GetRenderTargetForId(e) {
      return e < 0 ? null : this._renderTargets[e];
    }
    _GetRenderTarget() {
      return this._manager.GetRenderTarget(this);
    }
    _GetDestRenderTarget() {
      return this._destRenderTarget;
    }
    _ReleaseRenderTarget(e) {
      this._manager.ReleaseRenderTarget(e, this);
    }
    _GetShaderProgramAt(e) {
      return this._shaderProgramList[e];
    }
    _DrawContent(e) {
      this._cbDrawContentHook ? this._cbDrawContentHook(this, e, () => this._cbDrawContent(e, this)) : this._cbDrawContent(e, this), this._canUseFastPath || this._OnAfterEffectChainDrawContent(e);
    }
    _IsRenderTargetSameSizeAndOffset(e) {
      if (this._useFullSurface) return true;
      if (0 !== this._compositOffX || 0 !== this._compositOffY || 0 !== this._compositRtWidth || 0 !== this._compositRtHeight) return false;
      const [t2, r2] = e.GetRenderTargetSize(e.GetRenderTarget());
      return t2 === this._drawWidth && r2 === this._drawHeight;
    }
    _SetDeviceTransform(e, t2) {
      let r2 = this._projectionMatrix, s = this._modelViewMatrix;
      if (t2 && !this._IsRenderTargetSameSizeAndOffset(e)) {
        let t3, i;
        r2 = tempMat4a, s = tempMat4b, 0 !== this._compositRtWidth && 0 !== this._compositRtHeight ? [t3, i] = [this._compositRtWidth, this._compositRtHeight] : [t3, i] = e.GetRenderTargetSize(e.GetRenderTarget()), this._CalculateDeviceTransformMatrices(e, t3, i, this._compositOffX, this._compositOffY, r2, s), this._useFullSurface || e.RemoveScissorRect();
      }
      e.SetProjectionMatrix(r2), e.SetModelViewMatrix(s);
    }
    _Redraw() {
      this._manager.Redraw(this);
    }
    _GetShaderParameters(e, t2) {
      return this._cbGetShaderParameters(this._shaderProgramIndices[e], t2);
    }
    _SetProgramParameters(e, t2) {
      let r2 = this._rcTexDest, s = this._rcTexBounce, i = this._rcTexOriginal;
      e.IsWebGL() && (tempRect2.copy(r2), tempRect2.flipAround(1), r2 = tempRect2, tempRect3.copy(s), tempRect3.flipAround(1), s = tempRect3, tempRect4.copy(i), tempRect4.flipAround(1), i = tempRect4), this._DoSetProgramParameters(e, t2, s, i, r2, 1 / this._drawWidth, 1 / this._drawHeight);
    }
    _SetFirstBounceProgramParameters(e, t2) {
      let r2 = this._rcTexBounce, s = this._rcTexOriginal, i = 1 / this._drawWidth, a2 = 1 / this._drawHeight;
      if (this._cbGetSourceTextureInfo) {
        let { srcTexRect: e2, srcWidth: t3, srcHeight: n2 } = this._cbGetSourceTextureInfo(this._contentObject);
        e2 || (tempRect.set(0, 0, 0, 0), e2 = tempRect), t3 || (t3 = this._drawWidth), n2 || (n2 = this._drawHeight), r2 = e2, s = e2, i = 1 / t3, a2 = 1 / n2;
      } else e.IsWebGL() && (tempRect3.copy(r2), tempRect3.flipAround(1), r2 = tempRect3, tempRect4.copy(s), tempRect4.flipAround(1), s = tempRect4);
      let n = this._rcTexDest;
      e.IsWebGL() && (n = tempRect2, n.copy(this._rcTexDest), n.flipAround(1)), this._DoSetProgramParameters(e, t2, r2, s, n, i, a2), e.IsWebGPU() && this._isAnyIsSrcTexRotated && e.SetProgramParameter_IsSrcTexRotated(this._isSourceTextureRotated);
    }
    _GetBackTex(e) {
      return this._isAnyShaderBackgroundBlending ? e.IsWebGPU() ? this._UseCopyTextureBackgroundSampling() ? this._backTex : this._destRenderTarget.GetTexture() : this._destRenderTarget : null;
    }
    _DoSetProgramParameters(e, t2, r2, s, i, a2, n) {
      e.SetProgramParameters(this._GetBackTex(e), i, r2, s, this._layoutRect, a2, n, this._devicePixelRatio, this._layerScale, this._layerAngle, this._time), e.SetProgramCustomParameters(this._GetShaderParameters(t2, e));
    }
    _Render_FastPath(e, t2) {
      const r2 = this._shaderProgramList[0], s = e.IsDepthEnabled(), i = r2.UsesDepth();
      i && (e.SetDepthEnabled(false), e.SetDepthSamplingEnabled(true), this._rcTexDest.set(0, 0, 1, 1), this._rcTexOriginal.set(0, 0, 1, 1)), e.SetProgram(r2), e.SetBlendMode(this._blendMode), e.SetRenderTarget(this._destRenderTarget), e.ResetCullState();
      let a2 = 0, n = 1;
      if (this._rcTexOriginal.set(0, 0, 1, 1), r2.UsesAnySrcRectOrPixelSize() && this._cbGetSourceTextureInfo) {
        const { srcTexRect: e2, srcWidth: t3, srcHeight: r3 } = this._cbGetSourceTextureInfo(this._contentObject);
        e2 && this._rcTexOriginal.copy(e2), a2 = Number.isFinite(t3) ? 1 / t3 : 0, n = Number.isFinite(r3) ? 1 / r3 : 0;
      } else {
        const [t3, r3] = this._manager.GetDrawSize(e);
        a2 = 1 / t3, n = 1 / r3;
      }
      t2.layoutRect ? this._layoutRect.copy(t2.layoutRect) : this._layoutRect.set(0, 0, 0, 0), e.SetProgramParameters(this._GetBackTex(e), this._rcTexDest, this._rcTexOriginal, this._rcTexOriginal, this._layoutRect, a2, n, this._devicePixelRatio, this._layerScale, this._layerAngle, this._time), e.SetProgramCustomParameters(this._GetShaderParameters(0, e)), e.IsWebGPU() && this._isAnyIsSrcTexRotated && e.SetProgramParameter_IsSrcTexRotated(this._isSourceTextureRotated), e.SetBaseZ(0), this._DrawContent(e), i && (e.SetDepthSamplingEnabled(false), e.SetDepthEnabled(s));
    }
    _UseCopyTextureBackgroundSampling() {
      return this._useCopyTextureBackgroundSampling;
    }
    _UseRenderTargetBackgroundSampling() {
      return !this._useCopyTextureBackgroundSampling;
    }
    IsAnyShaderBackgroundBlending() {
      return this._isAnyShaderBackgroundBlending;
    }
    CanSkipCalculatingDrawSurfaceRect() {
      return !!this._canUseFastPath && !this._UseCopyTextureBackgroundSampling();
    }
    UseFullSurface() {
      return this._useFullSurface;
    }
    GetContentObject() {
      return this._contentObject;
    }
    GetContextObject() {
      return this._contextObject;
    }
    _GetBlendMode() {
      return this._blendMode;
    }
    _UpdateOwnProjection() {
      return this._updateOwnProjection;
    }
    DidChangeTransform() {
      return this._didChangeTransform;
    }
    _GetDrawSurfaceRect() {
      return this._drawSurfaceRect;
    }
    _GetRcTexBounce() {
      return this._rcTexBounce;
    }
    _ShouldInvalidateRenderTargets() {
      return this._invalidateRenderTargets;
    }
    async DebugLogRenderTargetContents(e, t2, r2) {
    }
  };
}
{
  const C32 = self.C3;
  C32.Gfx.EffectChain.Step = class {
    constructor(t2, e, r2, s = -1) {
      this._effectChain = t2, this._srcTargetId = e, this._destTargetId = r2, this._index = s;
    }
    GetEffectChain() {
      return this._effectChain;
    }
    GetSrcTargetId() {
      return this._srcTargetId;
    }
    GetDestTargetId() {
      return this._destTargetId;
    }
    GetIndex() {
      return this._index;
    }
    GetShaderProgram() {
      return this.GetEffectChain()._GetShaderProgramAt(this.GetIndex());
    }
    Run_WebGL(t2, e, r2) {
    }
    Run_WebGPU(t2, e, r2) {
    }
  };
}
{
  const C32 = self.C3;
  C32.Gfx.EffectChain.Step.PreDraw = class extends C32.Gfx.EffectChain.Step {
    constructor(e, t2, a2, n) {
      super(e, t2, a2, n);
    }
    Run_WebGL(e, t2, a2) {
      const n = this.GetEffectChain();
      e.SetAlphaBlend(), e.ResetCullState(), e.SetTextureFillMode(), e.SetRenderTarget(a2, n._UpdateOwnProjection()), e.ClearRgba(0, 0, 0, 0), n._DrawContent(e), n._ClampRcTexDest();
    }
    Run_WebGPU(e, t2, a2) {
      const n = this.GetEffectChain();
      e.SetAlphaBlend(), e.ResetCullState(), e.SetTextureFillMode(), e.SetRenderTarget(a2, false), e.ClearRgba(0, 0, 0, 0), n._DrawContent(e), n._ClampRcTexDest();
    }
  };
}
{
  const C32 = self.C3, tempRect = C32.New(C32.Rect), tempQuad = C32.New(C32.Quad);
  C32.Gfx.EffectChain.Step.PostDraw = class extends C32.Gfx.EffectChain.Step {
    constructor(e, t2, r2, a2) {
      super(e, t2, r2, a2);
    }
    Run_WebGL(e, t2, r2) {
      const a2 = this.GetEffectChain();
      e.SetTextureFillMode(), e.SetRenderTarget(r2), a2._SetDeviceTransform(e, true), e.SetBlendMode(a2._GetBlendMode()), e.SetTexture(t2.GetTexture()), tempQuad.setFromRect(a2._GetDrawSurfaceRect()), tempRect.copy(a2._GetRcTexBounce()), tempRect.flipAround(1), e.Quad3(tempQuad, tempRect), a2._ShouldInvalidateRenderTargets() && e.InvalidateRenderTarget(t2);
    }
    Run_WebGPU(e, t2, r2) {
      const a2 = this.GetEffectChain();
      e.SetTextureFillMode(), e.SetRenderTarget(r2, false), a2._IsRenderTargetSameSizeAndOffset(e) ? tempQuad.setFromRect(a2._GetRcTexBounce()) : (e.SetNormalizedCoordsProgramVariant(false), a2._SetDeviceTransform(e, true), tempQuad.setFromRect(a2._GetDrawSurfaceRect())), e.SetBackTexture(null), e.SetBlendMode(a2._GetBlendMode()), e.SetTexture(t2.GetTexture()), a2.UseFullSurface() ? e.FullscreenQuad() : e.Quad3(tempQuad, a2._GetRcTexBounce());
    }
  };
}
{
  const C32 = self.C3;
  C32.Gfx.EffectChain.Step.FirstBounce = class extends C32.Gfx.EffectChain.Step {
    constructor(e, t2, r2, a2) {
      super(e, t2, r2, a2);
    }
    Run_WebGL(e, t2, r2) {
      const a2 = this.GetEffectChain();
      e.SetRenderTarget(r2, a2._UpdateOwnProjection()), e.ClearRgba(0, 0, 0, 0), e.SetCopyBlend(), e.SetProgram(this.GetShaderProgram()), a2._SetFirstBounceProgramParameters(e, this.GetIndex()), a2._DrawContent(e), a2._ClampRcTexDest();
    }
    Run_WebGPU(e, t2, r2) {
      const a2 = this.GetEffectChain();
      e.SetRenderTarget(r2, false), e.ClearRgba(0, 0, 0, 0), e.SetCopyBlend(), e.SetProgram(this.GetShaderProgram()), a2._SetFirstBounceProgramParameters(e, this.GetIndex()), a2._DrawContent(e), a2._ClampRcTexDest();
    }
  };
}
{
  const C32 = self.C3, tempRect = C32.New(C32.Rect), tempQuad = C32.New(C32.Quad);
  C32.Gfx.EffectChain.Step.Bounce = class extends C32.Gfx.EffectChain.Step {
    constructor(e, t2, r2, a2) {
      super(e, t2, r2, a2);
    }
    Run_WebGL(e, t2, r2) {
      const a2 = this.GetEffectChain();
      e.SetRenderTarget(r2);
      const d2 = 0 === this.GetDestTargetId();
      d2 ? e.SetBlendMode(a2._GetBlendMode()) : (e.ClearRgba(0, 0, 0, 0), e.SetCopyBlend()), e.SetProgram(this.GetShaderProgram()), a2._SetProgramParameters(e, this.GetIndex()), e.SetTexture(t2.GetTexture()), a2._SetDeviceTransform(e, d2), tempQuad.setFromRect(a2._GetDrawSurfaceRect()), tempRect.copy(a2._GetRcTexBounce()), tempRect.flipAround(1), e.Quad3(tempQuad, tempRect), a2._ShouldInvalidateRenderTargets() && e.InvalidateRenderTarget(t2);
    }
    Run_WebGPU(e, t2, r2) {
      const a2 = this.GetEffectChain();
      e.SetRenderTarget(r2, false);
      0 === this.GetDestTargetId() ? (e.SetBlendMode(a2._GetBlendMode()), e.SetBackTexture(null), a2._IsRenderTargetSameSizeAndOffset(e) ? tempQuad.setFromRect(a2._GetRcTexBounce()) : (e.SetNormalizedCoordsProgramVariant(false), a2._SetDeviceTransform(e, true), tempQuad.setFromRect(a2._GetDrawSurfaceRect()))) : (e.ClearRgba(0, 0, 0, 0), e.SetCopyBlend(), tempQuad.setFromRect(a2._GetRcTexBounce())), e.SetProgram(this.GetShaderProgram()), a2._SetProgramParameters(e, this.GetIndex()), e.SetTexture(t2.GetTexture()), a2.UseFullSurface() ? e.FullscreenQuad() : e.Quad3(tempQuad, a2._GetRcTexBounce());
    }
  };
}
{
  let SortZOrderList = function(e, t2) {
    const r2 = e[0] - t2[0];
    if (0 !== r2) return r2;
    return e[1] - t2[1];
  };
  SortZOrderList2 = SortZOrderList;
  const C32 = self.C3, C3X = self.C3X;
  let runtime = null;
  const keysDownByKey = /* @__PURE__ */ new Set();
  const tempZOrderList = [], tempInstances = [];
  let didWarnInAlertPolyfill = false, didWarnFpsDeprecated = false, didWarnCreateWorkerDeprecated = false;
  const VALID_FRAMERATE_MODES = /* @__PURE__ */ new Set(["vsync", "unlimited-tick", "unlimited-frame"]);
  self.IRuntime = class {
    constructor(e) {
      runtime = e, Object.defineProperties(this, { assets: { value: runtime.GetAssetManager().GetIAssetManager(), writable: false }, collisions: { value: runtime.GetCollisionEngine().GetICollisionEngine(), writable: false }, objects: { value: {}, writable: false }, globalVars: { value: {}, writable: false }, projectName: { value: runtime.GetProjectName(), writable: false }, projectVersion: { value: runtime.GetProjectVersion(), writable: false }, projectId: { value: runtime.GetAppId(), writable: false }, projectUniqueId: { value: runtime.GetProjectUniqueId(), writable: false }, exportDate: { value: new Date(runtime.GetExportTimestamp()), writable: false }, storage: { value: new self.IStorage(runtime), writable: false }, isInWorker: { value: runtime.IsInWorker(), writable: false }, viewportWidth: { value: runtime.GetOriginalViewportWidth(), writable: false }, viewportHeight: { value: runtime.GetOriginalViewportHeight(), writable: false }, sampling: { value: runtime.GetSampling(), writable: false }, platformInfo: { value: new self.IPlatformInfo(e), writable: false }, sdk: { value: new self.ISDKUtils(e), writable: false } }), runtime.UserScriptDispatcher().addEventListener("keydown", (e2) => {
        keysDownByKey.has(e2["key"]) ? e2.stopPropagation() : keysDownByKey.add(e2["key"]);
      }), runtime.UserScriptDispatcher().addEventListener("keyup", (e2) => keysDownByKey.delete(e2["key"])), runtime.Dispatcher().addEventListener("window-blur", () => keysDownByKey.clear()), runtime.IsInWorker() && (self["alert"] = (e2) => (didWarnInAlertPolyfill || (didWarnInAlertPolyfill = true, console.warn("[Construct] alert() was called from a Web Worker, because the project 'Use worker' setting is enabled. This method is not normally available in a Web Worker. Construct has implemented the alert for you, but note that other features may be missing in worker mode. You may wish to disable 'Use worker', or use a more convenient function like console.log(). For more information please refer to the scripting section of the manual.")), this.alert(e2)));
    }
    _InitObjects(e) {
      Object.defineProperties(this.objects, e);
    }
    _InitGlobalVars(e) {
      Object.defineProperties(this.globalVars, e);
    }
    addEventListener(e, t2) {
      runtime.UserScriptDispatcher().addEventListener(e, t2);
    }
    removeEventListener(e, t2) {
      runtime.UserScriptDispatcher().removeEventListener(e, t2);
    }
    callFunction(e, ...t2) {
      C3X.RequireString(e);
      const r2 = runtime.GetEventSheetManager(), n = r2.GetFunctionBlockByName(e);
      if (!n) throw new Error(`cannot find function name '${e}'`);
      if (!n.IsEnabled()) return n.GetDefaultReturnValue();
      if (t2.length < n.GetFunctionParameterCount()) throw new Error(`not enough function parameters passed for '${e}' (${t2.length} passed, ${n.GetFunctionParameterCount()} expected)`);
      const i = n.GetEventBlock();
      let a2 = i.GetSolModifiersIncludingParents();
      const o2 = r2.GetCurrentEvent();
      if (o2) {
        a2 = a2.slice(0);
        const e2 = new Set(a2);
        for (const t3 of o2.GetSolModifiersIncludingParents()) e2.has(t3) || (a2.push(t3), e2.add(t3));
        for (const t3 of r2.GetDynamicSolModifiersSet()) e2.has(t3) || (a2.push(t3), e2.add(t3));
      }
      return i.RunAsExpressionFunctionCall(a2, n.IsCopyPicked(), n.GetReturnType(), n.GetDefaultReturnValue(), ...t2);
    }
    setReturnValue(e) {
      const t2 = runtime.GetEventStack().GetCurrentExpFuncStackFrame();
      if (!t2) throw new Error("not in a function which returns a value");
      switch (t2.GetFunctionReturnType()) {
        case 1:
          "number" == typeof e && t2.SetFunctionReturnValue(e);
          break;
        case 2:
          "string" == typeof e && t2.SetFunctionReturnValue(e);
          break;
        case 3:
          "number" != typeof e && "string" != typeof e || t2.SetFunctionReturnValue(e);
      }
    }
    signal(e) {
      C3X.RequireString(e), runtime.GetEventSheetManager().Signal(e);
    }
    waitForSignal(e) {
      return C3X.RequireString(e), runtime.GetEventSheetManager().WaitForSignal(e);
    }
    getViewportSize() {
      return [runtime.GetOriginalViewportWidth(), runtime.GetOriginalViewportHeight()];
    }
    get isSuspended() {
      return runtime.IsSuspended();
    }
    get dt() {
      return runtime.GetDt();
    }
    get dtRaw() {
      return runtime.GetDtRaw();
    }
    get gameTime() {
      return runtime.GetGameTime();
    }
    get tickCount() {
      return runtime.GetTickCount();
    }
    get wallTime() {
      return runtime.GetWallTime();
    }
    get timeScale() {
      return runtime.GetTimeScale();
    }
    set timeScale(e) {
      C3X.RequireFiniteNumber(e), runtime.SetTimeScale(e);
    }
    get fps() {
      return didWarnFpsDeprecated || (console.warn("IRuntime.fps is deprecated. Use IRuntime.framesPerSecond instead."), didWarnFpsDeprecated = true), runtime.GetFramesPerSecond();
    }
    get framesPerSecond() {
      return runtime.GetFramesPerSecond();
    }
    get ticksPerSecond() {
      return runtime.GetTicksPerSecond();
    }
    get cpuUtilisation() {
      return runtime.GetMainThreadTime();
    }
    get gpuUtilisation() {
      return runtime.GetGPUUtilisation();
    }
    get framerateMode() {
      return runtime.GetFramerateMode();
    }
    set framerateMode(e) {
      if (!VALID_FRAMERATE_MODES.has(e)) throw new Error("invalid framerate mode");
      runtime._SetFramerateMode(e);
    }
    get minDt() {
      return runtime.GetMinDt();
    }
    set minDt(e) {
      C3X.RequireFiniteNumber(e), runtime.SetMinDt(e);
    }
    get maxDt() {
      return runtime.GetMaxDt();
    }
    set maxDt(e) {
      runtime.SetMaxDt(e);
    }
    set isPixelRoundingEnabled(e) {
      runtime.SetPixelRoundingEnabled(!!e);
    }
    get isPixelRoundingEnabled() {
      return runtime.IsPixelRoundingEnabled();
    }
    get loadingProgress() {
      return runtime.GetAssetManager().GetLoadProgress();
    }
    get imageLoadingProgress() {
      return runtime.GetAssetManager().GetImageLoadProgress();
    }
    random() {
      return runtime.Random();
    }
    get layout() {
      const e = runtime.GetMainRunningLayout();
      if (!e) throw new Error("no layout is running - make sure a layout is loaded before accessing");
      return e.GetILayout();
    }
    getLayout(e) {
      const t2 = runtime.GetLayoutManager();
      let r2 = null;
      if ("number" != typeof e && "string" != typeof e) throw new TypeError("expected string or number");
      if (r2 = t2.GetLayout(e), !r2) throw new Error("invalid layout");
      return r2.GetILayout();
    }
    getAllLayouts() {
      return runtime.GetLayoutManager().GetAllLayouts().map((e) => e.GetILayout());
    }
    goToLayout(e) {
      const t2 = runtime.GetLayoutManager();
      let r2 = null;
      if ("number" != typeof e && "string" != typeof e) throw new TypeError("expected string or number");
      if (r2 = t2.GetLayout(e), !r2) throw new Error("invalid layout");
      t2.IsPendingChangeMainLayout() || t2.ChangeMainLayout(r2);
    }
    get keyboard() {
      const e = runtime._GetCommonScriptInterfaces().keyboard;
      if (!e) throw new Error("runtime.keyboard used but Keyboard object missing - add it to your project first");
      return e;
    }
    get mouse() {
      const e = runtime._GetCommonScriptInterfaces().mouse;
      if (!e) throw new Error("runtime.mouse used but Mouse object missing - add it to your project first");
      return e;
    }
    get touch() {
      const e = runtime._GetCommonScriptInterfaces().touch;
      if (!e) throw new Error("runtime.touch used but Touch object missing - add it to your project first");
      return e;
    }
    get timelineController() {
      const e = runtime._GetCommonScriptInterfaces().timelineController;
      if (!e) throw new Error("runtime.timelineController used but Timeline Controller object missing - add it to your project first");
      return e;
    }
    get renderer() {
      return runtime.GetCanvasManager().GetIRenderer();
    }
    invokeDownload(e, t2) {
      C3X.RequireString(e), C3X.RequireString(t2), runtime.InvokeDownload(e, t2);
    }
    getInstanceByUid(e) {
      C3X.RequireFiniteNumber(e);
      const t2 = runtime.GetInstanceByUID(e);
      return t2 ? t2.GetInterfaceClass() : null;
    }
    sortZOrder(e, t2) {
      C3X.RequireFunction(t2);
      const r2 = runtime.GetCurrentLayout();
      for (const t3 of e) {
        const e2 = runtime._UnwrapIWorldInstance(t3), r3 = e2.GetWorldInfo();
        tempZOrderList.push([r3.GetLayer().GetIndex(), r3.GetZIndex()]), tempInstances.push(e2);
      }
      if (0 === tempZOrderList.length) return;
      tempZOrderList.sort(SortZOrderList), tempInstances.sort((e2, r3) => t2(e2.GetInterfaceClass(), r3.GetInterfaceClass()));
      let n = false;
      for (let e2 = 0, t3 = tempZOrderList.length; e2 < t3; ++e2) {
        const t4 = tempInstances[e2], i = r2.GetLayerByIndex(tempZOrderList[e2][0]), a2 = tempZOrderList[e2][1], o2 = i._GetInstances();
        o2[a2] !== t4 && (o2[a2] = t4, t4.GetWorldInfo()._SetLayer(i, true), i.SetZIndicesChanged(t4), n = true);
      }
      n && runtime.UpdateRender(), C32.clearArray(tempZOrderList), C32.clearArray(tempInstances);
    }
    async createWorker(e, t2) {
      didWarnCreateWorkerDeprecated || (console.warn("IRuntime.createWorker() is deprecated. All modern browsers now support nested workers so this method is no longer needed."), didWarnCreateWorkerDeprecated = true);
      const r2 = new MessageChannel(), n = r2.port1, i = r2.port2;
      return await runtime.PostComponentMessageToDOMAsync("runtime", "script-create-worker", { "url": e, "opts": t2, "port2": i }, [i]), n;
    }
    alert(e) {
      return runtime.PostComponentMessageToDOMAsync("runtime", "alert", { "message": e + (runtime.IsInWorker() ? " [via Web Worker]" : "") });
    }
    getHTMLLayer(e) {
      return C3X.RequireFiniteNumber(e), runtime._GetHTMLLayerWrapElement(e);
    }
    addLoadPromise(e) {
      runtime.AddLoadPromise(e);
    }
    async saveCanvasImage(e, t2, r2) {
      C3X.RequireOptionalString(e), C3X.RequireOptionalNumber(t2), C3X.RequireOptionalInstanceOf(r2, DOMRect), r2 || (r2 = new DOMRect(0, 0, 0, 0));
      const n = runtime.GetCanvasManager();
      if (!n) return;
      runtime.UpdateRender();
      const i = await n.SnapshotCanvas(e || "image/png", t2, r2.x, r2.y, r2.width, r2.height);
      return await runtime.TriggerAsync(C32.Plugins.System.Cnds.OnCanvasSnapshot, null), i;
    }
  };
}
var SortZOrderList2;
{
  const C32 = self.C3, C3X = self.C3X;
  let assetManager = null;
  self.IAssetManager = class {
    constructor(e) {
      assetManager = e, Object.defineProperties(this, { isWebMOpusSupported: { value: true, writable: false } });
    }
    loadImageAsset(e) {
      const r2 = self.IImageInfo._Unwrap(e);
      if (!r2) throw new Error("invalid IImageInfo");
      r2.LoadAsset(assetManager.GetRuntime());
    }
    fetchText(e) {
      return assetManager.FetchText(e);
    }
    fetchJson(e) {
      return assetManager.FetchJson(e);
    }
    fetchBlob(e) {
      return assetManager.FetchBlob(e);
    }
    fetchArrayBuffer(e) {
      return assetManager.FetchArrayBuffer(e);
    }
    getProjectFileUrl(e) {
      return Promise.resolve(assetManager.GetProjectFileUrl(e));
    }
    getMediaFileUrl(e) {
      return assetManager.GetMediaFileUrl(e);
    }
    get mediaFolder() {
      return assetManager.GetMediaSubfolder();
    }
    async decodeWebMOpus(e, r2) {
      throw new Error("decodeWebMOpus() is no longer supported - use Web Audio's decodeAudioData() directly as all supported platforms now support WebM Opus");
    }
    loadScripts(...e) {
      return assetManager.LoadScripts(...e);
    }
    compileWebAssembly(e) {
      return assetManager.CompileWebAssembly(e);
    }
    loadStyleSheet(e) {
      return assetManager.LoadStyleSheet(e);
    }
    get projectFileList() {
      return assetManager.GetExportedFileList();
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X;
  let collisionEngine = null;
  self.ICollisionEngine = class {
    constructor(n) {
      collisionEngine = n, Object.defineProperties(this, { runtime: { value: collisionEngine.GetRuntime(), writable: false } });
    }
    testOverlap(n, e) {
      const l = collisionEngine.GetRuntime(), i = l._UnwrapIWorldInstance(n), t2 = l._UnwrapIWorldInstance(e);
      return collisionEngine.TestOverlap(i, t2);
    }
    testOverlapAny(n, e) {
      const l = collisionEngine.GetRuntime(), i = l._UnwrapIWorldInstance(n);
      for (const n2 of e) {
        const e2 = l._UnwrapIWorldInstance(n2);
        if (collisionEngine.TestOverlap(i, e2)) return n2;
      }
      return null;
    }
    testOverlapSolid(n) {
      const e = collisionEngine.GetRuntime()._UnwrapIWorldInstance(n), l = collisionEngine.TestOverlapSolid(e);
      return l ? l.GetInterfaceClass() : null;
    }
    setCollisionCellSize(n, e) {
      if (C3X.RequireFiniteNumber(n), C3X.RequireFiniteNumber(e), n = Math.floor(n), e = Math.floor(e), n <= 0 || e <= 0) throw new Error("invalid cell size");
      collisionEngine.SetCollisionCellSize(n, e);
    }
    getCollisionCellSize() {
      return collisionEngine.GetCollisionCellSize();
    }
    getCollisionCandidates(n, e) {
      const l = collisionEngine.GetRuntime();
      let i;
      i = Array.isArray(n) ? n.map((n2) => l._UnwrapIObjectClass(n2)) : [l._UnwrapIObjectClass(n)];
      const t2 = C32.Rect.FromObject(e), o2 = [];
      return collisionEngine.GetObjectClassesCollisionCandidates(null, i, t2, o2), o2.map((n2) => n2.GetInterfaceClass());
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X;
  let runtime = null;
  const osMap = /* @__PURE__ */ new Map([["Windows", "windows"], ["macOS", "macos"], ["Linux", "linux"], ["Chrome OS", "chrome-os"], ["Android", "android"], ["iOS", "ios"]]), browserMap = /* @__PURE__ */ new Map([["Chrome", "chrome"], ["Chromium", "chromium"], ["Edge", "edge"], ["Opera", "opera"], ["Firefox", "firefox"], ["Safari", "safari"]]), browserEngineMap = /* @__PURE__ */ new Map([["Chromium", "chromium"], ["Gecko", "gecko"], ["WebKit", "webkit"]]);
  self.IPlatformInfo = class {
    constructor(e) {
      runtime = e, Object.defineProperties(this, { isMobile: { value: C32.Platform.IsMobile, writable: false }, os: { value: osMap.get(C32.Platform.OS) || "unknown", writable: false }, osVersion: { value: C32.Platform.OSVersion, writable: false }, browser: { value: browserMap.get(C32.Platform.Browser) || "unknown", writable: false }, browserVersion: { value: C32.Platform.BrowserVersion, writable: false }, browserEngine: { value: browserEngineMap.get(C32.Platform.BrowserEngine) || "unknown", writable: false } });
    }
    get exportType() {
      let e = runtime.GetExportType();
      return runtime.IsWindowsWebView2() ? e = "windows-webview2" : "cordova" === e ? e = "Android" === C32.Platform.OS ? "cordova-android" : "cordova-ios" : "playable-ad-single-file" !== e && "playable-ad-zip" !== e || (e = "playable-ad"), e;
    }
    get renderer() {
      return runtime.GetCanvasManager().GetRendererString();
    }
    get rendererDetail() {
      return runtime.GetCanvasManager().GetRendererDetailString();
    }
    get canvasClientX() {
      return runtime.GetCanvasManager().GetCanvasClientX();
    }
    get canvasClientY() {
      return runtime.GetCanvasManager().GetCanvasClientY();
    }
    get canvasCssWidth() {
      return runtime.GetCanvasManager().GetCssWidth();
    }
    get canvasCssHeight() {
      return runtime.GetCanvasManager().GetCssHeight();
    }
    get canvasDeviceWidth() {
      return runtime.GetCanvasManager().GetDeviceWidth();
    }
    get canvasDeviceHeight() {
      return runtime.GetCanvasManager().GetDeviceHeight();
    }
    get devicePixelRatio() {
      return runtime.GetDevicePixelRatio();
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X;
  self.IStorage = class {
    constructor(e) {
      this._storage = e._GetProjectStorage();
    }
    getItem(e) {
      return C3X.RequireString(e), this._storage.getItem(e);
    }
    setItem(e, t2) {
      return C3X.RequireString(e), this._storage.setItem(e, t2);
    }
    removeItem(e) {
      return C3X.RequireString(e), this._storage.removeItem(e);
    }
    clear() {
      return this._storage.clear();
    }
    keys() {
      return this._storage.keys();
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X, internalApiToken = C32._GetInternalAPIToken();
  self.IPlugin = class {
    #e;
    constructor() {
      const e = C32.AddonManager._GetInitObject2(internalApiToken);
      this.#e = e, Object.defineProperties(this, { runtime: { value: e.GetRuntime().GetIRuntime(), writable: false }, id: { value: e.GetID(), writable: false }, isSingleGlobal: { value: e.IsSingleGlobal(), writable: false }, isWorldType: { value: e.IsWorldType(), writable: false }, isHTMLElementType: { value: e.IsHTMLElementType(), writable: false }, isRotatable: { value: e.IsRotatable(), writable: false }, hasEffects: { value: e.HasEffects(), writable: false }, is3d: { value: e.Is3D(), writable: false }, supportsHierarchies: { value: e.SupportsSceneGraph(), writable: false }, supportsMesh: { value: e.SupportsMesh(), writable: false } }), e.GetRuntime()._MapScriptInterface(this, e);
    }
    static getByConstructor(e) {
      if (!e) return null;
      const t2 = C32.AddonManager.GetPluginByConstructorFunction(e);
      return t2 ? t2.GetIPlugin() : null;
    }
    getSingleGlobalObjectType() {
      return this.#e.GetSingleGlobalObjectClass().GetIObjectClass();
    }
    getSingleGlobalInstance() {
      return this.#e.GetSingleGlobalInstance().GetInterfaceClass();
    }
  };
}
{
  const C32 = globalThis.C3, C3X = globalThis.C3X, internalApiToken = C32._GetInternalAPIToken();
  globalThis.IObjectClass = class {
    #e;
    constructor() {
      const e = C32.AddonManager._GetInitObject2(internalApiToken);
      this.#e = e, Object.defineProperties(this, { name: { value: e.GetName(), writable: false }, runtime: { value: e.GetRuntime().GetIRuntime(), writable: false }, plugin: { value: e.GetPlugin().GetIPlugin(), writable: false } }), e.GetRuntime()._MapScriptInterface(this, e);
    }
    addEventListener(e, t2) {
      C3X.RequireString(e), C3X.RequireFunction(t2), this.#e.UserScriptDispatcher().addEventListener(e, t2);
    }
    removeEventListener(e, t2) {
      C3X.RequireString(e), C3X.RequireFunction(t2), this.#e.UserScriptDispatcher().removeEventListener(e, t2);
    }
    getAllInstances() {
      return [...this.instances()];
    }
    getFirstInstance() {
      return C32.first(this.instances());
    }
    getPickedInstances() {
      return [...this.pickedInstances()];
    }
    getFirstPickedInstance() {
      return C32.first(this.pickedInstances());
    }
    getPairedInstance(e) {
      const t2 = this.#e, n = t2.GetRuntime()._UnwrapIInstance(e), i = t2.GetPairedInstance(n);
      return i ? i.GetInterfaceClass() : null;
    }
    *instances() {
      for (const e of this.#e.instancesIncludingPendingCreate()) yield e.GetInterfaceClass();
    }
    *pickedInstances() {
      for (const e of this.#e.GetCurrentSol().GetInstances()) yield e.GetInterfaceClass();
    }
  };
}
{
  const C32 = globalThis.C3, C3X = globalThis.C3X, internalApiToken = C32._GetInternalAPIToken();
  globalThis.IObjectType = class extends globalThis.IObjectClass {
    #e;
    constructor() {
      super();
      const e = C32.AddonManager._GetInitObject2(internalApiToken);
      this.#e = e;
    }
    setInstanceClass(e) {
      C3X.RequireFunction(e);
      const t2 = this.#e;
      if (t2.GetInstanceCount() > 0) throw new Error("setInstanceClass() called too late, because instances have already been created - call in runOnStartup");
      t2._SetUserScriptInstanceClass(e);
    }
    createInstance(e, t2, n, a2, s) {
      if (C3X.RequireNumber(t2), C3X.RequireNumber(n), "number" != typeof e && "string" != typeof e) throw new TypeError("invalid layer parameter");
      const r2 = this.#e, i = r2.GetRuntime(), l = i.GetMainRunningLayout().GetLayer(e);
      if (!l) throw new Error("invalid layer");
      const c2 = i.CreateInstance(r2, l, t2, n, a2, s);
      a2 && l.SortAndAddInstancesByZIndex(c2);
      const o2 = i.GetEventSheetManager();
      return o2.BlockFlushingInstances(true), c2._TriggerOnCreatedOnSelfAndRelated(), o2.BlockFlushingInstances(false), o2.IsInEventEngine() || i.GetLayoutManager().IsEndingLayout() || i.FlushPendingInstances(), c2.GetInterfaceClass();
    }
    getAllFamilies() {
      return this.#e.GetFamilies().map((e) => e.GetIObjectClass());
    }
    *families() {
      for (const e of this.#e.GetFamilies()) yield e.GetIObjectClass();
    }
    isInFamily(e) {
      return C3X.RequireInstanceOf(e, globalThis.IFamily), e.hasObjectType(this);
    }
  };
}
{
  const C32 = globalThis.C3, C3X = globalThis.C3X, IObjectType = globalThis.IObjectType, internalApiToken = C32._GetInternalAPIToken();
  globalThis.IFamily = class extends globalThis.IObjectClass {
    #e;
    constructor() {
      super();
      const e = C32.AddonManager._GetInitObject2(internalApiToken);
      this.#e = e;
    }
    getAllObjectTypes() {
      return this.#e.GetFamilyMembers().map((e) => e.GetIObjectClass());
    }
    *objectTypes() {
      for (const e of this.#e.GetFamilyMembers()) yield e.GetIObjectClass();
    }
    hasObjectType(e) {
      C3X.RequireInstanceOf(e, IObjectType);
      const t2 = this.#e, s = t2.GetRuntime()._UnwrapIObjectClass(e);
      return t2.FamilyHasMember(s);
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X, VALID_WHERE_STRINGS = ["above", "below", "top-sublayer", "bottom-sublayer"];
  self.ILayout = class {
    #e;
    constructor(e) {
      this.#e = e;
      const t2 = [], r2 = e.GetEffectList(), i = r2.GetAllEffectTypes().length;
      for (let e2 = 0; e2 < i; ++e2) t2.push(new self.IEffectInstance(r2, e2));
      Object.defineProperties(this, { runtime: { value: e.GetRuntime().GetIRuntime(), writable: false }, name: { value: e.GetName(), writable: false }, index: { value: e.GetIndex(), writable: false }, effects: { value: t2, writable: false } });
    }
    addEventListener(e, t2) {
      C3X.RequireString(e), C3X.RequireFunction(t2), this.#e.UserScriptDispatcher().addEventListener(e, t2);
    }
    removeEventListener(e, t2) {
      C3X.RequireString(e), C3X.RequireFunction(t2), this.#e.UserScriptDispatcher().removeEventListener(e, t2);
    }
    get width() {
      return this.#e.GetWidth();
    }
    set width(e) {
      C3X.RequireFiniteNumber(e), this.#e.SetWidth(e);
    }
    get height() {
      return this.#e.GetHeight();
    }
    set height(e) {
      C3X.RequireFiniteNumber(e), this.#e.SetHeight(e);
    }
    setSize(e, t2) {
      C3X.RequireFiniteNumber(e), C3X.RequireFiniteNumber(t2);
      const r2 = this.#e;
      r2.SetWidth(e), r2.SetHeight(t2);
    }
    getSize() {
      const e = this.#e;
      return [e.GetWidth(), e.GetHeight()];
    }
    set scale(e) {
      C3X.RequireFiniteNumber(e), this.#e.SetScale(e);
    }
    get scale() {
      return this.#e.GetScale();
    }
    set angle(e) {
      C3X.RequireFiniteNumber(e), this.#e.SetAngle(e);
    }
    get angle() {
      return this.#e.GetAngle();
    }
    set scrollX(e) {
      C3X.RequireNumber(e), this.#e.SetScrollX(e);
    }
    get scrollX() {
      return this.#e.GetScrollX();
    }
    set scrollY(e) {
      C3X.RequireNumber(e), this.#e.SetScrollY(e);
    }
    get scrollY() {
      return this.#e.GetScrollY();
    }
    scrollTo(e, t2) {
      C3X.RequireNumber(e), C3X.RequireNumber(t2);
      const r2 = this.#e;
      r2.SetScrollX(e), r2.SetScrollY(t2);
    }
    getScrollPosition() {
      const e = this.#e;
      return [e.GetScrollX(), e.GetScrollY()];
    }
    get isUnboundedScrolling() {
      return this.#e.IsUnboundedScrolling();
    }
    getLayer(e) {
      const t2 = this.#e;
      let r2 = null;
      if ("number" != typeof e && "string" != typeof e) throw new TypeError("expected string or number");
      return r2 = t2.GetLayer(e), r2 ? r2.GetILayer() : null;
    }
    getAllLayers() {
      return this.#e.GetLayers().map((e) => e.GetILayer());
    }
    *allLayers() {
      for (const e of this.#e.allLayers()) yield e.GetILayer();
    }
    addLayer(e, t2, r2) {
      const i = this.#e, n = self.ILayer;
      C3X.RequireString(e), C3X.RequireOptionalInstanceOf(t2, n);
      const s = t2 ? i.GetRuntime()._UnwrapScriptInterface(t2) : null, a2 = VALID_WHERE_STRINGS.indexOf(r2);
      if (a2 < 0) throw new Error("invalid location");
      i.AddLayer(e, s, a2);
    }
    moveLayer(e, t2, r2) {
      const i = this.#e, n = i.GetRuntime(), s = self.ILayer;
      C3X.RequireInstanceOf(e, s);
      const a2 = n._UnwrapScriptInterface(e);
      if (!a2) throw new Error("invalid layer");
      C3X.RequireOptionalInstanceOf(t2, s);
      const o2 = t2 ? n._UnwrapScriptInterface(t2) : null, l = VALID_WHERE_STRINGS.indexOf(r2);
      if (l < 0) throw new Error("invalid location");
      i.MoveLayer(a2, o2, l);
    }
    removeLayer(e) {
      const t2 = this.#e, r2 = self.ILayer;
      C3X.RequireInstanceOf(e, r2);
      const i = t2.GetRuntime()._UnwrapScriptInterface(e);
      if (!i) throw new Error("invalid layer");
      const n = i.GetRuntime();
      t2.RemoveLayer(i), n.GetEventSheetManager().IsInEventEngine() || n.FlushPendingInstances();
    }
    removeAllDynamicLayers() {
      const e = this.#e, t2 = e.GetRuntime();
      e.RemoveAllDynamicLayers(), t2.GetEventSheetManager().IsInEventEngine() || t2.FlushPendingInstances();
    }
    setVanishingPoint(e, t2) {
      C3X.RequireFiniteNumber(e), C3X.RequireFiniteNumber(t2), this.#e.SetVanishingPointXY(e, t2);
    }
    getVanishingPoint() {
      return this.#e.GetVanishingPoint();
    }
    set projection(e) {
      C3X.RequireString(e);
      const t2 = this.#e;
      if ("perspective" === e) t2.SetPerspectiveProjection();
      else {
        if ("orthographic" !== e) throw new Error("invalid projection");
        t2.SetOrthographicProjection();
      }
    }
    get projection() {
      return this.#e.IsOrthographicProjection() ? "orthographic" : "perspective";
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X, BLEND_MODE_TO_INDEX = /* @__PURE__ */ new Map([["normal", 0], ["additive", 1], ["copy", 3], ["destination-over", 4], ["source-in", 5], ["destination-in", 6], ["source-out", 7], ["destination-out", 8], ["source-atop", 9], ["destination-atop", 10]]), INDEX_TO_BLEND_MODE = new Map([...BLEND_MODE_TO_INDEX.entries()].map((e) => [e[1], e[0]])), VALID_RENDERING_MODES = /* @__PURE__ */ new Set(["2d", "3d"]), tempColor = C32.New(C32.Color);
  self.ILayer = class {
    #e;
    constructor(e) {
      this.#e = e;
      const t2 = [], r2 = e.GetEffectList(), i = r2.GetAllEffectTypes().length;
      for (let e2 = 0; e2 < i; ++e2) t2.push(new self.IEffectInstance(r2, e2));
      Object.defineProperties(this, { runtime: { value: e.GetRuntime().GetIRuntime(), writable: false }, name: { value: e.GetName(), writable: false }, layout: { value: e.GetLayout().GetILayout(), writable: false }, effects: { value: t2, writable: false } }), e.GetRuntime()._MapScriptInterface(this, e);
    }
    addEventListener(e, t2) {
      this.#e.UserScriptDispatcher().addEventListener(e, t2);
    }
    removeEventListener(e, t2) {
      this.#e.UserScriptDispatcher().removeEventListener(e, t2);
    }
    get parentLayer() {
      const e = this.#e.GetParentLayer();
      return e ? e.GetILayer() : null;
    }
    *parentLayers() {
      for (const e of this.#e.parentLayers()) yield e.GetILayer();
    }
    *subLayers() {
      for (const e of this.#e.GetSubLayers()) yield e.GetILayer();
    }
    *allSubLayers() {
      for (const e of this.#e.GetSubLayers()) for (const t2 of e.selfAndAllSubLayers()) yield t2.GetILayer();
    }
    get index() {
      return this.#e.GetIndex();
    }
    get isVisible() {
      return this.#e._IsVisibleFlagSet();
    }
    set isVisible(e) {
      this.#e.SetVisible(e);
    }
    get isSelfAndParentsVisible() {
      return this.#e.IsVisible();
    }
    get isInteractive() {
      return this.#e.IsInteractive();
    }
    set isInteractive(e) {
      this.#e.SetInteractive(e);
    }
    get isHTMLElementsLayer() {
      return this.#e.IsHTMLElementsLayer();
    }
    set isHTMLElementsLayer(e) {
      this.#e.SetIsHTMLElementsLayer(!!e);
    }
    get isSelfAndParentsInteractive() {
      return this.#e.IsSelfAndParentsInteractive();
    }
    get opacity() {
      return this.#e.GetOpacity();
    }
    set opacity(e) {
      e = C32.clamp(+e, 0, 1), isNaN(e) || this.#e.SetOpacity(e);
    }
    set scale(e) {
      C3X.RequireFiniteNumber(e), this.#e.SetOwnScale(e);
    }
    get scale() {
      return this.#e.GetOwnScale();
    }
    set scaleRate(e) {
      C3X.RequireFiniteNumber(e), this.#e.SetScaleRate(e);
    }
    get scaleRate() {
      return this.#e.GetScaleRate();
    }
    set angle(e) {
      C3X.RequireFiniteNumber(e), this.#e.SetAngle(e);
    }
    get angle() {
      return this.#e.GetOwnAngle();
    }
    set parallaxX(e) {
      C3X.RequireFiniteNumber(e), this.#e.SetParallaxX(e);
    }
    get parallaxX() {
      return this.#e.GetParallaxX();
    }
    set parallaxY(e) {
      C3X.RequireFiniteNumber(e), this.#e.SetParallaxY(e);
    }
    get parallaxY() {
      return this.#e.GetParallaxY();
    }
    set zElevation(e) {
      C3X.RequireFiniteNumber(e), this.#e.SetZElevation(e);
    }
    get zElevation() {
      return this.#e.GetZElevation();
    }
    set renderingMode(e) {
      if (!VALID_RENDERING_MODES.has(e)) throw TypeError("invalid rendering mode");
      this.#e.SetRenderAs3D("3d" === e);
    }
    get renderingMode() {
      return this.#e.IsRenderAs3D() ? "3d" : "2d";
    }
    set isTransparent(e) {
      this.#e.SetTransparent(e);
    }
    get isTransparent() {
      return this.#e.IsTransparent();
    }
    set isForceOwnTexture(e) {
      this.#e.SetForceOwnTexture(e);
    }
    get isForceOwnTexture() {
      return this.#e.IsForceOwnTexture();
    }
    set blendMode(e) {
      C3X.RequireString(e);
      const t2 = BLEND_MODE_TO_INDEX.get(e);
      if ("number" != typeof t2) throw new Error("invalid blend mode");
      this.#e.SetBlendMode(t2);
    }
    get blendMode() {
      return INDEX_TO_BLEND_MODE.get(this.#e.GetBlendMode());
    }
    set backgroundColor(e) {
      if (C3X.RequireArray(e), e.length < 3) throw new Error("expected 3 elements");
      tempColor.setRgb(e[0], e[1], e[2]);
      const t2 = this.#e, r2 = t2.GetBackgroundColor();
      r2.equalsIgnoringAlpha(tempColor) || (r2.copyRgb(tempColor), t2.GetRuntime().UpdateRender());
    }
    get backgroundColor() {
      const e = this.#e.GetBackgroundColor();
      return [e.getR(), e.getG(), e.getB()];
    }
    set scrollX(e) {
      C3X.RequireNumber(e);
      const t2 = this.#e;
      t2.SetOwnScrollPositionEnabled(true), t2.SetScrollX(e);
    }
    get scrollX() {
      return this.#e.GetScrollX();
    }
    set scrollY(e) {
      C3X.RequireNumber(e);
      const t2 = this.#e;
      t2.SetOwnScrollPositionEnabled(true), t2.SetScrollY(e);
    }
    get scrollY() {
      return this.#e.GetScrollY();
    }
    scrollTo(e, t2) {
      C3X.RequireNumber(e), C3X.RequireNumber(t2);
      const r2 = this.#e;
      r2.SetOwnScrollPositionEnabled(true), r2.SetScrollX(e), r2.SetScrollY(t2);
    }
    getScrollPosition() {
      const e = this.#e;
      return [e.GetScrollX(), e.GetScrollY()];
    }
    restoreScrollPosition() {
      this.#e.SetOwnScrollPositionEnabled(false);
    }
    getViewport() {
      return this.#e.GetViewport().toDOMRect();
    }
    cssPxToLayer(e, t2, r2 = 0) {
      C3X.RequireNumber(e), C3X.RequireNumber(t2), C3X.RequireNumber(r2);
      const i = this.#e, a2 = i.GetRuntime();
      return i.CanvasCssToLayer(e - a2.GetCanvasClientX(), t2 - a2.GetCanvasClientY(), r2);
    }
    layerToCssPx(e, t2, r2 = 0) {
      C3X.RequireNumber(e), C3X.RequireNumber(t2), C3X.RequireNumber(r2);
      const i = this.#e, a2 = i.GetRuntime(), [s, n] = i.LayerToCanvasCss(e, t2, r2);
      return [s + a2.GetCanvasClientX(), n + a2.GetCanvasClientY()];
    }
    drawSurfaceToLayer(e, t2, r2 = 0) {
      return C3X.RequireNumber(e), C3X.RequireNumber(t2), C3X.RequireNumber(r2), this.#e.DrawSurfaceToLayer(e, t2, r2);
    }
    layerToDrawSurface(e, t2, r2 = 0) {
      return C3X.RequireNumber(e), C3X.RequireNumber(t2), C3X.RequireNumber(r2), this.#e.LayerToDrawSurface(e, t2, r2);
    }
    get renderScale() {
      return this.#e.GetRenderScale();
    }
  };
}
{
  let GetDispatcher = function(e) {
    let t2 = dispatchers.get(e);
    return t2 || (t2 = C32.New(C32.Event.Dispatcher), dispatchers.set(e, t2), t2);
  };
  GetDispatcher2 = GetDispatcher;
  const C32 = self.C3, C3X = self.C3X, dispatchers = /* @__PURE__ */ new WeakMap(), internalApiToken = C32._GetInternalAPIToken();
  self.IInstance = class {
    #e;
    constructor() {
      const e = C32.AddonManager._GetInitObject2(internalApiToken);
      this.#e = e;
      const t2 = { runtime: { value: e.GetRuntime().GetIRuntime(), writable: false }, objectType: { value: e.GetObjectClass().GetIObjectClass(), writable: false }, plugin: { value: e.GetPlugin().GetIPlugin(), writable: false } };
      e._GetInstVarsScriptDescriptor(t2), e._GetBehaviorsScriptDescriptor(t2), Object.defineProperties(this, t2), e.GetRuntime()._MapScriptInterface(this, e);
    }
    static _GetInitInst() {
      return C32.AddonManager._GetInitObject();
    }
    _release() {
      const e = dispatchers.get(this);
      e && (e.Release(), dispatchers.delete(this));
    }
    addEventListener(e, t2, i) {
      C3X.RequireString(e), C3X.RequireFunction(t2), GetDispatcher(this).addEventListener(e, t2, i);
    }
    removeEventListener(e, t2, i) {
      C3X.RequireString(e), C3X.RequireFunction(t2), GetDispatcher(this).removeEventListener(e, t2, i);
    }
    dispatchEvent(e) {
      GetDispatcher(this).dispatchEvent(e);
    }
    destroy() {
      const e = this.#e, t2 = e.GetRuntime();
      t2.DestroyInstance(e), t2.GetEventSheetManager().IsInEventEngine() || t2.GetLayoutManager().IsEndingLayout() || t2.GetEventSheetManager().IsFlushingBlocked() || t2.FlushPendingInstances();
    }
    getOtherContainerInstances() {
      const e = this.#e.GetSiblings();
      return e ? e.map((e2) => e2.GetInterfaceClass()) : [];
    }
    *otherContainerInstances() {
      const e = this.#e;
      if (e.IsInContainer()) for (const t2 of e.siblings()) yield t2.GetInterfaceClass();
    }
    get uid() {
      return this.#e.GetUID();
    }
    get iid() {
      return this.#e.GetIID();
    }
    get templateName() {
      return this.#e.GetTemplateName();
    }
    set timeScale(e) {
      C3X.RequireFiniteNumber(e), this.#e.SetTimeScale(e);
    }
    get timeScale() {
      return this.#e.GetActiveTimeScale();
    }
    restoreTimeScale() {
      this.#e.RestoreTimeScale();
    }
    get dt() {
      const e = this.#e;
      return e.GetRuntime().GetDt(e);
    }
    hasTags(...e) {
      C3X.RequireArray(e);
      const t2 = new Set(e), i = this.#e.GetTagsSet();
      return t2.isSubsetOf(i);
    }
    setAllTags(e) {
      C3X.RequireInstanceOf(e, Set), this.#e.SetTagsSet(e);
    }
    getAllTags() {
      return new Set(this.#e.GetTagsSet());
    }
    signal(e) {
      C3X.RequireString(e);
      const t2 = this.#e;
      t2.GetRuntime().GetEventSheetManager().InstanceSignal(t2, e);
    }
    waitForSignal(e) {
      C3X.RequireString(e);
      const t2 = this.#e;
      return t2.GetRuntime().GetEventSheetManager().WaitForInstanceSignal(t2, e);
    }
  };
}
var GetDispatcher2;
{
  const C32 = self.C3, C3X = self.C3X, internalApiToken = C32._GetInternalAPIToken();
  self.ISDKInstanceBase = class extends self.IInstance {
    #e;
    #t = false;
    #n = null;
    #i = false;
    #r = null;
    #s;
    #o;
    constructor(e) {
      super(), this.#e = C32.AddonManager._GetInitObject2(internalApiToken), this.#t = false, this.#n = null, this.#i = false, this.#r = null, this.#s = e?.domComponentId, this.#o = e?.wrapperComponentId;
    }
    _release() {
      this._setTicking(false), this._setTicking2(false), super._release();
    }
    _getInitProperties() {
      return C32.AddonManager._GetInitProperties();
    }
    _trigger(e) {
      const t2 = this.#e;
      t2.GetRuntime().Trigger(e, t2);
    }
    _triggerAsync(e) {
      const t2 = this.#e;
      return t2.GetRuntime().TriggerAsync(e, t2);
    }
    _addDOMMessageHandler(e, t2) {
      if (C3X.RequireString(e), C3X.RequireFunction(t2), !this.#s) throw new Error("no DOM component id set");
      this.#e.GetRuntime().AddDOMComponentMessageHandler(this.#s, e, t2);
    }
    _addDOMMessageHandlers(e) {
      C3X.RequireArray(e);
      for (const [t2, n] of e) this._addDOMMessageHandler(t2, n);
    }
    _postToDOM(e, t2) {
      if (C3X.RequireString(e), !this.#s) throw new Error("no DOM component id set");
      this.#e.GetRuntime().PostComponentMessageToDOM(this.#s, e, t2);
    }
    _postToDOMAsync(e, t2) {
      if (C3X.RequireString(e), !this.#s) throw new Error("no DOM component id set");
      return this.#e.GetRuntime().PostComponentMessageToDOMAsync(this.#s, e, t2);
    }
    _postToDOMMaybeSync(e, t2) {
      if (!this.#e.GetRuntime().IsInWorker()) return window["c3_runtimeInterface"]["_OnMessageFromRuntime"]({ "type": "event", "component": this.#s, "handler": e, "data": t2, "responseId": null });
      this._postToDOM(e, t2);
    }
    _setTicking(e) {
      if (e = !!e, this.#t === e) return;
      this.#t = e;
      const t2 = this.#e.GetRuntime();
      if (e) {
        if (!this.#n) if (this.#e.GetRuntime().IsDebug()) {
          const e2 = globalThis.C3Debugger, t3 = this.plugin;
          this.#n = () => {
            const n = performance.now();
            this._tick(), e2.AddIndividualPluginTickTime(t3, performance.now() - n);
          };
        } else this.#n = () => this._tick();
        t2.Dispatcher().addEventListener("tick", this.#n);
      } else t2.Dispatcher().removeEventListener("tick", this.#n);
    }
    _isTicking() {
      return this.#t;
    }
    _tick() {
    }
    _setTicking2(e) {
      if (e = !!e, this.#i === e) return;
      this.#i = e;
      const t2 = this.#e.GetRuntime();
      if (e) {
        if (!this.#r) if (this.#e.GetRuntime().IsDebug()) {
          const e2 = globalThis.C3Debugger, t3 = this.plugin;
          this.#r = () => {
            const n = performance.now();
            this._tick2(), e2.AddIndividualPluginTickTime(t3, performance.now() - n);
          };
        } else this.#r = () => this._tick2();
        t2.Dispatcher().addEventListener("tick2", this.#r);
      } else t2.Dispatcher().removeEventListener("tick2", this.#r);
    }
    _isTicking2() {
      return this.#i;
    }
    _tick2() {
    }
    _getDebuggerProperties() {
      return [];
    }
    _saveToJson() {
      return null;
    }
    _loadFromJson(e) {
    }
    _isWrapperExtensionAvailable() {
      if (!this.#o) throw new Error("no wrapper component id set");
      return this.#e.GetRuntime().HasWrapperComponentId(this.#o);
    }
    _addWrapperExtensionMessageHandler(e, t2) {
      if (C3X.RequireString(e), C3X.RequireFunction(t2), !this.#o) throw new Error("no wrapper component id set");
      this.#e.GetRuntime().AddWrapperExtensionMessageHandler(this.#o, e, t2);
    }
    _addWrapperMessageHandlers(e) {
      C3X.RequireArray(e);
      for (const [t2, n] of e) this._addWrapperExtensionMessageHandler(t2, n);
    }
    _sendWrapperExtensionMessage(e, t2) {
      if (!this.#o) throw new Error("no wrapper component id set");
      this.runtime.sdk.sendWrapperExtensionMessage(this.#o, e, t2);
    }
    _sendWrapperExtensionMessageAsync(e, t2) {
      if (!this.#o) throw new Error("no wrapper component id set");
      return this.runtime.sdk.sendWrapperExtensionMessageAsync(this.#o, e, t2);
    }
  };
}
{
  let MakeIWorldInstanceClass = function(e) {
    return class t2 extends e {
      #e;
      #t;
      constructor(e2) {
        super(e2);
        const t3 = C32.AddonManager._GetInitObject2(internalApiToken), i = t3.GetWorldInfo();
        this.#e = t3, this.#t = i, map.set(this, t3);
        const n = [], r2 = i.GetInstanceEffectList();
        if (r2) {
          const e3 = i.GetObjectClass().GetEffectList().GetAllEffectTypes().length;
          for (let t4 = 0; t4 < e3; ++t4) n.push(new self.IEffectInstance(r2, t4));
        }
        const s = { effects: { value: n, writable: false } };
        Object.defineProperties(this, s);
      }
      get layout() {
        return this.#t.GetLayout().GetILayout();
      }
      get layer() {
        return this.#t.GetLayer().GetILayer();
      }
      get x() {
        return this.#t.GetX();
      }
      set x(e2) {
        e2 = +e2;
        const t3 = this.#t;
        isNaN(e2) || t3.GetX() === e2 || (t3.SetX(e2), t3.SetBboxChanged());
      }
      get y() {
        return this.#t.GetY();
      }
      set y(e2) {
        e2 = +e2;
        const t3 = this.#t;
        isNaN(e2) || t3.GetY() === e2 || (t3.SetY(e2), t3.SetBboxChanged());
      }
      setPosition(e2, t3) {
        e2 = +e2, t3 = +t3;
        const i = this.#t;
        isNaN(e2) || isNaN(t3) || i.GetX() === e2 && i.GetY() === t3 || (i.SetXY(e2, t3), i.SetBboxChanged());
      }
      getPosition() {
        const e2 = this.#t;
        return [e2.GetX(), e2.GetY()];
      }
      offsetPosition(e2, t3) {
        if (e2 = +e2, t3 = +t3, isNaN(e2) || isNaN(t3) || 0 === e2 && 0 === t3) return;
        const i = this.#t;
        i.OffsetXY(e2, t3), i.SetBboxChanged();
      }
      set originX(e2) {
        e2 = +e2;
        const t3 = this.#t;
        isNaN(e2) || t3.GetOriginX() === e2 || (t3.SetOriginX(e2), t3.SetBboxChanged());
      }
      get originX() {
        return this.#t.GetOriginX();
      }
      set originY(e2) {
        e2 = +e2;
        const t3 = this.#t;
        isNaN(e2) || t3.GetOriginY() === e2 || (t3.SetOriginY(e2), t3.SetBboxChanged());
      }
      get originY() {
        return this.#t.GetOriginY();
      }
      setOrigin(e2, t3) {
        e2 = +e2, t3 = +t3;
        const i = this.#t;
        isNaN(e2) || isNaN(t3) || i.GetOriginX() === e2 && i.GetOriginY() === t3 || (i.SetOriginX(e2), i.SetOriginY(t3), i.SetBboxChanged());
      }
      getOrigin() {
        const e2 = this.#t;
        return [e2.GetOriginX(), e2.GetOriginY()];
      }
      get zElevation() {
        return this.#t.GetZElevation();
      }
      set zElevation(e2) {
        e2 = +e2;
        const t3 = this.#e, i = this.#t;
        isNaN(e2) || i.GetZElevation() === e2 || (i.SetZElevation(e2), t3.GetRuntime().UpdateRender());
      }
      get totalZElevation() {
        return this.#t.GetTotalZElevation();
      }
      get width() {
        return this.#t.GetWidth();
      }
      set width(e2) {
        e2 = +e2;
        const t3 = this.#t;
        isNaN(e2) || t3.GetWidth() === e2 || (t3.SetWidth(e2), t3.SetBboxChanged());
      }
      get height() {
        return this.#t.GetHeight();
      }
      set height(e2) {
        e2 = +e2;
        const t3 = this.#t;
        isNaN(e2) || t3.GetHeight() === e2 || (t3.SetHeight(e2), t3.SetBboxChanged());
      }
      setSize(e2, t3) {
        e2 = +e2, t3 = +t3;
        const i = this.#t;
        isNaN(e2) || isNaN(t3) || i.GetWidth() === e2 && i.GetHeight() === t3 || (i.SetSize(e2, t3), i.SetBboxChanged());
      }
      getSize() {
        const e2 = this.#t;
        return [e2.GetWidth(), e2.GetHeight()];
      }
      get angle() {
        return this.#t.GetAngle();
      }
      set angle(e2) {
        e2 = C32.clampAngle(+e2);
        const t3 = this.#t;
        isNaN(e2) || t3.GetAngle() === e2 || (t3.SetAngle(e2), t3.SetBboxChanged());
      }
      get angleDegrees() {
        return C32.toDegrees(this.angle);
      }
      set angleDegrees(e2) {
        this.angle = C32.toRadians(e2);
      }
      getBoundingBox(e2) {
        return e2 ? (this.#t.CalculateBbox(tempRect, tempQuad, false), tempRect.toDOMRect()) : this.#t.GetBoundingBox().toDOMRect();
      }
      getBoundingQuad(e2) {
        return e2 ? (this.#t.CalculateBbox(tempRect, tempQuad, false), tempQuad.toDOMQuad()) : this.#t.GetBoundingQuad().toDOMQuad();
      }
      isOnScreen() {
        return this.#t.IsInViewport2();
      }
      get isVisible() {
        return this.#t.IsVisible();
      }
      set isVisible(e2) {
        e2 = !!e2;
        const t3 = this.#e, i = this.#t;
        i.IsVisible() !== e2 && (i.SetVisible(e2), t3.GetRuntime().UpdateRender());
      }
      get opacity() {
        return this.#t.GetOpacity();
      }
      set opacity(e2) {
        e2 = C32.clamp(+e2, 0, 1);
        const t3 = this.#e, i = this.#t;
        isNaN(e2) || i.GetOpacity() === e2 || (i.SetOpacity(e2), t3.GetRuntime().UpdateRender());
      }
      set colorRgb(e2) {
        if (C3X.RequireArray(e2), e2.length < 3) throw new Error("expected 3 elements");
        tempColor.setRgb(e2[0], e2[1], e2[2]);
        const t3 = this.#e, i = this.#t;
        i.GetUnpremultipliedColor().equalsIgnoringAlpha(tempColor) || (i.SetUnpremultipliedColor(tempColor), t3.GetRuntime().UpdateRender());
      }
      get colorRgb() {
        const e2 = this.#t.GetUnpremultipliedColor();
        return [e2.getR(), e2.getG(), e2.getB()];
      }
      set blendMode(e2) {
        C3X.RequireString(e2);
        const t3 = BLEND_MODE_TO_INDEX.get(e2);
        if ("number" != typeof t3) throw new Error("invalid blend mode");
        const i = this.#e;
        this.#t.SetBlendMode(t3), i.GetRuntime().UpdateRender();
      }
      get blendMode() {
        return INDEX_TO_BLEND_MODE.get(this.#t.GetBlendMode());
      }
      moveToTop() {
        this.#t.ZOrderMoveToTop();
      }
      moveToBottom() {
        this.#t.ZOrderMoveToBottom();
      }
      moveToLayer(e2) {
        C3X.RequireInstanceOf(e2, ILayer);
        const t3 = this.#e, i = t3.GetRuntime()._UnwrapScriptInterface(e2);
        if (!i) throw new Error("invalid layer");
        t3.GetWorldInfo().ZOrderMoveToLayer(i);
      }
      moveAdjacentToInstance(e2, i) {
        C3X.RequireInstanceOf(e2, t2), this.#t.ZOrderMoveAdjacentToInstance(map.get(e2), i);
      }
      get zIndex() {
        return this.#t.GetZIndex();
      }
      get isCollisionEnabled() {
        return this.#t.IsCollisionEnabled();
      }
      set isCollisionEnabled(e2) {
        this.#t.SetCollisionEnabled(!!e2);
      }
      containsPoint(e2, t3) {
        return C3X.RequireNumber(e2), C3X.RequireNumber(t3), this.#t.ContainsPoint(+e2, +t3);
      }
      testOverlap(e2) {
        C3X.RequireInstanceOf(e2, t2);
        const i = this.#e, n = map.get(e2);
        return i.GetRuntime().GetCollisionEngine().TestOverlap(i, n);
      }
      testOverlapSolid() {
        const e2 = this.#e, t3 = e2.GetRuntime().GetCollisionEngine().TestOverlapSolid(e2);
        return t3 ? t3.GetInterfaceClass() : null;
      }
      getParent() {
        const e2 = this.#e.GetParent();
        return e2 ? e2.GetInterfaceClass() : null;
      }
      getTopParent() {
        const e2 = this.#e.GetTopParent();
        return e2 ? e2.GetInterfaceClass() : null;
      }
      *parents() {
        for (const e2 of this.#e.parents()) yield e2.GetInterfaceClass();
      }
      getChildCount() {
        return this.#e.GetChildCount();
      }
      getChildAt(e2) {
        const t3 = this.#e.GetChildAt(e2);
        return t3 ? t3.GetInterfaceClass() : null;
      }
      *children() {
        for (const e2 of this.#e.children()) yield e2.GetInterfaceClass();
      }
      *allChildren() {
        for (const e2 of this.#e.allChildren()) yield e2.GetInterfaceClass();
      }
      addChild(e2, i) {
        C3X.RequireInstanceOf(e2, t2), C3X.RequireOptionalObject(i), i || (i = {});
        const n = this.#e, r2 = map.get(e2);
        n.AddChild(r2, i);
      }
      removeChild(e2) {
        C3X.RequireInstanceOf(e2, t2);
        const i = this.#e, n = map.get(e2);
        i.RemoveChild(n);
      }
      removeFromParent() {
        const e2 = this.#e;
        if (!e2.HasParent()) return;
        e2.GetParent().RemoveChild(e2);
      }
      getHierarchyOpts() {
        const e2 = this.#t;
        return { transformX: e2.GetTransformWithParentX(), transformY: e2.GetTransformWithParentY(), transformWidth: e2.GetTransformWithParentWidth(), transformHeight: e2.GetTransformWithParentHeight(), transformAngle: e2.GetTransformWithParentAngle(), transformZElevation: e2.GetTransformWithParentZElevation(), transformOpacity: e2.GetTransformWithParentOpacity(), transformVisibility: e2.GetTransformWithParentVisibility(), destroyWithParent: e2.GetDestroyWithParent() };
      }
      createMesh(e2, t3) {
        C3X.RequireFiniteNumber(e2), C3X.RequireFiniteNumber(t3), this.#t.CreateMesh(e2, t3);
      }
      releaseMesh() {
        const e2 = this.#t;
        e2.ReleaseMesh(), e2.SetBboxChanged();
      }
      setMeshPoint(e2, t3, i) {
        C3X.RequireFiniteNumber(e2), C3X.RequireFiniteNumber(t3), C3X.RequireObject(i);
        const n = this.#t;
        n.SetMeshPoint(e2, t3, i) && n.SetBboxChanged();
      }
      getMeshPoint(e2, t3) {
        let i = NaN, n = NaN, r2 = NaN, s = NaN, a2 = NaN;
        const o2 = this.#t;
        if (o2.HasMesh()) {
          const l = o2.GetSourceMesh().GetMeshPointAt(e2, t3);
          null !== l && (i = l.GetX(), n = l.GetY(), r2 = l.GetZElevation(), s = l.GetU(), a2 = l.GetV());
        }
        return { x: i, y: n, zElevation: r2, u: s, v: a2 };
      }
      getMeshSize() {
        const e2 = this.#t;
        if (!e2.HasMesh()) return [0, 0];
        const t3 = e2.GetSourceMesh();
        return [t3.GetHSize(), t3.GetVSize()];
      }
    };
  };
  MakeIWorldInstanceClass2 = MakeIWorldInstanceClass;
  const C32 = self.C3, C3X = self.C3X, IInstance = self.IInstance, ILayer = self.ILayer, tempRect = C32.New(C32.Rect), tempQuad = C32.New(C32.Quad), map = /* @__PURE__ */ new WeakMap(), internalApiToken = C32._GetInternalAPIToken(), BLEND_MODE_TO_INDEX = /* @__PURE__ */ new Map([["normal", 0], ["additive", 1], ["copy", 3], ["destination-over", 4], ["source-in", 5], ["destination-in", 6], ["source-out", 7], ["destination-out", 8], ["source-atop", 9], ["destination-atop", 10]]), INDEX_TO_BLEND_MODE = new Map([...BLEND_MODE_TO_INDEX.entries()].map((e) => [e[1], e[0]])), tempColor = C32.New(C32.Color);
  self.IWorldInstance = MakeIWorldInstanceClass(self.IInstance), self.IWorldInstanceSDKBase = MakeIWorldInstanceClass(self.ISDKInstanceBase);
}
var MakeIWorldInstanceClass2;
{
  const C32 = self.C3, C3X = self.C3X;
  self.IDOMInstance = class extends self.IWorldInstance {
    #e;
    constructor() {
      super(), this.#e = self.IInstance._GetInitInst();
    }
    getElement() {
      return this.#e.GetSdkInstance()._GetElementInDOMMode();
    }
    focus() {
      this.#e.GetSdkInstance().FocusElement();
    }
    blur() {
      this.#e.GetSdkInstance().BlurElement();
    }
    setCssStyle(e, t2) {
      C3X.RequireString(e), this.#e.GetSdkInstance().SetElementCSSStyle(e, t2);
    }
  };
}
{
  let GetDispatcher = function(e) {
    let t2 = dispatchers.get(e);
    return t2 || (t2 = C32.New(C32.Event.Dispatcher), dispatchers.set(e, t2), t2);
  };
  GetDispatcher2 = GetDispatcher;
  const C32 = self.C3, C3X = self.C3X, dispatchers = /* @__PURE__ */ new WeakMap(), internalApiToken = C32._GetInternalAPIToken();
  self.IBehaviorInstance = class {
    #e;
    constructor() {
      const e = C32.AddonManager._GetInitObject2(internalApiToken);
      this.#e = e;
      const t2 = { runtime: { value: e.GetRuntime().GetIRuntime(), writable: false }, behavior: { value: e.GetBehavior().GetIBehavior(), writable: false }, behaviorType: { value: e.GetBehaviorType().GetIBehaviorType(), writable: false } };
      Object.defineProperties(this, t2), e.GetRuntime()._MapScriptInterface(this, e);
    }
    static _GetInitInst() {
      return C32.AddonManager._GetInitObject();
    }
    get instance() {
      return this.#e.GetObjectInstance().GetInterfaceClass();
    }
    _release() {
      const e = dispatchers.get(this);
      e && (e.Release(), dispatchers.delete(this));
    }
    addEventListener(e, t2, i) {
      C3X.RequireString(e), C3X.RequireFunction(t2), GetDispatcher(this).addEventListener(e, t2, i);
    }
    removeEventListener(e, t2, i) {
      C3X.RequireString(e), C3X.RequireFunction(t2), GetDispatcher(this).removeEventListener(e, t2, i);
    }
    dispatchEvent(e) {
      GetDispatcher(this).dispatchEvent(e);
    }
  };
}
var GetDispatcher2;
{
  const C32 = self.C3, C3X = self.C3X, internalApiToken = C32._GetInternalAPIToken();
  self.IBehaviorType = class {
    constructor() {
      const e = C32.AddonManager._GetInitObject2(internalApiToken), t2 = { runtime: { value: e.GetRuntime().GetIRuntime(), writable: false }, behavior: { value: e.GetBehavior().GetIBehavior(), writable: false }, name: { value: e.GetName(), writable: false } };
      Object.defineProperties(this, t2);
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X, internalApiToken = C32._GetInternalAPIToken();
  self.IBehavior = class {
    #t;
    constructor() {
      const t2 = C32.AddonManager._GetInitObject2(internalApiToken);
      this.#t = t2;
      const e = { runtime: { value: t2.GetRuntime().GetIRuntime(), writable: false }, id: { value: t2.GetID(), writable: false } };
      Object.defineProperties(this, e), t2.GetRuntime()._MapScriptInterface(this, t2);
    }
    getAllInstances() {
      return this.#t.GetInstances().map((t2) => t2.GetInterfaceClass());
    }
    static getByConstructor(t2) {
      if (!t2) return null;
      const e = C32.AddonManager.GetBehaviorByConstructorFunction(t2);
      return e ? e.GetIBehavior() : null;
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X, tempColor = C32.New(C32.Color);
  self.IEffectInstance = class {
    #e;
    constructor(e, t2) {
      this.#e = e;
      const i = { index: { value: t2, writable: false } };
      Object.defineProperties(this, i);
    }
    get name() {
      return this.#e.GetAllEffectTypes()[this.index].GetName();
    }
    get isActive() {
      return this.#e.IsEffectIndexActive(this.index);
    }
    set isActive(e) {
      e = !!e;
      const t2 = this.#e;
      t2.IsEffectIndexActive(this.index) !== e && (t2.SetEffectIndexActive(this.index, e), t2.UpdateActiveEffects(), t2.GetRuntime().UpdateRender());
    }
    setParameter(e, t2) {
      C3X.RequireFiniteNumber(e), e = Math.floor(+e);
      const i = this.#e, r2 = i.GetEffectParameter(this.index, e);
      if (null === r2) throw new RangeError("invalid index");
      if (r2 instanceof C32.Color) {
        if (!Array.isArray(t2) || t2.length < 3) throw new TypeError("expected array with 3 elements");
        tempColor.setRgb(t2[0], t2[1], t2[2]), t2 = tempColor;
      } else if ("number" != typeof t2) throw new TypeError("expected number");
      i.SetEffectParameter(this.index, e, t2) && i.IsEffectIndexActive(this.index) && i.GetRuntime().UpdateRender();
    }
    getParameter(e) {
      C3X.RequireFiniteNumber(e), e = Math.floor(+e);
      const t2 = this.#e.GetEffectParameter(this.index, e);
      if (null === t2) throw new RangeError("invalid index");
      return t2 instanceof C32.Color ? [t2.getR(), t2.getG(), t2.getB()] : t2;
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X;
  self.IAnimation = class {
    #e;
    constructor(e) {
      this.#e = e, Object.defineProperties(this, { name: { value: e.GetName(), writable: false } });
    }
    get speed() {
      return this.#e.GetSpeed();
    }
    get isLooping() {
      return this.#e.IsLooping();
    }
    get repeatCount() {
      return this.#e.GetRepeatCount();
    }
    get repeatTo() {
      return this.#e.GetRepeatTo();
    }
    get isPingPong() {
      return this.#e.IsPingPong();
    }
    get frameCount() {
      return this.#e.GetFrameCount();
    }
    getFrames() {
      return this.#e.GetFrames().map((e) => e.GetIAnimationFrame());
    }
    *frames() {
      for (const e of this.#e.GetFrames()) yield e.GetIAnimationFrame();
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X;
  self.IImageInfo = class {
    #t;
    constructor(t2) {
      this.#t = t2;
    }
    static _Unwrap(t2) {
      return t2.#t;
    }
    get width() {
      return this.#t.GetWidth();
    }
    get height() {
      return this.#t.GetHeight();
    }
    getSize() {
      const t2 = this.#t;
      return [t2.GetWidth(), t2.GetHeight()];
    }
    getTexture(t2) {
      return t2.getTextureForImageInfo(this);
    }
    getTexRect() {
      return this.#t.GetTexRect().toDOMRect();
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X;
  self.IAnimationFrame = class extends self.IImageInfo {
    #t;
    constructor(t2) {
      super(t2.GetImageInfo()), this.#t = t2, Object.defineProperties(this, { duration: { value: t2.GetDuration(), writable: false }, originX: { value: t2.GetOriginX(), writable: false }, originY: { value: t2.GetOriginY(), writable: false } });
    }
    getOrigin() {
      const t2 = this.#t;
      return [t2.GetOriginX(), t2.GetOriginY()];
    }
    getImagePointCount() {
      return this.#t.GetImagePointCount();
    }
    getImagePointX(t2) {
      return this.getImagePoint(t2)[0];
    }
    getImagePointY(t2) {
      return this.getImagePoint(t2)[1];
    }
    getImagePoint(t2) {
      const e = this.#t;
      let i = null;
      if ("number" == typeof t2) i = e.GetImagePointByIndex(Math.floor(t2));
      else {
        if ("string" != typeof t2) throw new TypeError("expected string or number");
        i = e.GetImagePointByName(t2);
      }
      return i ? [i.GetX(), i.GetY()] : this.getOrigin();
    }
    getPolyPointCount() {
      const t2 = this.#t.GetCollisionPoly();
      return t2 ? t2.pointCount() : 0;
    }
    getPolyPointX(t2) {
      return this.getPolyPoint(t2)[0];
    }
    getPolyPointY(t2) {
      return this.getPolyPoint(t2)[1];
    }
    getPolyPoint(t2) {
      C3X.RequireFiniteNumber(t2), t2 = Math.floor(t2);
      const e = this.#t.GetCollisionPoly();
      if (!e || t2 < 0 || t2 >= e.pointCount()) return [0, 0];
      const i = e.pointsArr();
      return [i[2 * t2], i[2 * t2 + 1]];
    }
    get tag() {
      return this.#t.GetTag();
    }
  };
}
{
  let GetTimelineState = function(e) {
    const t2 = map.get(e);
    if (t2.IsReleased()) throw new Error("timeline/tween was released and is no longer valid");
    return t2;
  };
  GetTimelineState2 = GetTimelineState;
  const C32 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap();
  self.ITimelineStateBase = class {
    constructor(e) {
      map.set(this, e), e.GetRuntime()._MapScriptInterface(this, e);
    }
    pause() {
      GetTimelineState(this).Stop();
    }
    resume() {
      GetTimelineState(this).Resume();
    }
    stop() {
      GetTimelineState(this).Reset();
    }
    hasTags(e) {
      return GetTimelineState(this).HasTags(e);
    }
    set time(e) {
      C3X.RequireFiniteNumber(e), GetTimelineState(this).SetTime(e);
    }
    get time() {
      return GetTimelineState(this).GetTime();
    }
    set totalTime(e) {
      C3X.RequireFiniteNumber(e), GetTimelineState(this).SetTotalTime(e);
    }
    get totalTime() {
      return GetTimelineState(this).GetTotalTime();
    }
    set isLooping(e) {
      GetTimelineState(this).SetLoop(!!e);
    }
    get isLooping() {
      return GetTimelineState(this).GetLoop();
    }
    set isPingPong(e) {
      GetTimelineState(this).SetPingPong(!!e);
    }
    get isPingPong() {
      return GetTimelineState(this).GetPingPong();
    }
    set playbackRate(e) {
      C3X.RequireFiniteNumber(e), GetTimelineState(this).SetPlaybackRate(e);
    }
    get playbackRate() {
      return GetTimelineState(this).GetPlaybackRate();
    }
    get progress() {
      const e = GetTimelineState(this);
      return e.GetTime() / e.GetTotalTime();
    }
    get tags() {
      return GetTimelineState(this).GetTags();
    }
    get finished() {
      return GetTimelineState(this).GetPlayPromise();
    }
    get isPlaying() {
      return GetTimelineState(this).IsPlaying();
    }
    get isPaused() {
      return GetTimelineState(this).IsPaused();
    }
    get isReleased() {
      return map.get(this).IsReleased();
    }
  };
}
var GetTimelineState2;
{
  let GetTimelineState = function(e) {
    const t2 = map.get(e);
    if (t2.IsReleased()) throw new Error("timeline was released and is no longer valid");
    return t2;
  };
  GetTimelineState2 = GetTimelineState;
  const C32 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap();
  let easeToIndexFunc = null;
  self.ITimelineState = class extends self.ITimelineStateBase {
    constructor(e) {
      super(e), map.set(this, e);
      const t2 = { name: { value: e.GetName(), writable: false } };
      Object.defineProperties(this, t2);
    }
  };
}
var GetTimelineState2;
{
  let GetTweenState = function(e) {
    const t2 = map.get(e);
    if (t2.IsReleased()) throw new Error("tween was released and is no longer valid");
    return t2;
  };
  GetTweenState2 = GetTweenState;
  const C32 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap(), behInstMap = /* @__PURE__ */ new WeakMap();
  let easeToIndexFunc = null;
  self.ITweenState = class extends self.ITimelineStateBase {
    constructor(e, t2, n) {
      super(e), easeToIndexFunc || (easeToIndexFunc = n.easeToIndexFunc), map.set(this, e), t2 && behInstMap.set(this, t2);
    }
    stop() {
      const e = GetTweenState(this);
      behInstMap.get(this).ReleaseTween(e);
    }
    setEase(e) {
      C3X.RequireString(e);
      const t2 = self.Ease.GetEaseFromIndex(easeToIndexFunc(e));
      GetTweenState(this).SetEase(t2);
    }
    get instance() {
      const e = GetTweenState(this).GetInstance();
      return e ? e.GetInterfaceClass() : null;
    }
    get isDestroyOnComplete() {
      return GetTweenState(this).GetDestroyInstanceOnComplete();
    }
    set isDestroyOnComplete(e) {
      GetTweenState(this).SetDestroyInstanceOnComplete(!!e);
    }
    get finished() {
      const e = GetTweenState(this);
      return e.GetPlayPromise().then(() => new Promise((t2) => {
        e.IsComplete() && t2();
      }));
    }
    get released() {
      return GetTweenState(this).GetReleasePromise();
    }
    get value() {
      const e = GetTweenState(this);
      if ("value" !== e.GetId()) throw new Error("not a value tween");
      return e.GetPropertyTrack("value").GetSourceAdapterValue();
    }
  };
}
var GetTweenState2;
{
  const C32 = self.C3, C3X = self.C3X;
  self.ISDKPluginBase = class extends self.IPlugin {
    constructor() {
      super();
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X, internalApiToken = C32._GetInternalAPIToken();
  self.ISDKDOMPluginBase = class extends self.ISDKPluginBase {
    #e;
    #n;
    #t = 0;
    #s = /* @__PURE__ */ new Map();
    constructor(e) {
      if (super(), this.#e = C32.AddonManager._GetInitObject2(internalApiToken), !e?.domComponentId) throw new Error("no DOM component ID specified");
      this.#n = e.domComponentId, this._addElementMessageHandler("elem-focused", (e2) => e2._onElemFocused()), this._addElementMessageHandler("elem-blurred", (e2) => {
        e2 && e2._onElemBlurred();
      });
    }
    _addElement(e) {
      const n = this.#t++;
      return this.#s.set(n, e), n;
    }
    _removeElement(e) {
      this.#s.delete(e);
    }
    _addElementMessageHandler(e, n) {
      this.#e.GetRuntime().AddDOMComponentMessageHandler(this.#n, e, (e2) => {
        const t2 = this.#s.get(e2["elementId"]);
        n(t2, e2);
      });
    }
    _addElementMessageHandlers(e) {
      C3X.RequireArray(e);
      for (const [n, t2] of e) this._addElementMessageHandlers(n, t2);
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap(), internalApiToken = C32._GetInternalAPIToken();
  self.ISDKObjectTypeBase = class extends self.IObjectType {
    #e;
    constructor() {
      super(), this.#e = C32.AddonManager._GetInitObject2(internalApiToken);
    }
    _onCreate() {
    }
    getImageInfo() {
      return this.#e.GetImageInfo().GetIImageInfo();
    }
    _loadTextures(e) {
    }
    _releaseTextures(e) {
    }
    _onDynamicTextureLoadComplete() {
    }
    _preloadTexturesWithInstances(e) {
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap(), internalApiToken = C32._GetInternalAPIToken();
  self.ISDKWorldInstanceBase = class extends self.IWorldInstanceSDKBase {
    #e;
    #r = null;
    #t = null;
    constructor(e) {
      super(e), this.#e = C32.AddonManager._GetInitObject2(internalApiToken);
    }
    _release() {
      if (super._release(), this.#r) {
        const e = this.#e.GetRuntime().Dispatcher();
        e.removeEventListener("renderercontextlost", this.#r), e.removeEventListener("renderercontextrestored", this.#t), this.#r = null, this.#t = null;
      }
    }
    _handleRendererContextLoss() {
      if (this.#r) return;
      this.#r = () => this._onRendererContextLost(), this.#t = () => this._onRendererContextRestored();
      const e = this.#e.GetRuntime().Dispatcher();
      e.addEventListener("renderercontextlost", this.#r), e.addEventListener("renderercontextrestored", this.#t);
    }
    _onRendererContextLost() {
    }
    _onRendererContextRestored() {
    }
    _draw(e) {
    }
    _rendersToOwnZPlane() {
      return true;
    }
    _mustPreDraw() {
      return false;
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X, tempRect = C32.New(C32.Rect), map = /* @__PURE__ */ new WeakMap(), internalApiToken = C32._GetInternalAPIToken();
  self.ISDKDOMInstanceBase = class extends self.ISDKWorldInstanceBase {
    #e = -1;
    #t = true;
    #s = false;
    #i = false;
    #n = -0.2;
    #o = C32.New(C32.Rect, 0, 0, -1, -1);
    #l = 0;
    #a = 0;
    #h = -1;
    #d = -1;
    #m = false;
    constructor(e) {
      if (!e?.domComponentId) throw new Error("no DOM component ID specified");
      super(e);
      const t2 = C32.AddonManager._GetInitObject2(internalApiToken);
      map.set(this, t2), this.#e = this.plugin._addElement(this);
      const s = t2.GetRuntime().GetCanvasManager();
      this.#l = s.GetLastWidth(), this.#a = s.GetLastHeight(), this._setTicking(true);
    }
    _release() {
      super._release(), this.plugin._removeElement(this.#e), this._postToDOMElement("destroy"), this.#e = -1, map.delete(this);
    }
    _getElementInDOMMode() {
      if (map.get(this).GetRuntime().IsInWorker()) throw new Error("not valid in worker mode");
      return this._postToDOMElementMaybeSync("get-element");
    }
    _postToDOMElement(e, t2) {
      t2 || (t2 = {}), t2["elementId"] = this.#e, this._postToDOM(e, t2);
    }
    _postToDOMElementMaybeSync(e, t2) {
      return t2 || (t2 = {}), t2["elementId"] = this.#e, this._postToDOMMaybeSync(e, t2);
    }
    _postToDOMElementAsync(e, t2) {
      return t2 || (t2 = {}), t2["elementId"] = this.#e, this._postToDOMAsync(e, t2);
    }
    _createElement(e) {
      e || (e = {});
      const t2 = map.get(this).GetWorldInfo();
      e["elementId"] = this.#e, e["isVisible"] = t2.IsVisible(), e["htmlIndex"] = t2.GetLayer().GetHTMLIndex(), e["htmlZIndex"] = t2.GetHTMLZIndex(), Object.assign(e, this._getElementState()), this.#t = !!e["isVisible"], this._postToDOMMaybeSync("create", e), this._updatePosition(true);
    }
    setElementVisible(e) {
      e = !!e, this.#t !== e && (this.#t = e, this._postToDOMElement("set-visible", { "isVisible": e }));
    }
    _tick() {
      this._updatePosition(false);
    }
    _shouldPreserveElement() {
      const e = map.get(this).GetRuntime().GetCanvasManager().GetFullscreenMode();
      return "Android" === C32.Platform.OS && ("scale-inner" === e || "scale-outer" === e || "crop" === e);
    }
    _updatePosition(e) {
      const t2 = map.get(this);
      if (t2.IsDestroyed()) return;
      const s = t2.GetWorldInfo(), i = s.GetLayer(), n = s.GetBoundingBox();
      let [o2, l] = i.LayerToCanvasCss(n.getLeft(), n.getTop()), [a2, h2] = i.LayerToCanvasCss(n.getRight(), n.getBottom());
      const d2 = t2.GetRuntime().GetCanvasManager(), m2 = d2.GetCssWidth(), r2 = d2.GetCssHeight();
      if (!s.IsVisible() || !i.IsVisible()) return void this.setElementVisible(false);
      if (!this._shouldPreserveElement() && (a2 <= 0 || h2 <= 0 || o2 >= m2 || l >= r2)) return void this.setElementVisible(false);
      tempRect.set(o2, l, a2, h2);
      const c2 = d2.GetLastWidth(), p2 = d2.GetLastHeight(), u2 = i.GetHTMLIndex(), M2 = s.GetHTMLZIndex();
      if (!e && tempRect.equals(this.#o) && this.#l === c2 && this.#a === p2 && this.#h === u2 && this.#d === M2) return void this.setElementVisible(true);
      this.#o.copy(tempRect), this.#l = c2, this.#a = p2, this.#h = u2, this.#d = M2, this.setElementVisible(true);
      let I2 = null;
      this.#i && (I2 = i.GetDisplayScale() + this.#n), this._postToDOMElement("update-position", { "left": Math.round(this.#o.getLeft()), "top": Math.round(this.#o.getTop()), "width": Math.round(this.#o.width()), "height": Math.round(this.#o.height()), "htmlIndex": u2, "htmlZIndex": M2, "fontSize": I2 });
    }
    focusElement() {
      this._postToDOMElementMaybeSync("focus", { "focus": true });
    }
    blurElement() {
      this._postToDOMElementMaybeSync("focus", { "focus": false });
    }
    _onElemFocused() {
      this.#s = true;
    }
    _onElemBlurred() {
      this.#s = false;
    }
    isElementFocused() {
      return this.#s;
    }
    setElementCSSStyle(e, t2) {
      this.postToDOMElement("set-css-style", { "prop": C32.CSSToCamelCase(e), "val": t2 });
    }
    setElementAttribute(e, t2) {
      this.postToDOMElement("set-attribute", { "name": e, "val": t2 });
    }
    removeElementAttribute(e) {
      this.postToDOMElement("remove-attribute", { "name": e });
    }
    _updateElementState() {
      this.#m || (this.#m = true, Promise.resolve().then(() => {
        this.#m = false, this._postToDOMElement("update-state", this._getElementState());
      }));
    }
    _getElementState() {
    }
    _getElementId() {
      return this.#e;
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X;
  self.ISDKBehaviorBase = class extends self.IBehavior {
    constructor() {
      super();
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X;
  self.ISDKBehaviorTypeBase = class extends globalThis.IBehaviorType {
    constructor() {
      super();
    }
    _onCreate() {
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap(), internalApiToken = C32._GetInternalAPIToken();
  self.ISDKBehaviorInstanceBase = class extends self.IBehaviorInstance {
    #i = false;
    #t = false;
    #e = false;
    constructor() {
      super(), map.set(this, C32.AddonManager._GetInitObject2(internalApiToken));
    }
    _release() {
      super._release(), this._setTicking(false), this._setTicking2(false), this._setPostTicking(false), map.delete(this);
    }
    _getInitProperties() {
      return C32.AddonManager._GetInitProperties();
    }
    _postCreate() {
    }
    _trigger(i) {
      const t2 = map.get(this);
      t2.GetRuntime().Trigger(i, t2.GetObjectInstance(), t2.GetBehaviorType());
    }
    _triggerAsync(i) {
      const t2 = map.get(this);
      return t2.GetRuntime().TriggerAsync(i, t2.GetObjectInstance(), t2.GetBehaviorType());
    }
    _setTicking(i) {
      if (i = !!i, this.#i === i) return;
      this.#i = i;
      const t2 = map.get(this).GetRuntime();
      i ? t2._AddBehInstToTick(this) : t2._RemoveBehInstToTick(this);
    }
    _isTicking() {
      return this.#i;
    }
    _tick() {
    }
    _setTicking2(i) {
      if (i = !!i, this.#t === i) return;
      this.#t = i;
      const t2 = map.get(this).GetRuntime();
      i ? t2._AddBehInstToTick2(this) : t2._RemoveBehInstToTick2(this);
    }
    _isTicking2() {
      return this.#t;
    }
    _tick2() {
    }
    _setPostTicking(i) {
      if (i = !!i, this.#e === i) return;
      this.#e = i;
      const t2 = map.get(this).GetRuntime();
      i ? t2._AddBehInstToPostTick(this) : t2._RemoveBehInstToPostTick(this);
    }
    _isPostTicking() {
      return this.#e;
    }
    _postTick() {
    }
    _getDebuggerProperties() {
      return [];
    }
    _saveToJson() {
      return null;
    }
    _loadFromJson(i) {
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X;
  let runtime = null;
  self.ISDKUtils = class {
    constructor(e) {
      runtime = e, Object.defineProperties(this, { constructVersionCode: { value: runtime.GetConstructVersionCode(), writable: false } });
    }
    updateRender() {
      runtime.UpdateRender();
    }
    addLoadPromise(e) {
      runtime.AddLoadPromise(e);
    }
    sendWrapperExtensionMessage(e, n, t2) {
      C3X.RequireString(e), C3X.RequireString(n), C3X.RequireOptionalArray(t2), runtime.SendWrapperExtensionMessage(e, n, t2);
    }
    sendWrapperExtensionMessageAsync(e, n, t2) {
      return C3X.RequireString(e), C3X.RequireString(n), C3X.RequireOptionalArray(t2), runtime.SendWrapperExtensionMessageAsync(e, n, t2);
    }
    createLoopingConditionContext(e) {
      return C3X.RequireOptionalString(e), new self.ILoopingConditionContext(runtime, e);
    }
    set isAutoSuspendEnabled(e) {
      runtime._SetAutoSuspendEnabled(!!e);
    }
    get isAutoSuspendEnabled() {
      return runtime._IsAutoSuspendEnabled();
    }
    setSuspended(e) {
      runtime.SetSuspended(!!e);
    }
    getObjectClassBySid(e) {
      C3X.RequireNumber(e);
      const n = runtime.GetObjectClassBySID(e);
      return n ? n.GetIObjectClass() : null;
    }
  };
}
{
  const C32 = self.C3, C3X = self.C3X;
  self.ILoopingConditionContext = class {
    #e;
    #t;
    #o;
    #n;
    #s;
    #r;
    constructor(e, t2) {
      this.#e = e;
      const o2 = e.GetEventSheetManager(), n = e.GetCurrentEvent();
      this.#t = n, this.#o = n.GetSolModifiers();
      const s = e.GetEventStack();
      this.#n = s.GetCurrentStackFrame(), this.#s = s.Push(n);
      const r2 = o2.GetLoopStack().Push();
      this.#r = r2, t2 && r2.SetName(t2), e.SetDebuggingEnabled(false);
    }
    retrigger() {
      const e = this.#e.GetEventSheetManager(), t2 = this.#o, o2 = this.#r;
      e.PushCopySol(t2), this.#t.Retrigger(this.#n, this.#s), e.PopSol(t2), o2.SetIndex(o2.GetIndex() + 1);
    }
    get isStopped() {
      return this.#r.IsStopped();
    }
    release() {
      const e = this.#e, t2 = e.GetEventStack(), o2 = e.GetEventSheetManager().GetLoopStack();
      e.SetDebuggingEnabled(true), o2.Pop(), t2.Pop();
    }
  };
}
{
  let IsStaticTextureDataType = function(e) {
    return e instanceof ImageBitmap || "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof OffscreenCanvas && e instanceof OffscreenCanvas;
  };
  IsStaticTextureDataType2 = IsStaticTextureDataType;
  const C32 = self.C3, C3X = self.C3X;
  let renderer = null, runtime = null;
  const CULL_MODE_ARR = ["none", "back", "front"], FRONT_FACE_WINDING_ARR = ["cw", "ccw"];
  self.IRenderer = class {
    constructor(e, r2) {
      runtime = e, renderer = r2;
    }
    setAlphaBlendMode() {
      renderer.SetAlphaBlend();
    }
    setBlendMode(e) {
      renderer.SetNamedBlendMode(e);
    }
    setColorFillMode() {
      renderer.SetColorFillMode();
    }
    setTextureFillMode() {
      renderer.SetTextureFillMode();
    }
    setSmoothLineFillMode() {
      renderer.SetSmoothLineFillMode();
    }
    setColor(e) {
      renderer.SetColorRgba(e[0], e[1], e[2], e[3]);
    }
    setColorRgba(e, r2, n, t2) {
      renderer.SetColorRgba(e, r2, n, t2);
    }
    resetColor() {
      renderer.ResetColor();
    }
    setOpacity(e) {
      renderer.SetOpacity(e);
    }
    setCurrentZ(e) {
      renderer.SetCurrentZ(e);
    }
    getCurrentZ() {
      return renderer.GetCurrentZ();
    }
    setCullFaceMode(e) {
      const r2 = CULL_MODE_ARR.indexOf(e);
      if (-1 === r2) throw new Error("invalid cull mode");
      renderer.SetCullFaceMode(r2);
    }
    getCullFaceMode() {
      return CULL_MODE_ARR[renderer.GetCullFaceMode()];
    }
    setFrontFaceWinding(e) {
      const r2 = FRONT_FACE_WINDING_ARR.indexOf(e);
      if (-1 === r2) throw new Error("invalid front face winding");
      renderer.SetFrontFaceWinding(r2);
    }
    getFrontFaceWinding() {
      return renderer.GetFrontFaceWinding();
    }
    rect(e) {
      renderer.Rect2(e.left, e.top, e.right, e.bottom);
    }
    rect2(e, r2, n, t2) {
      renderer.Rect2(e, r2, n, t2);
    }
    quad(e) {
      renderer.Quad(C32.Quad.fromDOMQuad(e));
    }
    quad2(e, r2, n, t2, a2, d2, i, o2) {
      renderer.Quad2(e, r2, n, t2, a2, d2, i, o2);
    }
    quad3(e, r2) {
      renderer.Quad3(C32.Quad.fromDOMQuad(e), C32.Rect.fromDOMRect(r2));
    }
    quad4(e, r2) {
      renderer.Quad4(C32.Quad.fromDOMQuad(e), C32.Quad.fromDOMQuad(r2));
    }
    quad5(e, r2, n) {
      renderer.Quad5(C32.Quad.fromDOMQuad(e), C32.Quad.fromDOMQuad(r2), n);
    }
    quad3D(e, r2, n, t2, a2, d2, i, o2, u2, l, c2, s, p2) {
      renderer.Quad3D(e, r2, n, t2, a2, d2, i, o2, u2, l, c2, s, C32.Rect.fromDOMRect(p2));
    }
    quad3D2(e, r2, n, t2, a2, d2, i, o2, u2, l, c2, s, p2) {
      renderer.Quad3D2(e, r2, n, t2, a2, d2, i, o2, u2, l, c2, s, C32.Quad.fromDOMQuad(p2));
    }
    quad3D3(e, r2, n, t2, a2, d2, i, o2, u2, l, c2, s, p2, f2) {
      renderer.Quad3D3(e, r2, n, t2, a2, d2, i, o2, u2, l, c2, s, C32.Quad.fromDOMQuad(p2), f2);
    }
    drawMesh(e, r2, n, t2) {
      renderer.DrawMesh(e, r2, n, t2);
    }
    convexPoly(e) {
      renderer.ConvexPoly(e);
    }
    line(e, r2, n, t2) {
      renderer.Line(e, r2, n, t2);
    }
    texturedLine(e, r2, n, t2, a2, d2) {
      renderer.TexturedLine(e, r2, n, t2, a2, d2);
    }
    lineRect(e, r2, n, t2) {
      renderer.LineRect(e, r2, n, t2);
    }
    lineRect2(e) {
      renderer.LineRect2(C32.Rect.fromDOMRect(e));
    }
    lineQuad(e) {
      renderer.LineQuad(C32.Quad.fromDOMQuad(e));
    }
    pushLineWidth(e) {
      renderer.PushLineWidth(e);
    }
    popLineWidth() {
      renderer.PopLineWidth();
    }
    pushLineCap(e) {
      renderer.PushLineCap(e);
    }
    popLineCap() {
      renderer.PopLineCap();
    }
    setTexture(e) {
      C3X.RequireOptionalInstanceOf(e, self.ITexture);
      const r2 = e ? runtime._UnwrapScriptInterface(e) : null;
      renderer.SetTexture(r2);
    }
    loadTextureForImageInfo(e, r2) {
      const n = self.IImageInfo._Unwrap(e);
      if (!n) throw new Error("invalid IImageInfo");
      return n.LoadStaticTexture(renderer, { wrapX: r2?.wrapX ?? "clamp-to-edge", wrapY: r2?.wrapY ?? "clamp-to-edge", sampling: r2?.sampling ?? "trilinear", mipMap: r2?.mipMap ?? true });
    }
    releaseTextureForImageInfo(e) {
      const r2 = self.IImageInfo._Unwrap(e);
      if (!r2) throw new Error("invalid IImageInfo");
      r2.ReleaseTexture();
    }
    getTextureForImageInfo(e) {
      const r2 = self.IImageInfo._Unwrap(e);
      if (!r2) throw new Error("invalid IImageInfo");
      const n = r2.GetTexture();
      return self.ITexture.GetInterface(runtime, n);
    }
    createStaticTexture(e, r2) {
      if (!IsStaticTextureDataType(e)) throw new TypeError("invalid texture data");
      const n = renderer.CreateStaticTexture(e, { wrapX: r2?.wrapX ?? "clamp-to-edge", wrapY: r2?.wrapY ?? "clamp-to-edge", sampling: r2?.sampling ?? "trilinear", mipMap: r2?.mipMap ?? true });
      return self.ITexture.GetInterface(runtime, n);
    }
    createDynamicTexture(e, r2, n) {
      C3X.RequireFiniteNumber(e), C3X.RequireFiniteNumber(r2);
      const t2 = renderer.CreateDynamicTexture(e, r2, { wrapX: n?.wrapX ?? "clamp-to-edge", wrapY: n?.wrapY ?? "clamp-to-edge", sampling: n?.sampling ?? "trilinear", mipMap: n?.mipMap ?? true });
      return self.ITexture.GetInterface(runtime, t2);
    }
    updateTexture(e, r2, n) {
      C3X.RequireInstanceOf(r2, self.ITexture);
      const t2 = runtime._UnwrapScriptInterface(r2);
      renderer.UpdateTexture(e, t2, { premultiplyAlpha: n?.premultiplyAlpha ?? true });
    }
    deleteTexture(e) {
      C3X.RequireInstanceOf(e, self.ITexture);
      const r2 = runtime._UnwrapScriptInterface(e);
      renderer.DeleteTexture(r2);
    }
    createRendererText() {
      const e = renderer.CreateRendererText();
      return new self.IRendererText(runtime, e);
    }
    setDeviceTransform() {
      runtime.GetCanvasManager().SetDeviceTransform(renderer);
    }
    setLayerTransform(e) {
      C3X.RequireInstanceOf(e, globalThis.ILayer);
      runtime._UnwrapScriptInterface(e)._SetTransform(renderer);
    }
  };
}
var IsStaticTextureDataType2;
{
  const C32 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap(), reverseMap = /* @__PURE__ */ new WeakMap();
  self.ITexture = class {
    constructor(e, t2) {
      map.set(this, { runtime: e, texture: t2 }), reverseMap.set(t2, this), e._MapScriptInterface(this, t2), Object.defineProperties(this, { width: { value: t2.GetWidth(), writable: false }, height: { value: t2.GetHeight(), writable: false } });
    }
    static GetInterface(e, t2) {
      if (!t2) return null;
      const r2 = reverseMap.get(t2);
      return r2 || new self.ITexture(e, t2);
    }
  };
}
{
  let getActual = function(t2) {
    return map.get(t2).rendererText;
  };
  getActual2 = getActual;
  const C32 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap();
  self.IRendererText = class {
    constructor(t2, e) {
      map.set(this, { runtime: t2, rendererText: e }), t2._MapScriptInterface(this, e);
    }
    release() {
      getActual(this).Release();
    }
    set fontFace(t2) {
      C3X.RequireString(t2), getActual(this).SetFontName(t2);
    }
    get fontFace() {
      return getActual(this).GetFontName();
    }
    set sizePt(t2) {
      C3X.RequireFiniteNumber(t2), getActual(this).SetFontSize(t2);
    }
    get sizePt() {
      return getActual(this).GetFontSize();
    }
    set lineHeight(t2) {
      C3X.RequireFiniteNumber(t2), getActual(this).SetLineHeight(t2);
    }
    get lineHeight() {
      return getActual(this).GetLineHeight();
    }
    set isBold(t2) {
      getActual(this).SetBold(t2);
    }
    get isBold() {
      return getActual(this).IsBold();
    }
    set isItalic(t2) {
      getActual(this).SetItalic(t2);
    }
    get isItalic() {
      return getActual(this).IsItalic();
    }
    setColor(t2) {
      C3X.RequireArray(t2), this.setColorRgb(t2[0], t2[1], t2[2]);
    }
    setColorRgb(t2, e, i) {
      getActual(this).SetColorRgb(t2, e, i);
    }
    setCssColor(t2) {
      C3X.RequireString(t2), getActual(this).SetColor(t2);
    }
    set horizontalAlign(t2) {
      getActual(this).SetHorizontalAlignment(t2);
    }
    get horizontalAlign() {
      return getActual(this).GetHorizontalAlignment();
    }
    set verticalAlign(t2) {
      getActual(this).SetVerticalAlignment(t2);
    }
    get verticalAlign() {
      return getActual(this).GetVerticalAlignment();
    }
    set wordWrapMode(t2) {
      getActual(this).SetWordWrapMode(t2);
    }
    get wordWrapMode() {
      return getActual(this).GetWordWrapMode();
    }
    set textDirection(t2) {
      getActual(this).SetTextDirection(t2);
    }
    get textDirection() {
      return getActual(this).GetTextDirection();
    }
    set text(t2) {
      C3X.RequireString(t2), getActual(this).SetText(t2);
    }
    get text() {
      return getActual(this).GetText();
    }
    setSize(t2, e, i) {
      C3X.RequireFiniteNumber(t2), C3X.RequireFiniteNumber(e), C3X.RequireFiniteNumber(i), getActual(this).SetSize(t2, e, i);
    }
    getTexture() {
      const { runtime: t2, rendererText: e } = map.get(this), i = e.GetTexture();
      return self.ITexture.GetInterface(t2, i);
    }
    getTexRect() {
      return getActual(this).GetTexRect().toDOMRect();
    }
    setTextureUpdateCallback(t2) {
      C3X.RequireFunction(t2), getActual(this).ontextureupdate = t2;
    }
    releaseTexture() {
      getActual(this).ReleaseTexture();
    }
    get textWidth() {
      return getActual(this).GetTextWidth();
    }
    get textHeight() {
      return getActual(this).GetTextHeight();
    }
  };
}
var getActual2;
{
  let GetTypeFromFileExtension = function(e) {
    if (!e) return "";
    const t2 = e.split(".");
    if (t2.length < 2) return "";
    const s = t2.at(-1).toLowerCase();
    return EXT_TO_TYPE.get(s) || "";
  }, AddScript = function(e) {
    return new Promise((t2, s) => {
      const i = document.createElement("script");
      i.onload = t2, i.onerror = s, i.async = false, i.type = "module", i.src = e, document.head.appendChild(i);
    });
  };
  GetTypeFromFileExtension2 = GetTypeFromFileExtension, AddScript2 = AddScript;
  const C32 = self.C3, VALID_LOAD_POLICIES = /* @__PURE__ */ new Set(["local", "remote"]), EXT_TO_TYPE = /* @__PURE__ */ new Map([["mp4", "video/mp4"], ["webm", "video/webm"], ["m4a", "audio/mp4"], ["mp3", "audio/mpeg"], ["js", "application/javascript"], ["wasm", "application/wasm"], ["svg", "image/svg+xml"], ["html", "text/html"]]);
  C32.AssetManager = class extends C32.DefendedBase {
    constructor(e, t2) {
      super();
      const s = t2["exportType"];
      this._runtime = e, this._cordovaBlobUrlCache = /* @__PURE__ */ new Map(), this._isCordova = "cordova" === s, this._isiOSCordova = !!t2["isiOSCordova"], this._swClientId = t2["swClientId"], this._supportedAudioFormats = t2["supportedAudioFormats"] || {}, this._audioFiles = /* @__PURE__ */ new Map(), this._preloadSounds = false, this._scriptSubfolder = t2["scriptFolder"], this._mediaSubfolder = "", this._fontsSubfolder = "", this._iconsSubfolder = "", this._fileMap = t2["fileMap"] || /* @__PURE__ */ new Map(), this._fileMapBlobUrls = /* @__PURE__ */ new Map(), this._exportedFileList = [];
      const i = "html5" === s || "scirra-arcade" === s || "instant-games" === s;
      this._defaultLoadPolicy = i ? "remote" : "local", this._imageAssetsMap = /* @__PURE__ */ new Map(), this._webFonts = [], this._loadPromises = [], this._hasFinishedInitialLoad = false, this._totalAssetSizeToLoad = 0, this._assetSizeLoaded = 0, this._lastLoadProgress = 0, this._hasHadErrorLoading = false, this._loadingRateLimiter = C32.New(C32.RateLimiter, () => this._FireLoadingProgressEvent(), 50), this._localPromiseThrottle = C32.New(C32.PromiseThrottle, Math.max(C32.hardwareConcurrency, 8)), this._remotePromiseThrottle = C32.New(C32.PromiseThrottle, 20), this._iAssetManager = new self.IAssetManager(this);
    }
    Release() {
      for (const e of this._imageAssetsMap.values()) e.Release();
      this._imageAssetsMap.clear(), C32.clearArray(this._loadPromises), this._runtime = null;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetScriptSubfolder() {
      return this._scriptSubfolder;
    }
    _SetMediaSubfolder(e) {
      this._mediaSubfolder = e;
    }
    GetMediaSubfolder() {
      return this._mediaSubfolder;
    }
    _SetFontsSubfolder(e) {
      this._fontsSubfolder = e;
    }
    GetFontsSubfolder() {
      return this._fontsSubfolder;
    }
    _SetIconsSubfolder(e) {
      this._iconsSubfolder = e;
    }
    GetIconsSubfolder() {
      return this._iconsSubfolder;
    }
    _SetExportedFileList(e) {
      this._exportedFileList = e;
    }
    GetExportedFileList() {
      return this._exportedFileList;
    }
    FetchBlob(e, t2) {
      return t2 = t2 || this._defaultLoadPolicy, C32.IsRelativeURL(e) ? "playable-ad-single-file" === this._runtime.GetExportType() ? self["c3_runtimeInterface"]["_PlayableAdFetchBlob"](e) : "local" === t2 ? this._localPromiseThrottle.Add(() => C32.FetchBlob(e)) : this._remotePromiseThrottle.Add(() => C32.FetchBlob(e)) : C32.FetchBlob(e);
    }
    FetchArrayBuffer(e) {
      return C32.IsRelativeURL(e) ? "playable-ad-single-file" === this._runtime.GetExportType() ? C32.BlobToArrayBuffer(self["c3_runtimeInterface"]["_PlayableAdFetchBlob"](e)) : "local" === this._defaultLoadPolicy ? this._localPromiseThrottle.Add(() => C32.FetchArrayBuffer(e)) : this._remotePromiseThrottle.Add(() => C32.FetchArrayBuffer(e)) : C32.FetchArrayBuffer(e);
    }
    FetchText(e) {
      return C32.IsRelativeURL(e) ? "playable-ad-single-file" === this._runtime.GetExportType() ? C32.BlobToString(self["c3_runtimeInterface"]["_PlayableAdFetchBlob"](e)) : "local" === this._defaultLoadPolicy ? this._localPromiseThrottle.Add(() => C32.FetchText(e)) : this._remotePromiseThrottle.Add(() => C32.FetchText(e)) : C32.FetchText(e);
    }
    async FetchJson(e) {
      const t2 = await this.FetchText(e);
      return JSON.parse(t2);
    }
    GetMediaFileUrl(e) {
      let t2 = this._mediaSubfolder + e;
      return "Gecko" === C32.Platform.BrowserEngine && "preview" === this._runtime.GetExportType() && (t2 = this._GetLocalBlobURLFromFileMap(t2)), t2;
    }
    GetProjectFileUrl(e) {
      return "playable-ad-single-file" === this._runtime.GetExportType() && C32.IsRelativeURL(e) ? URL.createObjectURL(self["c3_runtimeInterface"]["_PlayableAdFetchBlob"](e)) : e;
    }
    GetProjectFileIframeUrl(e) {
      if (C32.IsAbsoluteURL(e) || "preview" !== this._runtime.GetExportType() || !this._swClientId || !e) return e;
      try {
        const t2 = new URL(e, location.href);
        return t2.searchParams.set("__c3_client_id", this._swClientId), t2.toString();
      } catch (t2) {
        return console.warn("Invalid iframe URL: " + e), e;
      }
    }
    _GetImageAssetKey(e, t2) {
      return (t2 ? "true" : "false") + "|" + e;
    }
    LoadImage(e) {
      const t2 = !!e.isTiled;
      if (e.loadPolicy && !VALID_LOAD_POLICIES.has(e.loadPolicy)) throw new Error("invalid load policy");
      const s = this._GetImageAssetKey(e.url, t2);
      let i = this._imageAssetsMap.get(s);
      return i || (i = C32.New(C32.ImageAsset, this, { url: e.url, size: e.size || 0, loadPolicy: e.loadPolicy || this._defaultLoadPolicy, isTiled: t2 }), this._imageAssetsMap.set(s, i), this._hasFinishedInitialLoad || (this._totalAssetSizeToLoad += i.GetSize(), this._loadPromises.push(i.Load().then(() => this._AddLoadedSize(i.GetSize())))), i);
    }
    _ReleaseImageAsset(e) {
      const t2 = this._GetImageAssetKey(e.GetURL(), e.IsTiled());
      this._imageAssetsMap.delete(t2);
    }
    async WaitForAllToLoad(e) {
      try {
        await Promise.all(this._loadPromises), this._lastLoadProgress = 1, e && 0 === this._totalAssetSizeToLoad && this._FireLoadingProgressEvent();
      } catch (e2) {
        console.error("Error loading: ", e2), this._hasHadErrorLoading = true, this._FireLoadingProgressEvent();
      }
    }
    SetInitialLoadFinished() {
      this._hasFinishedInitialLoad = true;
    }
    HasHadErrorLoading() {
      return this._hasHadErrorLoading;
    }
    _AddLoadedSize(e) {
      this._assetSizeLoaded += e, this._loadingRateLimiter.Call();
    }
    _FireLoadingProgressEvent() {
      const e = C32.New(C32.Event, "loadingprogress");
      0 === this._totalAssetSizeToLoad ? this._lastLoadProgress = 1 : this._lastLoadProgress = C32.clamp(this._assetSizeLoaded / this._totalAssetSizeToLoad, 0, 1), e.progress = this._lastLoadProgress, this._runtime.Dispatcher().dispatchEvent(e), this._runtime.DispatchUserScriptEvent(C32.New(C32.Event, "loadingprogress"));
    }
    GetLoadProgress() {
      return this._lastLoadProgress;
    }
    GetImageLoadProgress() {
      return this._runtime.GetSystemPlugin().GetImageLoadingProgress();
    }
    _SetWebFonts(e) {
      C32.shallowAssignArray(this._webFonts, e), this._webFonts.length && this._loadPromises.push(this._LoadWebFonts());
    }
    async _LoadWebFonts() {
      const e = [], t2 = [];
      for (const [s, i, o2] of this._webFonts) this._totalAssetSizeToLoad += o2, e.push(this._LoadWebFont(s, i, t2).then(() => this._AddLoadedSize(o2)));
      await Promise.all(e), this._runtime.IsInWorker() && t2.length > 0 && await this._runtime.PostComponentMessageToDOMAsync("runtime", "load-webfonts", { "webfonts": t2 });
    }
    async _LoadWebFont(e, t2, s) {
      try {
        let i = this.GetProjectFileUrl(t2);
        "Gecko" === C32.Platform.BrowserEngine && (e = `'${e}'`), ("Gecko" === C32.Platform.BrowserEngine && "preview" === this._runtime.GetExportType() || "playable-ad-single-file" === this._runtime.GetExportType()) && (i = this._GetLocalBlobURLFromFileMap(i));
        const o2 = new FontFace(e, `url('${i}')`);
        this._runtime.IsInWorker() ? self.fonts.add(o2) : document.fonts.add(o2), await o2.load(), this._runtime.IsInWorker() && s.push({ name: e, url: i });
      } catch (t3) {
        console.warn(`[C3 runtime] Failed to load web font '${e}': `, t3);
      }
    }
    IsAudioFormatSupported(e) {
      return !!this._supportedAudioFormats[e];
    }
    _SetAudioFiles(e, t2) {
      this._preloadSounds = !!t2;
      for (const [t3, s, i] of e) this._audioFiles.set(t3, { fileName: t3, formats: s.map((e2) => ({ type: e2[0], fileExtension: e2[1], fullName: t3 + e2[1], fileSize: e2[2] })), isMusic: i });
    }
    GetPreferredAudioFile(e) {
      const t2 = this._audioFiles.get(e);
      if (!t2) return null;
      let s = null;
      for (const e2 of t2.formats) if (s || "audio/webm; codecs=opus" !== e2.type || (s = e2), this.IsAudioFormatSupported(e2.type)) return e2;
      return s;
    }
    GetProjectAudioFileUrl(e) {
      const t2 = this.GetPreferredAudioFile(e);
      return t2 ? { url: this.GetMediaFileUrl(t2.fullName), type: t2.type } : null;
    }
    GetAudioToPreload() {
      if (this._preloadSounds) {
        const e = [];
        for (const t2 of this._audioFiles.values()) {
          if (t2.isMusic) continue;
          const s = this.GetPreferredAudioFile(t2.fileName);
          s && e.push({ originalUrl: t2.fileName, url: this.GetMediaFileUrl(s.fullName), type: s.type, fileSize: s.fileSize });
        }
        return e;
      }
      return [];
    }
    _GetLocalBlobFromFileMap(e) {
      return "preview" === this._runtime.GetExportType() && (e = new URL(e, location.href).toString()), this._fileMap.get(e) || null;
    }
    _GetLocalBlobURLFromFileMap(e) {
      let t2 = this._fileMapBlobUrls.get(e);
      if (t2) return t2;
      const s = this._GetLocalBlobFromFileMap(e);
      return s ? (t2 = URL.createObjectURL(s), this._fileMapBlobUrls.set(e, t2), t2) : e;
    }
    GetIAssetManager() {
      return this._iAssetManager;
    }
    async LoadScripts(...e) {
      const t2 = e.map((e2) => this.GetProjectFileUrl(e2));
      if (this._runtime.IsInWorker()) if (1 === e.length) {
        const t3 = e[0];
        await import((C32.IsRelativeURL(t3) ? "./" : "") + t3);
      } else {
        const t3 = e.map((e2) => `import "${C32.IsRelativeURL(e2) ? "./" : ""}${e2}";`).join("\n"), s = URL.createObjectURL(new Blob([t3], { type: "application/javascript" }));
        await import(s);
      }
      else await Promise.all(t2.map((e2) => AddScript(e2)));
    }
    async CompileWebAssembly(e) {
      if (WebAssembly.compileStreaming) {
        const t2 = this.GetProjectFileUrl(e);
        return await WebAssembly.compileStreaming(fetch(t2));
      }
      {
        const t2 = await C32.FetchArrayBuffer(e);
        return await WebAssembly.compile(t2);
      }
    }
    async LoadStyleSheet(e) {
      const t2 = this.GetProjectFileUrl(e);
      return await this._runtime.PostComponentMessageToDOMAsync("runtime", "add-stylesheet", { "url": t2 });
    }
  };
}
var GetTypeFromFileExtension2;
var AddScript2;
{
  const C32 = self.C3;
  C32.Asset = class extends C32.DefendedBase {
    constructor(s, i) {
      super(), this._assetManager = s, this._runtime = s.GetRuntime(), this._url = i.url || "", this._size = i.size, this._loadPolicy = i.loadPolicy, this._blob = i.blob || null, this._isLoaded = !!this._blob, this._loadPromise = null;
    }
    Release() {
      this._loadPromise = null, this._assetManager = null, this._runtime = null, this._blob = null;
    }
    GetURL() {
      return this._url;
    }
    GetSize() {
      return this._size;
    }
    Load() {
      return "local" === this._loadPolicy || this._blob ? (this._isLoaded = true, Promise.resolve()) : (this._loadPromise || (this._loadPromise = this._assetManager.FetchBlob(this._url, this._loadPolicy).then((s) => (this._isLoaded = true, this._loadPromise = null, this._blob = s, s)).catch((s) => {
        console.error("Error loading resource: ", s), this._loadPromise = null;
      })), this._loadPromise);
    }
    IsLoaded() {
      return this._isLoaded;
    }
    GetBlob() {
      return this._blob ? Promise.resolve(this._blob) : this._loadPromise ? this._loadPromise : this._assetManager.FetchBlob(this._url, this._loadPolicy);
    }
  };
}
{
  const C32 = self.C3, promiseThrottle = new C32.PromiseThrottle(), allImageAssets = /* @__PURE__ */ new Set();
  C32.ImageAsset = class extends C32.Asset {
    constructor(e, t2) {
      super(e, t2), this._texturePromise = null, this._webglTexture = null, this._refCount = 0, this._imageWidth = -1, this._imageHeight = -1, this._isTiled = !!t2.isTiled, allImageAssets.add(this);
    }
    Release() {
      if (0 !== this._refCount) throw new Error("released image asset which still has texture references");
      this._assetManager._ReleaseImageAsset(this), this._texturePromise = null, allImageAssets.delete(this), super.Release();
    }
    static OnRendererContextLost() {
      for (const e of allImageAssets) e._texturePromise = null, e._webglTexture = null, e._refCount = 0;
    }
    LoadStaticTexture(e, t2) {
      return t2 = t2 || {}, this._refCount++, this._webglTexture ? Promise.resolve(this._webglTexture) : (this._texturePromise || (t2.anisotropy = this._runtime.GetCanvasManager().GetTextureAnisotropy(), this._texturePromise = this._DoLoadStaticTexture(e, t2)), this._texturePromise);
    }
    async _DoLoadStaticTexture(e, t2) {
      try {
        const s = await this.GetBlob();
        return 0 === this._refCount ? (this._texturePromise = null, null) : await promiseThrottle.Add(async () => {
          const r2 = await e.CreateStaticTextureAsync(s, t2);
          return this._texturePromise = null, 0 === this._refCount ? (e.DeleteTexture(r2), null) : (this._webglTexture = r2, this._imageWidth = r2.GetWidth(), this._imageHeight = r2.GetHeight(), this._webglTexture);
        });
      } catch (e2) {
        throw console.error("Failed to load texture: ", e2), e2;
      }
    }
    ReleaseTexture() {
      if (this._refCount <= 0) throw new Error("texture released too many times");
      if (this._refCount--, 0 === this._refCount && this._webglTexture) {
        this._webglTexture.GetRenderer().DeleteTexture(this._webglTexture), this._webglTexture = null;
      }
    }
    GetRefCount() {
      return this._refCount;
    }
    GetTexture() {
      return this._webglTexture;
    }
    GetWidth() {
      return this._imageWidth;
    }
    GetHeight() {
      return this._imageHeight;
    }
    IsTiled() {
      return this._isTiled;
    }
    async LoadToDrawable() {
      const e = await this.GetBlob();
      return C32.Supports.ImageBitmap ? await createImageBitmap(e) : await C32.BlobToImage(e);
    }
  };
}
{
  let SortByInstLastCachedZIndex = function(e, s) {
    return e.GetWorldInfo()._GetLastCachedZIndex() - s.GetWorldInfo()._GetLastCachedZIndex();
  };
  SortByInstLastCachedZIndex2 = SortByInstLastCachedZIndex;
  const C32 = self.C3, assert = self.assert;
  C32.RenderCell = class extends C32.DefendedBase {
    constructor(e, s, n) {
      super(), this._grid = e, this._x = s, this._y = n, this._instances = [], this._isSorted = true, this._pendingRemoval = /* @__PURE__ */ new Set(), this._isAnyPendingRemoval = false;
    }
    Release() {
      C32.clearArray(this._instances), this._pendingRemoval.clear(), this._grid = null;
    }
    Reset() {
      C32.clearArray(this._instances), this._isSorted = true, this._pendingRemoval.clear(), this._isAnyPendingRemoval = false;
    }
    SetChanged() {
      this._isSorted = false;
    }
    IsEmpty() {
      return !this._instances.length || !(this._instances.length > this._pendingRemoval.size) && (this._FlushPending(), true);
    }
    Insert(e) {
      if (this._pendingRemoval.has(e)) return this._pendingRemoval.delete(e), void (0 === this._pendingRemoval.size && (this._isAnyPendingRemoval = false));
      this._instances.push(e), this._isSorted = 1 === this._instances.length;
    }
    Remove(e) {
      this._pendingRemoval.add(e), this._isAnyPendingRemoval = true, this._pendingRemoval.size >= 50 && this._FlushPending();
    }
    _FlushPending() {
      this._isAnyPendingRemoval && (this._instances.length !== this._pendingRemoval.size ? (C32.arrayRemoveAllInSet(this._instances, this._pendingRemoval), this._pendingRemoval.clear(), this._isAnyPendingRemoval = false) : this.Reset());
    }
    _EnsureSorted() {
      this._isSorted || (this._instances.sort(SortByInstLastCachedZIndex), this._isSorted = true);
    }
    Dump(e) {
      this._FlushPending(), this._EnsureSorted(), this._instances.length && e.push(this._instances);
    }
  };
}
var SortByInstLastCachedZIndex2;
{
  const C32 = self.C3;
  C32.RenderGrid = class extends C32.DefendedBase {
    constructor(e, t2) {
      super(), this._cellWidth = e, this._cellHeight = t2, this._cells = C32.New(C32.PairMap);
    }
    Release() {
      this._cells.Release(), this._cells = null;
    }
    GetCell(e, t2, l) {
      let o2 = this._cells.Get(e, t2);
      return o2 || (l ? (o2 = C32.New(C32.RenderCell, this, e, t2), this._cells.Set(e, t2, o2), o2) : null);
    }
    XToCell(e) {
      return Math.floor(e / this._cellWidth);
    }
    YToCell(e) {
      return Math.floor(e / this._cellHeight);
    }
    Update(e, t2, l) {
      if (t2) for (let o2 = t2.getLeft(), s = t2.getRight(); o2 <= s; ++o2) for (let s2 = t2.getTop(), i = t2.getBottom(); s2 <= i; ++s2) {
        if (l && l.containsPoint(o2, s2)) continue;
        const t3 = this.GetCell(o2, s2, false);
        t3 && (t3.Remove(e), t3.IsEmpty() && this._cells.Delete(o2, s2));
      }
      if (l) for (let o2 = l.getLeft(), s = l.getRight(); o2 <= s; ++o2) for (let s2 = l.getTop(), i = l.getBottom(); s2 <= i; ++s2) t2 && t2.containsPoint(o2, s2) || this.GetCell(o2, s2, true).Insert(e);
    }
    QueryRange(e, t2) {
      let l = this.XToCell(e.getLeft());
      const o2 = this.YToCell(e.getTop()), s = this.XToCell(e.getRight()), i = this.YToCell(e.getBottom());
      for (; l <= s; ++l) for (let e2 = o2; e2 <= i; ++e2) {
        const o3 = this.GetCell(l, e2, false);
        o3 && o3.Dump(t2);
      }
    }
    MarkRangeChanged(e) {
      let t2 = e.getLeft();
      const l = e.getTop(), o2 = e.getRight(), s = e.getBottom();
      for (; t2 <= o2; ++t2) for (let e2 = l; e2 <= s; ++e2) {
        const l2 = this.GetCell(t2, e2, false);
        l2 && l2.SetChanged();
      }
    }
  };
}
{
  let SortByInstLastCachedZIndex = function(e, t2) {
    return e.GetWorldInfo()._GetLastCachedZIndex() - t2.GetWorldInfo()._GetLastCachedZIndex();
  }, SortByInstZElevation = function(e, t2) {
    return e.GetWorldInfo().GetZElevation() - t2.GetWorldInfo().GetZElevation();
  };
  SortByInstLastCachedZIndex2 = SortByInstLastCachedZIndex, SortByInstZElevation2 = SortByInstZElevation;
  const C32 = self.C3, assert = self.assert, tmpRect = new C32.Rect(), tmpQuad = new C32.Quad(), renderCellArr = [], tmpDestRect = new C32.Rect(), tmpSrcRect = new C32.Rect(), glMatrix = self.glMatrix, vec3 = glMatrix.vec3, vec4 = glMatrix.vec4, mat4 = glMatrix.mat4, tempMat4 = mat4.create(), tempVec3 = vec3.create(), tempVec4 = vec4.create(), camVector = vec3.create(), lookVector = vec3.create(), upVector = vec3.create(), tempVec2 = C32.New(C32.Vector2), tempRect = C32.New(C32.Rect);
  const tempInstanceList1 = [], tempInstanceList2 = [], tempInstancesByCameraDist = [], DEFAULT_LAYER_OPTIONS = { name: "", sid: -1, isDynamic: false, isVisible: true, isInteractive: true, isHTMLElementsLayer: false, backgroundColor: [1, 1, 1, 1], isTransparent: true, parallax: [1, 1], opacity: 1, isForceOwnTexture: false, renderAs3d: false, useCameraDistanceDrawOrder: false, useRenderCells: false, scaleRate: 1, blendMode: 0, zElevation: 0, initialInstancesData: [], effectListData: [], subLayersData: [] }, allInitialGlobalInstances = /* @__PURE__ */ new Map(), on_global_instance_destroy = (e) => {
    if (!e.instance.GetObjectClass().IsGlobal()) return;
    const t2 = e.instance.GetUID();
    allInitialGlobalInstances.has(t2) && (allInitialGlobalInstances.delete(t2), allInitialGlobalInstances.size || e.instance.GetRuntime().Dispatcher().removeEventListener("instancedestroy", on_global_instance_destroy));
  };
  C32.Layer = class extends C32.DefendedBase {
    constructor(e, t2, s) {
      super(), s = Object.assign({}, DEFAULT_LAYER_OPTIONS, s), this._layout = e, this._runtime = e.GetRuntime(), this._parentLayer = t2, this._name = s.name, this._index = -1, this._isHTMLElementsLayer = !!s.isHTMLElementsLayer, this._htmlIndex = -1, this._sid = s.sid, this._isDynamic = !!s.isDynamic, this._isVisible = !!s.isVisible, this._isInteractive = !!s.isInteractive, this._backgroundColor = C32.New(C32.Color), this._backgroundColor.setFromJSON(s.backgroundColor), this._isTransparent = !!s.isTransparent, this._parallaxX = s.parallax[0], this._parallaxY = s.parallax[1], this._color = C32.New(C32.Color, 1, 1, 1, s.opacity), this._premultipliedColor = C32.New(C32.Color), this._isForceOwnTexture = !!s.isForceOwnTexture, this._renderAs3d = !!s.renderAs3d, this._useCameraDistanceDrawOrder = !!s.useCameraDistanceDrawOrder, this._useRenderCells = !!s.useRenderCells, this._scaleRate = s.scaleRate, this._blendMode = s.blendMode, this._curRenderTarget = null, this._scale = 1, this._zElevation = s.zElevation, this._angle = 0, this._scrollX = 0, this._scrollY = 0, this._hasOwnScrollPosition = false, this._viewport = C32.New(C32.Rect), this._viewportZ0 = C32.New(C32.Rect), this._viewport3D = C32.New(C32.Rect), this._isViewportChanged = true, this._projectionMatrix = mat4.create(), this._isProjectionMatrixChanged = true, this._modelViewMatrix = mat4.create(), this._isMVMatrixChanged = true, this._viewFrustum = C32.New(C32.Gfx.ViewFrustum), this._isViewFrustumChanged = true, this._startupInitialInstances = [], this._initialInstancesData = s.initialInstancesData, this._initialInstances = [], this._createdGlobalUids = [], this._initialUIDsToInstanceData = /* @__PURE__ */ new Map(), this._instances = [], this._zIndicesUpToDate = false, this._htmlZIndicesUpToDate = false, this._anyInstanceZElevated = false;
      const a2 = this._runtime.GetCanvasManager();
      this._effectList = C32.New(C32.EffectList, this, s.effectListData), this._effectChain = C32.New(C32.Gfx.EffectChain, a2.GetEffectChainManager(), { drawContent: (e2, t3) => {
        const s2 = t3.GetContentObject(), i = s2.GetRenderTarget();
        e2.SetColor(s2.GetPremultipliedColor()), e2.DrawRenderTarget(i), e2.InvalidateRenderTarget(i), a2.ReleaseAdditionalRenderTarget(i);
      }, getShaderParameters: (e2) => this.GetEffectList()._GetEffectChainShaderParametersForIndex(e2) }), this._needsRebuildEffectChainSteps = true, this._wasDefaultColor = true, this._renderGrid = null, this._lastRenderList = [], this._isRenderListUpToDate = false, this._lastRenderCells = C32.New(C32.Rect, 0, 0, -1, -1), this._curRenderCells = C32.New(C32.Rect, 0, 0, -1, -1), this._iLayer = new self.ILayer(this), this._userScriptDispatcher = C32.New(C32.Event.Dispatcher), this._UpdatePremultipliedColor(), this.UsesRenderCells() && (this._renderGrid = C32.New(C32.RenderGrid, this._runtime.GetOriginalViewportWidth(), this._runtime.GetOriginalViewportHeight())), this._subLayers = s.subLayersData.map((e2) => C32.Layer.CreateFromExportData(this._layout, this, e2));
    }
    _InitInitialInstances() {
      for (const e of this._initialInstancesData) {
        const t2 = this._runtime.GetObjectClassByIndex(e[1]);
        this._layout._AddInitialObjectClass(t2), t2.GetDefaultInstanceData() || (t2.SetDefaultInstanceData(e), t2._SetDefaultLayerIndex(this._index)), this._initialInstances.push(e), this._initialUIDsToInstanceData.set(e[2], e);
      }
      C32.shallowAssignArray(this._startupInitialInstances, this._initialInstances), this._initialInstancesData = null;
    }
    static CreateFromExportData(e, t2, s) {
      return C32.New(C32.Layer, e, t2, { name: s[0], sid: s[2], isVisible: s[3], isInteractive: s[13], isHTMLElementsLayer: s[19], backgroundColor: s[4].map((e2) => e2 / 255), isTransparent: s[5], parallax: [s[6], s[7]], opacity: s[8], isForceOwnTexture: s[9], renderAs3d: s[17], useCameraDistanceDrawOrder: s[18], useRenderCells: s[10], scaleRate: s[11], blendMode: s[12], zElevation: s[16], initialInstancesData: s[14], effectListData: s[15], subLayersData: s[20] });
    }
    Release() {
      for (const e of this._subLayers) e.Release();
      C32.clearArray(this._subLayers);
      for (const e of this._instances) this._runtime.DestroyInstance(e);
      C32.clearArray(this._instances), this._effectList.Release(), this._effectList = null, this._effectChain.Release(), this._effectChain = null, this._iLayer = null, this._parentLayer = null, this._layout = null, this._runtime = null;
    }
    WasReleased() {
      return !this._layout;
    }
    GetInitialInstanceData(e) {
      return this._initialUIDsToInstanceData.get(e);
    }
    CreateInitialInstances(e) {
      const t2 = this._layout.IsFirstVisit(), s = this._initialInstances;
      let a2 = 0;
      for (let i = 0, r2 = s.length; i < r2; ++i) {
        const r3 = s[i], n = this._runtime.GetObjectClassByIndex(r3[1]);
        let l = true;
        if (!n.HasPersistBehavior() || t2) if (n.IsGlobal() && allInitialGlobalInstances.has(r3[2])) l = false;
        else {
          const t3 = this._runtime.CreateInstanceFromData(r3, this, true);
          e.push(t3), n.IsGlobal() && (allInitialGlobalInstances.size || this._runtime.Dispatcher().addEventListener("instancedestroy", on_global_instance_destroy), allInitialGlobalInstances.set(t3.GetUID(), t3), l = false, this._createdGlobalUids.push(t3.GetUID()));
        }
        l && (s[a2] = s[i], ++a2);
      }
      C32.truncateArray(s, a2), this._runtime.FlushPendingInstances(), this.SetZIndicesChanged();
    }
    _AddInstance(e, t2) {
      if (!e.GetPlugin().IsWorldType()) throw new Error("instance is not of world type");
      const s = e.GetWorldInfo();
      if (s.GetLayer() !== this) throw new Error("instance added to wrong layer");
      this._instances.push(e), 0 !== s.GetZElevation() && (this._anyInstanceZElevated = true), t2 && this.UsesRenderCells() && e.GetWorldInfo().SetBboxChanged(), this.SetZIndicesChanged(e);
    }
    _MaybeAddInstance(e) {
      this._instances.includes(e) || (this._instances.push(e), 0 !== e.GetWorldInfo().GetZElevation() && (this._anyInstanceZElevated = true), this.SetZIndicesChanged(e));
    }
    _PrependInstance(e, t2) {
      const s = e.GetWorldInfo();
      if (s.GetLayer() !== this) throw new Error("instance added to wrong layer");
      this._instances.unshift(e), 0 !== s.GetZElevation() && (this._anyInstanceZElevated = true), this.SetZIndicesChanged(e), t2 && this.UsesRenderCells() && e.GetWorldInfo().SetBboxChanged();
    }
    _RemoveInstance(e, t2) {
      const s = this._instances.indexOf(e);
      s < 0 || (t2 && this.UsesRenderCells() && e.GetWorldInfo()._RemoveFromRenderCells(), this._instances.splice(s, 1), this.SetZIndicesChanged(e), this._MaybeResetAnyInstanceZElevatedFlag());
    }
    _SetAnyInstanceZElevated() {
      this._anyInstanceZElevated = true;
    }
    _MaybeResetAnyInstanceZElevatedFlag() {
      0 === this._instances.length && (this._anyInstanceZElevated = false);
    }
    _SortInstancesByLastCachedZIndex(e) {
      if (e) {
        const e2 = /* @__PURE__ */ new Set();
        for (const t3 of this._instances) {
          const s = t3.GetWorldInfo()._GetLastCachedZIndex();
          s >= 0 && e2.add(s);
        }
        let t2 = -1;
        for (const s of this._instances) {
          const a2 = s.GetWorldInfo();
          if (!(a2._GetLastCachedZIndex() >= 0)) {
            for (++t2; e2.has(t2); ) ++t2;
            a2._SetZIndex(t2);
          }
        }
      }
      this._instances.sort(SortByInstLastCachedZIndex);
    }
    _Start() {
    }
    _End() {
      for (const e of this._instances) e.GetObjectClass().IsGlobal() || this._runtime.DestroyInstance(e);
      this._runtime.FlushPendingInstances(), C32.clearArray(this._instances), this._anyInstanceZElevated = false, this.SetZIndicesChanged();
    }
    RecreateInitialObjects(e, t2, s, a2, i, r2) {
      const n = this._runtime.GetEventSheetManager(), l = this._runtime.GetAllObjectClasses(), o2 = e.IsFamily(), h2 = [];
      for (const c2 of this._initialInstances) {
        const d2 = c2[0], _2 = d2[0], u2 = d2[1];
        if (!t2.containsPoint(_2, u2)) continue;
        const G = l[c2[1]];
        if (G !== e) {
          if (!o2) continue;
          if (!e.FamilyHasMember(G)) continue;
        }
        let p2 = i;
        if (!p2) {
          const e2 = this._runtime.GetCurrentLayout();
          this.GetLayout() === e2 ? p2 = this : (p2 = e2.GetLayerByName(this.GetName()), p2 || (p2 = e2.GetLayerByIndex(this.GetIndex())));
        }
        const f2 = this._runtime.CreateInstanceFromData(c2, p2, false, void 0, void 0, false, r2, void 0, r2);
        r2 && p2.SortAndAddInstancesByZIndex(f2);
        const I2 = f2.GetWorldInfo();
        I2.OffsetXY(s, a2), I2.SetBboxChanged(), n.BlockFlushingInstances(true), f2._TriggerOnCreatedOnSelfAndRelated(), n.BlockFlushingInstances(false), h2.push(f2);
      }
      return h2;
    }
    GetInstanceCount() {
      return this._instances.length;
    }
    GetLayout() {
      return this._layout;
    }
    GetName() {
      return this._name;
    }
    _SetIndex(e) {
      this._index = e;
    }
    GetIndex() {
      return this._index;
    }
    _SetHTMLIndex(e) {
      this._htmlIndex = e;
    }
    GetHTMLIndex() {
      return this._htmlIndex;
    }
    IsHTMLElementsLayer() {
      return this._isHTMLElementsLayer;
    }
    SetIsHTMLElementsLayer(e) {
      e = !!e, this._isHTMLElementsLayer !== e && (this._isHTMLElementsLayer = e, this._layout._ReindexAndUpdateAllLayers(), this._runtime.UpdateRender());
    }
    _GetSiblingIndex() {
      let e = -1;
      const t2 = this.GetParentLayer();
      return e = t2 ? t2.GetSubLayers().indexOf(this) : this.GetLayout()._GetRootLayers().indexOf(this), e;
    }
    GetSID() {
      return this._sid;
    }
    GetRuntime() {
      return this._runtime;
    }
    IsDynamic() {
      return this._isDynamic;
    }
    HasAnyDynamicParentLayer() {
      for (const e of this.parentLayers()) if (e.IsDynamic()) return true;
      return false;
    }
    GetDevicePixelRatio() {
      return this._runtime.GetDevicePixelRatio();
    }
    GetEffectList() {
      return this._effectList;
    }
    GetEffectChain() {
      return this._MaybeRebuildEffectChainSteps(), this._effectChain;
    }
    _MaybeRebuildEffectChainSteps() {
      const e = this.HasDefaultColor();
      if (!this._needsRebuildEffectChainSteps && e === this._wasDefaultColor && !this._effectChain.NeedsRebuild()) return;
      const t2 = this.GetEffectList().GetActiveEffectTypes();
      this._effectChain.BuildSteps(t2.map((e2) => e2.GetShaderProgram()), { indexMap: t2.map((e2) => e2.GetIndex()), forcePreDraw: !e, useFullSurface: true }), this._needsRebuildEffectChainSteps = false, this._wasDefaultColor = e;
    }
    UpdateActiveEffects() {
      this.GetEffectList().UpdateActiveEffects(), this._needsRebuildEffectChainSteps = true;
    }
    UsesRenderCells() {
      return this._useRenderCells && !this._useCameraDistanceDrawOrder;
    }
    GetRenderGrid() {
      return this._renderGrid;
    }
    SetRenderListStale() {
      this._isRenderListUpToDate = false;
    }
    IsVisible() {
      for (const e of this.selfAndParentLayers()) if (!e._IsVisibleFlagSet()) return false;
      return true;
    }
    _IsVisibleFlagSet() {
      return this._isVisible;
    }
    SetVisible(e) {
      e = !!e, this._isVisible !== e && (this._isVisible = e, this._runtime.UpdateRender());
    }
    SetInteractive(e) {
      this._isInteractive = !!e;
    }
    IsInteractive() {
      return this._isInteractive;
    }
    IsSelfAndParentsInteractive() {
      for (const e of this.selfAndParentLayers()) if (!e.IsInteractive()) return false;
      return true;
    }
    SetOwnScrollPositionEnabled(e) {
      if (e = !!e, this._hasOwnScrollPosition !== e) {
        if (this._hasOwnScrollPosition = e, e) {
          const e2 = this.GetLayout();
          this._scrollX = e2.GetScrollX(), this._scrollY = e2.GetScrollY();
        }
        this._SetMVMatrixChanged(), this._runtime.UpdateRender();
      }
    }
    IsOwnScrollPositionEnabled() {
      return this._hasOwnScrollPosition;
    }
    SetScrollX(e) {
      const t2 = this.GetLayout(), s = t2.GetScrollLeftBound(), a2 = t2.GetScrollRightBound();
      e > a2 && (e = a2), e < s && (e = s), this._scrollX !== e && (this._scrollX = e, this.IsOwnScrollPositionEnabled() && (this._SetMVMatrixChanged(), this._runtime.UpdateRender()));
    }
    SetScrollY(e) {
      const t2 = this.GetLayout(), s = t2.GetScrollTopBound(), a2 = t2.GetScrollBottomBound();
      e > a2 && (e = a2), e < s && (e = s), this._scrollY !== e && (this._scrollY = e, this.IsOwnScrollPositionEnabled() && (this._SetMVMatrixChanged(), this._runtime.UpdateRender()));
    }
    GetScrollX() {
      return this.IsOwnScrollPositionEnabled() ? this._scrollX : this.GetLayout().GetScrollX();
    }
    GetScrollY() {
      return this.IsOwnScrollPositionEnabled() ? this._scrollY : this.GetLayout().GetScrollY();
    }
    GetViewport() {
      return this._MaybeUpdateViewport(), this._viewport;
    }
    _GetViewportZ0() {
      return this._MaybeUpdateViewport(), this._viewportZ0;
    }
    GetViewport3D() {
      return this._MaybeUpdateViewport(), this._viewport3D;
    }
    _GetVanishingPoint() {
      return this.GetLayout().GetVanishingPoint();
    }
    GetDefaultCameraZ(e) {
      return this._runtime.GetDefaultCameraZ(e);
    }
    GetViewportForZ(e, t2) {
      const s = this._GetViewportZ0();
      if (0 === e) t2.copy(s);
      else {
        let a2 = s.midX(), i = s.midY();
        const r2 = this.Get2DScaleFactorToZ(e), n = s.width() / r2, l = s.height() / r2, [o2, h2] = this._GetVanishingPoint();
        if (0.5 !== o2 || 0.5 !== h2) {
          const t3 = this.Get2DCameraZ(), s2 = this._runtime, r3 = this.GetDefaultCameraZ() / t3;
          let n2 = (o2 - 0.5) * s2.GetViewportWidth() / r3, l2 = (h2 - 0.5) * s2.GetViewportHeight() / r3;
          const c2 = this.GetAngle();
          0 !== c2 && (tempVec2.set(n2, l2), tempVec2.rotate(c2), n2 = tempVec2.getX(), l2 = tempVec2.getY());
          const d2 = C32.unlerp(t3, 0, e);
          a2 += C32.lerp(n2, 0, d2), i += C32.lerp(l2, 0, d2);
        }
        t2.set(a2 - n / 2, i - l / 2, a2 + n / 2, i + l / 2);
      }
    }
    GetOpacity() {
      return this._color.getA();
    }
    SetOpacity(e) {
      e = C32.clamp(e, 0, 1), this._color.getA() !== e && (this._color.setA(e), this._UpdatePremultipliedColor(), this._runtime.UpdateRender());
    }
    _UpdatePremultipliedColor() {
      this._premultipliedColor.copy(this._color), this._premultipliedColor.premultiply();
    }
    GetPremultipliedColor() {
      return this._premultipliedColor;
    }
    HasDefaultColor() {
      return this._color.equalsRgba(1, 1, 1, 1);
    }
    GetScaleRate() {
      return this._scaleRate;
    }
    SetScaleRate(e) {
      this._scaleRate !== e && (this._scaleRate = e, this._SetMVMatrixChanged(), this._runtime.UpdateRender());
    }
    GetParallaxX() {
      return this._parallaxX;
    }
    GetParallaxY() {
      return this._parallaxY;
    }
    SetParallax(e, t2) {
      this._parallaxX === e && this._parallaxY === t2 || (this._parallaxX = e, this._parallaxY = t2, this._SetMVMatrixChanged(), this._runtime.UpdateRender());
    }
    SetParallaxX(e) {
      this.SetParallax(e, this.GetParallaxY());
    }
    SetParallaxY(e) {
      this.SetParallax(this.GetParallaxX(), e);
    }
    SetZElevation(e) {
      this._zElevation !== e && (this._zElevation = e, this._runtime.UpdateRender());
    }
    GetZElevation() {
      return this._zElevation;
    }
    SetAngle(e) {
      e = C32.clampAngle(e), this._angle !== e && (this._angle = e, this._SetMVMatrixChanged(), this._runtime.UpdateRender());
    }
    GetAngle() {
      return C32.clampAngle(this._layout.GetAngle() + this._angle);
    }
    GetOwnAngle() {
      return this._angle;
    }
    HasInstances() {
      return this._instances.length > 0;
    }
    _GetInstances() {
      return this._instances;
    }
    _GetInstancesInDrawOrder() {
      return this.RendersIn3DMode() && this._useCameraDistanceDrawOrder ? (C32.shallowAssignArray(tempInstancesByCameraDist, this._GetInstances()), tempInstancesByCameraDist.sort((e, t2) => this._SortInstancesByCameraDistance(e, t2)), tempInstancesByCameraDist) : this._GetInstances();
    }
    _AppendAllInstancesIncludingSubLayersInDrawOrder(e) {
      C32.appendArray(e, this._GetInstancesInDrawOrder());
      for (const t2 of this._subLayers) t2.IsVisible() && t2.GetOpacity() > 0 && t2._AppendAllInstancesIncludingSubLayersInDrawOrder(e);
    }
    _SortInstancesByCameraDistance(e, t2) {
      const s = this.GetLayout().Get3DCameraPosition(), a2 = s[0], i = s[1], r2 = s[2], n = e.GetWorldInfo(), l = t2.GetWorldInfo(), o2 = n.GetX() - a2, h2 = n.GetY() - i, c2 = n.GetZElevation() - r2, d2 = l.GetX() - a2, _2 = l.GetY() - i, u2 = l.GetZElevation() - r2;
      return d2 * d2 + _2 * _2 + u2 * u2 - (o2 * o2 + h2 * h2 + c2 * c2);
    }
    GetBackgroundColor() {
      return this._backgroundColor;
    }
    IsTransparent() {
      return this._isTransparent;
    }
    SetTransparent(e) {
      e = !!e, this._isTransparent !== e && (this._isTransparent = e, this._runtime.UpdateRender());
    }
    IsForceOwnTexture() {
      return this._isForceOwnTexture;
    }
    SetForceOwnTexture(e) {
      e = !!e, this._isForceOwnTexture !== e && (this._isForceOwnTexture = e, this._runtime.UpdateRender());
    }
    SetRenderAs3D(e) {
      e = !!e, this._renderAs3d !== e && (this._renderAs3d = e, this._SetMVMatrixChanged(), this._runtime.UpdateRender());
    }
    IsRenderAs3D() {
      return this._renderAs3d;
    }
    RendersIn2DMode() {
      return !this.GetRuntime().Uses3DFeatures() || !this._renderAs3d;
    }
    RendersIn3DMode() {
      return !this.RendersIn2DMode();
    }
    Has3DCamera() {
      return this.RendersIn3DMode() && this.GetLayout().Is3DCameraEnabled();
    }
    SelfAndAllSubLayersHave3DCamera() {
      if (!this.Has3DCamera()) return false;
      for (const e of this._subLayers) if (!e.SelfAndAllSubLayersHave3DCamera()) return false;
      return true;
    }
    SetBlendMode(e) {
      this._blendMode !== e && (this._blendMode = e, this._runtime.UpdateRender());
    }
    GetBlendMode() {
      return this._blendMode;
    }
    IsRootLayer() {
      return !this._parentLayer;
    }
    GetParentLayer() {
      return this._parentLayer;
    }
    _SetParentLayer(e) {
      this._parentLayer = e;
    }
    GetSubLayers() {
      return this._subLayers;
    }
    HasAnySubLayers() {
      return this._subLayers.length > 0;
    }
    _AddSubLayer(e, t2 = true) {
      t2 ? this._subLayers.push(e) : this._subLayers.unshift(e);
    }
    _InsertSubLayer(e, t2, s) {
      let a2 = this._subLayers.indexOf(t2);
      if (-1 === a2) throw new Error("cannot find layer to insert by");
      s && ++a2, this._subLayers.splice(a2, 0, e);
    }
    _RemoveSubLayer(e) {
      const t2 = this._subLayers.indexOf(e);
      if (-1 === t2) throw new Error("cannot find layer to remove");
      this._subLayers.splice(t2, 1);
    }
    HasAnyVisibleSubLayer() {
      for (const e of this._subLayers) if (e.ShouldDraw()) return true;
      return false;
    }
    *selfAndAllSubLayers() {
      for (const e of this._subLayers) yield* e.selfAndAllSubLayers();
      yield this;
    }
    *parentLayers() {
      let e = this.GetParentLayer();
      for (; e; ) yield e, e = e.GetParentLayer();
    }
    *selfAndParentLayers() {
      yield this, yield* this.parentLayers();
    }
    HasParentLayer(e) {
      for (const t2 of this.parentLayers()) if (t2 === e) return true;
      return false;
    }
    IsTransformCompatibleWith(e) {
      return this === e || this._parallaxX === e._parallaxX && this._parallaxY === e._parallaxY && this._scale === e._scale && this._scaleRate === e._scaleRate && this._angle === e._angle && this.GetScrollX() === e.GetScrollX() && this.GetScrollY() === e.GetScrollY();
    }
    SaveTransform() {
      return { "parallaxX": this.GetParallaxX(), "parallaxY": this.GetParallaxY(), "scale": this.GetOwnScale(), "scaleRate": this.GetScaleRate(), "angle": this.GetOwnAngle(), "hasOwnScroll": this.IsOwnScrollPositionEnabled(), "scrollX": this.GetScrollX(), "scrollY": this.GetScrollY() };
    }
    RestoreTransform(e) {
      this.SetParallax(e["parallaxX"], e["parallaxY"]), this.SetOwnScale(e["scale"]), this.SetScaleRate(e["scaleRate"]), this.SetAngle(e["angle"]), this.SetOwnScrollPositionEnabled(e["hasOwnScroll"]), this.SetScrollX(e["scrollX"]), this.SetScrollY(e["scrollY"]), this._MaybeUpdateViewport();
    }
    _RemoveAllInstancesInSet(e) {
      if (0 === e.size) return;
      C32.arrayRemoveAllInSet(this._instances, e) > 0 && (this._MaybeResetAnyInstanceZElevatedFlag(), this.SetZIndicesChanged());
    }
    SetZIndicesChanged(e) {
      this._zIndicesUpToDate = false, this._isRenderListUpToDate = false, e && !e.GetObjectClass().GetPlugin().IsHTMLElementType() || (this._htmlZIndicesUpToDate = false);
    }
    _UpdateZIndices() {
      if (!this._zIndicesUpToDate) {
        if (this._instances.sort(SortByInstZElevation), this.UsesRenderCells()) for (let e = 0, t2 = this._instances.length; e < t2; ++e) {
          const t3 = this._instances[e].GetWorldInfo();
          t3._SetZIndex(e), this._renderGrid.MarkRangeChanged(t3.GetRenderCellRange());
        }
        else for (let e = 0, t2 = this._instances.length; e < t2; ++e) this._instances[e].GetWorldInfo()._SetZIndex(e);
        this._zIndicesUpToDate = true;
      }
    }
    _UpdateHTMLZIndices() {
      if (this._htmlZIndicesUpToDate) return;
      const e = this._layout.GetRootLayersForHTMLLayer(this.GetHTMLIndex()).map((e2) => [...e2.selfAndAllSubLayers()]).flat();
      let t2 = 0;
      for (const s of e) {
        for (const e2 of s._GetInstances()) e2.GetObjectClass().GetPlugin().IsHTMLElementType() && e2.GetWorldInfo()._SetHTMLZIndex(t2++);
        s._SetHTMLZIndicesUpToDate();
      }
    }
    _SetHTMLZIndicesUpToDate() {
      this._htmlZIndicesUpToDate = true;
    }
    _GetHTMLLayerDOMState() {
      return { "isVisible": this.IsVisible(), "opacity": this.GetOpacity(), "isInteractive": this.IsInteractive() };
    }
    MoveInstanceAdjacent(e, t2, s) {
      const a2 = e.GetWorldInfo(), i = t2.GetWorldInfo();
      if (a2.GetLayer() !== this || i.GetLayer() !== this) throw new Error("can't arrange Z order unless both objects on this layer");
      const r2 = a2.GetZIndex();
      let n = i.GetZIndex();
      return r2 !== n + (s ? 1 : -1) && (C32.arrayRemove(this._instances, r2), r2 < n && n--, s && n++, n === this._instances.length ? this._instances.push(e) : this._instances.splice(n, 0, e), this.SetZIndicesChanged(e), true);
    }
    _MergeSortedZArrays(e, t2) {
      const s = [];
      let a2 = 0, i = 0, r2 = e.length, n = t2.length;
      for (; a2 < r2 && i < n; ) {
        const r3 = e[a2], n2 = t2[i];
        r3.GetWorldInfo()._GetLastCachedZIndex() < n2.GetWorldInfo()._GetLastCachedZIndex() ? (s.push(r3), ++a2) : (s.push(n2), ++i);
      }
      for (; a2 < r2; ++a2) s.push(e[a2]);
      for (; i < n; ++i) s.push(t2[i]);
      return s;
    }
    _MergeAllSortedZArrays_pass(e) {
      const t2 = [], s = e.length;
      for (let a2 = 0; a2 < s - 1; a2 += 2) {
        const s2 = e[a2], i = e[a2 + 1];
        t2.push(this._MergeSortedZArrays(s2, i));
      }
      return s % 2 == 1 && t2.push(e[s - 1]), t2;
    }
    _MergeAllSortedZArrays(e) {
      for (; e.length > 1; ) e = this._MergeAllSortedZArrays_pass(e);
      return e[0];
    }
    _GetRenderCellInstancesToDraw() {
      return this._UpdateZIndices(), C32.clearArray(renderCellArr), this._renderGrid.QueryRange(this.GetViewport(), renderCellArr), renderCellArr.length ? 1 === renderCellArr.length ? renderCellArr[0] : this._MergeAllSortedZArrays(renderCellArr) : [];
    }
    ShouldDraw() {
      return this.IsVisible() && this.GetOpacity() > 0 && this._DrawsAnyContentInSelfOrSubLayers();
    }
    _DrawsAnyContentInSelfOrSubLayers() {
      if (this.HasInstances() || !this.IsTransparent() || this._userScriptDispatcher.HasAnyHandlerFor("beforedraw") || this._userScriptDispatcher.HasAnyHandlerFor("afterdraw")) return true;
      for (const e of this._subLayers) if (e._DrawsAnyContentInSelfOrSubLayers()) return true;
      return false;
    }
    UsesOwnTexture() {
      return this.IsForceOwnTexture() || !this.HasDefaultColor() || 0 !== this.GetBlendMode() || this._effectList.HasAnyActiveEffect();
    }
    SelfOrAnySubLayerUsesOwnTexture() {
      if (this.UsesOwnTexture()) return true;
      for (const e of this._subLayers) if (e.SelfOrAnySubLayerUsesOwnTexture()) return true;
      return false;
    }
    GetRenderTarget() {
      return this._curRenderTarget;
    }
    Get2DScaleFactorToZ(e) {
      if (this._layout.IsOrthographicProjection()) return 1;
      {
        const t2 = this.Get3DCameraZ();
        return t2 / (t2 - e);
      }
    }
    GetResolutionScaleFactorToZ(e) {
      const t2 = this._runtime.GetRenderScale();
      if (this._layout.IsOrthographicProjection()) return t2;
      {
        const s = this.Get3DCameraZ();
        return this.GetDefaultCameraZ() / Math.abs(s - e) * t2;
      }
    }
    _SetMVMatrixChanged() {
      this._isMVMatrixChanged = true, this._isViewFrustumChanged = true, this._isViewportChanged = true;
    }
    _GetModelViewMatrix(e) {
      return this._isMVMatrixChanged && (this._CalculateModelViewMatrix(e, this._modelViewMatrix, 0, 0, null), this._isMVMatrixChanged = false), this._modelViewMatrix;
    }
    Get2DCameraZ(e) {
      return this.GetDefaultCameraZ(e) / this.GetNormalScale();
    }
    Get3DCameraZ() {
      return this.Has3DCamera() ? this.GetLayout().Get3DCameraPosition()[2] : this.Get2DCameraZ();
    }
    GetCameraPosition() {
      if (this.Has3DCamera()) {
        const e = this.GetLayout().Get3DCameraPosition();
        return [e[0], e[1], e[2]];
      }
      return this._Get2DCameraPosition();
    }
    _Get2DCameraPosition(e = 0, t2 = 0, s = 0) {
      const a2 = this._runtime, i = this.GetLayout(), r2 = a2.GetParallaxXOrigin(), n = a2.GetParallaxYOrigin();
      let l = (this.GetScrollX() - r2) * this._parallaxX + r2, o2 = (this.GetScrollY() - n) * this._parallaxY + n;
      a2.IsPixelRoundingEnabled() && (l = Math.round(l), o2 = Math.round(o2));
      let h2 = l + e, c2 = o2 + t2;
      const d2 = i.IsOrthographicProjection() ? this.GetDefaultCameraZ(s) : this.Get2DCameraZ(s), [_2, u2] = this._GetVanishingPoint();
      if (0.5 !== _2 || 0.5 !== u2) {
        const e2 = this.GetDefaultCameraZ(s) / d2;
        let t3 = (_2 - 0.5) * a2.GetViewportWidth() / e2, i2 = (u2 - 0.5) * a2.GetViewportHeight() / e2;
        const r3 = this.GetAngle();
        0 !== r3 && (tempVec2.set(t3, i2), tempVec2.rotate(r3), t3 = tempVec2.getX(), i2 = tempVec2.getY()), h2 += t3, c2 += i2;
      }
      return [h2, c2, d2];
    }
    _CalculateModelViewMatrix(e, t2, s, a2, i) {
      const r2 = this._runtime, n = this.GetLayout();
      if (this.Has3DCamera()) {
        vec3.copy(camVector, n.Get3DCameraPosition()), vec3.copy(lookVector, n.Get3DCameraLookAt()), vec3.copy(upVector, n.Get3DCameraUpVector());
        const e2 = r2.GetParallaxXOrigin(), t3 = r2.GetParallaxYOrigin(), s2 = lookVector[0] - camVector[0], a3 = lookVector[1] - camVector[1], i2 = lookVector[2] - camVector[2];
        camVector[0] = (camVector[0] - e2) * this._parallaxX + e2, camVector[1] = (camVector[1] - t3) * this._parallaxY + t3, camVector[2] *= Math.max(this._parallaxX, this._parallaxY), lookVector[0] = camVector[0] + s2, lookVector[1] = camVector[1] + a3, lookVector[2] = camVector[2] + i2;
      } else {
        const [e2, t3, r3] = this._Get2DCameraPosition(s, a2, i);
        vec3.set(camVector, e2, t3, r3), vec3.set(lookVector, e2, t3, r3 - 100);
        const n2 = this.GetAngle();
        0 === n2 ? vec3.set(upVector, 0, 1, 0) : vec3.set(upVector, Math.sin(n2), Math.cos(n2), 0);
      }
      e.CalculateLookAtModelView(t2, camVector, lookVector, upVector, i || r2.GetViewportHeight());
    }
    _SetProjectionMatrixChanged() {
      this._isProjectionMatrixChanged = true, this._isViewFrustumChanged = true, this._isViewportChanged = true;
    }
    _GetProjectionMatrix(e) {
      return this._isProjectionMatrixChanged && (this._CalculateProjectionMatrix(e), this._isProjectionMatrixChanged = false), this._projectionMatrix;
    }
    _CalculateProjectionMatrix(e) {
      const t2 = this._runtime.GetCanvasManager(), [s, a2] = this._GetVanishingPoint();
      if (this._layout.IsOrthographicProjection()) e.CalculateOrthographicMatrix(this._projectionMatrix, t2.GetDrawWidth(), t2.GetDrawHeight());
      else if (0.5 === s && 0.5 === a2) mat4.copy(this._projectionMatrix, t2.GetDefaultProjectionMatrix());
      else {
        const i = t2.GetDrawWidth(), r2 = t2.GetDrawHeight();
        e.CalculatePerspectiveMatrix(this._projectionMatrix, i / r2, s, a2);
      }
    }
    _SetTransform(e, t2 = true, s = 0, a2 = 0, i = 0) {
      t2 && e.SetProjectionMatrix(this._GetProjectionMatrix(e));
      let r2 = null;
      0 === s && 0 === a2 && 0 === i ? r2 = this._GetModelViewMatrix(e) : (this._CalculateModelViewMatrix(e, tempMat4, s, a2, i), r2 = tempMat4), e.SetModelViewMatrix(r2);
    }
    PrepareForDraw(e) {
      this._SetTransform(e), e.SetBaseZ(this.GetZElevation());
    }
    _MaybeStartWebGLProfiling(e) {
      let t2 = null;
      if (e.IsWebGL() && this._runtime.IsGPUProfiling()) {
        const s = this._runtime.GetCanvasManager().GetLayerTimingsBuffer(this);
        s && (t2 = s.AddTimeElapsedQuery(), e.StartQuery(t2));
      }
      return t2;
    }
    _MaybeStartWebGPUProfiling(e) {
      if (e.IsWebGPU() && this._runtime.IsGPUProfiling()) {
        const t2 = 2 * (this.GetIndex() + 1);
        e.StartMeasuringRenderPassTime(t2, t2 + 1);
      }
    }
    _FireDrawEvent(e, t2) {
      if (this._userScriptDispatcher.HasAnyHandlerFor(t2)) {
        e.SetTextureFillMode(), e.SetTexture(null), e.SetAlphaBlend(), e.ResetCullState(), e.SetColorRgba(1, 1, 1, 1), e.SetBaseZ(this.GetZElevation()), e.SetCurrentZ(0);
        const s = new C32.Event(t2);
        s.renderer = this._runtime.GetCanvasManager().GetIRenderer(), this.DispatchUserScriptEvent(s);
      }
    }
    Draw(e, t2, s) {
      const a2 = this._runtime.GetCanvasManager(), i = this.UsesOwnTexture();
      let r2 = null;
      const n = this._MaybeStartWebGLProfiling(e);
      if (this._MaybeStartWebGPUProfiling(e), i) {
        const t3 = { sampling: this._runtime.GetSampling(), isSampled: true, canReadPixels: !!e.IsWebGPU() && this._runtime.UsesAnyBackgroundBlending() };
        "low" === a2.GetCurrentFullscreenScalingQuality() && (t3.width = a2.GetDrawWidth(), t3.height = a2.GetDrawHeight()), r2 = this._runtime.GetAdditionalRenderTarget(t3), this._curRenderTarget = r2, e.SetRenderTarget(r2), this.IsTransparent() && e.ClearRgba(0, 0, 0, 0);
      } else this._curRenderTarget = t2, e.SetRenderTarget(t2);
      if (this.IsTransparent() || e.Clear(this._backgroundColor), this._layout._DrawLayerList(e, this._curRenderTarget, this._subLayers, i && this.IsTransparent()), this._MaybeStartWebGPUProfiling(e), this._SetTransform(e), e.SetBaseZ(this.GetZElevation()), e.SetDepthEnabled(this.RendersIn3DMode()), this._FireDrawEvent(e, "beforedraw"), this.GetNormalScale() > Number.EPSILON) {
        this._UpdateZIndices();
        const t3 = this.UsesRenderCells() && 0 === this.GetZElevation() && !this._anyInstanceZElevated;
        this.Has3DCamera() ? this._DrawInstances_3DCamera(e) : t3 ? this._DrawInstances_RenderCells(e) : this._DrawInstances(e, this._GetInstancesInDrawOrder());
      }
      this._FireDrawEvent(e, "afterdraw"), e.SetBaseZ(0), e.SetCurrentZ(0), i && (e.SetDepthEnabled(false), this._DrawLayerOwnTextureToRenderTarget(e, r2, t2, s)), n && e.EndQuery(n), this._curRenderTarget = null;
    }
    _DrawInstances(e, t2) {
      const s = this.GetViewport(), a2 = this._curRenderTarget, i = this.GetLayout().IsOrthographicProjection(), r2 = this.GetLayout().HasVanishingPointOutsideViewport();
      let n = null;
      for (let l = 0, o2 = t2.length; l < o2; ++l) {
        const o3 = t2[l];
        if (o3 === n) continue;
        n = o3;
        const h2 = o3.GetWorldInfo();
        h2.IsVisible() && h2.IsInViewport(s, r2, i) && this._DrawInstanceMaybeWithEffects(o3, h2, e, a2);
      }
    }
    _DrawInstances_3DCamera(e) {
      const t2 = this._curRenderTarget, s = this._GetViewFrustum(), a2 = tempInstanceList1, i = tempInstanceList2, r2 = this._GetInstancesInDrawOrder();
      for (let n = 0, l = r2.length; n < l; ) {
        const o2 = r2[n], h2 = o2.GetWorldInfo();
        if (!h2.IsVisible() || !h2.IsInViewport3D(s)) {
          ++n;
          continue;
        }
        (!o2.RendersToOwnZPlane() || h2.GetDepth() > 0) && i.push(o2);
        const c2 = o2.GetWorldInfo().GetTotalZElevation();
        a2.push(o2);
        let d2 = n + 1;
        for (; d2 < l; ++d2) {
          const e2 = r2[d2], t3 = e2.GetWorldInfo();
          if (t3.IsVisible() && t3.IsInViewport3D(s)) {
            if (t3.GetTotalZElevation() !== c2) break;
            e2.RendersToOwnZPlane() ? (t3.GetDepth() > 0 && i.push(e2), a2.push(e2)) : i.push(e2);
          }
        }
        if (1 !== a2.length || a2[0].MustMitigateZFighting()) {
          this._DrawCoplanarInstances_3DCamera(e, a2);
          for (let s2 = 0, a3 = i.length; s2 < a3; ++s2) {
            const a4 = i[s2], r3 = a4.GetWorldInfo();
            r3._SetDrawNonBackFacesOnly(true), this._DrawInstanceMaybeWithEffects(a4, r3, e, t2), r3._SetDrawNonBackFacesOnly(false);
          }
        } else {
          this._DrawInstanceMaybeWithEffects(o2, h2, e, t2);
          for (let s2 = 0, a3 = i.length; s2 < a3; ++s2) {
            const a4 = i[s2];
            if (a4 === o2) continue;
            const r3 = a4.GetWorldInfo();
            r3.GetLayer()._DrawInstanceMaybeWithEffects(a4, r3, e, t2);
          }
        }
        n = d2, C32.clearArray(a2), C32.clearArray(i);
      }
    }
    _DrawCoplanarInstances_3DCamera(e, t2) {
      const s = this._curRenderTarget;
      e.CoplanarStartStencilPass();
      for (let s2 = 0, a2 = t2.length; s2 < a2; ++s2) {
        const a3 = t2[s2], i = a3.GetWorldInfo();
        i._SetDrawBackFaceOnly(true), this._DrawInstance(a3, i, e);
      }
      e.CoplanarStartColorPass();
      for (let a2 = 0, i = t2.length; a2 < i; ++a2) {
        const i2 = t2[a2], r2 = i2.GetWorldInfo();
        this._DrawInstanceMaybeWithEffects(i2, r2, e, s), r2._SetDrawBackFaceOnly(false);
      }
      e.CoplanarRestoreStandardRendering();
    }
    _DrawInstances_RenderCells(e) {
      const t2 = this._renderGrid, s = this._curRenderCells, a2 = this._lastRenderCells, i = this.GetViewport();
      let r2;
      s.set(t2.XToCell(i.getLeft()), t2.YToCell(i.getTop()), t2.XToCell(i.getRight()), t2.YToCell(i.getBottom())), this._isRenderListUpToDate && s.equals(a2) ? r2 = this._lastRenderList : (r2 = this._GetRenderCellInstancesToDraw(), this._isRenderListUpToDate = true, a2.copy(s)), this._DrawInstances(e, r2), r2 !== this._lastRenderList && C32.shallowAssignArray(this._lastRenderList, r2);
    }
    _DrawInstanceMaybeWithEffects(e, t2, s, a2) {
      t2.HasAnyActiveEffect() ? this._DrawInstanceWithEffectsAndRestore(e, t2, s, a2) : this._DrawInstance(e, t2, s);
    }
    _DrawInstance(e, t2, s) {
      const a2 = t2.GetRendererStateGroup();
      s.GetCurrentStateGroup() !== a2 && a2.Apply(), e.Draw(s);
    }
    _DrawInstanceWithEffectsAndRestore(e, t2, s, a2) {
      this._DrawInstanceWithEffects(e, t2, s, a2, null) && this._SetTransform(s);
    }
    _DrawInstanceWithEffects(e, t2, s, a2, i) {
      const r2 = t2.GetInstanceEffectList().GetEffectChain();
      return r2.Render(s, a2, { contentObject: e, blendMode: t2.GetBlendMode(), devicePixelRatio: this._runtime.GetEffectDevicePixelRatioParam(), time: e.GetInstanceGameTime(), layerScale: this._runtime.GetEffectLayerScaleParam() * this.GetNormalScale(), layerAngle: this.GetAngle(), layoutRect: t2.GetBoundingBox(), drawSurfaceRect: r2.CanSkipCalculatingDrawSurfaceRect() ? null : this._InstanceBoxToDrawSurface(t2), drawContentHook: i && i.drawContentHook, compositOffX: i && i.compositOffX, compositOffY: i && i.compositOffY, compositRtWidth: i && i.compositRtWidth, compositRtHeight: i && i.compositRtHeight, updateOwnProjection: i && i.updateOwnProjection }), s.SetBaseZ(this.GetZElevation()), r2.DidChangeTransform();
    }
    _DrawLayerOwnTextureToRenderTarget(e, t2, s, a2) {
      const i = this._effectList.GetActiveEffectTypes(), r2 = this._runtime;
      0 === i.length ? (e.SetRenderTarget(s), e.SetTextureFillMode(), a2 && 0 === this._blendMode && this.HasDefaultColor() ? e.CopyRenderTarget(t2) : (e.SetBlendMode(this._blendMode), e.SetColor(this._premultipliedColor), e.DrawRenderTarget(t2)), e.InvalidateRenderTarget(t2), r2.ReleaseAdditionalRenderTarget(t2)) : this.GetEffectChain().Render(e, s, { contentObject: this, blendMode: this.GetBlendMode(), devicePixelRatio: r2.GetEffectDevicePixelRatioParam(), layerScale: r2.GetEffectLayerScaleParam() * this.GetNormalScale(), layerAngle: this.GetAngle(), layoutRect: this.GetViewport(), drawSurfaceRect: null, invalidateRenderTargets: true });
    }
    GetOwnScale() {
      return this._scale;
    }
    SetOwnScale(e) {
      this._scale !== e && (this._scale = e, this._layout.BoundScrolling(), this._SetMVMatrixChanged(), this._runtime.UpdateRender());
    }
    GetRenderScale() {
      return this.GetNormalScale() * this._runtime.GetRenderScale();
    }
    GetDisplayScale() {
      return this.GetNormalScale() * this._runtime.GetDisplayScale();
    }
    GetNormalScale() {
      return (this._scale * this._layout.GetScale() - 1) * this._scaleRate + 1;
    }
    _MaybeUpdateViewport() {
      if (!this._isViewportChanged) return;
      this._isViewportChanged = false;
      const e = this._runtime.GetParallaxXOrigin(), t2 = this._runtime.GetParallaxYOrigin(), s = (this.GetScrollX() - e) * this._parallaxX + e, a2 = (this.GetScrollY() - t2) * this._parallaxY + t2, i = this.GetNormalScale(), r2 = this._runtime.GetViewportWidth() / i, n = this._runtime.GetViewportHeight() / i;
      let l = s - r2 / 2, o2 = a2 - n / 2;
      this._runtime.IsPixelRoundingEnabled() && (l = Math.round(l), o2 = Math.round(o2));
      const h2 = this._viewportZ0;
      h2.set(l, o2, l + r2, o2 + n);
      const c2 = this.GetAngle();
      0 !== c2 && (tmpRect.copy(h2), tmpRect.offset(-h2.midX(), -h2.midY()), tmpQuad.setFromRotatedRect(tmpRect, c2), tmpQuad.getBoundingBox(tmpRect), tmpRect.offset(h2.midX(), h2.midY()), h2.copy(tmpRect));
      const d2 = this._zElevation;
      this.GetViewportForZ(d2, this._viewport), this.Has3DCamera() ? this.CalculateViewport3D(d2, this._viewport3D) : this._viewport3D.copy(this._viewport);
    }
    CalculateViewport3D(e, t2) {
      const s = this._runtime.GetCanvasManager(), a2 = s.GetCssWidth(), i = s.GetCssHeight(), [r2, n] = this.CanvasCssToLayer(0, 0, e), [l, o2] = this.CanvasCssToLayer(a2, 0, e), [h2, c2] = this.CanvasCssToLayer(a2, i, e), [d2, _2] = this.CanvasCssToLayer(0, i, e);
      let u2 = Math.min(r2, l, h2, d2), G = Math.min(n, o2, c2, _2), p2 = Math.max(r2, l, h2, d2), f2 = Math.max(n, o2, c2, _2);
      isFinite(u2) || (u2 = -1 / 0), isFinite(G) || (G = -1 / 0), isFinite(p2) || (p2 = 1 / 0), isFinite(f2) || (f2 = 1 / 0), t2.set(u2, G, p2, f2);
    }
    CanvasCssToLayer(e, t2, s = 0) {
      return this._CanvasToLayer(e, t2, s, this.GetDisplayScale());
    }
    DrawSurfaceToLayer(e, t2, s = 0) {
      return this._CanvasToLayer(e, t2, s, this.GetRenderScale() * this.GetDevicePixelRatio());
    }
    _CanvasToLayer(e, t2, s, a2) {
      const i = this._runtime, r2 = i.GetRenderer(), n = this.GetNormalScale(), l = i.GetViewportWidth() / n, o2 = i.GetViewportHeight() / n, h2 = tempVec4;
      vec4.set(h2, 0, 0, l, o2), e /= a2, t2 = h2[3] - t2 / a2;
      const c2 = this._GetProjectionMatrix(r2), d2 = this._GetModelViewMatrix(r2), _2 = tempVec3;
      return C32.Gfx.UnprojectScreenToWorldZ(e, t2, s, d2, c2, h2, _2) ? [_2[0], _2[1]] : [NaN, NaN];
    }
    CanvasCssToLayer_DefaultTransform(e, t2) {
      const s = this._scale, a2 = this._scaleRate, i = this._parallaxX, r2 = this._parallaxY, n = this._angle, l = this.Has3DCamera();
      l && this.GetLayout().Set3DCameraEnabled(false), this._scale = 1, this._scaleRate = 1, this._parallaxX = 1, this._parallaxY = 1, this._angle = 0, this._SetMVMatrixChanged();
      const o2 = this.CanvasCssToLayer(e, t2);
      return this._scale = s, this._scaleRate = a2, this._parallaxX = i, this._parallaxY = r2, this._angle = n, this._SetMVMatrixChanged(), l && this.GetLayout().Set3DCameraEnabled(true), o2;
    }
    LayerToCanvasCss(e, t2, s = 0) {
      return this._LayerToCanvas(e, t2, s, this.GetDisplayScale());
    }
    LayerToDrawSurface(e, t2, s = 0) {
      return this._LayerToCanvas(e, t2, s, this.GetRenderScale() * this.GetDevicePixelRatio());
    }
    _LayerToCanvas(e, t2, s, a2) {
      const i = this._runtime, r2 = i.GetRenderer(), n = this.GetNormalScale(), l = i.GetViewportWidth() / n, o2 = i.GetViewportHeight() / n, h2 = tempVec4;
      vec4.set(h2, 0, 0, l, o2);
      const c2 = this._GetProjectionMatrix(r2), d2 = this._GetModelViewMatrix(r2), _2 = tempVec3;
      return C32.Gfx.Project(e, t2, s, d2, c2, h2, _2) ? [_2[0] * a2, (h2[3] - _2[1]) * a2] : [NaN, NaN];
    }
    _GetLayerToDrawSurfaceScale(e, t2) {
      return e *= this.GetRenderScale() * this.GetDevicePixelRatio(), 0 !== t2 && (e *= this.Get2DScaleFactorToZ(t2)), e;
    }
    _InstanceBoxToDrawSurface(e) {
      const t2 = e.GetBoundingBox(), s = e.GetTotalZElevation(), a2 = e.GetDepth(), i = s + a2, r2 = t2.getLeft(), n = t2.getTop(), l = t2.getRight(), o2 = t2.getBottom();
      if (this.Has3DCamera()) {
        if (this._IsPointBehindNearPlane(r2, n, s) || this._IsPointBehindNearPlane(l, n, s) || this._IsPointBehindNearPlane(l, o2, s) || this._IsPointBehindNearPlane(r2, o2, s)) return null;
        if (a2 > 0 && (this._IsPointBehindNearPlane(r2, n, i) || this._IsPointBehindNearPlane(l, n, i) || this._IsPointBehindNearPlane(l, o2, i) || this._IsPointBehindNearPlane(r2, o2, i))) return null;
      } else if (i >= this.Get2DCameraZ()) return null;
      let [h2, c2] = this.LayerToDrawSurface(r2, n, s), [d2, _2] = this.LayerToDrawSurface(l, o2, s);
      if (0 !== this.GetAngle() || a2 > 0 || this.Has3DCamera()) {
        const [e2, t3] = this.LayerToDrawSurface(l, n, s), [u2, G] = this.LayerToDrawSurface(r2, o2, s);
        if (a2 > 0) {
          const [s2, a3] = this.LayerToDrawSurface(r2, n, i), [p2, f2] = this.LayerToDrawSurface(l, n, i), [I2, C2] = this.LayerToDrawSurface(l, o2, i), [m2, y2] = this.LayerToDrawSurface(r2, o2, i);
          let S2 = Math.min(h2, d2, e2, u2, s2, p2, I2, m2);
          d2 = Math.max(h2, d2, e2, u2, s2, p2, I2, m2), h2 = S2, S2 = Math.min(c2, _2, t3, G, a3, f2, C2, y2), _2 = Math.max(c2, _2, t3, G, a3, f2, C2, y2), c2 = S2;
        } else {
          let s2 = Math.min(h2, d2, e2, u2);
          d2 = Math.max(h2, d2, e2, u2), h2 = s2, s2 = Math.min(c2, _2, t3, G), _2 = Math.max(c2, _2, t3, G), c2 = s2;
        }
      }
      return tmpRect.set(h2, c2, d2, _2), tmpRect;
    }
    _GetViewFrustum() {
      return this._isViewFrustumChanged && (this._UpdateViewFrustum(), this._isViewFrustumChanged = false), this._viewFrustum;
    }
    _UpdateViewFrustum() {
      const e = this._runtime.GetRenderer(), t2 = this._GetProjectionMatrix(e), s = this._GetModelViewMatrix(e);
      this._viewFrustum.CalculatePlanes(s, t2);
    }
    _IsPointBehindNearPlane(e, t2, s) {
      return this._GetViewFrustum().IsBehindNearPlane(e, t2, s);
    }
    _SaveToJson() {
      return { "d": this.IsDynamic(), "s": this.GetOwnScale(), "a": this.GetOwnAngle(), "v": this._IsVisibleFlagSet(), "i": this.IsInteractive(), "html": this.IsHTMLElementsLayer(), "bc": this._backgroundColor.toJSON(), "t": this.IsTransparent(), "sx": this._scrollX, "sy": this._scrollY, "hosp": this._hasOwnScrollPosition, "px": this.GetParallaxX(), "py": this.GetParallaxY(), "c": this._color.toJSON(), "sr": this.GetScaleRate(), "fx": this._effectList.SaveToJson(), "cg": this._createdGlobalUids };
    }
    _LoadFromJson(e) {
      this._isDynamic = !!e["d"], this._scale = e["s"], this._angle = e["a"], this._isVisible = !!e["v"], this._isInteractive = !e.hasOwnProperty("i") || e["i"], this._isHTMLElementsLayer = !!e["html"], this._backgroundColor.setFromJSON(e["bc"]), this._isTransparent = !!e["t"], e.hasOwnProperty("sx") && (this._scrollX = e["sx"]), e.hasOwnProperty("sy") && (this._scrollY = e["sy"]), e.hasOwnProperty("hosp") && (this._hasOwnScrollPosition = !!e["hosp"]), this._parallaxX = e["px"], this._parallaxY = e["py"], this._color.setFromJSON(e["c"]), this._UpdatePremultipliedColor(), this._scaleRate = e["sr"], C32.shallowAssignArray(this._createdGlobalUids, e["cg"]), C32.shallowAssignArray(this._initialInstances, this._startupInitialInstances);
      const t2 = new Set(this._createdGlobalUids);
      let s = 0;
      for (let e2 = 0, a2 = this._initialInstances.length; e2 < a2; ++e2) t2.has(this._initialInstances[e2][2]) || (this._initialInstances[s] = this._initialInstances[e2], ++s);
      C32.truncateArray(this._initialInstances, s), this._effectList.LoadFromJson(e["fx"]), this._needsRebuildEffectChainSteps = true;
    }
    _LoadFromJsonAfterInstances() {
      this._SortInstancesByLastCachedZIndex(false), this.SetZIndicesChanged(), this._SetMVMatrixChanged(), this._SetProjectionMatrixChanged();
    }
    GetILayer() {
      return this._iLayer;
    }
    UserScriptDispatcher() {
      return this._userScriptDispatcher;
    }
    DispatchUserScriptEvent(e) {
      e.layer = this.GetILayer(), this._userScriptDispatcher.dispatchEvent(e);
    }
    SortAndAddInstancesByZIndex(e, t2 = false, s = false) {
      if (this._instances.includes(e)) return t2 && this._instances.sort((e2, t3) => (e2.GetWorldInfo().GetSceneGraphZIndex() ?? 0) - (t3.GetWorldInfo().GetSceneGraphZIndex() ?? 0)), void (s && this._instances.forEach((e2, t3) => e2.GetWorldInfo()._SetZIndex(t3)));
      if (e.HasChildren()) {
        const t3 = [...e.allChildren()];
        t3.push(e), t3.sort((e2, t4) => (e2.GetWorldInfo().GetSceneGraphZIndex() ?? 0) - (t4.GetWorldInfo().GetSceneGraphZIndex() ?? 0));
        for (const e2 of t3) if (e2.IsInContainer()) for (const s2 of e2.siblings()) {
          if (t3.includes(s2)) continue;
          const e3 = [...s2.allChildren()];
          e3.push(s2), e3.sort((e4, t4) => (e4.GetWorldInfo().GetSceneGraphZIndex() ?? 0) - (t4.GetWorldInfo().GetSceneGraphZIndex() ?? 0)), e3 && e3.length && t3.splice(t3.length, 0, ...e3);
        }
        for (const e2 of t3) e2.GetPlugin().IsWorldType() && this._AddInstance(e2, true);
        s && this._instances.forEach((e2, t4) => e2.GetWorldInfo()._SetZIndex(t4));
      } else {
        if (e.GetPlugin().IsWorldType() && this._AddInstance(e, true), !e.IsInContainer()) return void (s && this._instances.forEach((e2, t3) => e2.GetWorldInfo()._SetZIndex(t3)));
        for (const t3 of e.siblings()) {
          const e2 = [...t3.allChildren()];
          if (e2.push(t3), e2.sort((e3, t4) => (e3.GetWorldInfo().GetSceneGraphZIndex() ?? 0) - (t4.GetWorldInfo().GetSceneGraphZIndex() ?? 0)), e2 && e2.length) for (const t4 of e2) t4.GetPlugin().IsWorldType() && this._AddInstance(t4, true);
        }
        s && this._instances.forEach((e2, t3) => e2.GetWorldInfo()._SetZIndex(t3));
      }
    }
  };
}
var SortByInstLastCachedZIndex2;
var SortByInstZElevation2;
{
  let vec3EqualsXYZ = function(e, t2, s, r2) {
    return e[0] === Math.fround(t2) && e[1] === Math.fround(s) && e[2] === Math.fround(r2);
  }, MaybePrepareLayerDraw = function(e, t2) {
    lastLayerPreparedForDrawing !== e && (e.PrepareForDraw(t2), lastLayerPreparedForDrawing = e);
  };
  vec3EqualsXYZ2 = vec3EqualsXYZ, MaybePrepareLayerDraw2 = MaybePrepareLayerDraw;
  const C32 = self.C3, C3Debugger = self.C3Debugger, assert = self.assert, tempDestRect = C32.New(C32.Rect), tempSrcRect = C32.New(C32.Rect), tempLayoutRect = C32.New(C32.Rect), tempColor = C32.New(C32.Color), glMatrix = self.glMatrix, vec3 = glMatrix.vec3, tempRender3dList = [], tempInstanceList1 = [], tempInstanceList2 = [], tempInstanceList3 = [];
  let lastLayerPreparedForDrawing = null;
  C32.Layout = class extends C32.DefendedBase {
    constructor(e, t2, s) {
      super(), this._layoutManager = e, this._runtime = e.GetRuntime(), this._name = s[0], this._originalWidth = s[1], this._originalHeight = s[2], this._width = s[1], this._height = s[2], this._isUnboundedScrolling = !!s[3], this._isOrthographicProjection = !!s[4], this._vanishingPointX = s[5], this._vanishingPointY = s[6], this._eventSheetName = s[7], this._eventSheet = null, this._sid = s[8], this._index = t2, this._scrollX = 0, this._scrollY = 0, this._scale = 1, this._angle = 0, this._initialObjectClasses = /* @__PURE__ */ new Set(), this._textureLoadedTypes = /* @__PURE__ */ new Set(), this._textureLoadPendingPromises = /* @__PURE__ */ new Set(), this._createdInstances = [], this._createdPersistedInstances = [], this._createdPersistedInstancesToDataMap = /* @__PURE__ */ new Map(), this._createdPersistedIndexToInstanceMap = /* @__PURE__ */ new Map(), this._initialNonWorld = [], this._is3dCameraEnabled = false, this._cam3dposition = vec3.create(), this._cam3dlook = vec3.create(), this._cam3dup = vec3.create(), this._rootLayers = [], this._allLayersFlat = [], this._layersByName = /* @__PURE__ */ new Map(), this._layersBySid = /* @__PURE__ */ new Map(), this._pendingSetHTMLLayerCount = -1;
      const r2 = this._runtime.GetCanvasManager();
      this._effectList = C32.New(C32.EffectList, this, s[11]), this._effectChain = C32.New(C32.Gfx.EffectChain, r2.GetEffectChainManager(), { drawContent: (e2, t3) => {
        const s2 = t3.GetContentObject().GetRenderTarget();
        e2.ResetColor(), e2.DrawRenderTarget(s2), e2.InvalidateRenderTarget(s2), r2.ReleaseAdditionalRenderTarget(s2);
      }, getShaderParameters: (e2) => this.GetEffectList()._GetEffectChainShaderParametersForIndex(e2) }), this._needsRebuildEffectChainSteps = true, this._wasFullScreenQualityLow = false, this._curRenderTarget = null, this._persistData = {}, this._persistedIntances = /* @__PURE__ */ new Map(), this._isFirstVisit = true, this._iLayout = new self.ILayout(this), this._userScriptDispatcher = C32.New(C32.Event.Dispatcher);
      for (const e2 of s[9]) this._rootLayers.push(C32.Layer.CreateFromExportData(this, null, e2));
      this._ReindexLayers();
      for (const e2 of this.allLayers()) e2._InitInitialInstances();
      for (const e2 of s[10]) {
        const t3 = this._runtime.GetObjectClassByIndex(e2[1]);
        if (!t3) throw new Error("missing nonworld object class");
        t3.GetDefaultInstanceData() || t3.SetDefaultInstanceData(e2), this._initialNonWorld.push(e2), this._AddInitialObjectClass(t3);
      }
    }
    Release() {
      for (const e of this._allLayersFlat) e.Release();
      C32.clearArray(this._allLayersFlat), this._textureLoadPendingPromises.clear(), this._eventSheet = null, this._layoutManager = null, this._runtime = null;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetName() {
      return this._name;
    }
    GetSID() {
      return this._sid;
    }
    GetIndex() {
      return this._index;
    }
    GetEffectList() {
      return this._effectList;
    }
    GetEffectChain() {
      return this._MaybeRebuildEffectChainSteps(), this._effectChain;
    }
    _MaybeRebuildEffectChainSteps() {
      const e = "low" === this._runtime.GetCanvasManager().GetCurrentFullscreenScalingQuality();
      if (!this._needsRebuildEffectChainSteps && this._wasFullScreenQualityLow === e && !this._effectChain.NeedsRebuild()) return;
      const t2 = this.GetEffectList().GetActiveEffectTypes();
      this._effectChain.BuildSteps(t2.map((e2) => e2.GetShaderProgram()), { indexMap: t2.map((e2) => e2.GetIndex()), forcePostDraw: e, useFullSurface: true }), this._needsRebuildEffectChainSteps = false, this._wasFullScreenQualityLow = e;
    }
    UpdateActiveEffects() {
      this.GetEffectList().UpdateActiveEffects(), this._needsRebuildEffectChainSteps = true;
    }
    GetMinLayerScale() {
      let e = this._allLayersFlat[0].GetNormalScale();
      for (let t2 = 1, s = this._allLayersFlat.length; t2 < s; ++t2) {
        const s2 = this._allLayersFlat[t2];
        0 === s2.GetParallaxX() && 0 === s2.GetParallaxY() || (e = Math.min(e, s2.GetNormalScale()));
      }
      return e;
    }
    _GetScrollBoundMarginHorizontal() {
      return 0.5 * this._runtime.GetViewportWidth() / this.GetMinLayerScale();
    }
    _GetScrollBoundMarginVertical() {
      return 0.5 * this._runtime.GetViewportHeight() / this.GetMinLayerScale();
    }
    GetScrollLeftBound() {
      return this.IsUnboundedScrolling() ? -1 / 0 : this._GetScrollBoundMarginHorizontal();
    }
    GetScrollRightBound() {
      return this.IsUnboundedScrolling() ? 1 / 0 : this.GetWidth() - this._GetScrollBoundMarginHorizontal();
    }
    GetScrollTopBound() {
      return this.IsUnboundedScrolling() ? -1 / 0 : this._GetScrollBoundMarginVertical();
    }
    GetScrollBottomBound() {
      return this.IsUnboundedScrolling() ? 1 / 0 : this.GetHeight() - this._GetScrollBoundMarginVertical();
    }
    SetScrollX(e) {
      const t2 = this.GetScrollLeftBound(), s = this.GetScrollRightBound();
      e > s && (e = s), e < t2 && (e = t2), this._scrollX !== e && (this._scrollX = e, this._SetAllLayersMVChanged(), this._runtime.UpdateRender());
    }
    GetScrollX() {
      return this._scrollX;
    }
    SetScrollY(e) {
      const t2 = this.GetScrollTopBound(), s = this.GetScrollBottomBound();
      e > s && (e = s), e < t2 && (e = t2), this._scrollY !== e && (this._scrollY = e, this._SetAllLayersMVChanged(), this._runtime.UpdateRender());
    }
    GetScrollY() {
      return this._scrollY;
    }
    IsUnboundedScrolling() {
      return this._isUnboundedScrolling;
    }
    BoundScrolling() {
      this.SetScrollX(this.GetScrollX()), this.SetScrollY(this.GetScrollY());
      for (const e of this._allLayersFlat) e.IsOwnScrollPositionEnabled() && (e.SetScrollX(e.GetScrollX()), e.SetScrollY(e.GetScrollY()));
    }
    SetVanishingPointXY(e, t2) {
      this._vanishingPointX === e && this._vanishingPointY === t2 || (this._vanishingPointX = e, this._vanishingPointY = t2, this.IsPerspectiveProjection() && (this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged(), this._runtime.UpdateRender()));
    }
    GetVanishingPointX() {
      return this.IsOrthographicProjection() ? 0.5 : this._vanishingPointX;
    }
    GetVanishingPointY() {
      return this.IsOrthographicProjection() ? 0.5 : this._vanishingPointY;
    }
    GetVanishingPoint() {
      return [this.GetVanishingPointX(), this.GetVanishingPointY()];
    }
    HasVanishingPointOutsideViewport() {
      const e = this.GetVanishingPointX(), t2 = this.GetVanishingPointY();
      return e < 0 || e > 1 || t2 < 0 || t2 > 1;
    }
    SetPerspectiveProjection() {
      this._isOrthographicProjection && (this._isOrthographicProjection = false, this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged(), this._runtime.UpdateRender());
    }
    SetOrthographicProjection() {
      this._isOrthographicProjection || (this._isOrthographicProjection = true, this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged(), this._runtime.UpdateRender());
    }
    IsOrthographicProjection() {
      return this._isOrthographicProjection;
    }
    IsPerspectiveProjection() {
      return !this.IsOrthographicProjection();
    }
    Set3DCameraEnabled(e) {
      e = !!e, this._is3dCameraEnabled !== e && (this._is3dCameraEnabled = e, this._SetAllLayersMVChanged(), this._runtime.UpdateRender());
    }
    Is3DCameraEnabled() {
      return this._is3dCameraEnabled;
    }
    Set3DCameraOrientation(e, t2, s, r2, a2, n, i, o2, l) {
      vec3EqualsXYZ(this._cam3dposition, e, t2, s) && vec3EqualsXYZ(this._cam3dlook, r2, a2, n) && vec3EqualsXYZ(this._cam3dup, i, o2, l) || (vec3.set(this._cam3dposition, e, t2, s), vec3.set(this._cam3dlook, r2, a2, n), vec3.set(this._cam3dup, i, o2, l), this.Set3DCameraChanged());
    }
    Set3DCameraChanged() {
      this._SetAllLayersMVChanged(), this._runtime.UpdateRender();
    }
    Get3DCameraPosition() {
      return this._cam3dposition;
    }
    Get3DCameraLookAt() {
      return this._cam3dlook;
    }
    Get3DCameraUpVector() {
      return this._cam3dup;
    }
    GetScale() {
      return this._scale;
    }
    SetScale(e) {
      this._scale !== e && (this._scale = e, this._SetAllLayersMVChanged(), this.BoundScrolling(), this._runtime.UpdateRender());
    }
    SetAngle(e) {
      e = C32.clampAngle(e), this._angle !== e && (this._angle = e, this._SetAllLayersMVChanged(), this._runtime.UpdateRender());
    }
    GetAngle() {
      return this._angle;
    }
    GetWidth() {
      return this._width;
    }
    SetWidth(e) {
      !isFinite(e) || e < 1 || (this._width = e);
    }
    GetHeight() {
      return this._height;
    }
    SetHeight(e) {
      !isFinite(e) || e < 1 || (this._height = e);
    }
    GetEventSheet() {
      return this._eventSheet;
    }
    _GetRootLayers() {
      return this._rootLayers;
    }
    *allLayers() {
      for (const e of this._rootLayers) yield* e.selfAndAllSubLayers();
    }
    GetLayers() {
      return this._allLayersFlat;
    }
    GetLayerCount() {
      return this._allLayersFlat.length;
    }
    GetLayer(e) {
      return "number" == typeof e ? this.GetLayerByIndex(e) : this.GetLayerByName(e.toString());
    }
    GetLayerByIndex(e) {
      return e = C32.clamp(Math.floor(e), 0, this._allLayersFlat.length - 1), this._allLayersFlat[e];
    }
    GetLayerByName(e) {
      return this._layersByName.get(e.toLowerCase()) || null;
    }
    HasLayerByName(e) {
      return !!this.GetLayerByName(e);
    }
    GetLayerBySID(e) {
      return this._layersBySid.get(e) || null;
    }
    _SetAllLayersProjectionChanged() {
      for (const e of this._allLayersFlat) e._SetProjectionMatrixChanged();
    }
    _SetAllLayersMVChanged() {
      for (const e of this._allLayersFlat) e._SetMVMatrixChanged();
    }
    AddLayer(e, t2, s) {
      if (this.HasLayerByName(e)) throw new Error(`layer name '${e}' already in use`);
      if (!t2 && s < 2) throw new Error("invalid insert position");
      const r2 = s >= 2 ? t2 : t2.GetParentLayer(), a2 = C32.New(C32.Layer, this, r2, { name: e, sid: Math.floor(1e15 * Math.random()), isDynamic: true });
      this._InsertLayer(a2, t2, s), this.GetRuntime().UpdateRender(), this._ReindexAndUpdateAllLayers();
    }
    MoveLayer(e, t2, s) {
      if (!t2 && s < 2) throw new Error("invalid insert position");
      e === t2 && s < 2 || (this._RemoveLayer(e), this._InsertLayer(e, t2, s), this.GetRuntime().UpdateRender(), this._ReindexAndUpdateAllLayers());
    }
    RemoveLayer(e) {
      if (this._RemoveLayer(e)) {
        const t2 = this._runtime.GetEventSheetManager();
        t2.BlockFlushingInstances(true), e.Release(), t2.BlockFlushingInstances(false), this.GetRuntime().UpdateRender(), this._ReindexAndUpdateAllLayers();
      }
    }
    RemoveAllDynamicLayers() {
      const e = /* @__PURE__ */ new Set();
      for (const t3 of this.allLayers()) t3.IsDynamic() && !t3.HasAnyDynamicParentLayer() && e.add(t3);
      if (0 === e.size) return;
      const t2 = this._runtime.GetEventSheetManager();
      t2.BlockFlushingInstances(true);
      for (const t3 of e) this._RemoveLayer(t3), t3.Release();
      t2.BlockFlushingInstances(false), this.GetRuntime().UpdateRender(), this._ReindexAndUpdateAllLayers();
    }
    _InsertLayer(e, t2, s) {
      if (s >= 2) if (t2) {
        if (t2 === e || t2.HasParentLayer(e)) throw new Error(`cannot move layer '${e.GetName()}' to sub-layer of itself`);
        t2._AddSubLayer(e, 2 === s), e._SetParentLayer(t2);
      } else 2 === s ? this._rootLayers.push(e) : this._rootLayers.unshift(e), e._SetParentLayer(null);
      else {
        const r2 = t2.GetParentLayer();
        if (r2) {
          if (t2.HasParentLayer(e)) throw new Error(`cannot move layer '${e.GetName()}' to sub-layer of itself`);
          r2._InsertSubLayer(e, t2, 0 === s), e._SetParentLayer(r2);
        } else {
          let r3 = this._rootLayers.indexOf(t2);
          if (-1 === r3) throw new Error("cannot find layer to insert by");
          0 === s && ++r3, this._rootLayers.splice(r3, 0, e), e._SetParentLayer(null);
        }
      }
    }
    _RemoveLayer(e) {
      const t2 = e.GetParentLayer();
      if (t2) return t2._RemoveSubLayer(e), true;
      if (this._rootLayers.length > 1) {
        const t3 = this._rootLayers.indexOf(e);
        if (-1 === t3) throw new Error("cannot find layer to remove");
        return this._rootLayers.splice(t3, 1), true;
      }
      return false;
    }
    _ReindexLayers() {
      this._allLayersFlat = [...this.allLayers()], this._layersByName.clear(), this._layersBySid.clear();
      for (let e = 0, t2 = this._allLayersFlat.length; e < t2; ++e) {
        const t3 = this._allLayersFlat[e];
        t3._SetIndex(e), this._layersByName.set(t3.GetName().toLowerCase(), t3), this._layersBySid.set(t3.GetSID(), t3);
      }
    }
    _ReindexHTMLLayers() {
      let e = 0;
      for (const t2 of this._rootLayers) {
        for (const s of t2.selfAndAllSubLayers()) s._SetHTMLIndex(e);
        t2.IsHTMLElementsLayer() && e++;
      }
    }
    GetHTMLLayerCount() {
      return this._rootLayers.at(-1).GetHTMLIndex() + 1;
    }
    async _ReindexAndUpdateAllLayers() {
      this._ReindexLayers(), this._ReindexHTMLLayers(), this._pendingSetHTMLLayerCount = this.GetHTMLLayerCount();
    }
    _GetPendingSetHTMLLayerCount() {
      return this._pendingSetHTMLLayerCount;
    }
    _ResetPendingHTMLLayerCount() {
      this._pendingSetHTMLLayerCount = -1;
    }
    GetRootLayersForHTMLLayer(e) {
      const t2 = [];
      for (const s of this._rootLayers) {
        const r2 = s.GetHTMLIndex();
        if (r2 === e) t2.push(s);
        else if (r2 > e) break;
      }
      return t2;
    }
    SaveTransform() {
      return { "scrollX": this.GetScrollX(), "scrollY": this.GetScrollY(), "scale": this.GetScale(), "angle": this.GetAngle(), "vpX": this.GetVanishingPointX(), "vpY": this.GetVanishingPointY() };
    }
    RestoreTransform(e) {
      this.SetScrollX(e["scrollX"]), this.SetScrollY(e["scrollY"]), this.SetScale(e["scale"]), this.SetAngle(e["angle"]), this.SetVanishingPointXY(e["vpX"], e["vpY"]);
    }
    GetLayoutBackgroundColor() {
      let e = this._rootLayers.filter((e2) => e2.ShouldDraw())[0];
      for (; e; ) {
        if (!e.IsTransparent()) return tempColor.copyRgb(e.GetBackgroundColor()), tempColor.setA(1), tempColor;
        if (e.UsesOwnTexture()) return tempColor.setRgba(0, 0, 0, 0), tempColor;
        e = e.GetSubLayers().filter((e2) => e2.ShouldDraw())[0];
      }
      return tempColor.setRgba(0, 0, 0, 0), tempColor;
    }
    IsFirstVisit() {
      return this._isFirstVisit;
    }
    _GetInitialObjectClasses() {
      return [...this._initialObjectClasses];
    }
    _AddInitialObjectClass(e) {
      if (e.IsInContainer()) for (const t2 of e.GetContainer().GetObjectTypes()) this._initialObjectClasses.add(t2);
      else this._initialObjectClasses.add(e);
    }
    _GetTextureLoadedObjectTypes() {
      return [...this._textureLoadedTypes];
    }
    _Load(e, t2) {
      if (e === this || !t2) return Promise.resolve();
      e && (C32.CopySet(this._textureLoadedTypes, e._textureLoadedTypes), e._textureLoadedTypes.clear());
      const s = [];
      for (const e2 of this._initialObjectClasses) this._textureLoadedTypes.has(e2) || (s.push(e2.LoadTextures(t2)), this._textureLoadedTypes.add(e2));
      return Promise.all(s);
    }
    async MaybeLoadTexturesFor(e) {
      if (e.IsFamily()) throw new Error("cannot load textures for family");
      const t2 = this._runtime.GetRenderer();
      if (!t2 || t2.IsContextLost() || this._textureLoadedTypes.has(e)) return;
      this._textureLoadedTypes.add(e);
      const s = e.LoadTextures(t2);
      this._AddPendingTextureLoadPromise(s), await s, e.OnDynamicTextureLoadComplete(), this._runtime.UpdateRender();
    }
    _AddPendingTextureLoadPromise(e) {
      this._textureLoadPendingPromises.add(e), e.then(() => this._textureLoadPendingPromises.delete(e)).catch(() => this._textureLoadPendingPromises.delete(e));
    }
    WaitForPendingTextureLoadsToComplete() {
      return Promise.all([...this._textureLoadPendingPromises]);
    }
    MaybeUnloadTexturesFor(e) {
      if (e.IsFamily() || e.GetInstanceCount() > 0) throw new Error("cannot unload textures");
      const t2 = this._runtime.GetRenderer();
      t2 && this._textureLoadedTypes.has(e) && (this._textureLoadedTypes.delete(e), e.ReleaseTextures(t2));
    }
    _Unload(e, t2) {
      if (e !== this && t2) for (const t3 of this._textureLoadedTypes) t3.IsGlobal() || e._initialObjectClasses.has(t3) || (t3.ReleaseTextures(), this._textureLoadedTypes.delete(t3));
    }
    _OnRendererContextLost() {
      this._textureLoadedTypes.clear();
    }
    async _StartRunning(e) {
      const t2 = this._runtime, s = this._layoutManager, r2 = t2.GetEventSheetManager();
      this._eventSheetName && (this._eventSheet = r2.GetEventSheetByName(this._eventSheetName), this._eventSheet._UpdateDeepIncludes()), s._SetMainRunningLayout(this), this._width = this._originalWidth, this._height = this._originalHeight, this._scrollX = t2.GetOriginalViewportWidth() / 2, this._scrollY = t2.GetOriginalViewportHeight() / 2, this.BoundScrolling(), this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged(), this._ReindexHTMLLayers(), await this._runtime.GetCanvasManager().SetHTMLLayerCount(this.GetHTMLLayerCount(), true), this._MoveGlobalObjectsToThisLayout(e), this._runtime.SetUsingCreatePromises(true), this._CreateInitialInstances(), this._isFirstVisit || this._CreatePersistedInstances(), this._CreateAndLinkContainerInstances(this._createdInstances), this._CreateAndLinkContainerInstances(this._createdPersistedInstances), this._CreateInitialNonWorldInstances(), s.ClearPendingChangeLayout(), t2.FlushPendingInstances(), this._runtime.SetUsingCreatePromises(false);
      const a2 = this._runtime.GetCreatePromises();
      if (await Promise.all(a2), C32.clearArray(a2), !t2.IsLoadingState()) {
        for (const e2 of this._createdInstances) e2.SetupInitialSceneGraphConnections();
        for (const e2 of this._createdPersistedInstances) e2.SetupPersistedSceneGraphConnections(this._createdPersistedInstancesToDataMap, this._createdPersistedIndexToInstanceMap);
        for (const [e2, t3] of Object.entries(this._persistData)) {
          const s2 = this._runtime.GetObjectClassBySID(parseInt(e2, 10));
          s2 && !s2.IsFamily() && s2.HasPersistBehavior() && C32.clearArray(t3);
        }
        for (const e2 of this._createdInstances) e2._TriggerOnCreated();
        for (const e2 of this._createdPersistedInstances) e2._TriggerOnCreated();
        for (const e2 of this._createdInstances) e2.HasParent() || e2._OnHierarchyReady();
        for (const e2 of this._createdPersistedInstances) e2.HasParent() || e2._OnHierarchyReady();
      }
      C32.clearArray(this._createdInstances), C32.clearArray(this._createdPersistedInstances), this._createdPersistedInstancesToDataMap.clear(), this._createdPersistedIndexToInstanceMap.clear(), await Promise.all([...this._initialObjectClasses].map((e2) => e2.PreloadTexturesWithInstances(this._runtime.GetRenderer()))), e && (t2.Dispatcher().dispatchEvent(new C32.Event("beforefirstlayoutstart")), await t2.DispatchUserScriptEventAsyncWait(new C32.Event("beforeprojectstart"))), await this.DispatchRuntimeUserScriptEventAsyncWait(new C32.Event("beforeanylayoutstart")), t2.Dispatcher().dispatchEvent(new C32.Event("beforelayoutstart")), await this.DispatchUserScriptEventAsyncWait(new C32.Event("beforelayoutstart")), t2.IsLoadingState() || await t2.TriggerAsync(C32.Plugins.System.Cnds.OnLayoutStart, null, null), t2.Dispatcher().dispatchEvent(new C32.Event("afterlayoutstart")), await this.DispatchUserScriptEventAsyncWait(new C32.Event("afterlayoutstart")), await this.DispatchRuntimeUserScriptEventAsyncWait(new C32.Event("afteranylayoutstart")), e && (t2.Dispatcher().dispatchEvent(new C32.Event("afterfirstlayoutstart")), await t2.DispatchUserScriptEventAsyncWait(new C32.Event("afterprojectstart"))), r2._RunQueuedTriggers(s), await this.WaitForPendingTextureLoadsToComplete(), this._isFirstVisit = false;
    }
    _MoveGlobalObjectsToThisLayout(e) {
      for (const e2 of this._runtime.GetAllObjectClasses()) if (!e2.IsFamily() && e2.IsWorldType()) for (const t2 of e2.GetInstances()) {
        const e3 = t2.GetWorldInfo(), s = e3.GetLayer(), r2 = s.GetName(), a2 = this.GetLayerByName(r2);
        if (a2) e3._SetLayer(a2, true), a2._MaybeAddInstance(t2);
        else {
          const r3 = C32.clamp(s.GetIndex(), 0, this._allLayersFlat.length - 1), a3 = this._allLayersFlat[r3];
          e3._SetLayer(a3, true), a3._MaybeAddInstance(t2);
        }
      }
      if (!e) for (const e2 of this._allLayersFlat) e2._SortInstancesByLastCachedZIndex(false);
    }
    _CreateInitialInstances() {
      for (const e of this._allLayersFlat) e.CreateInitialInstances(this._createdInstances), e._Start();
    }
    _CreatePersistedInstances() {
      let e = false;
      for (const [t2, s] of Object.entries(this._persistData)) {
        const r2 = this._runtime.GetObjectClassBySID(parseInt(t2, 10));
        if (r2 && !r2.IsFamily() && r2.HasPersistBehavior()) for (const t3 of s) {
          let s2 = null;
          if (r2.IsWorldType() && (s2 = t3.hasOwnProperty("instJson") ? this.GetLayerBySID(t3["instJson"]["w"]["l"]) : this.GetLayerBySID(t3["w"]["l"]), !s2)) continue;
          const a2 = this._runtime.CreateInstanceFromData(r2, s2, false, 0, 0, true);
          t3.hasOwnProperty("instJson") ? a2.LoadFromJson(t3["instJson"]) : a2.LoadFromJson(t3), e = true, this._createdPersistedInstances.push(a2), t3.hasOwnProperty("instJson") && (this._createdPersistedInstancesToDataMap.set(a2, t3), this._createdPersistedIndexToInstanceMap.set(t3["index"], a2));
        }
      }
      for (const e2 of this._allLayersFlat) e2._SortInstancesByLastCachedZIndex(true), e2.SetZIndicesChanged();
      e && (this._runtime.FlushPendingInstances(), this._runtime._RefreshUidMap());
    }
    _CreateAndLinkContainerInstances(e) {
      for (const t2 of e) {
        if (!t2.IsInContainer()) continue;
        const s = t2.GetWorldInfo(), r2 = t2.GetIID();
        for (const a2 of t2.GetObjectClass().GetContainer().objectTypes()) {
          if (a2 === t2.GetObjectClass()) continue;
          const n = a2.GetInstances();
          if (n.length > r2) t2._AddSibling(n[r2]);
          else {
            let r3;
            r3 = s ? this._runtime.CreateInstanceFromData(a2, s.GetLayer(), true, s.GetX(), s.GetY(), true) : this._runtime.CreateInstanceFromData(a2, null, true, 0, 0, true), this._runtime.FlushPendingInstances(), a2._UpdateIIDs(), t2._AddSibling(r3), e.push(r3);
          }
        }
      }
    }
    _CreateInitialNonWorldInstances() {
      for (const e of this._initialNonWorld) {
        this._runtime.GetObjectClassByIndex(e[1]).IsInContainer() || this._runtime.CreateInstanceFromData(e, null, true);
      }
    }
    _CreateGlobalNonWorlds() {
      const e = [], t2 = this._initialNonWorld;
      let s = 0;
      for (let r2 = 0, a2 = t2.length; r2 < a2; ++r2) {
        const a3 = t2[r2], n = this._runtime.GetObjectClassByIndex(a3[1]);
        n.IsGlobal() ? n.IsInContainer() && n.GetContainer().HasAnyWorldType() || e.push(this._runtime.CreateInstanceFromData(a3, null, true)) : (t2[s] = a3, ++s);
      }
      C32.truncateArray(t2, s), this._runtime.FlushPendingInstances(), this._CreateAndLinkContainerInstances(e);
    }
    RecreateInitialObjects(e, t2, s, r2, a2, n, i) {
      if (s) return s.RecreateInitialObjects(e, t2, a2, n, r2, i);
      {
        const s2 = [];
        for (const o2 of this._allLayersFlat) s2.push(o2.RecreateInitialObjects(e, t2, a2, n, r2, i));
        return s2.flat();
      }
    }
    async _StopRunning() {
      const e = this._layoutManager;
      this._runtime.IsLoadingState() || (await this.DispatchRuntimeUserScriptEventAsyncWait(new C32.Event("beforeanylayoutend")), await this.DispatchUserScriptEventAsyncWait(new C32.Event("beforelayoutend")), await this._runtime.TriggerAsync(C32.Plugins.System.Cnds.OnLayoutEnd, null, null), await this.DispatchUserScriptEventAsyncWait(new C32.Event("afterlayoutend")), await this.DispatchRuntimeUserScriptEventAsyncWait(new C32.Event("afteranylayoutend"))), e.SetIsEndingLayout(true), this._runtime.GetEventSheetManager().ClearAllScheduledWaits(), this._isFirstVisit || this._SavePersistData();
      for (const e2 of this._allLayersFlat) e2._End();
      for (const e2 of this._runtime.GetAllObjectClasses()) if (!(e2.IsGlobal() || e2.IsWorldType() || e2.GetPlugin().IsSingleGlobal() || e2.IsFamily())) {
        for (const t2 of e2.GetInstances()) this._runtime.DestroyInstance(t2);
        this._runtime.FlushPendingInstances();
      }
      e.SetIsEndingLayout(false), e.GetMainRunningLayout() === this && e._SetMainRunningLayout(null);
    }
    _SaveInstanceToPersist(e, t2) {
      const s = e.GetObjectClass().GetSID().toString();
      this._persistData.hasOwnProperty(s) || (this._persistData[s] = []);
      const r2 = this._persistData[s], a2 = { "index": t2, "instJson": e.SaveToJson(), "sceneGraphJson": { "children": [] } };
      r2.push(a2), this._persistedIntances.set(e, a2);
    }
    _SaveSceneGraphInfoToPersist(e) {
      const t2 = this._persistedIntances.get(e);
      for (const s of e.GetChildren()) {
        const e2 = this._persistedIntances.get(s);
        e2 && t2["sceneGraphJson"]["children"].push({ "index": e2["index"], "flags": C32.SceneGraphInfo._GetFlagsNumber(s.GetWorldInfo()) });
      }
    }
    _SavePersistData() {
      this._persistedIntances.clear();
      let e = 0;
      for (const t2 of this._allLayersFlat) {
        t2._UpdateZIndices();
        for (const s of t2._GetInstances()) {
          const t3 = s.GetObjectClass();
          !t3.IsGlobal() && t3.HasPersistBehavior() && (this._SaveInstanceToPersist(s, e), e++);
        }
      }
      for (const e2 of this._allLayersFlat) for (const t2 of e2._GetInstances()) {
        const e3 = t2.GetObjectClass();
        !e3.IsGlobal() && e3.HasPersistBehavior() && this._SaveSceneGraphInfoToPersist(t2);
      }
      this._persistedIntances.clear();
    }
    ResetPersistData() {
      this._persistData = {}, this._isFirstVisit = true;
    }
    GetRenderTarget() {
      return this._curRenderTarget;
    }
    UsesOwnTexture() {
      const e = this._runtime, t2 = e.GetRenderer().IsWebGL();
      return "low" === e.GetCanvasManager().GetCurrentFullscreenScalingQuality() || t2 && e.UsesAnyBackgroundBlending() || this._effectList.HasAnyActiveEffect() || t2 && e.Uses3DFeatures();
    }
    _MaybeStartDrawToOwnTexture(e) {
      const t2 = this._runtime.GetCanvasManager();
      if (this.UsesOwnTexture()) {
        e.SetRenderTarget(null), e.ClearRgba(0, 0, 0, 0);
        const s = { sampling: this._runtime.GetSampling(), isSampled: e.IsWebGPU() || this._runtime.UsesAnyBackgroundBlending() || this._effectList.HasAnyActiveEffect(), canReadPixels: !!e.IsWebGPU() && this._runtime.UsesAnyBackgroundBlending() };
        "low" === t2.GetCurrentFullscreenScalingQuality() && (s.width = t2.GetDrawWidth(), s.height = t2.GetDrawHeight()), this._curRenderTarget = this._runtime.GetAdditionalRenderTarget(s);
      } else this._curRenderTarget = null;
    }
    _MaybeCopyOwnTextureToBackbuffer(e) {
      this._runtime._NeedsHTMLLayerCompositing(e) && (e.SetDepthEnabled(false), e.SetRenderTarget(null), e.SetTextureFillMode(), e.CopyRenderTarget(this._curRenderTarget));
    }
    _MaybeEndDrawToOwnTexture(e) {
      this.UsesOwnTexture() && (e.SetDepthEnabled(false), this._DrawLayoutOwnTextureToRenderTarget(e, this._curRenderTarget));
    }
    DrawMain(e) {
      e.SetRenderTarget(this._curRenderTarget), e.Clear(this.GetLayoutBackgroundColor()), this._runtime.Uses3DFeatures() && e.ClearDepth();
      const t2 = this.GetRootLayersForHTMLLayer(0);
      this._DrawLayerList(e, this._curRenderTarget, t2, true), e.IsWebGPU() && e.StartMeasuringRenderPassTime(0, 1), this._MaybeEndDrawToOwnTexture(e), this._curRenderTarget = null;
    }
    DrawForHTMLLayerIndex(e, t2) {
      let s = null;
      this._runtime._NeedsHTMLLayerCompositing(e) && (s = this._curRenderTarget), e.SetRenderTarget(s), e.ClearRgba(0, 0, 0, 0), this._runtime.Uses3DFeatures() && e.ClearDepth();
      const r2 = this.GetRootLayersForHTMLLayer(t2);
      this._DrawLayerList(e, s, r2, true), this._MaybeCopyOwnTextureToBackbuffer(e), e.EndBatch(), this._runtime.GetCanvasManager().BlitMainCanvasToHTMLLayerCanvas(t2);
    }
    _DrawLayerList(e, t2, s, r2) {
      const a2 = s.filter((e2) => e2.ShouldDraw());
      for (let s2 = 0, n = a2.length; s2 < n; ) {
        const i = a2[s2];
        if (i.SelfAndAllSubLayersHave3DCamera() && !i.SelfOrAnySubLayerUsesOwnTexture()) {
          tempRender3dList.push(i);
          for (let e2 = s2 + 1; e2 < n; ++e2) {
            const t3 = a2[e2];
            if (!t3.SelfAndAllSubLayersHave3DCamera() || t3.SelfOrAnySubLayerUsesOwnTexture()) break;
            tempRender3dList.push(a2[e2]);
          }
          if (tempRender3dList.length >= 2 || 1 === tempRender3dList.length && tempRender3dList[0].HasAnyVisibleSubLayer()) {
            this._Draw3DLayers(e, t2, tempRender3dList), s2 += tempRender3dList.length, C32.clearArray(tempRender3dList);
            continue;
          }
          C32.clearArray(tempRender3dList);
        }
        i.Draw(e, t2, r2 && 0 === s2), ++s2;
      }
    }
    _DrawLayoutOwnTextureToRenderTarget(e, t2) {
      const s = this._effectList.GetActiveEffectTypes(), r2 = this._runtime;
      0 === s.length ? (e.SetRenderTarget(null), e.SetTextureFillMode(), e.CopyRenderTarget(t2), e.InvalidateRenderTarget(t2), r2.ReleaseAdditionalRenderTarget(t2)) : (tempLayoutRect.set(0, 0, r2.GetViewportWidth(), r2.GetViewportHeight()), this.GetEffectChain().Render(e, null, { contentObject: this, blendMode: 3, devicePixelRatio: this._runtime.GetEffectDevicePixelRatioParam(), layerScale: this._runtime.GetEffectLayerScaleParam() * this.GetScale(), layerAngle: this.GetAngle(), layoutRect: tempLayoutRect, drawSurfaceRect: null, invalidateRenderTargets: true }));
    }
    _Draw3DLayers(e, t2, s) {
      const r2 = s[0], a2 = r2._MaybeStartWebGLProfiling(e);
      r2._MaybeStartWebGPUProfiling(e), s[0].IsTransparent() || (tempColor.copyRgb(s[0].GetBackgroundColor()), tempColor.setA(1), e.Clear(tempColor)), e.SetDepthEnabled(true);
      const n = tempInstanceList1, i = tempInstanceList2, o2 = tempInstanceList3;
      for (const t3 of s) t3._UpdateZIndices(), t3._AppendAllInstancesIncludingSubLayersInDrawOrder(n), t3._FireDrawEvent(e, "beforedraw");
      for (let s2 = 0, r3 = n.length; s2 < r3; ) {
        const a3 = n[s2], l = a3.GetWorldInfo(), h2 = l.GetLayer();
        if (!l.IsVisible() || !l.IsInViewport3D(h2._GetViewFrustum())) {
          ++s2;
          continue;
        }
        (!a3.RendersToOwnZPlane() || l.GetDepth() > 0) && o2.push(a3);
        const c2 = a3.GetWorldInfo().GetTotalZElevation();
        i.push(a3);
        let d2 = s2 + 1;
        for (; d2 < r3; ++d2) {
          const e2 = n[d2], t3 = e2.GetWorldInfo();
          if (t3.IsVisible() && t3.IsInViewport3D(t3.GetLayer()._GetViewFrustum())) {
            if (t3.GetTotalZElevation() !== c2) break;
            e2.RendersToOwnZPlane() ? (t3.GetDepth() > 0 && o2.push(e2), i.push(e2)) : o2.push(e2);
          }
        }
        if (1 !== i.length || i[0].MustMitigateZFighting()) {
          this._Draw3DLayersCoplanarInstances(e, t2, i);
          for (let s3 = 0, r4 = o2.length; s3 < r4; ++s3) {
            const r5 = o2[s3], a4 = r5.GetWorldInfo(), n2 = a4.GetLayer();
            a4._SetDrawNonBackFacesOnly(true), MaybePrepareLayerDraw(n2, e), n2._DrawInstanceMaybeWithEffects(r5, a4, e, t2), a4._SetDrawNonBackFacesOnly(false);
          }
        } else {
          MaybePrepareLayerDraw(h2, e), h2._DrawInstanceMaybeWithEffects(a3, l, e, t2);
          for (let s3 = 0, r4 = o2.length; s3 < r4; ++s3) {
            const r5 = o2[s3];
            if (r5 === a3) continue;
            const n2 = r5.GetWorldInfo(), i2 = n2.GetLayer();
            MaybePrepareLayerDraw(i2, e), i2._DrawInstanceMaybeWithEffects(r5, n2, e, t2);
          }
        }
        s2 = d2, C32.clearArray(i), C32.clearArray(o2);
      }
      for (const t3 of s) t3._FireDrawEvent(e, "afterdraw");
      a2 && e.EndQuery(a2), C32.clearArray(n), lastLayerPreparedForDrawing = null;
    }
    _Draw3DLayersCoplanarInstances(e, t2, s) {
      e.CoplanarStartStencilPass();
      for (let t3 = 0, r2 = s.length; t3 < r2; ++t3) {
        const r3 = s[t3], a2 = r3.GetWorldInfo(), n = a2.GetLayer();
        a2._SetDrawBackFaceOnly(true), MaybePrepareLayerDraw(n, e), n._DrawInstance(r3, a2, e);
      }
      e.CoplanarStartColorPass();
      for (let r2 = 0, a2 = s.length; r2 < a2; ++r2) {
        const a3 = s[r2], n = a3.GetWorldInfo(), i = n.GetLayer();
        MaybePrepareLayerDraw(i, e), i._DrawInstanceMaybeWithEffects(a3, n, e, t2), n._SetDrawBackFaceOnly(false);
      }
      e.CoplanarRestoreStandardRendering();
    }
    _SaveToJson() {
      const e = { "sx": this.GetScrollX(), "sy": this.GetScrollY(), "s": this.GetScale(), "a": this.GetAngle(), "w": this.GetWidth(), "h": this.GetHeight(), "ortho": this.IsOrthographicProjection(), "vpX": this.GetVanishingPointX(), "vpY": this.GetVanishingPointY(), "fv": this._isFirstVisit, "persist": this._persistData, "fx": this._effectList.SaveToJson(), "layers": {}, "dynamicLayers": [] };
      for (const t2 of this._allLayersFlat) if (t2.IsDynamic()) {
        const s = t2.GetParentLayer();
        e["dynamicLayers"].push({ "sid": t2.GetSID(), "name": t2.GetName(), "parentSid": s ? s.GetSID() : null, "siblingIndex": t2._GetSiblingIndex(), "data": t2._SaveToJson() });
      } else e["layers"][t2.GetSID().toString()] = t2._SaveToJson();
      return e;
    }
    _LoadFromJson(e) {
      this._scrollX = e["sx"], this._scrollY = e["sy"], this._scale = e["s"], this._angle = e["a"], this._width = e["w"], this._height = e["h"], this._isOrthographicProjection = !!e["ortho"], e.hasOwnProperty("vpX") && (this._vanishingPointX = e["vpX"]), e.hasOwnProperty("vpY") && (this._vanishingPointY = e["vpY"]), this._isFirstVisit = !!e["fv"], this._persistData = e["persist"], this._effectList.LoadFromJson(e["fx"]), this._needsRebuildEffectChainSteps = true;
      for (const [t2, s] of Object.entries(e["layers"])) {
        const e2 = parseInt(t2, 10), r2 = this.GetLayerBySID(e2);
        r2 && r2._LoadFromJson(s);
      }
      if (e.hasOwnProperty("dynamicLayers")) {
        this.RemoveAllDynamicLayers(), this._runtime.FlushPendingInstances();
        const t2 = /* @__PURE__ */ new Map(), s = e["dynamicLayers"];
        for (let e2 = s.length - 1; e2 >= 0; --e2) {
          const r2 = s[e2], a2 = r2["sid"], n = r2["name"], i = r2["parentSid"], o2 = r2["siblingIndex"], l = r2["data"];
          if (this._ReindexLayers(), this.HasLayerByName(n) || this.GetLayerBySID(a2)) continue;
          let h2, c2;
          if (null === i) h2 = null, c2 = this._rootLayers;
          else {
            if (h2 = this.GetLayerBySID(i), !h2) continue;
            c2 = h2.GetSubLayers();
          }
          const d2 = C32.New(C32.Layer, this, h2, { name: n, sid: a2, isDynamic: true });
          c2.push(d2);
          let _2 = t2.get(c2);
          _2 || (_2 = [], t2.set(c2, _2)), _2.push({ layer: d2, siblingIndex: o2 }), d2._LoadFromJson(l);
        }
        for (const [e2, s2] of t2) {
          s2.sort((e3, t3) => e3.siblingIndex - t3.siblingIndex);
          for (const t3 of s2) {
            const s3 = t3.layer, r2 = t3.siblingIndex;
            let a2 = e2.indexOf(s3);
            e2.splice(a2, 1), e2.splice(r2, 0, s3);
          }
        }
      }
      this._ReindexAndUpdateAllLayers(), this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged();
    }
    GetILayout() {
      return this._iLayout;
    }
    UserScriptDispatcher() {
      return this._userScriptDispatcher;
    }
    DispatchUserScriptEvent(e) {
      e.layout = this.GetILayout();
      const t2 = this._runtime, s = t2.IsDebug() && !t2.GetEventSheetManager().IsInEventEngine();
      s && C3Debugger.StartMeasuringScriptTime(), this._userScriptDispatcher.dispatchEvent(e), s && C3Debugger.AddScriptTime();
    }
    DispatchUserScriptEventAsyncWait(e) {
      return e.layout = this.GetILayout(), this._userScriptDispatcher.dispatchEventAndWaitAsync(e);
    }
    DispatchRuntimeUserScriptEventAsyncWait(e) {
      return e.layout = this.GetILayout(), this._runtime.DispatchUserScriptEventAsyncWait(e);
    }
    _LogLayerTree() {
      this._LogLayerList(this._rootLayers);
    }
    _LogLayerList(e, t2 = 0) {
      const s = e.slice(0);
      s.reverse();
      for (const e2 of s) console.log(`${"	".repeat(t2)}- ${e2.GetName()}`), this._LogLayerList(e2.GetSubLayers(), t2 + 1);
    }
  };
}
var vec3EqualsXYZ2;
var MaybePrepareLayerDraw2;
{
  const C32 = self.C3;
  C32.LayoutManager = class extends C32.DefendedBase {
    #t;
    #n = [];
    #u = /* @__PURE__ */ new Map();
    #a = /* @__PURE__ */ new Map();
    #i = null;
    #e = [];
    #s = null;
    #o = 0;
    #y = null;
    constructor(t2) {
      super(), this.#t = t2;
    }
    Release() {
      this.#t = null, this.#i = null, this.#s = null, this.#y = null, C32.clearArray(this.#n), this.#u.clear(), this.#a.clear(), C32.clearArray(this.#e);
    }
    Create(t2) {
      const n = C32.New(C32.Layout, this, this.#n.length, t2);
      this.#n.push(n), this.#u.set(n.GetName().toLowerCase(), n), this.#a.set(n.GetSID(), n);
    }
    GetRuntime() {
      return this.#t;
    }
    SetFirstLayout(t2) {
      this.#s = t2;
    }
    GetFirstLayout() {
      if (this.#s) return this.#s;
      if (this.#n.length) return this.#n[0];
      throw new Error("no first layout");
    }
    GetLayoutByName(t2) {
      return this.#u.get(t2.toLowerCase()) || null;
    }
    GetLayoutBySID(t2) {
      return this.#a.get(t2) || null;
    }
    GetLayoutByIndex(t2) {
      return t2 = C32.clamp(Math.floor(t2), 0, this.#n.length - 1), this.#n[t2];
    }
    GetLayout(t2) {
      return "number" == typeof t2 ? this.GetLayoutByIndex(t2) : this.GetLayoutByName(t2.toString());
    }
    GetAllLayouts() {
      return this.#n;
    }
    _SetMainRunningLayout(t2) {
      this.#i = t2;
    }
    GetMainRunningLayout() {
      return this.#i;
    }
    _AddRunningSubLayout(t2) {
      if (this.#e.includes(t2)) throw new Error("layout already running");
      this.#e.push(t2);
    }
    _RemoveRunningSubLayout(t2) {
      const n = this.#e.indexOf(t2);
      if (-1 === n) throw new Error("layout not running");
      this.#e.splice(n, 1);
    }
    *runningLayouts() {
      this.#i && (yield this.#i), this.#e.length && (yield* this.#e);
    }
    IsLayoutRunning(t2) {
      return this.#i === t2 || this.#e.includes(t2);
    }
    SetIsEndingLayout(t2) {
      if (t2) this.#o++;
      else {
        if (this.#o <= 0) throw new Error("already unset");
        this.#o--;
      }
    }
    IsEndingLayout() {
      return this.#o > 0;
    }
    ChangeMainLayout(t2) {
      this.#y = t2;
    }
    ClearPendingChangeLayout() {
      this.#y = null;
    }
    IsPendingChangeMainLayout() {
      return !!this.#y;
    }
    GetPendingChangeMainLayout() {
      return this.#y;
    }
    SetAllLayerProjectionChanged() {
      const t2 = this.GetMainRunningLayout();
      t2 && t2._SetAllLayersProjectionChanged();
    }
    SetAllLayerMVChanged() {
      const t2 = this.GetMainRunningLayout();
      t2 && t2._SetAllLayersMVChanged();
    }
  };
}
{
  const C32 = self.C3, NAMES_REGEXP = new RegExp("<(.+?)>", "g");
  C32.TimelineManager = class extends C32.DefendedBase {
    constructor(e) {
      super(), this._runtime = e, this._timelineDataManager = C32.New(C32.TimelineDataManager), this._pluginInstance = null, this._timelines = [], this._timelinesByName = /* @__PURE__ */ new Map(), this._objectClassToTimelineMap = /* @__PURE__ */ new Map(), this._timelinesCreatedByTemplate = /* @__PURE__ */ new Map(), this._scheduledTimelines = [], this._playingTimelines = [], this._markedForRemovalTimelines = [], this._hasRuntimeListeners = false, this._changingLayout = false, this._isTickingTimelines = false, this._tickFunc = () => this._OnTick(), this._tick2Func = () => this._OnTick2(), this._beforeLayoutChange = () => this._OnBeforeChangeLayout(), this._layoutChange = () => this._OnAfterChangeLayout(), this._instanceDestroy = (e2) => this._OnInstanceDestroy(e2.instance), this._beforeLoad = (e2) => this._OnBeforeLoad(), this._afterLoad = (e2) => this._OnAfterLoad(), this._afterLayoutStart = (e2) => this._OnAfterLayoutStart(), this._destroyedWhileLoadingState = [], this._renderChange = 0;
    }
    Release() {
      this.RemoveRuntimeListeners(), this._tickFunc = null, this._tick2Func = null, this._beforeLayoutChange = null, this._layoutChange = null, this._instanceDestroy = null, this._afterLoad = null;
      for (const e of this._timelines) e.Stop(), e.Release();
      C32.clearArray(this._timelines), this._timelines = null, this._timelineDataManager.Release(), this._timelineDataManager = null, C32.clearArray(this._scheduledTimelines), this._scheduledTimelines = null, C32.clearArray(this._playingTimelines), this._playingTimelines = null, C32.clearArray(this._markedForRemovalTimelines), this._markedForRemovalTimelines = null, this._timelinesByName.clear(), this._timelinesByName = null, this._objectClassToTimelineMap.clear(), this._objectClassToTimelineMap = null, this._timelinesCreatedByTemplate.clear(), this._timelinesCreatedByTemplate = null, C32.clearArray(this._destroyedWhileLoadingState), this._destroyedWhileLoadingState = null, this._runtime = null;
    }
    AddRuntimeListeners() {
      const e = this._runtime.Dispatcher();
      e.addEventListener("pretick", this._tickFunc), e.addEventListener("tick2", this._tick2Func), e.addEventListener("beforelayoutchange", this._beforeLayoutChange), e.addEventListener("layoutchange", this._layoutChange), e.addEventListener("instancedestroy", this._instanceDestroy), e.addEventListener("beforeload", this._beforeLoad), e.addEventListener("afterload", this._afterLoad), e.addEventListener("afterlayoutstart", this._afterLayoutStart);
    }
    RemoveRuntimeListeners() {
      const e = this._runtime.Dispatcher();
      e.removeEventListener("pretick", this._tickFunc), e.removeEventListener("tick2", this._tick2Func), e.removeEventListener("beforelayoutchange", this._beforeLayoutChange), e.removeEventListener("layoutchange", this._layoutChange), e.removeEventListener("instancedestroy", this._instanceDestroy), e.removeEventListener("beforeload", this._beforeLoad), e.removeEventListener("afterload", this._afterLoad), e.removeEventListener("afterlayoutstart", this._afterLayoutStart);
    }
    Create(e) {
      this._timelineDataManager.Add(e);
      const i = C32.TimelineState.CreateInitial(e, this);
      this.Add(i), this.SetTimelineObjectClassesToMap(i), this._timelinesCreatedByTemplate.set(i.GetName(), 0);
    }
    CreateFromTemplate(e) {
      const i = this.GetTimelineDataManager(), t2 = e.GetTemplateName(), s = i.Get(t2), n = C32.TimelineState.CreateFromTemplate(`${t2}:${this._timelinesCreatedByTemplate.get(t2)}`, s, this);
      return this._IncreaseTemplateTimelinesCount(t2), this.Add(n), this._runtime.IsDebug() && globalThis.C3Debugger.TimelineCreated(n), n;
    }
    GetCreatedTemplateTimelinesCount(e) {
      return this._timelinesCreatedByTemplate.get(e);
    }
    _IncreaseTemplateTimelinesCount(e) {
      this._timelinesCreatedByTemplate.set(e, this._timelinesCreatedByTemplate.get(e) + 1);
    }
    _SetCreatedTemplateTimelinesCount() {
      for (const e of this._timelines) {
        if (e.IsTemplate()) continue;
        const i = e.GetTemplateName();
        this._IncreaseTemplateTimelinesCount(i);
      }
    }
    _ClearCreatedTemplateTimelinesCount() {
      for (const e of this._timelinesCreatedByTemplate.keys()) this._timelinesCreatedByTemplate.set(e, 0);
    }
    Add(e) {
      this._timelines.push(e), this._timelinesByName.set(e.GetName().toLowerCase(), e);
    }
    Remove(e) {
      e.Removed(), e.IsTemplate() || (C32.arrayFindRemove(this._timelines, e), C32.arrayFindRemove(this._scheduledTimelines, e), C32.arrayFindRemove(this._playingTimelines, e), C32.arrayFindRemove(this._markedForRemovalTimelines, e), this._timelinesByName.delete(e.GetName().toLowerCase()), this.RemoveTimelineFromObjectClassMap(e), this._runtime.IsDebug() && globalThis.C3Debugger.TimelineDestroyed(e), e.IsReleased() || e.Release());
    }
    Trigger(e) {
      this._runtime.Trigger(e, this._pluginInstance, null);
    }
    GetRuntime() {
      return this._runtime;
    }
    GetTimelineDataManager() {
      return this._timelineDataManager;
    }
    SetPluginInstance(e) {
      this._pluginInstance = e;
    }
    GetPluginInstance() {
      return this._pluginInstance;
    }
    *GetTimelines() {
      for (const e of this._timelines) yield e;
    }
    *GetPlayingTimelines() {
      for (const e of this._playingTimelines) yield e;
    }
    SetTimelineObjectClassToMap(e, i) {
      this._objectClassToTimelineMap.has(e) || this._objectClassToTimelineMap.set(e, /* @__PURE__ */ new Set()), this._objectClassToTimelineMap.get(e).add(i);
    }
    SetTimelineObjectClassesToMap(e) {
      for (const i of e.GetObjectClasses()) this.SetTimelineObjectClassToMap(i, e);
    }
    RemoveTimelineFromObjectClassMap(e) {
      for (const [i, t2] of this._objectClassToTimelineMap.entries()) t2.has(e) && (t2.delete(e), 0 === t2.size && this._objectClassToTimelineMap.delete(i));
    }
    GetTimelinesForObjectClass(e) {
      if (this._objectClassToTimelineMap.has(e)) return this._objectClassToTimelineMap.get(e);
    }
    GetTimelineOfTemplateForInstances(e, i) {
      if (i) for (const t2 of this._timelines) {
        if (i.every((e2) => t2.HasTrackInstance(e2.instance, e2.trackId)) && t2.GetName().includes(e.GetName())) return t2;
      }
    }
    GetTimelineByName(e) {
      return this._timelinesByName.get(e.toLowerCase()) || null;
    }
    GetScheduledOrPlayingTimelineByName(e) {
      for (const i of this._scheduledTimelines) if (i.GetName() === e) return i;
      for (const i of this._playingTimelines) if (i.GetName() === e) return i;
      return null;
    }
    *GetTimelinesByName(e) {
      if (NAMES_REGEXP.test(e)) {
        let i;
        NAMES_REGEXP.lastIndex = 0;
        const t2 = /* @__PURE__ */ new Set();
        do {
          if (i = NAMES_REGEXP.exec(e), i) {
            const e2 = i[1].split(",");
            for (const i2 of e2) t2.add(i2);
          }
        } while (i);
        for (const e2 of t2.values()) {
          const i2 = this.GetTimelineByName(e2);
          i2 && (yield i2);
        }
        t2.clear();
      } else {
        const i = this.GetTimelineByName(e);
        i && (yield i);
      }
    }
    *GetTimelinesByTags(e) {
      for (const i of this._timelines) i.HasTags(e) && (yield i);
    }
    AddScheduledTimeline(e) {
      this._scheduledTimelines.includes(e) || this._scheduledTimelines.push(e), this._MaybeEnableRuntimeListeners();
    }
    RemovePlayingTimeline(e) {
      C32.arrayFindRemove(this._playingTimelines, e), this._MaybeDisableRuntimeListeners();
    }
    ScheduleTimeline(e) {
      this._playingTimelines.includes(e) ? (e.SetPlaying(true), e.SetScheduled(false), e.SetMarkedForRemoval(false)) : (e.SetPlaying(false), e.SetScheduled(true), e.SetMarkedForRemoval(false), this._scheduledTimelines.includes(e) || this._scheduledTimelines.push(e)), this._MaybeEnableRuntimeListeners();
    }
    DeScheduleTimeline(e) {
      e.SetPlaying(false), e.SetScheduled(false), e.ResolvePlayPromise(), C32.arrayFindRemove(this._scheduledTimelines, e), this._MaybeDisableRuntimeListeners();
    }
    CompleteTimeline(e) {
      e.SetPlaying(false), e.SetScheduled(false), this._playingTimelines.includes(e) && (e.SetMarkedForRemoval(true), this._markedForRemovalTimelines.push(e), C32.arrayFindRemove(this._playingTimelines, e)), this._scheduledTimelines.includes(e) && e.SetMarkedForRemoval(true);
    }
    CompleteTimelineBeforeChangeOfLayout(e) {
      e.SetPlaying(false), e.SetScheduled(false), e.SetMarkedForRemoval(false), e.SetPlaybackRate(1), C32.arrayFindRemove(this._playingTimelines, e);
    }
    CompleteTimelineAndResolve(e) {
      this.CompleteTimeline(e), e.ResolvePlayPromise();
    }
    _OnTick() {
      const e = this.GetRuntime();
      if (e.IsLoadingState()) return;
      if (!this._hasRuntimeListeners) return;
      if (this._changingLayout) return;
      let i = 0;
      for (e.IsDebug() && (i = performance.now()), this._isTickingTimelines = true; this._scheduledTimelines.length; ) {
        const e2 = this._scheduledTimelines.pop();
        e2.IsMarkedForRemoval() ? (e2.SetInitialStateForce(), this._markedForRemovalTimelines.push(e2)) : (e2.SetInitialState(), this._playingTimelines.push(e2)), 0 !== e2.GetRenderChange() && (this._renderChange = 1);
      }
      const t2 = this._runtime._GetDtFast(), s = this._runtime.GetDt1(), n = this._runtime.GetTimeScale();
      for (let e2 = this._playingTimelines.length - 1; e2 >= 0; e2--) {
        const i2 = this._playingTimelines[e2];
        i2 && i2.Tick(t2, n, s);
      }
      this._isTickingTimelines = false, e.IsDebug() && globalThis.C3Debugger.AddTweensAndTimelinesTime(performance.now() - i), 0 !== this._renderChange && e.UpdateRender();
    }
    _OnTick2() {
      const e = this.GetRuntime();
      if (e.IsLoadingState()) return;
      if (!this._hasRuntimeListeners) return;
      if (this._changingLayout) return;
      let i, t2 = 0;
      e.IsDebug() && (t2 = performance.now());
      for (let e2 = 0, t3 = this._markedForRemovalTimelines.length; e2 < t3; e2++) {
        const t4 = this._markedForRemovalTimelines[e2];
        i || (i = /* @__PURE__ */ new Set()), t4.Removed(), this._MaybeExecuteTimelineFinishTriggers(t4), i.add(t4);
      }
      if (i) {
        C32.arrayRemoveAllInSet(this._markedForRemovalTimelines, i), this._renderChange = 0;
        for (let e2 = 0, i2 = this._playingTimelines.length; e2 < i2; e2++) if (0 !== this._playingTimelines[e2].GetRenderChange()) {
          this._renderChange = 1;
          break;
        }
      }
      this._MaybeDisableRuntimeListeners(), e.IsDebug() && globalThis.C3Debugger.AddTweensAndTimelinesTime(performance.now() - t2);
    }
    _MaybeExecuteTimelineFinishTriggers(e) {
      e.IsReleased() || e.HasValidTracks() && e.IsComplete() && e.InitialStateSet() && e.FinishTriggers();
    }
    _MaybeEnableRuntimeListeners() {
      this._hasRuntimeListeners || (this._hasRuntimeListeners = true);
    }
    _MaybeDisableRuntimeListeners() {
      this._markedForRemovalTimelines.length || this._playingTimelines.length || this._scheduledTimelines.length || this._isTickingTimelines || (this._hasRuntimeListeners = false);
    }
    _OnBeforeChangeLayout() {
      for (this._changingLayout = true; this._scheduledTimelines.length; ) this.DeScheduleTimeline(this._scheduledTimelines.pop());
      const e = /* @__PURE__ */ new Set();
      for (const i of this._playingTimelines) {
        i._OnBeforeChangeLayout() && (i.Removed(), e.add(i));
      }
      C32.arrayRemoveAllInSet(this._playingTimelines, e), e.clear();
      for (const i of this._markedForRemovalTimelines) {
        i._OnBeforeChangeLayout() && (i.Removed(), e.add(i));
      }
      C32.arrayRemoveAllInSet(this._markedForRemovalTimelines, e), this._MaybeDisableRuntimeListeners();
      for (const e2 of this._timelines) e2.CleanCaches();
    }
    _OnAfterChangeLayout() {
      this._changingLayout = false;
    }
    _OnInstanceDestroy(e) {
      const i = e.GetObjectClass(), t2 = this.GetTimelinesForObjectClass(i);
      if (t2) if (this._runtime.IsLoadingState()) this._destroyedWhileLoadingState.push(e);
      else for (const e2 of t2) e2.IsTemplate() || (e2.IsReleased() ? this.Remove(e2) : e2.HasValidTracks() || (this._MaybeExecuteTimelineFinishTriggers(e2), this.Remove(e2)));
    }
    _OnBeforeLoad() {
      for (const e of this._scheduledTimelines.map((e2) => e2)) this._MaybeExecuteTimelineFinishTriggers(e), this.Remove(e);
      for (const e of this._playingTimelines.map((e2) => e2)) this._MaybeExecuteTimelineFinishTriggers(e), this.Remove(e);
    }
    _OnAfterLoad() {
      for (const e of this._destroyedWhileLoadingState) this._OnInstanceDestroy(e);
      C32.clearArray(this._destroyedWhileLoadingState);
      for (const e of this._timelines) e._OnAfterLoad();
    }
    _OnAfterLayoutStart() {
      const e = this._runtime.GetLayoutManager().GetMainRunningLayout();
      if (e) for (const i of this._timelines) {
        const t2 = i.GetStartOnLayout();
        t2 && (e.GetName() === t2 && this.ScheduleTimeline(i));
      }
    }
    _SaveToJson() {
      return { "timelinesJson": this._SaveTimelinesToJson(), "scheduledTimelinesJson": this._SaveScheduledTimelinesToJson(), "playingTimelinesJson": this._SavePlayingTimelinesToJson(), "markedForRemovalTimelinesJson": this._SaveMarkedForRemovalTimelinesToJson(), "hasRuntimeListeners": this._hasRuntimeListeners, "changingLayout": this._changingLayout, "isTickingTimelines": this._isTickingTimelines };
    }
    _LoadFromJson(e) {
      e && (this._ClearCreatedTemplateTimelinesCount(), this._LoadTimelinesFromJson(e["timelinesJson"]), this._LoadScheduledTimelinesFromJson(e["scheduledTimelinesJson"]), this._LoadPlayingTimelinesFromJson(e["playingTimelinesJson"]), this._LoadMarkedForRemovalTimelinesFromJson(e["markedForRemovalTimelinesJson"]), this._hasRuntimeListeners = !e["hasRuntimeListeners"], this._changingLayout = !!e["changingLayout"], this._isTickingTimelines = !!e["isTickingTimelines"], this._SetCreatedTemplateTimelinesCount(), this._MaybeEnableRuntimeListeners(), this._MaybeDisableRuntimeListeners());
    }
    _SaveTimelinesToJson() {
      return this._timelines.map((e) => e._SaveToJson());
    }
    _LoadTimelinesFromJson(e) {
      for (const i of e) {
        let e2 = this.GetTimelineByName(i["name"]);
        if (e2) e2._LoadFromJson(i);
        else {
          const t2 = this._GetTemplateNameFromJson(i);
          if (!t2) continue;
          const s = this.GetTimelineByName(t2);
          e2 = this.CreateFromTemplate(s), e2._LoadFromJson(i);
        }
        e2.HasTracks() || this.Remove(e2);
      }
    }
    _GetTemplateNameFromJson(e) {
      const i = e["name"].split(":");
      return i && 2 === i.length ? i[0] : null;
    }
    _SaveScheduledTimelinesToJson() {
      return this._SaveTimelines(this._scheduledTimelines);
    }
    _LoadScheduledTimelinesFromJson(e) {
      this._LoadTimelines(e, this._scheduledTimelines);
    }
    _SavePlayingTimelinesToJson() {
      return this._SaveTimelines(this._playingTimelines);
    }
    _LoadPlayingTimelinesFromJson(e) {
      this._LoadTimelines(e, this._playingTimelines);
    }
    _SaveMarkedForRemovalTimelinesToJson() {
      return this._SaveTimelines(this._markedForRemovalTimelines);
    }
    _LoadMarkedForRemovalTimelinesFromJson(e) {
      this._LoadTimelines(e, this._markedForRemovalTimelines);
    }
    _IsTimelineInJson(e, i) {
      if (!i) return false;
      for (const t2 of i) if (t2 === e.GetName()) return true;
      return false;
    }
    _SaveTimelines(e) {
      return e.map((e2) => e2.GetName());
    }
    _LoadTimelines(e, i) {
      const t2 = /* @__PURE__ */ new Set();
      for (const s of i) this._IsTimelineInJson(s, e) || t2.add(s);
      if (C32.arrayRemoveAllInSet(i, t2), e) {
        const t3 = (e2) => (i2) => i2.GetName() === e2;
        for (const s of e) {
          const e2 = this.GetTimelineByName(s);
          if (e2) {
            i.find(t3(s)) || i.push(e2);
          }
        }
      }
    }
  };
}
{
  const C32 = self.C3, STEPS = 100, LENGTH_STEP_SIZE = 0.01, BEZIER_STEP_SIZE = 25, REFINE_ITERATIONS = 20, LOOKUP_STEPS_FROM_LAST = 5, TANGENT_RESULT = [0, 0], MAP_RESULT = [0, 0], SHORT_PROJECTION_RESULT = [0, 0], PROJECTION_RESULT = [0, 0, 0, 0, 0], REFINE_LUT = new Array(4), REFINE_LUT_OBJECTS = [{ x: 0, y: 0, t: 0, distance: 0 }, { x: 0, y: 0, t: 0, distance: 0 }, { x: 0, y: 0, t: 0, distance: 0 }], REFINE_RESULT = { x: 0, y: 0, t: 0, distance: 0 };
  C32.TimelineInfo = class {
    constructor(t2, i) {
      this._initialized = false, this._timeline = t2, this._segments = [];
      let e = null;
      if (e = i ? this._timeline.GetTrackById(i) : C32.first(this._timeline.GetTracks()), !e) return;
      const s = e.GetPropertyTrack("offsetX"), _2 = e.GetPropertyTrack("offsetY");
      if (!s || !_2) return;
      this._xTrack = s, this._yTrack = _2;
      const h2 = s.GetPropertyKeyframeDataItemArrayIncludingDisabled(), n = _2.GetPropertyKeyframeDataItemArrayIncludingDisabled();
      for (let t3 = 1, i2 = Math.min(h2.length, n.length); t3 < i2; ++t3) {
        const i3 = h2[t3], e2 = (i3.GetNext(), i3.GetPrevious()), s2 = n[t3], _3 = (s2.GetNext(), s2.GetPrevious());
        e2 && "cubic-bezier" === e2.GetPathMode() && _3 && "cubic-bezier" === _3.GetPathMode() ? this._segments.push(C32.New(C32.TimelineCubicBezierSegmentInfo, e2, _3, i3, s2, this._segments.length)) : (e2 && "line" === e2.GetPathMode() && _3 && _3.GetPathMode(), this._segments.push(C32.New(C32.TimelineLineSegmentInfo, i3, s2, this._segments.length)));
      }
      this._initialized = true;
    }
    Release() {
      for (const t2 of this._segments) t2.Release();
      C32.clearArray(this._segments), this._segments = null, this._timeline = null, this._xTrack = null, this._yTrack = null;
    }
    WasInitialized() {
      return this._initialized;
    }
    segments() {
      return this._segments;
    }
    SetOrigin(t2) {
      const i = "relative" === this._xTrack.GetResultMode() ? t2.GetX() : 0, e = "relative" === this._yTrack.GetResultMode() ? t2.GetY() : 0;
      for (const t3 of this._segments) t3.SetOrigin(i, e);
    }
    Project(t2, i, e) {
      let s = NaN, _2 = this._segments.length;
      for (let e2 = 0; e2 < _2; e2++) {
        const _3 = this._segments[e2];
        if ("cubic-bezier" === _3.GetType()) {
          const e3 = _3.Project(t2, i);
          (isNaN(s) || e3[3] < s) && (s = e3[3], SHORT_PROJECTION_RESULT[0] = e3[2], SHORT_PROJECTION_RESULT[1] = _3.GetIndex());
        }
      }
      return SHORT_PROJECTION_RESULT;
    }
    ProjectWithOptions(t2, i, e) {
      const s = e.tRange;
      C32.IsFiniteNumber(s[0]) || (s[0] = 0), C32.IsFiniteNumber(s[1]) || (s[1] = 1);
      let _2 = NaN, h2 = this._segments.length;
      for (let e2 = 0; e2 < h2; e2++) {
        const h3 = this._segments[e2];
        if ("cubic-bezier" === h3.GetType()) {
          const e3 = h3.ProjectWithRange(t2, i, s);
          (isNaN(_2) || e3[3] < _2) && (_2 = e3[3], SHORT_PROJECTION_RESULT[0] = e3[2], SHORT_PROJECTION_RESULT[1] = h3.GetIndex());
        }
      }
      return SHORT_PROJECTION_RESULT;
    }
    Tangent(t2, i) {
      return this._segments[i].Tangent(t2);
    }
    TangentAngle(t2, i) {
      return this._segments[i].TangentAngle(t2);
    }
  }, C32.TimelineCubicBezierSegmentInfo = class {
    constructor(t2, i, e, s, _2) {
      this._index = _2;
      const h2 = t2.GetAddOn("cubic-bezier"), n = e.GetAddOn("cubic-bezier"), r2 = i.GetAddOn("cubic-bezier"), a2 = s.GetAddOn("cubic-bezier");
      this._aX = t2.GetValueWithResultMode(), this._aY = i.GetValueWithResultMode(), this._bX = t2.GetValueWithResultMode() + h2.GetStartAnchor(), this._bY = i.GetValueWithResultMode() + r2.GetStartAnchor(), this._cX = e.GetValueWithResultMode() + n.GetEndAnchor(), this._cY = s.GetValueWithResultMode() + a2.GetEndAnchor(), this._dX = e.GetValueWithResultMode(), this._dY = s.GetValueWithResultMode(), this._aXO = 0, this._aYO = 0, this._bXO = 0, this._bYO = 0, this._cXO = 0, this._cYO = 0, this._dXO = 0, this._dYO = 0, this._d0x = 0, this._d0y = 0, this._d1x = 0, this._d1y = 0, this._d2x = 0, this._d2y = 0, this._x1Factor = 0, this._x2Factor = 0, this._x3Factor = 0, this._y1Factor = 0, this._y2Factor = 0, this._y3Factor = 0, this._lutIndex = NaN, this._initialized = false, this._len = 100, this._arcLengths = new Array(this._len + 1), this._arcLengths[0] = 0, this._length = 0, this._lut = [], this._lutObjects = [];
      for (let t3 = 0; t3 < 100; t3++) this._lutObjects.push({ x: 0, y: 0, t: 0, distance: 0 });
      this._CalculateLength();
    }
    Release() {
      C32.clearArray(this._arcLengths), this._arcLengths = null, C32.clearArray(this._lut), this._lut = null, C32.clearArray(this._lutObjects), this._lutObjects = null;
    }
    GetType() {
      return "cubic-bezier";
    }
    GetIndex() {
      return this._index;
    }
    GetStepCount() {
      return Math.floor(this._length / 25);
    }
    GetStepIncrement() {
      return 1 / this.GetStepCount();
    }
    SetOrigin(t2, i) {
      this._originX = t2, this._originY = i, this._arcLengths = new Array(this._len + 1), this._arcLengths[0] = 0, this._CalculateLength(), this._aXO = this._aX + this._originX, this._aYO = this._aY + this._originY, this._bXO = this._bX + this._originX, this._bYO = this._bY + this._originY, this._cXO = this._cX + this._originX, this._cYO = this._cY + this._originY, this._dXO = this._dX + this._originX, this._dYO = this._dY + this._originY, this._d0x = 3 * (this._bXO - this._aXO), this._d0y = 3 * (this._bYO - this._aYO), this._d1x = 3 * (this._cXO - this._bXO), this._d1y = 3 * (this._cYO - this._bYO), this._d2x = 3 * (this._dXO - this._cXO), this._d2y = 3 * (this._dYO - this._cYO), this._x1Factor = 3 * (this._bXO - this._aXO), this._x2Factor = 3 * (this._aXO + this._cXO - 2 * this._bXO), this._x3Factor = this._dXO - this._aXO + 3 * (this._bXO - this._cXO), this._y1Factor = 3 * (this._bYO - this._aYO), this._y2Factor = 3 * (this._aYO + this._cYO - 2 * this._bYO), this._y3Factor = this._dYO - this._aYO + 3 * (this._bYO - this._cYO);
    }
    Map(t2) {
      if (!this._initialized) return NaN;
      const i = this._Map(t2);
      return MAP_RESULT[0] = this._X(i), MAP_RESULT[1] = this._Y(i), MAP_RESULT;
    }
    Project(t2, i) {
      const e = this._GenerateLUT(100), s = this._FindClosestFromLUT(t2, i, e), _2 = this._RefineProjection(t2, i, e, s);
      return PROJECTION_RESULT[0] = _2.x, PROJECTION_RESULT[1] = _2.y, PROJECTION_RESULT[2] = _2.t, PROJECTION_RESULT[3] = _2.distance, PROJECTION_RESULT;
    }
    ProjectWithRange(t2, i, e) {
      const s = this._GenerateLUT(100), _2 = this._FindClosestFromLUTWithRange(t2, i, s, e), h2 = this._RefineProjection(t2, i, s, _2);
      return PROJECTION_RESULT[0] = h2.x, PROJECTION_RESULT[1] = h2.y, PROJECTION_RESULT[2] = h2.t, PROJECTION_RESULT[3] = h2.distance, PROJECTION_RESULT;
    }
    Tangent(t2) {
      const i = 1 - t2, e = i * i, s = 2 * i * t2, _2 = t2 * t2, h2 = e * this._d0x + s * this._d1x + _2 * this._d2x, n = e * this._d0y + s * this._d1y + _2 * this._d2y, r2 = C32.hypot2DFast(h2, n);
      return TANGENT_RESULT[0] = h2 / r2, TANGENT_RESULT[1] = n / r2, TANGENT_RESULT;
    }
    TangentAngle(t2) {
      const i = 1 - t2, e = i * i, s = 2 * i * t2, _2 = t2 * t2, h2 = e * this._d0x + s * this._d1x + _2 * this._d2x, n = e * this._d0y + s * this._d1y + _2 * this._d2y;
      return Math.atan2(n, h2);
    }
    _Map(t2) {
      if (!this._initialized) return;
      let i = t2 * this._arcLengths[this._len], e = 0, s = this._len, _2 = 0;
      for (; e < s; ) _2 = e + ((s - e) / 2 | 0), this._arcLengths[_2] < i ? e = _2 + 1 : s = _2;
      this._arcLengths[_2] > i && _2--;
      const h2 = this._arcLengths[_2];
      return h2 === i ? _2 / this._len : (_2 + (i - h2) / (this._arcLengths[_2 + 1] - h2)) / this._len;
    }
    _X(t2) {
      return this._initialized ? self.Ease.GetRuntimeEase("cubicbezier")(t2, this._aX + this._originX, this._bX + this._originX, this._cX + this._originX, this._dX + this._originX) : NaN;
    }
    _Y(t2) {
      return this._initialized ? self.Ease.GetRuntimeEase("cubicbezier")(t2, this._aY + this._originY, this._bY + this._originY, this._cY + this._originY, this._dY + this._originY) : NaN;
    }
    _GenerateLUT(t2) {
      if (t2 = t2 || 100, this._lut.length >= t2) return this._lut;
      this._lut = new Array(t2), t2++;
      for (let i = 0; i < t2 - 1; i++) {
        const e = i / (t2 - 1), s = e ** 2, _2 = e ** 3, h2 = this._x1Factor * e, n = this._x2Factor * s, r2 = this._x3Factor * _2, a2 = this._y1Factor * e, c2 = this._y2Factor * s, l = this._y3Factor * _2, o2 = this._aXO + h2 + n + r2, d2 = this._aYO + a2 + c2 + l;
        this._lutObjects[i].x = o2, this._lutObjects[i].y = d2, this._lutObjects[i].t = e, this._lutObjects[i].distance = 0, this._lut[i] = this._lutObjects[i];
      }
      return this._lut;
    }
    _FindClosestFromLUT(t2, i, e, s = null, _2 = Number.MAX_SAFE_INTEGER) {
      let h2 = 0;
      if (isNaN(this._lutIndex)) for (let s2 = 0; s2 < 100; s2++) {
        const n = e[s2], r2 = n.x - t2, a2 = n.y - i;
        n.distance = r2 * r2 + a2 * a2, n.distance < _2 && (_2 = n.distance, h2 = s2);
      }
      else {
        for (let s2 = this._lutIndex; s2 < this._lutIndex + 5 && !(s2 >= e.length); s2++) {
          const n = e[s2], r2 = n.x - t2, a2 = n.y - i;
          n.distance = r2 * r2 + a2 * a2, n.distance < _2 && (_2 = n.distance, h2 = s2);
        }
        for (let s2 = this._lutIndex; s2 > this._lutIndex - 5 && !(s2 < 0); s2--) {
          const n = e[s2], r2 = n.x - t2, a2 = n.y - i;
          n.distance = r2 * r2 + a2 * a2, n.distance < _2 && (_2 = n.distance, h2 = s2);
        }
      }
      return this._lutIndex = h2, h2;
    }
    _FindClosestFromLUTWithRange(t2, i, e, s, _2 = Number.MAX_SAFE_INTEGER) {
      let h2 = 0;
      if (isNaN(this._lutIndex)) for (let n = 0; n < 100; n++) {
        const r2 = e[n], a2 = r2.x - t2, c2 = r2.y - i;
        r2.distance = a2 * a2 + c2 * c2, r2.t >= s[0] && r2.t <= s[1] && r2.distance < _2 && (_2 = r2.distance, h2 = n);
      }
      else {
        for (let n = this._lutIndex; n < this._lutIndex + 5 && !(n >= e.length); n++) {
          const r2 = e[n], a2 = r2.x - t2, c2 = r2.y - i;
          r2.distance = a2 * a2 + c2 * c2, r2.t >= s[0] && r2.t <= s[1] && r2.distance < _2 && (_2 = r2.distance, h2 = n);
        }
        for (let n = this._lutIndex; n > this._lutIndex - 5 && !(n < 0); n--) {
          const r2 = e[n], a2 = r2.x - t2, c2 = r2.y - i;
          r2.distance = a2 * a2 + c2 * c2, r2.t >= s[0] && r2.t <= s[1] && r2.distance < _2 && (_2 = r2.distance, h2 = n);
        }
      }
      return this._lutIndex = h2, h2;
    }
    _RefineProjection(t2, i, e, s) {
      let _2 = e[s], h2 = 1, n = Number.MAX_SAFE_INTEGER;
      t: do {
        const h3 = e.length;
        let r2 = 0 === s ? 0 : s - 1, a2 = s === h3 - 1 ? h3 - 1 : s + 1, c2 = e[r2].t, l = (e[a2].t - c2) / 4;
        if (l < 1e-3) break;
        REFINE_LUT[0] = e[r2];
        for (let e2 = 1; e2 <= 2; e2++) {
          const h4 = c2 + e2 * l, r3 = h4 ** 2, a3 = h4 ** 3, o2 = this._x1Factor * h4, d2 = this._x2Factor * r3, u2 = this._x3Factor * a3, O2 = this._y1Factor * h4, T2 = this._y2Factor * r3, E2 = this._y3Factor * a3, R = this._aXO + o2 + d2 + u2, g2 = this._aYO + O2 + T2 + E2, N = R - t2, I2 = g2 - i, S2 = N * N + I2 * I2;
          if (S2 < n) {
            n = S2, s = e2, REFINE_RESULT.x = R, REFINE_RESULT.y = g2, REFINE_RESULT.t = h4, REFINE_RESULT.distance = S2, _2 = REFINE_RESULT;
            break t;
          }
          const x2 = REFINE_LUT_OBJECTS[e2 - 1];
          x2.x = R, x2.y = g2, x2.t = h4, x2.distance = S2, REFINE_LUT[e2] = x2;
        }
        REFINE_LUT[3] = e[a2], e = REFINE_LUT;
      } while (h2++ < 20);
      return _2;
    }
    _CalculateLength() {
      this._initialized = true;
      let t2 = this._X(0), i = this._Y(0), e = 0;
      for (let s = 1; s <= this._len; s++) {
        const _2 = this._X(0.01 * s), h2 = this._Y(0.01 * s), n = t2 - _2, r2 = i - h2;
        e += C32.hypot2DFast(n, r2), this._arcLengths[s] = e, t2 = _2, i = h2;
      }
      this._length = e;
    }
  }, C32.TimelineLineSegmentInfo = class {
    constructor(t2, i, e) {
      this._index = e, this._targetX = t2.GetValueWithResultMode(), this._targetY = i.GetValueWithResultMode(), this._originX = 0, this._originY = 0;
    }
    Release() {
    }
    GetType() {
      return "line";
    }
    GetIndex() {
      return this._index;
    }
    SetOrigin(t2, i) {
      this._originX = t2, this._originY = i;
    }
    GetX() {
      return this._targetX + this._originX;
    }
    GetY() {
      return this._targetY + this._originY;
    }
  };
}
{
  const C32 = self.C3, PING_PONG_BEGIN = 0, PING_PONG_END = 1;
  C32.TimelineState = class extends C32.DefendedBase {
    constructor(t2, e, i) {
      super(), this._runtime = i.GetRuntime(), this._timelineManager = i, this._timelineDataItem = e, this._name = t2, this._tracks = [], this._tracksLength = 0, this._beforeAndAfterTracks = null, this._beforeAndAfterTracksLength = 0, this.CreateTrackStates(), this._playPromise = null, this._playResolve = null, this._playheadTime = 0, this._overshoot = 0, this._playbackRate = 1, this._pingPongState = 0, this._resumePingPongState = -1, this._currentRepeatCount = 1, this._isPlaying = false, this._isScheduled = false, this._initialStateSet = false, this._complete = true, this._released = false, this._markedForRemoval = false, this._completedTick = -1, this._implicitPause = false, this._isTemplate = false, this._finishedTriggers = false, this._firstTick = false, this._lastDelta = NaN, this._tags = [""], this._stringTags = "", this._tagsChanged = false, this._renderChange = 0, this._hasNestedContent = 0, this._stoppedKeyframeDataItem = null, this._iTimelineState = null;
    }
    static CreateInitial(t2, e) {
      const i = e.GetTimelineDataManager(), s = i.GetNameId(), a2 = i.Get(t2[s]), n = C32.New(C32.TimelineState, t2[s], a2, e);
      return n.SetIsTemplate(true), n;
    }
    static CreateFromTemplate(t2, e, i) {
      return C32.New(C32.TimelineState, t2, e, i);
    }
    Release() {
      if (this.IsReleased()) return;
      const t2 = this._runtime.Dispatcher();
      this._timelineManager.DeScheduleTimeline(this), this._timelineManager.CompleteTimelineAndResolve(this);
      for (const t3 of this._tracks) t3.Release();
      C32.clearArray(this._tracks), this._tracks = null, this._runtime = null, this._timelineManager = null, this._timelineDataItem = null, this._released = true, this._playPromise = null, this._playResolve = null, this.FireReleaseEvent(t2);
    }
    FireReleaseEvent(t2) {
      const e = C32.New(C32.Event, "timelinestatereleased");
      e.timelineState = this, t2.dispatchEvent(e);
    }
    GetType() {
      return 0;
    }
    CreateTrackStates() {
      for (const t2 of this._timelineDataItem.GetTrackData().trackDataItems()) this._tracksLength = this._tracks.push(C32.TrackState.Create(this, t2));
    }
    GetTimelineManager() {
      return this._timelineManager;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetTracks() {
      return this._tracks;
    }
    GetSimilarPropertyTracks(t2, e, i, s) {
      if (!this._hasNestedContent) return;
      let a2;
      for (let n = 0; n < this._tracks.length; n++) {
        let r2 = this._tracks[n];
        if (t2 !== r2.GetInstance()) continue;
        const h2 = r2.GetPropertyTrack(i);
        h2 && (e.constructor === h2.GetSourceAdapter().constructor && h2.GetResultMode() === s.GetResultMode() && (a2 || (a2 = []), a2.push(h2)));
      }
      return a2;
    }
    HasTracks() {
      return !!this._tracks.length;
    }
    GetTrackById(t2) {
      for (const e of this._tracks) if (C32.equalsNoCase(e.GetId(), t2)) return e;
      return null;
    }
    GetTrackByName(t2) {
      for (const e of this._tracks) if (!e.IsInstanceTrack() && C32.equalsNoCase(e.GetName(), t2)) return e;
      return null;
    }
    SetName(t2) {
      this._name = t2;
    }
    GetName() {
      return this._name;
    }
    GetTimelineDataItem() {
      return this._timelineDataItem;
    }
    GetTemplateName() {
      return this._timelineDataItem.GetName();
    }
    GetTotalTime() {
      return this._timelineDataItem.GetTotalTime();
    }
    SetTotalTime(t2) {
      this._timelineDataItem.SetTotalTime(t2);
    }
    GetStep() {
      return this._timelineDataItem.GetStep();
    }
    SetStep(t2) {
      this._timelineDataItem.SetStep(t2);
    }
    GetInterpolationMode() {
      return this._timelineDataItem.GetInterpolationMode();
    }
    SetInterpolationMode(t2) {
      this._timelineDataItem.SetInterpolationMode(t2);
    }
    GetResultMode() {
      return this._timelineDataItem.GetResultMode();
    }
    SetResultMode(t2) {
      this._timelineDataItem.GetResultMode(t2);
    }
    SetEase(t2) {
      for (const e of this.GetTracks()) e.SetEase(t2);
    }
    GetLoop() {
      return this._timelineDataItem.GetLoop();
    }
    SetLoop(t2) {
      return this._timelineDataItem.SetLoop(t2);
    }
    GetPingPong() {
      return this._timelineDataItem.GetPingPong();
    }
    SetPingPong(t2) {
      return this._timelineDataItem.SetPingPong(t2);
    }
    GetRepeatCount() {
      return this._timelineDataItem.GetRepeatCount();
    }
    GetCurrentRepeatCount() {
      return this._currentRepeatCount;
    }
    SetRepeatCount(t2) {
      return this._timelineDataItem.SetRepeatCount(t2);
    }
    SetPlaybackRate(t2) {
      if (t2 = Number(t2), C32.IsFiniteNumber(t2)) return this._playbackRate = t2;
    }
    GetPlaybackRate() {
      return this._playbackRate;
    }
    GetStartOnLayout() {
      return this._timelineDataItem.GetStartOnLayout();
    }
    GetTransformWithSceneGraph() {
      return this._timelineDataItem.GetTransformWithSceneGraph();
    }
    GetUseSystemTimescale() {
      return this._timelineDataItem.GetUseSystemTimescale();
    }
    GetPingPongState() {
      return this._pingPongState;
    }
    IsForwardPlayBack() {
      return !this.IsPlaying() || this._playbackRate > 0;
    }
    GetStatus() {
      return this.IsPlaying() ? "playing" : this.IsPaused() ? "paused" : this.IsComplete() ? "complete" : "other";
    }
    GetPlayPromise() {
      return this._playPromise || (this._playPromise = new Promise((t2) => {
        this._playResolve = t2;
      })), this._playPromise;
    }
    ResolvePlayPromise() {
      this._playPromise && (this._playResolve(), this._playPromise = null, this._playResolve = null);
    }
    SetTags(t2) {
      this._tags = C32.TimelineState._GetTagArray(t2), this._tagsChanged = true;
    }
    GetTags() {
      return this._tags;
    }
    GetStringTags() {
      return this._tagsChanged && (this._stringTags = this._tags.join(" ")), this._tagsChanged = false, this._stringTags;
    }
    HasTags(t2) {
      if (!this._tags) return false;
      if (!this._tags.length) return false;
      const e = C32.TimelineState._GetTagArray(t2);
      return !!e && (!!e.length && e.every(C32.TimelineState._HasTag, this));
    }
    OnStarted() {
      C32.Plugins.Timeline && this.constructor === C32.TimelineState && (C32.Plugins.Timeline.Cnds.PushTriggerTimeline(this), this._timelineManager.Trigger(C32.Plugins.Timeline.Cnds.OnTimelineStarted), this._timelineManager.Trigger(C32.Plugins.Timeline.Cnds.OnTimelineStartedByName), this._timelineManager.Trigger(C32.Plugins.Timeline.Cnds.OnTimelineStartedByTags), this._timelineManager.Trigger(C32.Plugins.Timeline.Cnds.OnAnyTimelineStarted), C32.Plugins.Timeline.Cnds.PopTriggerTimeline());
    }
    OnCompleted() {
      this._completedTick = this._runtime.GetTickCount();
    }
    FinishTriggers() {
      this._finishedTriggers || (this._finishedTriggers = true, C32.Plugins.Timeline && this.constructor === C32.TimelineState && (C32.Plugins.Timeline.Cnds.PushTriggerTimeline(this), this._timelineManager.Trigger(C32.Plugins.Timeline.Cnds.OnTimelineFinished), this._timelineManager.Trigger(C32.Plugins.Timeline.Cnds.OnTimelineFinishedByName), this._timelineManager.Trigger(C32.Plugins.Timeline.Cnds.OnTimelineFinishedByTags), this._timelineManager.Trigger(C32.Plugins.Timeline.Cnds.OnAnyTimelineFinished), C32.Plugins.Timeline.Cnds.PopTriggerTimeline()));
    }
    SetPlaying(t2) {
      this._isPlaying = t2;
    }
    IsCompletedTick() {
      return this._completedTick === this._runtime.GetTickCount();
    }
    IsPlaying(t2 = false) {
      return !!this.IsCompletedTick() || (!(!this.IsScheduled() || t2) || this._isPlaying);
    }
    _IsPlaying() {
      return this.IsPlaying(true);
    }
    IsPaused() {
      return this._IsPaused();
    }
    _IsPaused() {
      return !this.IsReleased() && (!this.IsScheduled() && (!this._IsPlaying() && !this.IsComplete()));
    }
    SetScheduled(t2) {
      this._isScheduled = t2;
    }
    IsScheduled() {
      return this._isScheduled;
    }
    SetComplete(t2) {
      this._complete = t2;
      const e = this.GetLoop(), i = this.GetPingPong();
      if (e || i) {
        if (e && !i) ;
        else if (!e && i) {
          const t3 = this.GetTime();
          1 === this._pingPongState && (t3 <= 0 || t3 >= this.GetTotalTime()) && (this._complete = true);
        }
      } else {
        const t3 = this.GetTime();
        (t3 <= 0 || t3 >= this.GetTotalTime()) && (this._complete = true);
      }
    }
    IsComplete() {
      return this._complete;
    }
    IsReleased() {
      return this._released;
    }
    SetMarkedForRemoval(t2) {
      this._markedForRemoval = t2;
    }
    IsMarkedForRemoval() {
      return this._markedForRemoval;
    }
    SetImplicitPause(t2) {
      this._implicitPause = t2;
    }
    IsImplicitPause() {
      return this._implicitPause;
    }
    SetIsTemplate(t2) {
      this._isTemplate = !!t2;
    }
    IsTemplate() {
      return this._isTemplate;
    }
    InitialStateSet() {
      return this._initialStateSet;
    }
    GetTime() {
      return this._playheadTime;
    }
    SetTime(t2) {
      if (t2 = Number(t2), !C32.IsFiniteNumber(t2)) return;
      const e = this.GetTime();
      this._SetTime(t2), this.SetComplete(false), this.IsComplete() || this.SetImplicitPause(true), (this._IsPlaying() || this.IsScheduled() || !this._initialStateSet) && (this._IsPlaying() || this.IsScheduled() || this._initialStateSet ? this._IsPlaying() ? this.Stop() : this.IsScheduled() && (this._timelineManager.DeScheduleTimeline(this), this.SetInitialStateFromSetTime()) : this.SetInitialStateFromSetTime()), this._SetUpdateStateBefore(), this._Interpolate(this.GetTime(), false, true, true, e), this._SetUpdateStateAfter(), this._renderChange && this.GetRuntime().UpdateRender(), this._OnSetTime();
    }
    _SetTime(t2) {
      C32.IsFiniteNumber(t2) || (t2 = this.GetTotalTime()), t2 < 0 ? this._playheadTime = 0 : t2 >= this.GetTotalTime() ? this._playheadTime = this.GetTotalTime() : this._playheadTime = t2;
    }
    _SetTimeAndReset(t2) {
      C32.IsFiniteNumber(t2) || (t2 = this.GetTotalTime()), t2 < 0 ? this._playheadTime = 0 : t2 >= this.GetTotalTime() ? this._playheadTime = this.GetTotalTime() : this._playheadTime = t2;
      for (const t3 of this._tracks) t3.SetResetState();
    }
    _OnSetTime() {
      C32.Plugins.Timeline && this.constructor === C32.TimelineState && (C32.Plugins.Timeline.Cnds.PushTriggerTimeline(this), this._timelineManager.Trigger(C32.Plugins.Timeline.Cnds.OnTimeSet), this._timelineManager.Trigger(C32.Plugins.Timeline.Cnds.OnTimeSetByName), this._timelineManager.Trigger(C32.Plugins.Timeline.Cnds.OnTimeSetByTags), C32.Plugins.Timeline.Cnds.PopTriggerTimeline());
    }
    _CanResume() {
      if (this.GetLoop()) return true;
      if (this.GetPingPong() && 1 === this._pingPongState) {
        if (this.IsForwardPlayBack()) {
          if (this.GetTime() >= this.GetTotalTime()) return false;
        } else if (this.GetTime() <= 0) return false;
      } else if (!this.GetLoop() && !this.GetPingPong()) {
        if (this.IsForwardPlayBack()) {
          if (this.GetTime() >= this.GetTotalTime()) return false;
        } else if (this.GetTime() <= 0) return false;
      }
      return true;
    }
    Resume() {
      this.IsReleased() || this._CanResume() && this.Play(true);
    }
    Play(t2 = false) {
      return !this.IsReleased() && (!this.IsScheduled() && (this._IsPlaying() && this.IsCompletedTick() ? this._SchedulePlayingTimeline() : !this._IsPlaying() && (!!(this.IsComplete() || t2 || this.IsImplicitPause()) && this._ScheduleStoppedTimeline())));
    }
    _SchedulePlayingTimeline() {
      return this.SetImplicitPause(false), this._timelineManager.RemovePlayingTimeline(this), this._timelineManager.ScheduleTimeline(this), this.GetPlayPromise(), true;
    }
    _ScheduleStoppedTimeline() {
      return this.SetImplicitPause(false), this._timelineManager.ScheduleTimeline(this), this.GetPlayPromise(), true;
    }
    Stop(t2 = false) {
      this.IsReleased() || (this.SetComplete(t2), this._timelineManager.CompleteTimeline(this), this.IsComplete() && this.ResolvePlayPromise());
    }
    Reset(t2 = true, e = false) {
      if (this.IsReleased()) return;
      if (!this._IsPlaying() && this.IsScheduled()) return this._timelineManager.DeScheduleTimeline(this);
      if (this.IsComplete()) return;
      this.Stop(true), this.IsForwardPlayBack() ? this._SetTime(0) : this._SetTime(this.GetTotalTime());
      const i = this.GetTime();
      this._SetUpdateStateBefore(), e ? this._InterpolateBeforeChangeLayout(i) : this._Interpolate(i, false, false, true), t2 && this._OnSetTime(), this._SetUpdateStateAfter(), this._renderChange && t2 && this.GetRuntime().UpdateRender();
    }
    ResetBeforeChangeLayout() {
      this.Reset(false, true);
    }
    _InterpolateBeforeChangeLayout(t2) {
      this._Interpolate(t2, false, false, true, NaN, false, true);
    }
    _OnBeforeChangeLayout() {
      return !!this.IsReleased() || !(!this.GetRuntime().IsLoadingState() && this.HasValidGlobalTracks()) && (this._timelineManager.CompleteTimelineBeforeChangeOfLayout(this), this.GetRuntime().IsLoadingState() || this.ResetBeforeChangeLayout(), true);
    }
    SetInitialStateFromSetTime() {
      this.SetInitialState(true);
    }
    SetInitialStateForce() {
      this.SetInitialState(false, true), this.SetPlaying(false), this.SetScheduled(false);
    }
    SetInitialState(t2 = false, e = false) {
      if (!this.IsMarkedForRemoval() || e) if (t2) {
        this._finishedTriggers = false, this._initialStateSet = true, this._firstTick = true, this._SetUpdateStateBefore();
        for (const t3 of this._tracks) t3.SetInitialState();
        this._SetUpdateStateAfter();
      } else if (this.SetPlaying(true), this.SetScheduled(false), this.OnStarted(), this.IsComplete()) {
        this._completedTick = -1, 0 !== this._pingPongState && (this._playbackRate = Math.abs(this._playbackRate)), this._pingPongState = 0, this._resumePingPongState = -1, this._currentRepeatCount = 1, this._complete = false, this._finishedTriggers = false, this._initialStateSet = true, this._firstTick = true, this.IsForwardPlayBack() ? this._SetTime(0) : this._SetTime(this.GetTotalTime()), this._SetUpdateStateBefore();
        for (const t3 of this._tracks) t3.SetInitialState();
        this._SetUpdateStateAfter();
      } else {
        -1 !== this._resumePingPongState && (this._pingPongState = this._resumePingPongState), this._firstTick = true, this._finishedTriggers = false, this._SetUpdateStateBefore();
        for (const t3 of this._tracks) t3.SetResumeState();
        this._SetUpdateStateAfter();
      }
    }
    GetRenderChange() {
      return this._renderChange;
    }
    _SetUpdateStateBefore() {
      this._hasNestedContent = 0;
      for (const t2 of this._tracks) t2.IsNested() && (this._hasNestedContent = 1);
    }
    _SetUpdateStateAfter() {
      this._renderChange = 0;
      for (const t2 of this._tracks) t2._SetUpdateState(), 0 === this._renderChange && 1 === t2.GetRenderChange() && (this._renderChange = 1), this._beforeAndAfterTracks || 1 !== t2.GetNeedsBeforeAndAfter() || (this._beforeAndAfterTracks || (this._beforeAndAfterTracks = []), this._beforeAndAfterTracksLength = this._beforeAndAfterTracks.push(t2));
    }
    Tick(t2, e, i) {
      if (this.GetUseSystemTimescale()) {
        if (0 === t2 && 0 === this._lastDelta) return;
        this._lastDelta = t2, t2 = i;
      } else {
        if (0 === i && 0 === this._lastDelta) return;
        this._lastDelta = i, t2 = i, e = 1;
      }
      const s = this._playheadTime + this._overshoot, a2 = s + t2 * e * this._playbackRate, n = this._timelineDataItem._totalTime;
      a2 < 0 ? (this._playheadTime = 0, this._overshoot = -a2) : a2 >= n ? (this._playheadTime = n, this._overshoot = this._playheadTime - a2) : (this._playheadTime = a2, this._overshoot = 0);
      let r2 = false, h2 = false;
      const l = this.GetLoop(), o2 = this.GetPingPong();
      let m2;
      l || o2 ? l && !o2 ? this._playbackRate > 0 ? this._playheadTime >= n && (this._SetTimeAndReset(0), h2 = true) : this._playheadTime <= 0 && (this._SetTimeAndReset(n), h2 = true) : !l && o2 ? this._playbackRate > 0 ? this._playheadTime >= n && (this._SetTime(n), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), h2 = true, 1 === this._pingPongState ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._pingPongState = 0) : r2 = true : 0 === this._pingPongState && (this._pingPongState = 1)) : this._playheadTime <= 0 && (this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), h2 = true, 1 === this._pingPongState ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._pingPongState = 0) : r2 = true : 0 === this._pingPongState && (this._pingPongState = 1)) : l && o2 && (this._playbackRate > 0 ? this._playheadTime >= n && (this._SetTime(n), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), h2 = true, this._pingPongState++, C32.wrap(this._pingPongState, 0, 2)) : this._playheadTime <= 0 && (this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), h2 = true, this._pingPongState++, C32.wrap(this._pingPongState, 0, 2))) : this._playbackRate > 0 ? this._playheadTime >= n && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._SetTimeAndReset(0), h2 = true) : (this._SetTime(n), r2 = true)) : this._playheadTime <= 0 && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._SetTimeAndReset(n), h2 = true) : (this._SetTime(0), r2 = true));
      const _2 = this._tracksLength;
      if (r2) {
        for (m2 = 0; m2 < _2; m2++) this._tracks[m2].SetEndState();
        return this.Stop(true), void this.OnCompleted();
      }
      const c2 = this._beforeAndAfterTracksLength;
      for (m2 = 0; m2 < c2; m2++) this._beforeAndAfterTracks[m2].BeforeInterpolate();
      if (1 === this._hasNestedContent) for (m2 = 0; m2 < _2; m2++) {
        const t3 = this._tracks[m2], e2 = t3.GetStartOffset();
        this._playheadTime - e2 < 0 && s - e2 > 0 ? (this._playheadTime = e2 < 0 ? 0 : e2 >= n ? n : e2, t3.Interpolate(e2, true, false, h2, this._firstTick, false)) : t3.Interpolate(this._playheadTime, true, false, h2, this._firstTick, false);
      }
      else for (m2 = 0; m2 < _2; m2++) this._tracks[m2].Interpolate(this._playheadTime, true, false, h2, this._firstTick, false);
      if (!this.IsPlaying() && this._stoppedKeyframeDataItem) {
        const t3 = this._stoppedKeyframeDataItem.GetTime() + this._stoppedKeyframeDataItem.GetKeyframeData().GetTrackDataItem().GetStartOffset(), e2 = this._playheadTime - t3;
        this._playheadTime -= e2, 0 !== this._overshoot && (this._overshoot -= e2), this._stoppedKeyframeDataItem = null;
      }
      for (m2 = 0; m2 < c2; m2++) this._beforeAndAfterTracks[m2].AfterInterpolate();
      this._firstTick && (this._firstTick = false);
    }
    SetStoppedOnKeyframe(t2) {
      this._stoppedKeyframeDataItem = t2;
    }
    GetStoppedOnKeyframe() {
      return this._stoppedKeyframeDataItem;
    }
    _Interpolate(t2, e = false, i = false, s = false, a2 = NaN, n = false, r2 = false) {
      for (const t3 of this._tracks) t3.BeforeInterpolate();
      for (const n2 of this._tracks) {
        let h2 = t2;
        if ("number" == typeof a2 && !isNaN(a2)) {
          const t3 = this.GetTime() - n2.GetStartOffset(), e2 = a2 - n2.GetStartOffset();
          t3 < 0 && e2 > 0 && (h2 = n2.GetStartOffset(), this._SetTime(h2));
        }
        n2.Interpolate(h2, e, i, s, this._firstTick, r2);
      }
      for (const t3 of this._tracks) t3.AfterInterpolate();
      this._firstTick && n && (this._firstTick = false);
    }
    AddTrack() {
      const t2 = this._timelineDataItem.GetTrackData().AddEmptyTrackDataItem(), e = C32.TrackState.Create(this, t2);
      return this._tracksLength = this._tracks.push(e), e;
    }
    Removed() {
      if (!this.IsReleased()) for (const t2 of this._tracks) t2.TimelineRemoved();
    }
    CleanCaches() {
      for (const t2 of this._tracks) t2.CleanCaches();
    }
    *GetInstances() {
      for (const t2 of this._tracks) {
        t2.GetInstance() && (yield t2.GetInstance());
      }
    }
    ClearTrackInstances() {
      for (const t2 of this._tracks) t2.ClearInstance();
    }
    SetTrackInstance(t2, e, i) {
      if (e) {
        if ("number" == typeof i && i >= 0) {
          const t3 = this._tracks[i];
          if (!t3) return;
          return t3.SetInstance(e), void this._timelineManager.SetTimelineObjectClassToMap(e.GetObjectClass(), this);
        }
        for (const i2 of this._tracks) if (i2.IsInstanceTrack()) {
          if (t2) {
            if (i2.GetId() !== t2) continue;
            i2.SetInstance(e), this._timelineManager.SetTimelineObjectClassToMap(e.GetObjectClass(), this);
            break;
          }
          if (!i2.HasInstance()) {
            i2.SetInstance(e), this._timelineManager.SetTimelineObjectClassToMap(e.GetObjectClass(), this);
            break;
          }
        }
      }
    }
    HasTrackInstance(t2, e) {
      for (const i of this._tracks) if (i.IsInstanceTrack()) {
        if (e) {
          if (e === i.GetId() && t2 === i.GetInstance()) return true;
        } else if (t2 === i.GetInstance()) return true;
      }
      return false;
    }
    HasValidTracks() {
      return this._tracks.some((t2) => !t2.IsInstanceTrack() || t2.CanInstanceBeValid());
    }
    HasValidGlobalTracks() {
      return this._tracks.some((t2) => {
        if (t2.IsInstanceTrack()) {
          if (!t2.CanInstanceBeValid()) return false;
          const e = t2.GetObjectClass();
          return !!e && e.IsGlobal();
        }
        return false;
      });
    }
    GetPropertyTrack(t2) {
      for (const e of this.GetTracks()) for (const i of e.GetPropertyTracks()) if (i.GetPropertyName() === t2) return i;
    }
    GetTrackFromInstance(t2) {
      for (const e of this._tracks) if (t2 === e.GetInstance()) return e;
      return null;
    }
    GetKeyframeWithTags(t2) {
      let e = t2 ? t2.split(" ") : [];
      const i = new Set(e.map((t3) => t3.toLowerCase().trim()));
      e = [...i.values()];
      for (const t3 of this.GetTracks()) for (const i2 of t3.GetKeyframeDataItems()) {
        if (e.every((t4) => i2.HasTag(t4))) return i2;
      }
    }
    GetObjectClasses() {
      const t2 = [];
      for (const e of this.GetTracks()) t2.push(e.GetObjectClass());
      return t2.filter((t3) => t3);
    }
    _OnAfterLoad() {
      for (const t2 of this.GetTracks()) t2._OnAfterLoad();
    }
    _SaveToJson() {
      return { "tracksJson": this._SaveTracksToJson(), "name": this._name, "playheadTime": this.GetTime(), "playbackRate": this._playbackRate, "pingPongState": this._pingPongState, "resumePingPongState": this._resumePingPongState, "currentRepeatCount": this._currentRepeatCount, "isPlaying": this._isPlaying, "isScheduled": this._isScheduled, "initialStateSet": this._initialStateSet, "finishedTriggers": this._finishedTriggers, "complete": this._complete, "released": this._released, "markedForRemoval": this._markedForRemoval, "completedTick": this._completedTick, "implicitPause": this._implicitPause, "isTemplate": this._isTemplate, "tags": this._tags.join(" "), "stringTags": this._stringTags, "tagsChanged": this._tagsChanged, "firstTick": this._firstTick };
    }
    _LoadFromJson(t2) {
      t2 && (this._LoadTracksFromJson(t2["tracksJson"]), this._name = t2["name"], this._playheadTime = t2["playheadTime"], this._playbackRate = t2["playbackRate"], this._pingPongState = t2["pingPongState"], this._resumePingPongState = t2.hasOwnProperty("resumePingPongState") ? t2["resumePingPongState"] : -1, this._currentRepeatCount = t2["currentRepeatCount"], this._isPlaying = !!t2["isPlaying"], this._isScheduled = !!t2["isScheduled"], this._initialStateSet = !!t2["initialStateSet"], this._finishedTriggers = !!t2.hasOwnProperty("finishedTriggers") && !!t2["finishedTriggers"], this._complete = !!t2["complete"], this._released = !!t2["released"], this._markedForRemoval = !!t2["markedForRemoval"], this._completedTick = t2["completedTick"], this._implicitPause = !!t2["implicitPause"], this._isTemplate = !!t2["isTemplate"], this._tags = t2["tags"].split(" "), this._stringTags = t2["stringTags"], this._tagsChanged = !!t2["tagsChanged"], this._firstTick = !!t2["firstTick"]);
    }
    _SaveTracksToJson() {
      return this._tracks.map((t2) => t2._SaveToJson());
    }
    _LoadTracksFromJson(t2) {
      this.ClearTrackInstances(), t2.forEach((t3, e) => {
        this._tracks[e]._LoadFromJson(t3);
      }), this._tracks.filter((t3) => t3.CanInstanceBeValid());
    }
    static _HasTag(t2) {
      const e = this.GetTags();
      return "" === t2 ? 1 === e.length && "" === e[0] : e.map((t3) => t3.toLowerCase()).includes(t2.toLowerCase());
    }
    static _GetTagArray(t2) {
      if (C32.IsArray(t2)) return t2.slice(0);
      if (C32.IsString(t2)) return t2.split(" ");
      throw new Error("invalid tags");
    }
    GetITimelineState() {
      return this._iTimelineState || (this._iTimelineState = C32.New(self.ITimelineState, this)), this._iTimelineState;
    }
  };
}
{
  const C32 = self.C3, INSTANCE_TRACK = 0, VALUE_TRACK = 1, AUDIO_TRACK = 2;
  C32.TrackState = class extends C32.DefendedBase {
    constructor(t2, e) {
      super(), this._timeline = t2, this._trackDataItem = e, this._trackData = e.GetTrackData(), this._instanceUid = NaN, this._objectClassIndex = NaN, this._instance = null, this._worldInfo = null, this._cleared = false, this._isNested = e.GetStartOffset() > 0, this._initialStateOfNestedSet = false, this._endStateOfNestedSet = false, this._instanceUidToLoad = NaN, this._lastKeyframeDataItem = null, this._keyframeDataItems = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemArray(), this._propertyTracks = [], this.CreatePropertyTrackStates(), this._worldInfoChange = 0, this._renderChange = 0, this._needsBeforeAndAfter = 0;
    }
    static Create(t2, e) {
      return C32.New(C32.TrackState, t2, e);
    }
    Release() {
      this._keyframeDataItems = null;
      for (const t2 of this._propertyTracks) t2.Release();
      C32.clearArray(this._propertyTracks), this._propertyTracks = null, this._timeline = null, this._instance = null, this._worldInfo = null, this._trackDataItem = null, this._lastKeyframeDataItem = null;
    }
    CreatePropertyTrackStates() {
      for (const t2 of this._trackDataItem.GetPropertyTrackData().propertyTrackDataItems()) this._propertyTracks.push(C32.PropertyTrackState.Create(this, t2));
    }
    TimelineRemoved() {
      for (const t2 of this._propertyTracks) t2.TimelineRemoved();
    }
    CleanCaches() {
      for (const t2 of this._propertyTracks) t2.CleanCaches();
      this._instance = null, this._worldInfo = null;
    }
    GetTimeline() {
      return this._timeline;
    }
    GetRuntime() {
      return this._timeline.GetRuntime();
    }
    GetKeyframeDataItems() {
      return this._keyframeDataItems || (this._keyframeDataItems = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemArray()), this._keyframeDataItems;
    }
    GetPropertyTracks() {
      return this._propertyTracks;
    }
    GetPropertyTrack(t2) {
      for (let e = 0; e < this._propertyTracks.length; e++) {
        const a2 = this._propertyTracks[e];
        if (a2.GetPropertyName() === t2) return a2;
      }
    }
    MaybeGetInstance() {
      this._instance || this.GetInstance();
    }
    IsInstanceValid() {
      return !!this._instance && !this._instance.IsDestroyed();
    }
    CanInstanceBeValid() {
      if (!this.IsInstanceTrack()) return false;
      if (this._cleared) return false;
      const t2 = this.GetInstanceUID(), e = this.GetRuntime().GetInstanceByUID(t2);
      return !!e && !e.IsDestroyed();
    }
    GetObjectClass() {
      if (!this.IsInstanceTrack()) return;
      const t2 = this.GetObjectClassIndex();
      return -1 !== t2 ? this.GetRuntime().GetObjectClassByIndex(t2) : void 0;
    }
    GetTrackIndexInTimeline() {
      return this._timeline.GetTracks().indexOf(this);
    }
    ClearInstance() {
      this._instance = null, this._instanceUid = NaN, this._worldInfo = null, this._objectClassIndex = NaN, this._cleared = true;
    }
    HasInstance() {
      return !!this._instance;
    }
    GetInstance() {
      if (this._cleared) return;
      if (this._instance && this.IsInstanceValid()) return this._instance;
      const t2 = this.GetInstanceUID();
      return this._instance = this.GetRuntime().GetInstanceByUID(t2), this._instance;
    }
    SetInstance(t2) {
      if (this._cleared = false, this._instance !== t2) {
        this.CleanCaches(), this._instance = t2, this._objectClassIndex = t2.GetObjectClass().GetIndex(), this._instanceUid = t2.GetUID(), this._worldInfo = t2.GetWorldInfo();
        for (const e of this.propertyTrackItems()) {
          const a2 = e.propertyTrack, s = e.sourceAdapter;
          switch (a2.GetSourceAdapterId()) {
            case "instance-variable": {
              s.GetEditorIndex();
              const a3 = t2.GetObjectClass(), r2 = a3.GetInstanceVariableIndexByName(e.name), i = a3.GetInstanceVariableName(r2), n = a3.GetInstanceVariableType(r2);
              i === e.name && n === e.type && s.UpdateInstanceVariableIndex(r2);
              break;
            }
            case "behavior": {
              const a3 = e.behaviorType, r2 = this.GetObjectClass(), i = t2.GetObjectClass(), n = s.GetBehaviorType(i);
              if (a3 && n) {
                const t3 = a3.GetName();
                r2.GetBehaviorIndexByName(t3), i.GetBehaviorIndexByName(t3), s.GetEditorIndex();
                s.UpdateBehaviorTypeSid(n.GetSID());
              }
              break;
            }
          }
        }
      }
    }
    *propertyTrackItems() {
      for (const t2 of this._propertyTracks) {
        const e = t2.GetSourceAdapter(), a2 = this.GetObjectClass(), s = { propertyTrack: t2, sourceAdapter: e };
        switch (t2.GetSourceAdapterId()) {
          case "world-instance":
            s.property = t2.GetPropertyName();
            break;
          case "instance-variable": {
            const t3 = e.GetEditorIndex();
            s.name = a2.GetInstanceVariableName(t3), s.type = a2.GetInstanceVariableType(t3);
            break;
          }
          case "effect": {
            const t3 = a2.GetEffectList(), r2 = e.GetEffectType(t3);
            s.effectType = r2;
            break;
          }
          case "behavior": {
            const t3 = e.GetBehaviorType(a2);
            s.behaviorType = t3;
            break;
          }
          case "plugin":
            s.plugin = a2.GetPlugin();
        }
        yield s;
      }
    }
    GetWorldInfo() {
      if (this._worldInfo && this.IsInstanceValid()) return this._worldInfo;
      const t2 = this.GetInstance();
      return t2 && (this._worldInfo = t2.GetWorldInfo()), this._worldInfo;
    }
    GetTrackDataItem() {
      return this._trackDataItem;
    }
    GetInstanceUID() {
      return isNaN(this._instanceUid) ? this._trackDataItem.GetInstanceUID() : this._instanceUid;
    }
    SetInstanceUID(t2) {
      this._trackDataItem.SetInstanceUID(t2);
    }
    GetInterpolationMode() {
      return this._trackDataItem.GetInterpolationMode();
    }
    SetInterpolationMode(t2) {
      this._trackDataItem.SetInterpolationMode(t2);
    }
    GetResultMode() {
      return this._trackDataItem.GetResultMode();
    }
    GetId() {
      return this._trackDataItem.GetId();
    }
    GetStartOffset() {
      return this._trackDataItem.GetStartOffset();
    }
    GetLocalTotalTime() {
      return this._trackDataItem.GetLocalTotalTime();
    }
    SetLocalTotalTime(t2) {
      this._trackDataItem.SetLocalTotalTime(t2);
    }
    SetResultMode(t2) {
      this._trackDataItem.SetResultMode(t2);
    }
    SetEase(t2) {
      for (const e of this.GetKeyframeDataItems()) e.SetEase(t2);
      for (const e of this.GetPropertyTracks()) e.SetEase(t2);
    }
    GetEnable() {
      return this._trackDataItem.GetEnable();
    }
    SetEnable(t2) {
      this._trackDataItem.SetEnable(t2);
    }
    GetObjectClassIndex() {
      return isNaN(this._objectClassIndex) ? this._trackDataItem.GetObjectClassIndex() : this._objectClassIndex;
    }
    SetObjectClassIndex(t2) {
      this._trackDataItem.SetObjectClassIndex(t2);
    }
    SetOriginalWidth(t2) {
      this._trackDataItem.SetOriginalWidth(t2);
    }
    GetOriginalWidth() {
      const t2 = this.GetInstance();
      if (t2) {
        if (t2.GetSdkInstance().IsOriginalSizeKnown()) return t2.GetSdkInstance().GetOriginalWidth();
      }
      return this._trackDataItem.GetOriginalWidth();
    }
    SetOriginalHeight(t2) {
      this._trackDataItem.SetOriginalHeight(t2);
    }
    GetOriginalHeight() {
      const t2 = this.GetInstance();
      if (t2) {
        if (t2.GetSdkInstance().IsOriginalSizeKnown()) return t2.GetSdkInstance().GetOriginalHeight();
      }
      return this._trackDataItem.GetOriginalHeight();
    }
    GetType() {
      return this._trackDataItem.GetType();
    }
    GetName() {
      return this._trackDataItem.GetName();
    }
    IsInstanceTrack() {
      return 0 === this.GetType();
    }
    IsValueTrack() {
      return 1 === this.GetType();
    }
    IsAudioTrack() {
      return 2 === this.GetType();
    }
    GetWorldInfoChange() {
      return this._worldInfoChange;
    }
    GetRenderChange() {
      return this._renderChange;
    }
    GetNeedsBeforeAndAfter() {
      return this._needsBeforeAndAfter;
    }
    IsNested() {
      return this._isNested;
    }
    SetResetState() {
      for (const t2 of this._propertyTracks) t2.SetResetState();
    }
    SetInitialState() {
      if (this.MaybeGetInstance(), !this.IsInstanceValid() && this.IsInstanceTrack()) return;
      const t2 = this.GetTimeline().IsForwardPlayBack(), e = t2 ? 0 : this.GetLocalTotalTime();
      for (const t3 of this._propertyTracks) t3.SetInitialState(e), 0 === this._worldInfoChange && 1 === t3.GetWorldInfoChange() && (this._worldInfoChange = 1), 0 === this._renderChange && 1 === t3.GetRenderChange() && (this._renderChange = 1);
      this._needsBeforeAndAfter = 0;
      this._propertyTracks.some((t3) => t3.GetNeedsBeforeAndAfter()) && (this._needsBeforeAndAfter = 1), this._lastKeyframeDataItem = t2 ? this._GetLastKeyFrameBeforeTime(e) : this._GetFirstKeyFrameAfterTime(e), this._initialStateOfNestedSet = false, this._endStateOfNestedSet = false, this.Interpolate(e), this.OnInitialKeyframeReached(this._lastKeyframeDataItem);
    }
    GetCurrentKeyframeInterval() {
      const t2 = this.GetLastKeyframe(), e = this.GetNextKeyframe();
      let a2, s;
      return this._timeline.IsForwardPlayBack() ? (a2 = { GetTime: () => t2.GetTime() + this.GetStartOffset(), GetTags: () => t2.GetTagsString() || "<no tags>" }, s = { GetTime: () => e ? e.GetTime() + this.GetStartOffset() : this.GetLocalTotalTime(), GetTags: () => e?.GetTagsString() || "<no tags>" }) : (a2 = { GetTime: () => e ? e.GetTime() + this.GetStartOffset() : this.GetLocalTotalTime(), GetTags: () => e?.GetTagsString() || "<no tags>" }, s = { GetTime: () => t2.GetTime() + this.GetStartOffset(), GetTags: () => t2.GetTagsString() || "<no tags>" }), [a2, s];
    }
    GetLastKeyframe() {
      const t2 = this._timeline.GetTime() - this.GetStartOffset();
      return this._timeline.IsForwardPlayBack() ? this._GetLastKeyFrameBeforeTime(t2) : this._GetFirstKeyFrameAfterTime(t2);
    }
    GetNextKeyframe() {
      return this._timeline.IsForwardPlayBack() ? this.GetLastKeyframe().GetNext() : this.GetLastKeyframe().GetLast();
    }
    SetResumeState() {
      if (this.MaybeGetInstance(), !this.IsInstanceValid() && this.IsInstanceTrack()) return;
      const t2 = this._timeline.IsForwardPlayBack(), e = this._timeline.GetTime() - this.GetStartOffset();
      this._lastKeyframeDataItem = t2 ? this._GetLastKeyFrameBeforeTime(e) : this._GetFirstKeyFrameAfterTime(e);
      for (const t3 of this._propertyTracks) t3.SetResumeState(e);
    }
    SetEndState() {
      if (!this.GetTimeline().IsComplete() && (this.MaybeGetInstance(), (this.IsInstanceValid() || !this.IsInstanceTrack()) && !this._isNested)) {
        const t2 = this._timeline.GetTime();
        t2 >= this.GetStartOffset() + this.GetLocalTotalTime() ? this.Interpolate(this.GetLocalTotalTime(), true, false, true, false, false, true) : t2 <= 0 && this.Interpolate(0, true, false, true, false, false, true);
      }
    }
    _SetUpdateState() {
      for (let t2 = 0, e = this._propertyTracks.length; t2 < e; t2++) {
        const e2 = this._propertyTracks[t2];
        e2._SetUpdateState(), 0 === this._worldInfoChange && 1 === e2.GetWorldInfoChange() && (this._worldInfoChange = 1), 0 === this._renderChange && 1 === e2.GetRenderChange() && (this._renderChange = 1);
      }
    }
    BeforeInterpolate() {
      const t2 = this._propertyTracks.length;
      for (let e = 0; e < t2; e++) this._propertyTracks[e].BeforeInterpolate();
    }
    Interpolate(t2, e = false, a2 = false, s = false, r2 = false, i = false, n = false) {
      this._instance || this.GetInstance();
      const o2 = this._instance && !this._instance.IsDestroyed(), h2 = 0 === this._trackDataItem._type;
      if ((o2 || !h2) && !(i && h2 && this.GetObjectClass().IsGlobal() || (t2 -= this.GetStartOffset()) < 0)) {
        this.MaybeSetInitialStateOfNestedTrack(t2, e), this.MaybeTriggerKeyframeReachedConditions(t2, e, r2), !this.GetTimeline().IsPlaying() && this.GetTimeline().GetStoppedOnKeyframe() && (t2 = this.GetTimeline().GetStoppedOnKeyframe().GetTime());
        for (let e2 = 0, r3 = this._propertyTracks.length; e2 < r3; e2++) this._propertyTracks[e2].Interpolate(t2, a2, s, n);
        this.MaybeSetEndStateOfNestedTrack(t2, e), 0 !== this._worldInfoChange && (this._worldInfo || (this._worldInfo = this._instance.GetWorldInfo()), this._worldInfo && this._worldInfo.SetBboxChanged());
      }
    }
    AfterInterpolate() {
      const t2 = this._propertyTracks.length;
      for (let e = 0; e < t2; e++) this._propertyTracks[e].AfterInterpolate();
    }
    MaybeSetInitialStateOfNestedTrack(t2, e) {
      if (!e) return;
      if (!this._isNested) return;
      if (this._initialStateOfNestedSet) return;
      if (this.GetTimeline().IsForwardPlayBack()) {
        if (t2 < 0) return;
      } else if (t2 > this.GetLocalTotalTime()) return;
      for (const t3 of this._propertyTracks) t3.SetInitialState();
      this._initialStateOfNestedSet = true;
    }
    MaybeSetEndStateOfNestedTrack(t2, e) {
      if (!e) return;
      if (!this._isNested) return;
      if (this._endStateOfNestedSet) return;
      if (this.GetTimeline().IsForwardPlayBack()) {
        if (t2 >= this.GetLocalTotalTime()) {
          for (const t3 of this._propertyTracks) t3.Interpolate(this.GetLocalTotalTime(), false, true);
          this._endStateOfNestedSet = true;
        }
      } else if (t2 <= 0) {
        for (const t3 of this._propertyTracks) t3.Interpolate(0, false, true);
        this._endStateOfNestedSet = true;
      }
    }
    MaybeTriggerKeyframeReachedConditions(t2, e, a2) {
      if (a2) return;
      if (!e) return;
      if (!C32.Plugins.Timeline) return;
      const s = this.GetTimeline();
      if (s.IsForwardPlayBack()) {
        const e2 = this._lastKeyframeDataItem.GetNext(), a3 = this._lastKeyframeDataItem.GetTime(), r2 = e2 ? e2.GetTime() : s.GetTotalTime();
        (t2 <= a3 || t2 >= r2) && (this._lastKeyframeDataItem = this._trackData.GetFirstKeyFrameDataItemLowerOrEqualThan(t2, this._trackDataItem), e2 && this.OnKeyframeReached(this._lastKeyframeDataItem));
      } else {
        if (!this._trackData.GetFirstKeyFrameDataItemHigherOrEqualThan(t2, this._trackDataItem)) return;
        this._lastKeyframeDataItem || (this._lastKeyframeDataItem = this._trackData.GetFirstKeyFrameDataItemHigherOrEqualThan(t2, this._trackDataItem));
        const e2 = this._lastKeyframeDataItem.GetLast(), a3 = this._lastKeyframeDataItem.GetTime(), s2 = e2 ? e2.GetTime() : 0;
        (t2 >= a3 || t2 <= s2) && (this._lastKeyframeDataItem = this._trackData.GetFirstKeyFrameDataItemHigherOrEqualThan(t2, this._trackDataItem), this._lastKeyframeDataItem && this.OnKeyframeReached(this._lastKeyframeDataItem));
      }
    }
    _GetLastKeyFrameBeforeTime(t2) {
      const e = this._trackData.GetKeyFrameDataItemAtTime(t2, this._trackDataItem);
      return e || this._trackData.GetFirstKeyFrameDataItemLowerOrEqualThan(t2, this._trackDataItem);
    }
    _GetFirstKeyFrameAfterTime(t2) {
      const e = this._trackData.GetKeyFrameDataItemAtTime(t2, this._trackDataItem);
      return e || this._trackData.GetFirstKeyFrameDataItemHigherOrEqualThan(t2, this._trackDataItem);
    }
    OnKeyframeReached(t2, e = false) {
      if (!C32.Plugins.Timeline) return;
      const a2 = this.GetTimeline(), s = a2.GetTimelineManager();
      C32.Plugins.Timeline.Cnds.PushTriggerTimeline(a2), C32.Plugins.Timeline.Cnds.PushTriggerKeyframe(t2), s.Trigger(C32.Plugins.Timeline.Cnds.OnAnyKeyframeReached), s.Trigger(C32.Plugins.Timeline.Cnds.OnKeyframeReached), a2.IsPlaying() || e || a2.SetStoppedOnKeyframe(t2), C32.Plugins.Timeline.Cnds.PopTriggerTimeline(a2), C32.Plugins.Timeline.Cnds.PopTriggerKeyframe(t2);
    }
    OnInitialKeyframeReached(t2) {
      this.OnKeyframeReached(t2, true);
    }
    AddKeyframe() {
      return this._trackDataItem.GetKeyframeData().AddEmptyKeyframeDataItem();
    }
    AddPropertyTrack() {
      const t2 = this._trackDataItem.GetPropertyTrackData().AddEmptyPropertyTrackDataItem(), e = C32.PropertyTrackState.Create(this, t2);
      return this._propertyTracks.push(e), e;
    }
    DeleteKeyframes(t2) {
      this._trackDataItem.GetKeyframeData().DeleteKeyframeDataItems(t2);
    }
    DeletePropertyKeyframes(t2) {
      for (const e of this._propertyTracks) e.DeletePropertyKeyframes(t2);
    }
    SaveState() {
      for (const t2 of this._propertyTracks) t2.SaveState();
    }
    CompareInitialStateWithCurrent() {
      if (this.MaybeGetInstance(), this.IsInstanceValid() || !this.IsInstanceTrack()) for (const t2 of this._propertyTracks) t2.CompareInitialStateWithCurrent();
    }
    CompareSaveStateWithCurrent() {
      if (this.MaybeGetInstance(), !this.IsInstanceValid() && this.IsInstanceTrack()) return;
      let t2 = false;
      for (const e of this._propertyTracks) {
        const a2 = e.CompareSaveStateWithCurrent();
        !t2 && a2 && (t2 = true);
      }
      if (t2) {
        const t3 = this.AddKeyframe();
        t3.SetTime(this.GetTimeline().GetTime()), t3.SetEase("noease"), t3.SetEnable(true), t3.SetTags("");
      }
    }
    _OnAfterLoad() {
      isNaN(this._instanceUidToLoad) || this._LoadInstanceFromJson(this._instanceUidToLoad), this._instanceUidToLoad = NaN;
    }
    _SaveToJson() {
      const t2 = this.GetInstance(), e = t2 ? t2.GetUID() : this.GetInstanceUID();
      return { "propertyTracksJson": this._SavePropertyTracksToJson(), "lastKeyframeDataItemJson": this._SaveLastKeyframeDataItemToJson(), "initialStateOfNestedSet": this._initialStateOfNestedSet, "endStateOfNestedSet": this._endStateOfNestedSet, "instanceUid": e, "cleared": this._cleared };
    }
    _LoadFromJson(t2) {
      if (t2) {
        this._LoadPropertyTracksFromJson(t2["propertyTracksJson"]), this._LoadLastKeyframeDataItemFromJson(t2["lastKeyframeDataItemJson"]), this._instanceUidToLoad = t2["instanceUid"], this._initialStateOfNestedSet = false, t2.hasOwnProperty["initialStateOfNestedSet"] && (this._initialStateOfNestedSet = t2["initialStateOfNestedSet"]), this._endStateOfNestedSet = false, t2.hasOwnProperty["endStateOfNestedSet"] && (this._endStateOfNestedSet = t2["endStateOfNestedSet"]), this._cleared = !!t2.hasOwnProperty("cleared") && t2["cleared"];
        for (const t3 of this._propertyTracks) 0 === this._worldInfoChange && 1 === t3.GetWorldInfoChange() && (this._worldInfoChange = 1), 0 === this._renderChange && 1 === t3.GetRenderChange() && (this._renderChange = 1);
        this._needsBeforeAndAfter = 0, this._propertyTracks.some((t3) => t3.GetNeedsBeforeAndAfter()) && (this._needsBeforeAndAfter = 1);
      }
    }
    _SaveLastKeyframeDataItemToJson() {
      return this._trackDataItem.GetKeyframeData().GetKeyframeDataItemIndex(this._lastKeyframeDataItem);
    }
    _SavePropertyTracksToJson() {
      return this._propertyTracks.map((t2) => t2._SaveToJson());
    }
    _LoadPropertyTracksFromJson(t2) {
      t2.forEach((t3, e) => {
        this._propertyTracks[e]._LoadFromJson(t3);
      });
    }
    _LoadInstanceFromJson(t2) {
      if (!C32.IsFiniteNumber(t2)) return;
      const e = this.GetRuntime().GetInstanceByUID(t2);
      if (!e) return;
      this.GetTimeline().SetTrackInstance(this._trackDataItem.GetId(), e, this.GetTrackIndexInTimeline());
    }
    _LoadLastKeyframeDataItemFromJson(t2) {
      const e = this._trackDataItem.GetKeyframeData();
      this._lastKeyframeDataItem = e.GetKeyframeDataItemFromIndex(t2);
    }
  };
}
{
  const C32 = self.C3;
  C32.PropertyTrackState = class extends C32.DefendedBase {
    constructor(e, t2) {
      super(), this._track = e, this._propertyTrackDataItem = t2, this._propertyTrackData = t2.GetPropertyTrackData(), this._worldInfoChange = 0, this._renderChange = 0, this._needsBeforeAndAfter = 0, this._sourceAdapter = this.GetSourceAdapter(), this._propertyKeyframeDataItems = this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray(), this._lastPropertyKeyframeDataItem = null, this._absoluteValueObject = null;
    }
    static Create(e, t2) {
      return C32.New(C32.PropertyTrackState, e, t2);
    }
    Release() {
      this._track = null, this._sourceAdapter && (this._sourceAdapter.Release(), this._sourceAdapter = null), this._propertyKeyframeDataItems = null, this._propertyTrackDataItem = null, this._propertyTrackData = null;
    }
    GetWorldInfoChange() {
      return this._worldInfoChange;
    }
    GetRenderChange() {
      return this._renderChange;
    }
    GetNeedsBeforeAndAfter() {
      return this._needsBeforeAndAfter;
    }
    HasAbsoluteValueObject() {
      return !!this._absoluteValueObject;
    }
    SetAbsoluteValueObject(e) {
      this._absoluteValueObject = e;
    }
    GetAbsoluteValueObject() {
      return this._absoluteValueObject;
    }
    GetTrack() {
      return this._track;
    }
    GetPropertyTrackDataItem() {
      return this._propertyTrackDataItem;
    }
    GetPropertyTrackData() {
      return this._propertyTrackData;
    }
    GetTimeline() {
      return this._track.GetTimeline();
    }
    GetRuntime() {
      return this._track.GetRuntime();
    }
    GetInstance() {
      return this._track.GetInstance();
    }
    GetSourceAdapter() {
      if (this._sourceAdapter) return this._sourceAdapter;
      let e;
      switch (this._propertyTrackDataItem.GetSourceAdapterId()) {
        case "behavior":
          e = new C32.PropertyTrackState.BehaviorSourceAdapter(this);
          break;
        case "effect":
          e = new C32.PropertyTrackState.EffectSourceAdapter(this), this._renderChange = 1;
          break;
        case "instance-variable":
          e = new C32.PropertyTrackState.InstanceVariableSourceAdapter(this);
          break;
        case "plugin":
          e = new C32.PropertyTrackState.PluginSourceAdapter(this), this._renderChange = 1;
          break;
        case "world-instance":
          e = new C32.PropertyTrackState.PropertySourceAdapter(this), this._renderChange = 1, this._worldInfoChange = 1;
          break;
        case "value":
          e = new C32.PropertyTrackState.ValueSourceAdapter(this);
          break;
        case "audio":
          e = new C32.PropertyTrackState.AudioSourceAdapter(this);
      }
      return this._sourceAdapter = e, this._sourceAdapter;
    }
    GetSourceAdapterId() {
      return this._propertyTrackDataItem.GetSourceAdapterId();
    }
    SetSourceAdapterId(e) {
      this._propertyTrackDataItem.SetSourceAdapterId(e);
    }
    GetSourceAdapterArgs() {
      return this._propertyTrackDataItem.GetSourceAdapterArguments();
    }
    SetSourceAdapterArgs(e) {
      this._propertyTrackDataItem.SetSourceAdapterArguments(e);
    }
    GetSourceAdapterValue() {
      return this.GetSourceAdapter().GetValue();
    }
    GetPropertyName() {
      return this._propertyTrackDataItem.GetProperty();
    }
    SetPropertyName(e) {
      this._propertyTrackDataItem.SetProperty(e);
    }
    GetPropertyType() {
      return this._propertyTrackDataItem.GetType();
    }
    SetPropertyType(e) {
      this._propertyTrackDataItem.SetType(e);
    }
    GetPropertyKeyframeType() {
      return this.GetPropertyTrackData().GetFirstPropertyKeyframeDataItem(this._propertyTrackDataItem).GetType();
    }
    GetMin() {
      return this._propertyTrackDataItem.GetMin();
    }
    SetMin(e) {
      this._propertyTrackDataItem.SetMin(e);
    }
    GetMax() {
      return this._propertyTrackDataItem.GetMax();
    }
    SetMax(e) {
      this._propertyTrackDataItem.SetMax(e);
    }
    GetEnable() {
      return this._propertyTrackDataItem.GetEnable();
    }
    SetEnable(e) {
      this._propertyTrackDataItem.SetEnable(e);
    }
    GetInterpolationMode() {
      return this._propertyTrackDataItem.GetInterpolationMode();
    }
    SetInterpolationMode(e) {
      this._propertyTrackDataItem.SetInterpolationMode(e);
    }
    GetResultMode() {
      return this._propertyTrackDataItem.GetResultMode();
    }
    SetResultMode(e) {
      this._propertyTrackDataItem.SetResultMode(e);
    }
    SetEase(e) {
      for (const t2 of this.GetPropertyKeyframeDataItems()) t2.SetEase(e);
    }
    CanHavePropertyKeyframes() {
      return this._propertyTrackDataItem.CanHavePropertyKeyframes();
    }
    GetPropertyKeyframeDataItems() {
      return this._propertyKeyframeDataItems || (this._propertyKeyframeDataItems = this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray()), this._propertyKeyframeDataItems;
    }
    GetPropertyKeyframeDataItemArrayIncludingDisabled() {
      return this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArrayIncludingDisabled();
    }
    GetPropertyKeyFrameDataItemAtTime(e) {
      return this._propertyTrackData.GetPropertyKeyFrameDataItemAtTime(e, this._propertyTrackDataItem);
    }
    GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e) {
      return this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem);
    }
    GetPropertyKeyframeDataItemPairForTime(e) {
      let t2, r2 = this._propertyTrackData.GetPropertyKeyFrameDataItemAtTime(e, this._propertyTrackDataItem);
      return r2 ? t2 = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherThan(e, this._propertyTrackDataItem) : (r2 = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem), t2 = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(e, this._propertyTrackDataItem)), { start: r2, end: t2 };
    }
    *GetPropertyKeyframeValues() {
      for (const e of this.GetPropertyKeyframeDataItems()) yield e.GetValueWithResultMode();
    }
    *GetPropertyKeyframeTimes() {
      for (const e of this.GetPropertyKeyframeDataItems()) yield e.GetTime();
    }
    TimelineRemoved() {
      this.GetSourceAdapter().TimelineRemoved();
    }
    CleanCaches() {
      this.GetSourceAdapter().CleanCaches();
    }
    GetCurrentState() {
      return this.GetSourceAdapter().GetCurrentState();
    }
    SetResetState() {
      this.GetSourceAdapter().SetResetState();
    }
    SetInitialState(e) {
      this.GetSourceAdapter().SetInitialState(), this._lastPropertyKeyframeDataItem = this._GetLastPropertyKeyFrameBeforeTime(e), this._SetUpdateState();
    }
    SetResumeState(e) {
      this.GetSourceAdapter().SetResumeState(), this._lastPropertyKeyframeDataItem = this._GetLastPropertyKeyFrameBeforeTime(e);
    }
    _SetUpdateState() {
      const e = this.GetTrack();
      if (this._needsBeforeAndAfter = 0, e.IsInstanceTrack()) {
        const t2 = this.GetTimeline(), r2 = e.GetInstance(), a2 = this.GetSourceAdapter(), o2 = this.GetPropertyName();
        if (a2.MayNeedBeforeAndAfterInterpolate()) {
          const e2 = t2.GetSimilarPropertyTracks(r2, a2, o2, this);
          e2 && e2.length && (this._needsBeforeAndAfter = 1);
        } else this._needsBeforeAndAfter = 0;
      }
    }
    _GetLastPropertyKeyFrameBeforeTime(e) {
      const t2 = this.GetTimeline(), r2 = this._propertyTrackData.GetPropertyKeyFrameDataItemAtTime(e, this._propertyTrackDataItem);
      return r2 || (t2.IsForwardPlayBack() ? this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem) : this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(e, this._propertyTrackDataItem));
    }
    BeforeInterpolate() {
      this._sourceAdapter.BeforeInterpolate();
    }
    Interpolate(e, t2 = false, r2 = false, a2 = false) {
      let o2, s, p2 = false;
      if (t2) o2 = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem);
      else {
        if (this._lastPropertyKeyframeDataItem) {
          const t3 = this.GetTimeline(), r3 = this._lastPropertyKeyframeDataItem.GetNext(), a3 = this._lastPropertyKeyframeDataItem.GetTime(), o3 = r3 ? r3.GetTime() : t3.GetTotalTime();
          (e <= a3 || e >= o3) && (this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem), p2 = true);
        } else this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem), p2 = true;
        o2 = this._lastPropertyKeyframeDataItem;
      }
      o2 && (s = o2.GetNext()), this._sourceAdapter.Interpolate(e, o2, s, t2, r2, a2, p2);
    }
    GetInterpolatedValue(e) {
      if (this._lastPropertyKeyframeDataItem) {
        const t3 = this.GetTimeline(), r3 = this._lastPropertyKeyframeDataItem.GetNext(), a2 = this._lastPropertyKeyframeDataItem.GetTime(), o2 = r3 ? r3.GetTime() : t3.GetTotalTime();
        (e <= a2 || e >= o2) && (this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem));
      } else this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem);
      const t2 = this._lastPropertyKeyframeDataItem, r2 = t2.GetNext();
      return this._sourceAdapter.GetInterpolatedValue(e, t2, r2);
    }
    GetInterpolatedValueFast(e, t2, r2) {
      return this._sourceAdapter.GetInterpolatedValue(e, t2, r2);
    }
    AfterInterpolate() {
      this._sourceAdapter.AfterInterpolate();
    }
    static GetStartPropertyKeyframeForTime(e, t2) {
      const r2 = t2.GetPropertyTrackDataItem();
      return t2._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, r2);
    }
    static GetEndPropertyKeyframeForTime(e, t2) {
      const r2 = t2.GetPropertyTrackDataItem();
      return t2._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(e, r2);
    }
    AddPropertyKeyframe() {
      const e = this._propertyTrackDataItem.GetPropertyKeyframeData().AddEmptyPropertyKeyframeDataItem();
      return this._lastPropertyKeyframeDataItem = null, e;
    }
    DeletePropertyKeyframes(e) {
      this._lastPropertyKeyframeDataItem = null;
      this._propertyTrackDataItem.GetPropertyKeyframeData().DeletePropertyKeyframeDataItems(e);
    }
    SaveState() {
      this.GetSourceAdapter().SaveState();
    }
    CompareInitialStateWithCurrent() {
      if (this.GetSourceAdapter().CompareInitialStateWithCurrent()) {
        const e = this._propertyTrackData.GetFirstPropertyKeyframeDataItem(this._propertyTrackDataItem), t2 = this.GetSourceAdapter().GetCurrentState();
        e.SetAbsoluteValue(t2);
      }
    }
    CompareSaveStateWithCurrent() {
      const e = this.GetSourceAdapter().CompareSaveStateWithCurrent();
      return e && this.AddPropertyKeyframeAtCurrentTime(), this.GetSourceAdapter().ClearSaveState(), e;
    }
    AddPropertyKeyframeAtCurrentTime() {
      const e = this.GetTimeline().GetTime(), t2 = this.GetSourceAdapter(), r2 = C32.PropertyTrackState.GetStartPropertyKeyframeForTime(e, this), a2 = this.AddPropertyKeyframe();
      a2.SetType(r2.GetType()), a2.SetTime(e), a2.SetEase(r2.GetEase()), a2.SetEnable(true), a2.SetValue(t2.GetValueAtTime()), a2.SetAbsoluteValue(t2.GetCurrentState());
    }
    _SaveToJson() {
      return { "sourceAdapterJson": this.GetSourceAdapter()._SaveToJson() };
    }
    _LoadFromJson(e) {
      e && this.GetSourceAdapter()._LoadFromJson(e["sourceAdapterJson"]);
    }
  };
}
{
  const C32 = self.C3, NS = C32.PropertyTrackState;
  NS.PropertySourceAdapter = class {
    constructor(e) {
      this._propertyTrack = e, this._propertyAdapter = null, this.GetPropertyAdapter();
    }
    Release() {
      this._propertyAdapter && (this._propertyAdapter.Release(), this._propertyAdapter = null), this._propertyTrack = null;
    }
    MayNeedBeforeAndAfterInterpolate() {
      return this._propertyAdapter.MayNeedBeforeAndAfterInterpolate();
    }
    GetPropertyTrack() {
      return this._propertyTrack;
    }
    TimelineRemoved() {
      this._propertyAdapter && this._propertyAdapter.TimelineRemoved();
    }
    CleanCaches() {
      this._propertyAdapter && this._propertyAdapter.CleanCaches();
    }
    GetPropertyAdapter() {
      return this._propertyAdapter || (this._propertyAdapter = this._CreatePropertyAdapter()), this._propertyAdapter;
    }
    GetEditorIndex() {
    }
    GetIndex() {
      return this.GetEditorIndex();
    }
    GetTarget() {
    }
    SetResetState() {
      this.GetPropertyAdapter().SetResetState();
    }
    SetInitialState() {
      this.GetPropertyAdapter().SetInitialState();
    }
    SetResumeState() {
      this.GetPropertyAdapter().SetResumeState();
    }
    BeforeInterpolate() {
      this._propertyAdapter.BeforeChangeProperty();
    }
    Interpolate(e, t2, r2, p2, a2, o2, n) {
      let s;
      switch (this._propertyTrack.GetPropertyKeyframeType()) {
        case "numeric":
          s = NS.NumericTypeAdapter.Interpolate(e, t2, r2, this._propertyTrack);
          break;
        case "angle":
          s = NS.AngleTypeAdapter.Interpolate(e, t2, r2, this._propertyTrack);
          break;
        case "boolean":
          s = NS.BooleanTypeAdapter.Interpolate(e, t2, r2, this._propertyTrack);
          break;
        case "color":
          s = NS.ColorTypeAdapter.Interpolate(e, t2, r2, this._propertyTrack);
          break;
        case "text":
          s = NS.TextTypeAdapter.Interpolate(e, t2, r2, this._propertyTrack);
      }
      this._propertyAdapter.ChangeProperty(e, s, t2, r2, p2, a2, o2, n);
    }
    GetInterpolatedValue(e, t2, r2) {
      switch (this._propertyTrack.GetPropertyKeyframeType()) {
        case "numeric":
          return NS.NumericTypeAdapter.Interpolate(e, t2, r2, this._propertyTrack);
        case "angle":
          return NS.AngleTypeAdapter.Interpolate(e, t2, r2, this._propertyTrack);
        case "boolean":
          return NS.BooleanTypeAdapter.Interpolate(e, t2, r2, this._propertyTrack);
        case "color":
          return NS.ColorTypeAdapter.Interpolate(e, t2, r2, this._propertyTrack);
        case "text":
          return NS.TextTypeAdapter.Interpolate(e, t2, r2, this._propertyTrack);
      }
    }
    AfterInterpolate() {
      this._propertyAdapter.AfterChangeProperty();
    }
    SaveState() {
      this.GetPropertyAdapter().SetSaveState();
    }
    ClearSaveState() {
      this.GetPropertyAdapter().ClearSaveState();
    }
    GetCurrentState() {
      return this.GetPropertyAdapter().GetCurrentState();
    }
    CompareInitialStateWithCurrent() {
      return this.GetPropertyAdapter().CompareInitialStateWithCurrent();
    }
    CompareSaveStateWithCurrent() {
      return this.GetPropertyAdapter().CompareSaveStateWithCurrent();
    }
    GetValueAtTime() {
      const e = this._propertyTrack, t2 = e.GetTrack().GetTimeline().GetTime(), r2 = NS.GetStartPropertyKeyframeForTime(t2, e), p2 = r2.GetNext();
      switch (e.GetPropertyKeyframeType()) {
        case "numeric":
          return NS.NumericTypeAdapter.Interpolate(t2, r2, p2, e);
        case "angle":
          return NS.AngleTypeAdapter.Interpolate(t2, r2, p2, e);
        case "boolean":
          return NS.BooleanTypeAdapter.Interpolate(t2, r2, p2, e);
        case "color":
          return NS.ColorTypeAdapter.Interpolate(t2, r2, p2, e);
        case "text":
          return NS.TextTypeAdapter.Interpolate(t2, r2, p2, e);
      }
    }
    _CreatePropertyAdapter() {
      const e = this._propertyTrack;
      switch (e.CanHavePropertyKeyframes() ? e.GetPropertyKeyframeType() : "") {
        case "combo":
        case "boolean":
        case "text":
        case "string":
          return new NS.PropertyInterpolationAdapter.NoInterpolationAdapter(this);
        case "numeric":
        case "number":
        case "angle":
          return "combo" === this._propertyTrack.GetPropertyType() ? new NS.PropertyInterpolationAdapter.NoInterpolationAdapter(this) : new NS.PropertyInterpolationAdapter.NumericInterpolationAdapter(this);
        case "color":
        case "offsetColor":
          return new NS.PropertyInterpolationAdapter.ColorInterpolationAdapter(this);
        default:
          return new NS.PropertyInterpolationAdapter.NumericInterpolationAdapter(this);
      }
    }
    _SaveToJson() {
      return { "propertyAdapterJson": this.GetPropertyAdapter()._SaveToJson() };
    }
    _LoadFromJson(e) {
      e && this.GetPropertyAdapter()._LoadFromJson(e["propertyAdapterJson"]);
    }
  };
}
{
  const C32 = self.C3, INDEX = 0;
  class InstanceVariableSourceAdapter extends C32.PropertyTrackState.PropertySourceAdapter {
    constructor(e) {
      super(e), this._updatedIndex = NaN;
    }
    GetEditorIndex() {
      return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0];
    }
    GetIndex() {
      return this._updatedIndex ? this._updatedIndex : super.GetIndex();
    }
    GetTarget() {
      return this._propertyTrack.GetTrack().GetInstance();
    }
    UpdateInstanceVariableIndex(e) {
      this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0] !== e && (this._updatedIndex = e);
    }
    Interpolate(e, t2, r2, a2, n, d2, p2) {
      this.GetPropertyAdapter().CanChange(t2.GetValue()) && super.Interpolate(e, t2, r2, a2, n, d2, p2);
    }
    GetInterpolatedValue(e, t2, r2) {
      if (this.GetPropertyAdapter().CanChange(t2.GetValue())) return super.GetInterpolatedValue(e, t2, r2);
    }
    _SaveToJson() {
      return Object.assign(super._SaveToJson(), { "index": this._updatedIndex });
    }
    _LoadFromJson(e) {
      e && (super._LoadFromJson(e), this._updatedIndex = e["index"]);
    }
  }
  C32.PropertyTrackState.InstanceVariableSourceAdapter = InstanceVariableSourceAdapter;
}
{
  const C32 = self.C3, SID = 0, INDEX = 1, NAME = 2;
  class BehaviorSourceAdapter extends C32.PropertyTrackState.PropertySourceAdapter {
    constructor(e) {
      super(e), this._sid = NaN;
    }
    GetEditorIndex() {
      return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[1];
    }
    GetTarget() {
      const e = this._propertyTrack.GetPropertyTrackDataItem(), t2 = this._propertyTrack.GetTrack(), r2 = this._sid ? this._sid : e.GetSourceAdapterArguments()[0], a2 = t2.GetInstance(), s = a2.GetBehaviorIndexBySID(r2);
      return a2.GetBehaviorInstances()[s].GetSdkInstance();
    }
    GetBehaviorType(e) {
      const t2 = this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[2];
      return e.GetBehaviorTypeByName(t2);
    }
    UpdateBehaviorTypeSid(e) {
      this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0] !== e && (this._sid = e);
    }
    Interpolate(e, t2, r2, a2, s, o2, p2) {
      const c2 = this._propertyTrack.GetTrack().GetInstance();
      this.GetBehaviorType(c2.GetObjectClass()) && super.Interpolate(e, t2, r2, a2, s, o2, p2);
    }
    GetInterpolatedValue(e, t2, r2) {
      const a2 = this._propertyTrack.GetTrack().GetInstance();
      if (this.GetBehaviorType(a2.GetObjectClass())) return super.GetInterpolatedValue(e, t2, r2);
    }
    _SaveToJson() {
      return Object.assign(super._SaveToJson(), { "sid": this._sid });
    }
    _LoadFromJson(e) {
      e && (super._LoadFromJson(e), this._sid = e["sid"]);
    }
  }
  C32.PropertyTrackState.BehaviorSourceAdapter = BehaviorSourceAdapter;
}
{
  const C32 = self.C3, NAME = 0, INDEX = 1;
  class EffectSourceAdapter extends C32.PropertyTrackState.PropertySourceAdapter {
    constructor(e) {
      super(e);
    }
    GetEditorIndex() {
      return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[1];
    }
    GetTarget() {
      const e = this._propertyTrack.GetTrack().GetWorldInfo().GetInstanceEffectList(), t2 = e.GetEffectList(), r2 = this.GetEffectType(t2).GetIndex();
      return e.IsEffectIndexActive(r2) ? e.GetEffectParametersForIndex(r2) : null;
    }
    GetEffectType(e) {
      const t2 = this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0];
      return e.GetEffectTypeByName(t2);
    }
    Interpolate(e, t2, r2, c2, f2, a2, s) {
      this._IsEffectActive() && super.Interpolate(e, t2, r2, c2, f2, a2, s);
    }
    GetInterpolatedValue(e, t2, r2) {
      if (this._IsEffectActive()) return super.GetInterpolatedValue(e, t2, r2);
    }
    _IsEffectActive() {
      const e = this._propertyTrack.GetTrack().GetWorldInfo().GetInstanceEffectList(), t2 = e.GetEffectList(), r2 = this.GetEffectType(t2);
      if (!r2) return;
      const c2 = r2.GetIndex();
      return e.IsEffectIndexActive(c2);
    }
  }
  C32.PropertyTrackState.EffectSourceAdapter = EffectSourceAdapter;
}
{
  const C32 = self.C3, INDEX = 0;
  class PluginSourceAdapter extends C32.PropertyTrackState.PropertySourceAdapter {
    constructor(t2) {
      super(t2);
    }
    GetEditorIndex() {
      return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0];
    }
    GetTarget() {
      return this._propertyTrack.GetTrack().GetInstance().GetSdkInstance();
    }
    Interpolate(t2, e, r2, n, a2, i, s) {
      const c2 = this._propertyTrack.GetTrack();
      c2.GetObjectClass().GetPlugin() === c2.GetInstance().GetObjectClass().GetPlugin() && super.Interpolate(t2, e, r2, n, a2, i, s);
    }
    GetInterpolatedValue(t2, e, r2) {
      const n = this._propertyTrack.GetTrack();
      if (n.GetObjectClass().GetPlugin() === n.GetInstance().GetObjectClass().GetPlugin()) return super.GetInterpolatedValue(t2, e, r2);
    }
    GetOptionalCallbacks() {
      const t2 = this._propertyTrack.GetTrack(), e = t2.GetObjectClass().GetPlugin();
      if (C32.Plugins.Sprite && e instanceof C32.Plugins.Sprite && ("initial-frame" === this._propertyTrack.GetPropertyName() || "initial-animation" === this._propertyTrack.GetPropertyName())) switch (this._propertyTrack.GetResultMode()) {
        case "relative":
          return { onFrameChange: (e2, r2, n, a2, i) => {
            if (r2 !== a2) {
              const n2 = a2 / r2, i2 = t2.GetPropertyTrack("offsetWidth"), s = t2.GetPropertyTrack("offsetScaleX");
              if (i2 || s) {
                const c2 = i2?.GetSourceAdapter()?.GetPropertyAdapter(), o2 = s?.GetSourceAdapter()?.GetPropertyAdapter();
                if (e2.HasParent() && e2.GetTransformWithParentWidth()) o2 && o2.SetOriginalSizeProperty(a2), e2.SetWidth(this.GetNewWidth(a2, r2, e2, t2, c2, o2));
                else {
                  const r3 = a2 * ((e2._GetSceneGraphInfo()?._GetStartWidth() ?? this.GetInstanceOriginalWidth(e2, t2)) / this.GetInstanceOriginalWidth(e2, t2));
                  o2 && o2.SetOriginalSizeProperty(a2);
                  const i3 = c2?.GetChangeAccumulatorProperty() ?? 0, s2 = o2?.GetChangeAccumulatorProperty() ?? 0;
                  e2.SetWidth(r3 + (i3 + s2 * n2));
                }
              } else e2.SetWidth(e2.GetWidth() * n2);
            }
            if (n !== i) {
              const r3 = i / n, a3 = t2.GetPropertyTrack("offsetHeight"), s = t2.GetPropertyTrack("offsetScaleY");
              if (a3 || s) {
                const c2 = a3?.GetSourceAdapter()?.GetPropertyAdapter(), o2 = s?.GetSourceAdapter()?.GetPropertyAdapter();
                if (e2.HasParent() && e2.GetTransformWithParentHeight()) o2 && o2.SetOriginalSizeProperty(i), e2.SetHeight(this.GetNewHeight(i, n, e2, t2, c2, o2));
                else {
                  const n2 = i * ((e2._GetSceneGraphInfo()?._GetStartHeight() ?? this.GetInstanceOriginalHeight(e2, t2)) / this.GetInstanceOriginalHeight(e2, t2));
                  o2 && o2.SetOriginalSizeProperty(i);
                  const a4 = c2?.GetChangeAccumulatorProperty() ?? 0, s2 = o2?.GetChangeAccumulatorProperty() ?? 0;
                  e2.SetHeight(n2 + (a4 + s2 * r3));
                }
              } else e2.SetHeight(e2.GetHeight() * r3);
            }
          } };
        case "absolute":
          return null;
      }
    }
    GetLastPropertyKeyframeValue(t2, e, r2, n = 0) {
      const a2 = e.GetTimeline().GetTrackFromInstance(t2.GetInstance());
      if (!a2) return n;
      const i = a2.GetPropertyTrack(r2);
      if (!i) return n;
      const s = i.GetPropertyTrackDataItem().GetPropertyKeyframeData();
      if (!s) return n;
      const c2 = s.GetLastPropertyKeyframeDataItem();
      return c2 ? c2.GetValue() : n;
    }
    GetInstanceOriginalWidth(t2, e) {
      const r2 = e.GetTimeline().GetTrackFromInstance(t2.GetInstance());
      if (r2) return r2.GetOriginalWidth();
      const n = t2.GetInstance().GetSdkInstance();
      return n.IsOriginalSizeKnown() ? n.GetOriginalWidth() : t2._GetSceneGraphInfo()._GetStartWidth();
    }
    GetInstanceOriginalHeight(t2, e) {
      const r2 = e.GetTimeline().GetTrackFromInstance(t2.GetInstance());
      if (r2) return r2.GetOriginalHeight();
      const n = t2.GetInstance().GetSdkInstance();
      return n.IsOriginalSizeKnown() ? n.GetOriginalHeight() : t2._GetSceneGraphInfo()._GetStartHeight();
    }
    GetNewWidth(t2, e, r2, n, a2, i) {
      const s = r2._GetSceneGraphInfo()._GetStartWidth(), c2 = s / r2.GetParent()._GetSceneGraphInfo()._GetStartWidth();
      let o2 = 1;
      const G = i?.GetAbsoluteScaleXOffsetProperty() ?? 0;
      if (0 !== G) {
        const t3 = s / this.GetInstanceOriginalWidth(r2, n);
        o2 = (t3 + G) / (0 === t3 ? Number.EPSILON : t3);
      }
      const p2 = s * (t2 / e);
      let l = a2?.GetAbsoluteWidthOffsetProperty() ?? 0;
      l += p2 - s;
      const h2 = (s + l) / (0 === s ? Number.EPSILON : s);
      return r2.GetParent().GetWidth() * c2 * o2 * h2;
    }
    GetNewHeight(t2, e, r2, n, a2, i) {
      const s = r2._GetSceneGraphInfo()._GetStartHeight(), c2 = s / r2.GetParent()._GetSceneGraphInfo()._GetStartHeight();
      let o2 = 1;
      const G = i?.GetAbsoluteScaleYOffsetProperty() ?? 0;
      if (0 !== G) {
        const t3 = s / this.GetInstanceOriginalHeight(r2, n);
        o2 = (t3 + G) / (0 === t3 ? Number.EPSILON : t3);
      }
      const p2 = s * (t2 / e);
      let l = a2?.GetAbsoluteHeightOffsetProperty() ?? 0;
      l += p2 - s;
      const h2 = (s + l) / (0 === s ? Number.EPSILON : s);
      return r2.GetParent().GetHeight() * c2 * o2 * h2;
    }
  }
  C32.PropertyTrackState.PluginSourceAdapter = PluginSourceAdapter;
}
{
  const C32 = self.C3;
  class ValueSourceAdapter extends C32.PropertyTrackState.PropertySourceAdapter {
    constructor(t2) {
      super(t2), this._value = 0, this._init = false;
    }
    MayNeedBeforeAndAfterInterpolate() {
      return false;
    }
    SetInitialState() {
      const t2 = this._propertyTrack.GetPropertyTrackData();
      let e = this._propertyTrack.GetPropertyTrackDataItem();
      e = t2.GetFirstPropertyKeyframeDataItem(e), this._value = e.GetValueWithResultMode();
    }
    SetResumeState() {
    }
    GetValue() {
      return this._init || this._propertyTrack.Interpolate(0), this._value;
    }
    Interpolate(t2, e, r2, a2, i, o2, u2) {
      this._value = C32.PropertyTrackState.NumericTypeAdapter.Interpolate(t2, e, r2, this._propertyTrack), this._init = true;
    }
    SaveState() {
    }
    ClearSaveState() {
    }
    GetCurrentState() {
      return this._value;
    }
    CompareInitialStateWithCurrent() {
      return false;
    }
    CompareSaveStateWithCurrent() {
      return false;
    }
    _SaveToJson() {
      return { "value": this._value, "init": this._init };
    }
    _LoadFromJson(t2) {
      t2 && (this._value = t2["value"], this._init = !t2.hasOwnProperty("init") || t2["init"]);
    }
  }
  C32.PropertyTrackState.ValueSourceAdapter = ValueSourceAdapter;
}
{
  const C32 = self.C3, PROJECT_FILE = 0, PROJECT_FILE_NAME = 0, PROJECT_FILE_TYPE = 1, START_OFFSET = 1, AUDIO_DURATION = 2, AUDIO_TAG = 3;
  class AudioSourceAdapter extends C32.PropertyTrackState.PropertySourceAdapter {
    constructor(t2) {
      super(t2), this._audioPlaybackStarted = false, this._sdkInstance = null, this._actions = null, this._expressions = null, this._timeline = this._propertyTrack.GetTimeline(), this._track = this._propertyTrack.GetTrack(), this._sourceAdapterArgs = this._propertyTrack.GetSourceAdapterArgs(), this._fileArgs = this._sourceAdapterArgs[0], this._startOffsetTime = this._sourceAdapterArgs[1], this._sourceAdapterArgs[3] ? this._audioTag = this._sourceAdapterArgs[3] : this._audioTag = Math.random().toString(36).slice(2), this._pauseTime = NaN, this._pauseVolume = NaN, this._volume = NaN, this._audioSource = null, this._Initialize();
    }
    Release() {
      super.Release(), this._sdkInstance = null, this._actions = null, this._expressions = null, this._timeline = null, this._track = null, this._sourceAdapterArgs = null, this._fileArgs = null, this._audioSource = null;
    }
    _Initialize() {
      if (!self.C3.Plugins.Audio) return;
      const t2 = this._propertyTrack.GetRuntime().GetSingleGlobalObjectClassByCtor(self.C3.Plugins.Audio);
      t2 && (this._sdkInstance = t2.GetSingleGlobalInstance().GetSdkInstance()), this._actions = self.C3.Plugins.Audio.Acts, this._expressions = self.C3.Plugins.Audio.Exps;
    }
    _MaybeSetAudioSource() {
      if (this._audioSource) return;
      const t2 = this._propertyTrack.GetTrack().GetPropertyTrack("audioSource");
      t2 && (this._audioSource = t2.GetSourceAdapter());
    }
    _GetPauseVolume() {
      const t2 = this._propertyTrack.GetTrack().GetPropertyTrack("volume");
      return t2 ? t2.GetSourceAdapter()._pauseVolume : this._pauseVolume;
    }
    TimelineRemoved() {
      super.TimelineRemoved(), this._audioPlaybackStarted = false, this._sdkInstance && (this._expressions && (this._pauseTime = this._expressions.PlaybackTime.call(this._sdkInstance, this._audioTag), this._pauseVolume = this._expressions.Volume.call(this._sdkInstance, this._audioTag)), this._actions && this._actions.Stop.call(this._sdkInstance, this._audioTag));
    }
    GetAudioTag() {
      return this._audioTag;
    }
    GetVolume() {
      return this._volume;
    }
    SetVolume(t2) {
      this._volume = t2;
    }
    SetInitialState() {
      super.SetInitialState(), this._pauseTime = NaN, this._audioPlaybackStarted = false;
    }
    SetResumeState() {
      super.SetResumeState();
      const t2 = this._propertyTrack.GetTimeline().GetTime();
      switch (this._pauseTime = t2 - this._startOffsetTime, this._propertyTrack.GetPropertyName()) {
        case "audioSource":
          break;
        case "volume":
          this._pauseVolume = this._propertyTrack.GetInterpolatedValue(t2);
      }
      this._audioPlaybackStarted = false;
    }
    Interpolate(t2, e, s, i, a2, o2, r2) {
      if (this._sdkInstance) switch (this._propertyTrack.GetPropertyName()) {
        case "audioSource": {
          if (!this._timeline.IsForwardPlayBack()) return;
          if (i) return void (this._actions && this._actions.Stop.call(this._sdkInstance, this._audioTag));
          if (t2 < this._startOffsetTime) return void (this._audioPlaybackStarted = false);
          const e2 = this._expressions.PlaybackRate.call(this._sdkInstance, this._audioTag), s2 = this._timeline.GetPlaybackRate();
          if (s2 !== e2 && this._actions.SetPlaybackRate.call(this._sdkInstance, this._audioTag, s2), this._audioPlaybackStarted) return;
          if (!this._propertyTrack.GetTimeline().IsPlaying()) return;
          if (this._audioPlaybackStarted = true, isNaN(this._pauseTime)) {
            const e3 = self["performance"].now(), s3 = t2 - this._startOffsetTime;
            if ("suspended" === this._sdkInstance.GetAudioContextState()) return void (this._audioPlaybackStarted = false);
            const i2 = s3 + (self["performance"].now() - e3) / 1e3;
            if (this._actions) {
              let t3 = this.GetVolume();
              isNaN(t3) ? (this.SetVolume(0), t3 = 0) : this.SetVolume(t3), this._actions.PlayFromTimeline.call(this._sdkInstance, this._fileArgs, t3, this._audioTag, i2);
            }
          } else {
            const t3 = this._pauseTime;
            this._pauseTime = NaN;
            const e3 = this._GetPauseVolume();
            this._pauseVolume = NaN;
            if ("suspended" === this._sdkInstance.GetAudioContextState()) return void (this._audioPlaybackStarted = false);
            this._actions && (this.SetVolume(e3), this._actions.PlayFromTimeline.call(this._sdkInstance, this._fileArgs, e3, this._audioTag, t3));
          }
          break;
        }
        case "volume":
          this._MaybeSetAudioSource(), super.Interpolate(t2, e, s, i, a2, o2, r2);
      }
    }
    GetInterpolatedValue(t2, e, s) {
      if (this._sdkInstance) switch (this._propertyTrack.GetPropertyName()) {
        case "audioSource":
          return;
        case "volume":
          return this._MaybeSetAudioSource(), super.GetInterpolatedValue(t2, e, s);
      }
    }
    Getter(t2, e) {
      return this._audioSource ? this._audioSource.GetVolume() : 0;
    }
    Setter(t2, e, s, i) {
      this._audioSource && this._audioSource.SetVolume(this.Getter() + e), this._actions && this._audioSource && this._actions.SetVolume.call(this._sdkInstance, this._audioSource.GetAudioTag(), this._audioSource.GetVolume());
    }
    AbsoluteSetter(t2, e, s) {
      this._audioSource && this._audioSource.SetVolume(e), this._actions && this._audioSource && this._actions.SetVolume.call(this._sdkInstance, this._audioSource.GetAudioTag(), this._audioSource.GetVolume());
    }
    DoesRounding() {
      return true;
    }
    _SaveToJson() {
      return { "audioPlaybackStarted": this._audioPlaybackStarted, "audioTag": this._audioTag, "pauseTime": this._pauseTime, "pauseVolume": this._pauseVolume, "volume": this._volume };
    }
    _LoadFromJson(t2) {
      t2 && (this._audioPlaybackStarted = t2["audioPlaybackStarted"], this._audioTag = t2["audioTag"], this._pauseTime = t2["pauseTime"], this._pauseVolume = t2["pauseVolume"], this._volume = t2["volume"], this._Initialize());
    }
  }
  C32.PropertyTrackState.AudioSourceAdapter = AudioSourceAdapter;
}
{
  const C32 = self.C3;
  C32.PropertyTrackState.PropertyInterpolationAdapter = class {
    constructor(t2) {
      this._sourceAdapter = t2, this._propertyTrack = t2.GetPropertyTrack(), this._worldInfo = this._propertyTrack.GetTrack().GetWorldInfo(), this._property = this._propertyTrack.GetPropertyName(), this._firstAbsoluteUpdate = false, this._saveState = null, this._target = null;
    }
    Release() {
      this._sourceAdapter = null, this._propertyTrack = null, this._worldInfo = null, this._saveState = null, this._target = null;
    }
    MayNeedBeforeAndAfterInterpolate() {
      return false;
    }
    TimelineRemoved() {
    }
    CleanCaches() {
      this._worldInfo = null, this._saveState = null, this._target = null;
    }
    GetSourceAdapter() {
      return this._sourceAdapter;
    }
    GetPropertyTrack() {
      return this._propertyTrack;
    }
    GetWorldInfo() {
      return this._worldInfo || (this._worldInfo = this._propertyTrack.GetTrack().GetWorldInfo()), this._worldInfo;
    }
    SetFirstAbsoluteUpdate(t2) {
      this._firstAbsoluteUpdate = !!t2;
    }
    GetFirstAbsoluteUpdate() {
      return this._firstAbsoluteUpdate;
    }
    SetResetState() {
    }
    SetInitialState() {
    }
    SetResumeState() {
    }
    SetSaveState() {
      this._saveState = this.GetCurrentState();
    }
    ClearSaveState() {
      this._saveState = null;
    }
    GetCurrentState() {
    }
    CompareInitialStateWithCurrent() {
    }
    CompareSaveStateWithCurrent() {
    }
    CanChange(t2) {
      return typeof this._Getter() === typeof t2;
    }
    BeforeChangeProperty() {
    }
    ChangeProperty(t2, e, r2, a2, s, o2, i, n) {
    }
    AfterChangeProperty() {
    }
    _FirstKeyframeGetter() {
      return this._PickTimelinePlaybackMode(() => {
        const t2 = this._propertyTrack.GetPropertyTrackDataItem();
        return this._propertyTrack.GetPropertyTrackData().GetFirstPropertyKeyframeDataItem(t2);
      }, () => {
        const t2 = this._propertyTrack.GetPropertyTrackDataItem();
        return this._propertyTrack.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(t2);
      }).GetAbsoluteValue();
    }
    _CurrentKeyframeGetter() {
      const t2 = this._propertyTrack.GetTimeline().GetTime() - this._propertyTrack.GetTrack().GetStartOffset();
      return this._PickTimelinePlaybackMode(() => {
        const e = this._propertyTrack.GetPropertyTrackDataItem();
        return this._propertyTrack.GetPropertyTrackData().GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(t2, e);
      }, () => {
        const e = this._propertyTrack.GetPropertyTrackDataItem(), r2 = this._propertyTrack.GetPropertyTrackData(), a2 = r2.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(t2, e);
        return a2 || r2.GetLastPropertyKeyframeDataItem(e);
      }).GetAbsoluteValue();
    }
    _PickTimelinePlaybackMode(t2, e) {
      return this._propertyTrack.GetTimeline().IsForwardPlayBack() ? t2() : e();
    }
    _PickResultMode(t2, e) {
      return "relative" === this._propertyTrack.GetResultMode() ? t2() : e();
    }
    _PickFirstAbsoluteUpdate(t2, e) {
      return this.GetFirstAbsoluteUpdate() ? (this.SetFirstAbsoluteUpdate(false), t2()) : e();
    }
    _GetAbsoluteInitialValue(t2) {
    }
    _GetIndex() {
      return this._sourceAdapter.GetIndex();
    }
    _GetTarget() {
      return this._target || (this._target = this._sourceAdapter.GetTarget()), this._target;
    }
    _PickSource(t2, e, r2, a2, s, o2) {
      switch (this._propertyTrack.GetSourceAdapterId()) {
        case "behavior":
          return t2();
        case "effect":
          return e();
        case "instance-variable":
          return r2();
        case "plugin":
          return a2();
        case "world-instance":
          return s();
        case "audio":
          return o2();
      }
    }
    _SaveToJson() {
      return { "firstAbsoluteUpdate": this._firstAbsoluteUpdate, "saveState": this._saveState };
    }
    _LoadFromJson(t2) {
      t2 && (this._firstAbsoluteUpdate = t2["firstAbsoluteUpdate"], this._saveState = t2["saveState"]);
    }
    _GetPropertyKeyframeStubs(t2, e = false) {
      const r2 = [];
      for (const a2 of t2) {
        const t3 = a2.GetTrack().GetStartOffset();
        for (const s of a2.GetPropertyKeyframeDataItems()) e && 0 === s.GetTime() ? r2.push({ time: t3 + s.GetTime(), value: s.GetAbsoluteValue() }) : e || r2.push({ time: t3 + s.GetTime(), value: s.GetAbsoluteValue() });
      }
      return r2.sort((t3, e2) => t3.time - e2.time);
    }
    _GetLastPropertyKeyframeStub(t2, e, r2) {
      return this._GetPropertyKeyframeStubLowerThanPlayhead(e, r2);
    }
    _GetPropertyKeyframeStubLowerThanPlayhead(t2, e) {
      for (let r2 = e.length - 1; r2 >= 0; r2--) {
        if (e[r2].time <= t2) return e[r2];
      }
      return null;
    }
  };
}
{
  const C32 = self.C3, TMP_COLORS_MAP = /* @__PURE__ */ new Map(), TMP_COLOR = [0, 0, 0];
  class ColorInterpolationAdapter extends C32.PropertyTrackState.PropertyInterpolationAdapter {
    constructor(e) {
      super(e);
    }
    SetResetState() {
    }
    SetInitialState() {
    }
    SetResumeState() {
    }
    GetCurrentState() {
      const e = this._propertyTrack.GetSourceAdapterId(), t2 = this._GetTarget(), r2 = this._GetIndex();
      switch (e) {
        case "behavior":
        case "plugin":
          return this._ToColorArray(t2.GetPropertyValueByIndex(r2));
        case "effect":
          return this._ToColorArray(t2[r2]);
        case "world-instance":
          return this._ToColorArray(this._Getter());
      }
    }
    CompareInitialStateWithCurrent() {
      const e = this._FirstKeyframeGetter();
      return !this._CompareColors(e, this._Getter());
    }
    CompareSaveStateWithCurrent() {
      return !C32.IsNullOrUndefined(this._saveState) && !this._CompareColors(this._saveState, this._Getter());
    }
    _CompareColors(e, t2) {
      return e = this._GetColorFromArray(e), t2 = this._GetColorFromArray(t2), e.equalsIgnoringAlpha(t2);
    }
    _FirstKeyframeGetter() {
      const e = super._FirstKeyframeGetter();
      return this._GetColorFromArray(e);
    }
    _CurrentKeyframeGetter() {
      const e = super._CurrentKeyframeGetter();
      return this._GetColorFromArray(e);
    }
    _GetAbsoluteInitialValue(e) {
    }
    _ToColorArray(e) {
      return C32.IsInstanceOf(e, C32.Color) ? e.toArray().slice(0, 3) : e.slice(0, 3);
    }
    _GetColorFromArray(e) {
      return C32.IsInstanceOf(e, C32.Color) ? e : new C32.Color(e[0], e[1], e[2], 1);
    }
    CanChange(e) {
      return true;
    }
    MayNeedBeforeAndAfterInterpolate() {
      return true;
    }
    BeforeChangeProperty() {
      const e = this._propertyTrack.GetTimeline(), t2 = this._propertyTrack.GetInstance(), r2 = this._propertyTrack.GetSourceAdapter(), o2 = e.GetSimilarPropertyTracks(t2, r2, this._property, this._propertyTrack);
      if (o2 && o2.length > 1) {
        TMP_COLORS_MAP.has(t2) || TMP_COLORS_MAP.set(t2, /* @__PURE__ */ new Map());
        const e2 = TMP_COLORS_MAP.get(t2), r3 = this._propertyTrack.GetSourceAdapterId();
        e2.has(r3) || e2.set(r3, /* @__PURE__ */ new Map());
        const o3 = e2.get(r3);
        o3.has(this._property) || o3.set(this._property, { used: false, color: new C32.Color(0, 0, 0, 1) });
      }
    }
    _GetTmpColor(e, t2, r2) {
      const o2 = TMP_COLORS_MAP.get(e).get(t2).get(r2);
      return o2.used = true, o2.color;
    }
    ChangeProperty(e, t2, r2, o2, s, a2, n, i) {
      const p2 = this._propertyTrack.GetTimeline(), _2 = this._propertyTrack.GetTrack(), c2 = this._propertyTrack.GetInstance(), l = this._propertyTrack.GetSourceAdapter(), h2 = this._propertyTrack.GetSourceAdapterId(), C2 = this._property, y2 = p2.GetSimilarPropertyTracks(c2, l, C2, this._propertyTrack);
      if (y2 && y2.length > 1) {
        const e2 = this._GetPropertyKeyframeStubs(y2, true), r3 = this._GetLastPropertyKeyframeStub(p2, p2.GetTime(), e2);
        if (r3) {
          const e3 = _2.GetStartOffset(), o3 = r3.time - e3;
          if (0 === o3) this._GetTmpColor(c2, h2, this._property).addRgb(t2[0], t2[1], t2[2]);
          else {
            if (o3 < 0) return;
            const e4 = t2[0], r4 = t2[1], s2 = t2[2], a3 = this._propertyTrack.Interpolate(o3, false, true), n2 = C32.Color.DiffChannel(e4, a3[0]), i2 = C32.Color.DiffChannel(r4, a3[1]), p3 = C32.Color.DiffChannel(s2, a3[2]);
            this._GetTmpColor(c2, h2, this._property).addRgb(n2, i2, p3);
          }
        }
      } else this._Setter(t2[0], t2[1], t2[2]);
    }
    AfterChangeProperty() {
      const e = this._propertyTrack.GetInstance();
      if (!TMP_COLORS_MAP.has(e)) return;
      const t2 = TMP_COLORS_MAP.get(e), r2 = this._propertyTrack.GetSourceAdapterId();
      if (!t2.has(r2)) return;
      const o2 = t2.get(r2);
      if (!o2.has(this._property)) return;
      const s = o2.get(this._property), a2 = s.used, n = s.color;
      a2 && this._Setter(n.getR(), n.getG(), n.getB()), 0 === o2.size && t2.delete(r2), 0 === t2.size && TMP_COLORS_MAP.delete(e);
    }
    _Getter() {
      const e = this._propertyTrack.GetSourceAdapterId(), t2 = this._GetTarget(), r2 = this._GetIndex();
      switch (e) {
        case "behavior":
        case "plugin":
          return this._GetColorFromArray(t2.GetPropertyValueByIndex(r2));
        case "effect":
          return t2[r2].clone();
        case "world-instance":
          return this.GetWorldInfo().GetUnpremultipliedColor().clone();
      }
    }
    _Setter(e, t2, r2) {
      const o2 = this._propertyTrack.GetSourceAdapterId(), s = this._GetTarget(), a2 = this._GetIndex();
      switch (o2) {
        case "behavior":
        case "plugin":
          TMP_COLOR[0] = e, TMP_COLOR[1] = t2, TMP_COLOR[2] = r2, s.SetPropertyValueByIndex(a2, TMP_COLOR);
          break;
        case "effect":
          s[a2].setRgb(e, t2, r2);
          break;
        case "world-instance":
          this.GetWorldInfo().SetUnpremultipliedColorRGB(e, t2, r2);
      }
    }
    _SaveToJson() {
    }
    _LoadFromJson(e) {
    }
  }
  C32.PropertyTrackState.PropertyInterpolationAdapter.ColorInterpolationAdapter = ColorInterpolationAdapter;
}
{
  const C32 = self.C3, NS = C32.PropertyTrackState;
  class NoInterpolationAdapter extends C32.PropertyTrackState.PropertyInterpolationAdapter {
    constructor(e) {
      super(e);
    }
    SetResetState() {
    }
    SetInitialState() {
    }
    SetResumeState() {
    }
    GetCurrentState() {
      return this._Getter();
    }
    CompareInitialStateWithCurrent() {
      return this._FirstKeyframeGetter() !== this.GetCurrentState();
    }
    CompareSaveStateWithCurrent() {
      return !C32.IsNullOrUndefined(this._saveState) && this._saveState !== this.GetCurrentState();
    }
    MayNeedBeforeAndAfterInterpolate() {
      return false;
    }
    ChangeProperty(e, t2, r2, a2, n, i, s, o2) {
      const p2 = this._propertyTrack, c2 = p2.GetTrack(), l = p2.GetSourceAdapterId(), h2 = p2.GetTimeline(), u2 = c2.GetInstance(), S2 = p2.GetSourceAdapter(), G = this._property, d2 = h2.GetSimilarPropertyTracks(u2, S2, G, p2);
      if (d2 && d2.length > 1) {
        const r3 = this._GetPropertyKeyframeStubs(d2), a3 = e + c2.GetStartOffset(), n2 = this._GetLastPropertyKeyframeStub(h2, a3, r3);
        n2 && (t2 = n2.value);
      }
      switch (p2.GetPropertyKeyframeType()) {
        case "numeric":
          if (!NS.NumericTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), t2, l)) return;
          break;
        case "angle":
          if (!NS.AngleTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), t2, l)) return;
          break;
        case "boolean":
          if (!NS.BooleanTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), t2, l)) return;
          break;
        case "color":
          if (!NS.ColorTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), t2, l)) return;
          break;
        case "text":
          if (!NS.TextTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), t2, l)) return;
      }
      this._Setter(t2);
    }
    _Getter() {
      const e = this._propertyTrack.GetSourceAdapterId(), t2 = this._GetTarget(), r2 = this._GetIndex();
      switch (e) {
        case "behavior":
        case "plugin":
          return t2.GetPropertyValueByIndex(r2);
        case "effect":
          return t2[r2];
        case "instance-variable":
          return t2.GetInstanceVariableValue(r2);
      }
    }
    _Setter(e) {
      const t2 = this._propertyTrack.GetSourceAdapterId(), r2 = this._GetTarget(), a2 = this._GetIndex();
      switch (t2) {
        case "behavior":
        case "plugin":
          r2.SetPropertyValueByIndex(a2, e);
          break;
        case "effect":
          r2[a2] = e;
          break;
        case "instance-variable":
          r2.SetInstanceVariableValue(a2, e);
      }
    }
  }
  C32.PropertyTrackState.PropertyInterpolationAdapter.NoInterpolationAdapter = NoInterpolationAdapter;
}
{
  const C32 = self.C3, NS = C32.PropertyTrackState.PropertyInterpolationAdapter, INSTANCE_FUNC_MAP = /* @__PURE__ */ new Map(), add = (t2, e, a2, r2, i, s = false, o2 = null, n = null) => {
    INSTANCE_FUNC_MAP.set(t2, { setter: e, absolute_setter: a2, getter: r2, round: i, fRound: s, init: o2, reset: n });
  }, get_original_size = (t2, e) => {
    const a2 = e.GetTimeline().GetTrackFromInstance(t2.GetInstance());
    if (a2) return a2.GetOriginalWidth();
    const r2 = t2.GetInstance().GetSdkInstance();
    return r2.IsOriginalSizeKnown() ? r2.GetOriginalWidth() : t2._GetSceneGraphInfo()._GetStartWidth();
  }, get_last_property_keyframe_value = (t2, e, a2, r2 = 0) => {
    const i = e.GetTimeline().GetTrackFromInstance(t2.GetInstance());
    if (!i) return r2;
    const s = i.GetPropertyTrack(a2);
    if (!s) return r2;
    const o2 = s.GetPropertyTrackDataItem().GetPropertyKeyframeData();
    if (!o2) return r2;
    const n = o2.GetLastPropertyKeyframeDataItem();
    return n ? n.GetValue() : r2;
  }, get_parents = (t2) => {
    const e = [];
    let a2 = t2.GetParent();
    for (; a2; ) e.push(a2), a2 = a2.GetParent();
    return e.reverse(), e;
  };
  add("offsetX", (t2, e, a2, r2) => {
    "relative" === r2._propertyTrack.GetResultMode() ? t2.OffsetX(e, a2.GetTimeline().GetTransformWithSceneGraph()) : t2.OffsetX(e);
  }, (t2, e) => t2.SetX(e), (t2) => t2.GetX(), true), add("offsetY", (t2, e, a2, r2) => {
    "relative" === r2._propertyTrack.GetResultMode() ? t2.OffsetY(e, a2.GetTimeline().GetTransformWithSceneGraph()) : t2.OffsetY(e);
  }, (t2, e) => t2.SetY(e), (t2) => t2.GetY(), true), add("offsetWidth", (t2, e, a2, r2, i = false, s = true) => {
    if (0 === e) return;
    const o2 = "relative" === r2._propertyTrack.GetResultMode(), n = 1 === r2._typeAdapter.GetType();
    if ((o2 || n) && t2.HasParent() && t2.GetTransformWithParentWidth()) {
      if (isNaN(r2._absoluteToFactor)) {
        const e2 = get_parents(t2);
        let a4;
        if (n) {
          a4 = e2[e2.length - 1].GetWidth();
        } else {
          a4 = e2[e2.length - 1]._GetSceneGraphInfo()._GetStartWidth();
        }
        r2._absoluteToFactor = 0 === a4 ? Number.EPSILON : a4;
      }
      if (i) return;
      r2._absoluteWidthOffset += e;
      const a3 = e / r2._absoluteToFactor;
      t2.OffsetWidth(a3, s), r2._changeAccumulator += a3;
    } else t2.OffsetWidth(e), r2._changeAccumulator += e;
  }, (t2, e) => t2.SetWidth(e), (t2) => t2.GetWidth(), true, false, null, (t2) => {
    t2._changeAccumulator = 0, t2._absoluteWidthOffset = 0;
  }), add("offsetHeight", (t2, e, a2, r2, i = false, s = true) => {
    if (0 === e) return;
    const o2 = "relative" === r2._propertyTrack.GetResultMode(), n = 1 === r2._typeAdapter.GetType();
    if ((o2 || n) && t2.HasParent() && t2.GetTransformWithParentHeight()) {
      if (isNaN(r2._absoluteToFactor)) {
        const e2 = get_parents(t2);
        let a4;
        if (n) {
          a4 = e2[e2.length - 1].GetHeight();
        } else {
          a4 = e2[e2.length - 1]._GetSceneGraphInfo()._GetStartHeight();
        }
        r2._absoluteToFactor = 0 === a4 ? Number.EPSILON : a4;
      }
      if (i) return;
      r2._absoluteHeightOffset += e;
      const a3 = e / r2._absoluteToFactor;
      t2.OffsetHeight(a3, s), r2._changeAccumulator += a3;
    } else t2.OffsetHeight(e), r2._changeAccumulator += e;
  }, (t2, e) => t2.SetHeight(e), (t2) => t2.GetHeight(), true, false, null, (t2) => {
    t2._changeAccumulator = 0, t2._absoluteHeightOffset = 0;
  }), add("offsetAngle", (t2, e, a2, r2, i) => {
    t2.OffsetAngle(e);
  }, (t2, e) => t2.SetAngle(e), (t2) => t2.GetAngle(), false, true), add("offsetOpacity", (t2, e, a2, r2, i) => {
    e /= r2._opacityFactor ? r2._opacityFactor : 1;
    const s = t2.GetOpacity() + e;
    if (0 === r2._clampAccumulator) s > 1 ? r2._clampAccumulator += s - 1 : s < 0 && (r2._clampAccumulator += s), t2.OffsetOpacity(e);
    else {
      const a3 = t2.GetOpacity() + e;
      e > 0 && r2._clampAccumulator > 0 ? a3 > 1 && (r2._clampAccumulator += a3 - 1) : e > 0 && r2._clampAccumulator < 0 ? (r2._clampAccumulator += e, r2._clampAccumulator > 0 && (t2.OffsetOpacity(r2._clampAccumulator), r2._clampAccumulator = 0)) : e < 0 && r2._clampAccumulator > 0 ? (r2._clampAccumulator += e, r2._clampAccumulator < 0 && (t2.OffsetOpacity(r2._clampAccumulator), r2._clampAccumulator = 0)) : e < 0 && r2._clampAccumulator < 0 && a3 < 0 && (r2._clampAccumulator += a3);
    }
  }, (t2, e) => {
    t2.SetOpacity(e);
  }, (t2) => t2.GetOpacity(), false, true, (t2, e, a2) => {
    switch (t2._clampAccumulator = 0, t2._propertyTrack.GetResultMode()) {
      case "relative": {
        t2._propertyTrack.GetPropertyTrackData();
        const e2 = t2._propertyTrack.GetPropertyTrackDataItem().GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray();
        let a3 = t2.GetWorldInfo().GetOpacity(), r3 = a3;
        for (const i2 of e2) {
          const e3 = i2.GetTime();
          r3 = a3 + t2._propertyTrack.GetInterpolatedValue(e3), r3 = C32.clamp(r3, 0, 1);
        }
        t2._totalForewardOpacityDelta = a3 - r3, t2._totalForewardOpacityDelta = Math.round(100 * (t2._totalForewardOpacityDelta + Number.EPSILON)) / 100, r3 = a3;
        for (let a4 = e2.length - 1; a4 >= 0; a4--) {
          const i2 = e2[a4].GetTime();
          r3 -= t2._propertyTrack.GetInterpolatedValue(i2), r3 = C32.clamp(r3, 0, 1);
        }
        t2._totalBackwardOpacityDelta = r3, t2._totalBackwardOpacityDelta = Math.round(100 * (t2._totalBackwardOpacityDelta + Number.EPSILON)) / 100;
        break;
      }
    }
    const r2 = "relative" === t2._propertyTrack.GetResultMode(), i = 1 === t2._typeAdapter.GetType();
    if ((r2 || i) && e.HasParent() && e.GetTransformWithParentOpacity()) {
      const r3 = get_parents(e);
      let i2 = r3[0]._GetSceneGraphInfo().GetStartOpacity();
      i2 += get_last_property_keyframe_value(r3[0], a2, "offsetOpacity");
      for (let t3 = 1; t3 < r3.length; t3++) i2 += get_last_property_keyframe_value(r3[t3], a2, "offsetOpacity");
      t2._opacityFactor = 0 === i2 ? 1 : i2;
    }
  }, (t2) => {
    switch (t2._propertyTrack.GetResultMode()) {
      case "relative": {
        t2._clampAccumulator = 0;
        const e = t2.GetWorldInfo();
        let a2 = e.GetOpacity();
        a2 = Math.round(100 * (a2 + Number.EPSILON)) / 100, t2._propertyTrack.GetTimeline().IsForwardPlayBack() ? (e.SetOpacity(a2 + t2._totalForewardOpacityDelta), t2._lastValue = 0) : (e.SetOpacity(a2 - t2._totalBackwardOpacityDelta), t2._lastValue = t2.GetSourceAdapter().GetValueAtTime());
        break;
      }
    }
  }), add("offsetOriginX", (t2, e) => t2.OffsetOriginX(e), (t2, e) => t2.SetOriginX(e), (t2) => t2.GetOriginX(), false), add("offsetOriginY", (t2, e) => t2.OffsetOriginY(e), (t2, e) => t2.SetOriginY(e), (t2) => t2.GetOriginY(), false), add("offsetZElevation", (t2, e) => t2.OffsetZElevation(e), (t2, e) => t2.SetZElevation(e), (t2) => t2.GetZElevation(), true), add("offsetScaleX", (t2, e, a2, r2) => {
    if (0 === e) return;
    const i = t2.GetWidth() < 0 ? -1 : 1;
    if (r2._absoluteScaleXOffset += e, "relative" === r2._propertyTrack.GetResultMode() && t2.HasParent() && t2.GetTransformWithParentWidth()) {
      const s = get_last_property_keyframe_value(t2, a2, "offsetWidth"), o2 = isNaN(r2._originalSize) ? a2.GetOriginalWidth() : r2._originalSize, n = (o2 + s / (t2._GetSceneGraphInfo()._GetStartWidth() / o2)) * i * e;
      isNaN(r2._absoluteToFactor) && INSTANCE_FUNC_MAP.get("offsetWidth").setter(t2, 1, a2, r2, true);
      const l = n / r2._absoluteToFactor;
      t2.OffsetWidth(l, true), r2._changeAccumulator += l;
    } else {
      const s = (isNaN(r2._originalSize) ? a2.GetOriginalWidth() : r2._originalSize) * i * e;
      t2.OffsetWidth(s), r2._changeAccumulator += s;
    }
  }, (t2, e, a2) => {
    t2.SetWidth(a2.GetOriginalWidth() * e);
  }, (t2, e) => {
    const a2 = t2.GetWidth() < 0 ? -1 : 1;
    if (t2.GetTransformWithParentWidth()) {
      const r2 = t2.GetParent(), i = e.GetTimeline().GetTrackFromInstance(r2.GetInstance());
      let s = NaN;
      if (i) s = r2.GetWidth() / i.GetOriginalWidth();
      else {
        const t3 = r2.GetInstance().GetSdkInstance();
        s = t3.IsOriginalSizeKnown() ? r2.GetWidth() / t3.GetOriginalWidth() : 1;
      }
      return t2.GetWidth() * a2 / (e.GetOriginalWidth() * s);
    }
    return t2.GetWidth() * a2 / e.GetOriginalWidth();
  }, false, false, null, (t2) => {
    t2._changeAccumulator = 0, t2._originalSize = NaN, t2._absoluteScaleXOffset = 0;
  }), add("offsetScaleY", (t2, e, a2, r2) => {
    if (0 === e) return;
    const i = t2.GetHeight() < 0 ? -1 : 1;
    if (r2._absoluteScaleYOffset += e, "relative" === r2._propertyTrack.GetResultMode() && t2.HasParent() && t2.GetTransformWithParentHeight()) {
      const s = get_last_property_keyframe_value(t2, a2, "offsetHeight"), o2 = isNaN(r2._originalSize) ? a2.GetOriginalHeight() : r2._originalSize, n = (o2 + s / (t2._GetSceneGraphInfo()._GetStartHeight() / o2)) * i * e;
      isNaN(r2._absoluteToFactor) && INSTANCE_FUNC_MAP.get("offsetHeight").setter(t2, 1, a2, r2, true);
      const l = n / r2._absoluteToFactor;
      t2.OffsetHeight(l, true), r2._changeAccumulator += l;
    } else {
      const s = (isNaN(r2._originalSize) ? a2.GetOriginalHeight() : r2._originalSize) * i * e;
      t2.OffsetHeight(s), r2._changeAccumulator += s;
    }
  }, (t2, e, a2) => {
    t2.SetHeight(a2.GetOriginalHeight() * e);
  }, (t2, e) => {
    const a2 = t2.GetHeight() < 0 ? -1 : 1;
    if (t2.GetTransformWithParentHeight()) {
      const r2 = t2.GetParent(), i = e.GetTimeline().GetTrackFromInstance(r2.GetInstance());
      let s = NaN;
      if (i) s = r2.GetHeight() / i.GetOriginalHeight();
      else {
        const t3 = r2.GetInstance().GetSdkInstance();
        s = t3.IsOriginalSizeKnown() ? r2.GetHeight() / t3.GetOriginalHeight() : 1;
      }
      return t2.GetHeight() * a2 / (e.GetOriginalHeight() * s);
    }
    return t2.GetHeight() * a2 / e.GetOriginalHeight();
  }, false, false, null, (t2) => {
    t2._changeAccumulator = 0, t2._originalSize = NaN, t2._absoluteScaleYOffset = 0;
  });
  class NumericInterpolationAdapter extends C32.PropertyTrackState.PropertyInterpolationAdapter {
    constructor(t2) {
      super(t2), this._lastValue = 0, this._clampAccumulator = 0, this._totalForewardOpacityDelta = 0, this._totalBackwardOpacityDelta = 0, this._opacityFactor = NaN, this._absoluteToFactor = NaN, this._changeAccumulator = 0, this._originalSize = NaN, this._absoluteWidthOffset = 0, this._absoluteScaleXOffset = 0, this._absoluteHeightOffset = 0, this._absoluteScaleYOffset = 0, this._angleReflectMirrorOrFlip = void 0, this._angleReflectMirrorAndFlip = void 0, this._instance_getter = null, this._instance_setter = null, this._instance_absolute_setter = null, this._reset_action = null, this._init_action = null, this._source_adapter_getter = null, this._source_adapter_setter = null, this._source_adapter_absolute_setter = null, this._round = false, this._fRound = false, C32.IsInstanceOf(this._propertyTrack.GetTimeline(), C32.TweenState) ? this._typeAdapter = new C32.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTween(this) : this._typeAdapter = new C32.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTimeline(this);
      const e = this._propertyTrack.GetPropertyName();
      switch (this._propertyTrack.GetSourceAdapterId()) {
        case "world-instance": {
          const t3 = INSTANCE_FUNC_MAP.get(e);
          this._instance_getter = t3.getter, this._instance_setter = t3.setter, this._instance_absolute_setter = t3.absolute_setter, this._round = t3.round, this._fRound = t3.fRound, this._init_action = t3.init, this._reset_action = t3.reset;
          break;
        }
        case "audio":
          this._source_adapter_getter = t2.Getter, this._source_adapter_setter = t2.Setter, this._source_adapter_absolute_setter = t2.AbsoluteSetter, this._round = !!t2.DoesRounding(), this._fRound = false;
      }
    }
    Release() {
      this._typeAdapter = null, this._instance_getter = null, this._instance_setter = null, this._instance_absolute_setter = null, this._reset_action = null, this._init_action = null, this._source_adapter_getter = null, this._source_adapter_setter = null, this._source_adapter_absolute_setter = null, super.Release();
    }
    MayNeedBeforeAndAfterInterpolate() {
      return this._typeAdapter.MayNeedBeforeAndAfterInterpolate();
    }
    GetLastValue() {
      return this._lastValue;
    }
    SetLastValue(t2) {
      this._lastValue = t2;
    }
    SetResetState() {
      this._reset_action && this._reset_action(this);
    }
    SetInitialState() {
      const t2 = this._typeAdapter.SetInitialState();
      if ("number" == typeof t2 && (this._lastValue = t2), this._init_action) {
        const t3 = this.GetWorldInfo(), e = this._propertyTrack.GetTrack();
        this._init_action(this, t3, e);
      }
    }
    SetResumeState() {
      const t2 = this._typeAdapter.SetResumeState();
      "number" == typeof t2 && (this._lastValue = t2);
    }
    GetCurrentState() {
      return this._Getter();
    }
    CompareInitialStateWithCurrent() {
      return this._FirstKeyframeGetter() !== this.GetCurrentState();
    }
    CompareSaveStateWithCurrent() {
      return !C32.IsNullOrUndefined(this._saveState) && this._saveState !== this.GetCurrentState();
    }
    BeforeChangeProperty() {
      this._typeAdapter.BeforeChangeProperty();
    }
    ChangeProperty(t2, e, a2, r2, i, s, o2, n) {
      return this._typeAdapter.ChangeProperty(t2, e, a2, r2, i, s, o2, n);
    }
    AfterChangeProperty() {
      this._typeAdapter.AfterChangeProperty();
    }
    _Getter() {
      const t2 = this._GetTarget(), e = this._GetIndex(), a2 = this.GetWorldInfo(), r2 = this._propertyTrack.GetTrack();
      switch (this._propertyTrack.GetSourceAdapterId()) {
        case "behavior":
        case "plugin":
          return t2.GetPropertyValueByIndex(e);
        case "effect":
          return t2[e];
        case "instance-variable":
          return t2.GetInstanceVariableValue(e);
        case "world-instance":
          return this._instance_getter(a2, r2);
        case "audio":
          return this._source_adapter_getter.call(this.GetSourceAdapter(), a2, r2);
      }
    }
    _Setter(t2, e, a2, r2 = true) {
      const i = this._GetTarget(), s = this._GetIndex(), o2 = this.GetWorldInfo(), n = this._propertyTrack.GetTrack();
      switch (this._propertyTrack.GetSourceAdapterId()) {
        case "behavior":
          i.OffsetPropertyValueByIndex(s, t2);
          break;
        case "effect":
          i[s] += t2;
          break;
        case "instance-variable":
          i.SetInstanceVariableOffset(s, t2);
          break;
        case "plugin":
          i.OffsetPropertyValueByIndex(s, t2, this.GetSourceAdapter().GetOptionalCallbacks());
          break;
        case "world-instance":
          this._instance_setter(o2, t2, n, this, false, r2);
          break;
        case "audio":
          this._source_adapter_setter.call(this.GetSourceAdapter(), o2, t2, n, this);
      }
    }
    _SetterAbsolute(t2, e, a2) {
      let r2 = this._propertyTrack.GetInterpolationMode();
      if (r2 = "default" === r2 ? "continuous" : r2, "discrete" === r2 && !e) return;
      if ("discrete" === r2 && a2) {
        const t3 = this._propertyTrack.GetTimeline().GetTime();
        if (!this._propertyTrack.GetPropertyKeyFrameDataItemAtTime(t3)) return;
      }
      const i = this._GetTarget(), s = this._GetIndex(), o2 = this.GetWorldInfo(), n = this._propertyTrack.GetTrack();
      switch (this._propertyTrack.GetSourceAdapterId()) {
        case "behavior":
          i.SetPropertyValueByIndex(s, t2);
          break;
        case "effect":
          i[s] = t2;
          break;
        case "instance-variable":
          i.SetInstanceVariableValue(s, t2);
          break;
        case "plugin":
          i.SetPropertyValueByIndex(s, t2, this.GetSourceAdapter().GetOptionalCallbacks());
          break;
        case "world-instance":
          this._instance_absolute_setter(o2, t2, n);
          break;
        case "audio":
          this._source_adapter_absolute_setter.call(this.GetSourceAdapter(), o2, t2, n);
      }
    }
    _MaybeEnsureValue(t2, e, a2, r2, i, s, o2, n) {
      this._typeAdapter._MaybeEnsureValue(t2, e, a2, r2, i, s, o2, n);
    }
    _AddDelta(t2, e, a2, r2, i) {
      if ("angle" === this._propertyTrack.GetPropertyType()) t2 = C32.toDegrees(t2);
      const s = (t2.toString().split(".")[1] || "").length, o2 = this._Getter();
      let n;
      if (0 === s) if (this._round) n = Math.round(o2);
      else if (this._fRound) if ("angle" === this._propertyTrack.GetPropertyType()) n = C32.toRadians(Math.round(C32.toDegrees(o2)));
      else n = Number(C32.toFixed(o2, 2));
      else n = o2;
      else n = this._round ? Number(C32.toFixed(o2, s)) : (this._fRound, o2);
      switch (this._Setter(n - o2, e, a2, false), this._propertyTrack.GetPropertyName()) {
        case "offsetWidth":
        case "offsetScaleX": {
          const t3 = this.GetWorldInfo(), e2 = t3.GetWidth(), a3 = Number(C32.toFixed(e2, 2));
          t3.OffsetWidth(a3 - e2);
          break;
        }
        case "offsetHeight":
        case "offsetScaleY": {
          const t3 = this.GetWorldInfo(), e2 = t3.GetHeight(), a3 = Number(C32.toFixed(e2, 2));
          t3.OffsetHeight(a3 - e2);
          break;
        }
      }
    }
    _SaveToJson() {
      return Object.assign(super._SaveToJson(), { "v": this._lastValue, "a": this._clampAccumulator, "fod": this._totalForewardOpacityDelta, "bod": this._totalBackwardOpacityDelta, "of": this._opacityFactor, "sf": this._absoluteToFactor, "armorf": this._angleReflectMirrorOrFlip, "armandf": this._angleReflectMirrorAndFlip, "ca": this._changeAccumulator, "os": this._originalSize, "awo": this._absoluteWidthOffset, "aho": this._absoluteHeightOffset, "asxo": this._absoluteScaleXOffset, "asyo": this._absoluteScaleYOffset });
    }
    _LoadFromJson(t2) {
      t2 && (super._LoadFromJson(t2), this._lastValue = t2["v"], this._clampAccumulator = t2["a"], this._totalForewardOpacityDelta = C32.IsFiniteNumber(t2["fod"]) ? t2["fod"] : 0, this._totalBackwardOpacityDelta = C32.IsFiniteNumber(t2["bod"]) ? t2["bod"] : 0, this._opacityFactor = C32.IsFiniteNumber(t2["of"]) ? t2["of"] : NaN, this._absoluteToFactor = C32.IsFiniteNumber(t2["sf"]) ? t2["sf"] : NaN, this._angleReflectMirrorOrFlip = C32.IsFiniteNumber(t2["armorf"]) ? t2["armorf"] : void 0, this._angleReflectMirrorAndFlip = C32.IsFiniteNumber(t2["armandf"]) ? t2["armandf"] : void 0, this._changeAccumulator = C32.IsFiniteNumber(t2["ca"]) ? t2["ca"] : 0, this._originalSize = C32.IsFiniteNumber(t2["os"]) ? t2["os"] : NaN, this._absoluteWidthOffset = C32.IsFiniteNumber(t2["awo"]) ? t2["awo"] : 0, this._absoluteHeightOffset = C32.IsFiniteNumber(t2["aho"]) ? t2["aho"] : 0, this._absoluteScaleXOffset = C32.IsFiniteNumber(t2["asxo"]) ? t2["asxo"] : 0, this._absoluteScaleYOffset = C32.IsFiniteNumber(t2["asyo"]) ? t2["asyo"] : 0);
    }
    SetOriginalSizeProperty(t2) {
      this._originalSize = t2;
    }
    GetChangeAccumulatorProperty() {
      return this._changeAccumulator;
    }
    GetAbsoluteWidthOffsetProperty() {
      return this._absoluteWidthOffset;
    }
    GetAbsoluteHeightOffsetProperty() {
      return this._absoluteHeightOffset;
    }
    GetAbsoluteScaleXOffsetProperty() {
      return this._absoluteScaleXOffset;
    }
    GetAbsoluteScaleYOffsetProperty() {
      return this._absoluteScaleYOffset;
    }
  }
  C32.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapter = NumericInterpolationAdapter;
}
{
  const C32 = self.C3;
  class AbsoluteValueObject {
    constructor(e) {
      this._used = false, this._value = 0, this._propertyKeyframeReached = false, this._endState = false, this._propertyTracks = e;
      for (let e2 = 0, t2 = this._propertyTracks.length; e2 < t2; e2++) this._propertyTracks[e2].SetAbsoluteValueObject(this);
    }
    GetPropertyTracks() {
      return this._propertyTracks;
    }
    SetUsed() {
      this._used = true;
    }
    GetUsed() {
      return this._used;
    }
    SetValue(e) {
      this._value = e;
    }
    GetValue() {
      return this._value;
    }
    SetPropertyKeyframeReached(e) {
      this._propertyKeyframeReached = e;
    }
    GetPropertyKeyframeReached() {
      return this._propertyKeyframeReached;
    }
    SetEndState(e) {
      this._endState = e;
    }
    GetEndState() {
      return this._endState;
    }
    Reset() {
      this._used = false, this._value = 0, this._propertyKeyframeReached = false, this._endState = false;
    }
  }
  class NumericInterpolationAdapterForTimeline {
    constructor(e) {
      this._numericInterpolationAdapter = e;
    }
    Release() {
      this._numericInterpolationAdapter = null;
    }
    GetType() {
      return 0;
    }
    SetInitialState() {
      const e = this._numericInterpolationAdapter;
      this._numericInterpolationAdapter.GetPropertyTrack();
      return e._PickResultMode(() => e._PickTimelinePlaybackMode(() => 0, () => e.GetSourceAdapter().GetValueAtTime()), () => {
      });
    }
    SetResumeState() {
    }
    MayNeedBeforeAndAfterInterpolate() {
      this._numericInterpolationAdapter;
      switch (this._numericInterpolationAdapter.GetPropertyTrack().GetResultMode()) {
        case "relative":
          return false;
        case "absolute":
          return true;
      }
    }
    BeforeChangeProperty() {
      this._numericInterpolationAdapter;
      const e = this._numericInterpolationAdapter.GetPropertyTrack(), t2 = e.GetPropertyName();
      switch (e.GetResultMode()) {
        case "relative":
          break;
        case "absolute":
          if (e.HasAbsoluteValueObject()) {
            e.GetAbsoluteValueObject().Reset();
          } else {
            const r2 = e.GetTimeline(), a2 = e.GetInstance(), s = e.GetSourceAdapter(), o2 = r2.GetSimilarPropertyTracks(a2, s, t2, e);
            o2 && o2.length > 1 && new AbsoluteValueObject(o2);
          }
      }
    }
    ChangeProperty(e, t2, r2, a2, s, o2, i, n) {
      const l = this._numericInterpolationAdapter, u2 = this._numericInterpolationAdapter.GetPropertyTrack();
      switch (u2.GetResultMode()) {
        case "relative": {
          const i2 = l.GetLastValue();
          l._Setter(t2 - i2, r2, a2), o2 && this._MaybeEnsureValue(e, r2, a2, s, i2, t2), l.SetLastValue(t2);
          break;
        }
        case "absolute": {
          const e2 = u2.GetTimeline(), r3 = u2.GetTrack();
          u2.GetInstance(), u2.GetSourceAdapter();
          if (u2.HasAbsoluteValueObject()) {
            const a3 = u2.GetAbsoluteValueObject(), s2 = a3.GetPropertyTracks(), o3 = l._GetPropertyKeyframeStubs(s2, true), c2 = l._GetLastPropertyKeyframeStub(e2, e2.GetTime(), o3);
            if (c2) {
              const e3 = r3.GetStartOffset(), s3 = c2.time - e3;
              if (0 === s3) a3.SetEndState(i), a3.SetPropertyKeyframeReached(n), a3.SetUsed(), a3.SetValue(a3.GetValue() + t2);
              else {
                if (s3 < 0) return;
                const e4 = u2.GetInterpolatedValue(s3);
                a3.SetEndState(i), a3.SetPropertyKeyframeReached(n), a3.SetUsed(), a3.SetValue(a3.GetValue() + (t2 - e4));
              }
            }
          } else l._SetterAbsolute(t2, n, i);
          break;
        }
      }
    }
    AfterChangeProperty() {
      const e = this._numericInterpolationAdapter, t2 = this._numericInterpolationAdapter.GetPropertyTrack();
      switch (t2.GetResultMode()) {
        case "relative":
          break;
        case "absolute":
          if (t2.HasAbsoluteValueObject()) {
            const r2 = t2.GetAbsoluteValueObject();
            r2.GetUsed() && e._SetterAbsolute(r2.GetValue(), r2.GetPropertyKeyframeReached(), r2.GetEndState());
          }
      }
    }
    _MaybeEnsureValue(e, t2, r2, a2, s, o2) {
      const i = this._numericInterpolationAdapter;
      a2 || (t2 && e === t2.GetTime() ? i._AddDelta(t2.GetValueWithResultMode(), t2, r2) : r2 && e === r2.GetTime() ? i._AddDelta(r2.GetValueWithResultMode(), t2, r2) : o2 - s === 0 && i._AddDelta(t2.GetValueWithResultMode(), t2, r2));
    }
  }
  C32.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTimeline = NumericInterpolationAdapterForTimeline;
}
{
  const C32 = self.C3;
  class NumericInterpolationAdapterForTween {
    constructor(e) {
      this._numericInterpolationAdapter = e;
    }
    Release() {
      this._numericInterpolationAdapter = null;
    }
    GetType() {
      return 1;
    }
    SetInitialState() {
      const e = this._numericInterpolationAdapter;
      return e.SetFirstAbsoluteUpdate(true), this._GetAbsoluteInitialValue(e._FirstKeyframeGetter());
    }
    SetResumeState() {
      const e = this._numericInterpolationAdapter;
      if (e._FirstKeyframeGetter() !== e._CurrentKeyframeGetter()) return e.SetFirstAbsoluteUpdate(true), this._GetAbsoluteInitialValue(e._CurrentKeyframeGetter());
    }
    MayNeedBeforeAndAfterInterpolate() {
      return false;
    }
    BeforeChangeProperty() {
    }
    ChangeProperty(e, t2, r2, a2, n, i, o2, l) {
      const s = this._numericInterpolationAdapter, u2 = s.GetLastValue();
      switch (s.GetPropertyTrack().GetResultMode()) {
        case "relative":
          s._Setter(t2 - u2, r2, a2), i && this._MaybeEnsureValue(e, r2, a2, n, u2, t2, false, o2);
          break;
        case "absolute":
          s.GetFirstAbsoluteUpdate() ? (s.SetFirstAbsoluteUpdate(false), s._Setter(u2, r2, a2)) : 0 === e && 0 === s.GetPropertyTrack().GetTimeline().GetTotalTime() ? s._SetterAbsolute(t2, true, false) : (s._Setter(t2 - u2, r2, a2), i && this._MaybeEnsureValue(e, r2, a2, n, u2, t2, this._ForceEndValue(), o2));
      }
      s.SetLastValue(t2);
    }
    AfterChangeProperty() {
    }
    _GetAbsoluteInitialValue(e) {
      return e - this._numericInterpolationAdapter.GetCurrentState();
    }
    _ForceEndValue() {
      const e = this._numericInterpolationAdapter, t2 = e.GetWorldInfo().GetInstance(), r2 = e.GetPropertyTrack().GetRuntime().GetTimelineManager();
      let a2 = 0;
      for (const e2 of r2.GetPlayingTimelines()) 0 === e2.GetType() ? e2.HasTrackInstance(t2) && a2++ : 1 === e2.GetType() && e2.GetInstance() === t2 && a2++;
      return a2 <= 1;
    }
    _MaybeEnsureValue(e, t2, r2, a2, n, i, o2, l) {
      const s = this._numericInterpolationAdapter;
      a2 ? t2 && e === t2.GetTime() ? s._AddDelta(t2.GetValueWithResultMode(), t2, r2, o2, l) : r2 && e === r2.GetTime() ? s._AddDelta(r2.GetValueWithResultMode(), t2, r2, o2, l) : r2 || s._AddDelta(t2.GetValueWithResultMode(), t2, r2, o2, l) : t2 && e === t2.GetTime() ? s._AddDelta(t2.GetValueWithResultMode(), t2, r2, o2, l) : r2 && e === r2.GetTime() ? s._AddDelta(r2.GetValueWithResultMode(), t2, r2, o2, l) : i - n === 0 && s._AddDelta(t2.GetValueWithResultMode(), t2, r2, o2, l);
    }
  }
  C32.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTween = NumericInterpolationAdapterForTween;
}
{
  const C32 = self.C3, Ease = self.Ease;
  C32.PropertyTrackState.NumericTypeAdapter = class {
    constructor() {
    }
    static WillChange(e, t2, a2, r2) {
      let s;
      switch (r2) {
        case "behavior":
        case "plugin":
          s = t2.GetPropertyValueByIndex(e);
          break;
        case "effect":
          s = t2[e];
          break;
        case "instance-variable":
          s = t2.GetInstanceVariableValue(e);
      }
      return s !== a2;
    }
    static Interpolate(e, t2, a2, r2) {
      if (!a2) {
        let e2 = r2.GetPropertyTrackDataItem();
        return e2 = r2.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(e2), e2.GetValueWithResultMode();
      }
      let s = r2.GetInterpolationMode();
      if ("default" === s && (s = "continuous"), "combo" === r2.GetPropertyType() && (s = "discrete"), "discrete" === s) return t2.GetValueWithResultMode();
      if ("continuous" === s || "step" === s) {
        const n = r2.GetTimeline().GetStep();
        if ("step" === s && 0 !== n) {
          const t3 = 1 / n;
          e = Math.floor(e * t3) / t3;
        }
        const i = t2.GetValueWithResultMode(), c2 = a2.GetValueWithResultMode(), o2 = t2.GetAddOn("cubic-bezier"), l = a2.GetAddOn("cubic-bezier"), u2 = o2 && o2.GetStartEnable() && l && l.GetEndEnable();
        if (!u2 && i === c2) return i;
        const G = t2.GetTime(), p2 = a2.GetTime();
        "step" === s && 0 !== n && (e = C32.clamp(e, G, p2));
        const d2 = C32.normalize(e, G, p2), b2 = t2.GetEase();
        let f2;
        if (u2) {
          const e2 = p2 - G;
          f2 = Ease.GetRuntimeEase(b2)(e2 * d2, 0, 1, e2), f2 = Ease.GetRuntimeEase("cubicbezier")(f2, i, i + o2.GetStartAnchor(), c2 + l.GetEndAnchor(), c2);
        } else f2 = Ease.GetRuntimeEase(b2)((p2 - G) * d2, i, c2 - i, p2 - G);
        return "integer" === r2.GetPropertyType() ? Math.floor(f2) : f2;
      }
    }
  };
}
{
  const C32 = self.C3;
  C32.PropertyTrackState.AngleTypeAdapter = class {
    constructor() {
    }
    static WillChange(e, t2, a2, r2) {
      let s;
      switch (r2) {
        case "behavior":
        case "plugin":
          s = t2.GetPropertyValueByIndex(e);
          break;
        case "effect":
          s = t2[e];
          break;
        case "instance-variable":
          s = t2.GetInstanceVariableValue(e);
      }
      return s !== a2;
    }
    static Interpolate(e, t2, a2, r2) {
      if (!a2) {
        let e2 = r2.GetPropertyTrackDataItem();
        return e2 = r2.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(e2), e2.GetValueWithResultMode();
      }
      let s = r2.GetInterpolationMode();
      if ("default" === s && (s = "continuous"), "combo" === r2.GetPropertyType() && (s = "discrete"), "discrete" === s) return t2.GetValueWithResultMode();
      if ("continuous" === s || "step" === s) {
        const n = r2.GetTimeline().GetStep();
        if ("step" === s && 0 !== n) {
          const t3 = 1 / n;
          e = Math.floor(e * t3) / t3;
        }
        const i = t2.GetTime(), o2 = a2.GetTime(), c2 = t2.GetValueWithResultMode(), l = a2.GetValueWithResultMode();
        "step" === s && 0 !== n && (e = C32.clamp(e, i, o2));
        const u2 = t2.GetAddOn("angle");
        if (!u2) {
          if (c2 === l) return c2;
          const a3 = C32.normalize(e, i, o2), r3 = self.Ease.GetRuntimeEase(t2.GetEase());
          return C32.angleLerp(c2, l, r3(a3, 0, 1, 1));
        }
        {
          const a3 = u2.GetRevolutions();
          if (c2 === l && 0 === a3) return c2;
          const r3 = C32.normalize(e, i, o2), s2 = self.Ease.GetRuntimeEase(t2.GetEase())(r3, 0, 1, 1);
          switch (u2.GetDirection()) {
            case "closest":
              return C32.angleLerp(c2, l, s2, a3);
            case "clockwise":
              return C32.angleLerpClockwise(c2, l, s2, a3);
            case "anti-clockwise":
              return C32.angleLerpAntiClockwise(c2, l, s2, a3);
          }
        }
      }
    }
  };
}
{
  const C32 = self.C3;
  C32.PropertyTrackState.BooleanTypeAdapter = class {
    constructor() {
    }
    static WillChange(e, t2, a2, r2) {
      let c2;
      switch (r2) {
        case "behavior":
        case "plugin":
          c2 = t2.GetPropertyValueByIndex(e);
          break;
        case "effect":
          c2 = t2[e];
          break;
        case "instance-variable":
          c2 = t2.GetInstanceVariableValue(e);
      }
      return !!c2 != !!a2;
    }
    static Interpolate(e, t2, a2, r2) {
      if (!a2) {
        let e2 = r2.GetPropertyTrackDataItem();
        return e2 = r2.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(e2), e2.GetValueWithResultMode() ? 1 : 0;
      }
      return t2.GetValueWithResultMode() ? 1 : 0;
    }
  };
}
{
  const C32 = self.C3, TEMP_COLOR_ARRAY = [0, 0, 0], TEMP_COLOR_ARRAY_2 = [0, 0, 0], TEMP_COLOR_ARRAY_3 = [0, 0, 0];
  C32.PropertyTrackState.ColorTypeAdapter = class {
    constructor() {
    }
    static WillChange(R, _2, e, t2) {
      let A;
      switch (t2) {
        case "behavior":
        case "plugin":
          A = _2.GetPropertyValueByIndex(R);
          break;
        case "effect":
          A = _2[R];
          break;
        case "instance-variable":
          A = _2.GetInstanceVariableValue(R);
      }
      return Array.isArray(e) ? (TEMP_COLOR_ARRAY[0] = e[0], TEMP_COLOR_ARRAY[1] = e[1], TEMP_COLOR_ARRAY[2] = e[2]) : (TEMP_COLOR_ARRAY_3.parseCommaSeparatedRgb(e), TEMP_COLOR_ARRAY[0] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getR()), TEMP_COLOR_ARRAY[1] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getG()), TEMP_COLOR_ARRAY[2] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getB())), Array.isArray(A) ? (TEMP_COLOR_ARRAY_2[0] = A[0], TEMP_COLOR_ARRAY_2[1] = A[1], TEMP_COLOR_ARRAY_2[2] = A[2]) : (TEMP_COLOR_ARRAY_3.parseCommaSeparatedRgb(A), TEMP_COLOR_ARRAY_2[0] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getR()), TEMP_COLOR_ARRAY_2[1] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getG()), TEMP_COLOR_ARRAY_2[2] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getB())), TEMP_COLOR_ARRAY[0] !== TEMP_COLOR_ARRAY_2[0] || (TEMP_COLOR_ARRAY[1] !== TEMP_COLOR_ARRAY_2[1] || TEMP_COLOR_ARRAY[2] !== TEMP_COLOR_ARRAY_2[2]);
    }
    static Interpolate(R, _2, e, t2) {
      if (!e) {
        let R2 = t2.GetPropertyTrackDataItem();
        R2 = t2.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(R2);
        const _3 = R2.GetValueWithResultMode();
        return TEMP_COLOR_ARRAY[0] = _3[0], TEMP_COLOR_ARRAY[1] = _3[1], TEMP_COLOR_ARRAY[2] = _3[2], TEMP_COLOR_ARRAY;
      }
      let A = t2.GetInterpolationMode();
      if ("default" === A && (A = "continuous"), "discrete" === A) {
        const R2 = _2.GetValueWithResultMode();
        return TEMP_COLOR_ARRAY[0] = R2[0], TEMP_COLOR_ARRAY[1] = R2[1], TEMP_COLOR_ARRAY[2] = R2[2], TEMP_COLOR_ARRAY;
      }
      if ("continuous" === A || "step" === A) {
        const O2 = t2.GetTimeline().GetStep();
        if ("step" === A && 0 !== O2) {
          const _3 = 1 / O2;
          R = Math.floor(R * _3) / _3;
        }
        const a2 = _2.GetTime(), r2 = e.GetTime(), M2 = _2.GetValueWithResultMode(), C2 = e.GetValueWithResultMode();
        "step" === A && 0 !== O2 && (R = C32.clamp(R, a2, r2));
        const T2 = C32.normalize(R, a2, r2), o2 = _2.GetEase(), P2 = M2[0], E2 = M2[1], L = M2[2], Y = C2[0], s = C2[1], l = C2[2], i = self.Ease.GetRuntimeEase(o2), n = r2 - a2, c2 = n * T2;
        return TEMP_COLOR_ARRAY[0] = P2 === Y ? P2 : i(c2, P2, Y - P2, n), TEMP_COLOR_ARRAY[1] = E2 === s ? E2 : i(c2, E2, s - E2, n), TEMP_COLOR_ARRAY[2] = L === l ? L : i(c2, L, l - L, n), TEMP_COLOR_ARRAY;
      }
    }
  };
}
{
  const C32 = self.C3;
  C32.PropertyTrackState.TextTypeAdapter = class {
    constructor() {
    }
    static WillChange(e, t2, a2, r2) {
      let c2;
      switch (r2) {
        case "behavior":
        case "plugin":
          c2 = t2.GetPropertyValueByIndex(e);
          break;
        case "effect":
          c2 = t2[e];
          break;
        case "instance-variable":
          c2 = t2.GetInstanceVariableValue(e);
      }
      return c2 !== a2;
    }
    static Interpolate(e, t2, a2, r2) {
      if (!a2) {
        let e2 = r2.GetPropertyTrackDataItem();
        return e2 = r2.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(e2), e2.GetValueWithResultMode();
      }
      return t2.GetValueWithResultMode();
    }
  };
}
{
  const C32 = self.C3;
  C32.TimelineDataManager = class {
    constructor() {
      this._timelineDataItems = /* @__PURE__ */ new Map();
    }
    Release() {
      for (const e of this._timelineDataItems.values()) e.Release();
      this._timelineDataItems.clear(), this._timelineDataItems = null;
    }
    Add(e) {
      const a2 = new C32.TimelineDataItem(e), t2 = a2.GetName();
      this._timelineDataItems.set(t2, a2);
    }
    Get(e) {
      return this._timelineDataItems.get(e);
    }
    GetNameId() {
      return 0;
    }
    static _CreateDataItems(e, a2, t2, s) {
      if (a2) for (const i of a2) C32.TimelineDataManager._CreateDataItem("create", i, e, t2, s);
    }
    static _CreateDataItemsIncludingDisabled(e, a2, t2, s) {
      if (a2) for (const i of a2) C32.TimelineDataManager._CreateDataItem("create-including-disabled", i, e, t2, s);
    }
    static _LoadDataItemsFromJson(e, a2, t2, s) {
      e.length ? a2.forEach((a3, t3) => {
        e[t3]._LoadFromJson(a3);
      }) : a2.forEach((a3) => {
        C32.TimelineDataManager._CreateDataItem("load", a3, e, t2, s);
      });
    }
    static _CreateDataItem(e, a2, t2, s, i) {
      let n;
      if ("function" == typeof s) switch (e) {
        case "load":
          n = new s(null, i);
          break;
        case "create":
        case "create-including-disabled":
          n = new s(a2, i);
      }
      else if ("object" == typeof s) {
        const t3 = a2[s.prop], c2 = s.map.get(t3);
        switch (e) {
          case "load":
            n = new c2(null, i);
            break;
          case "create":
          case "create-including-disabled":
            n = new c2(a2, i);
        }
      }
      switch (e) {
        case "load":
          n._LoadFromJson(a2), t2.push(n);
          break;
        case "create":
          if ("function" == typeof n.GetEnable && !n.GetEnable()) return n.Release();
          t2.push(n);
          break;
        case "create-including-disabled":
          t2.push(n);
      }
    }
  };
}
{
  const C32 = self.C3, NAME = 0, TOTAL_TIME = 1, STEP = 2, INTERPOLATION_MODE = 3, RESULT_MODE = 4, TRACKS = 5, LOOP = 6, PING_PONG = 7, REPEAT_COUNT = 8, START_ON_LAYOUT = 9, TRANSFORM_WITH_SCENE_GRAPH = 10, USE_SYSTEM_TIMESCALE = 11;
  C32.TimelineDataItem = class {
    constructor(t2) {
      this._name = "", this._totalTime = NaN, this._step = 0, this._interpolationMode = "default", this._resultMode = "default", this._loop = false, this._pingPong = false, this._repeatCount = 1, this._trackData = null, this._startOnLayout = "", this._transformWithSceneGraph = false, this._useSystemTimescale = true, t2 && (this._name = t2[0], this._totalTime = t2[1], this._step = t2[2], this._interpolationMode = t2[3], this._resultMode = t2[4], this._loop = !!t2[6], this._pingPong = !!t2[7], this._repeatCount = t2[8], this._startOnLayout = t2[9], this._transformWithSceneGraph = !!t2[10], this._useSystemTimescale = !!t2[11], this._trackData = new C32.TrackData(t2[5], this));
    }
    Release() {
      this._trackData.Release(), this._trackData = null;
    }
    GetTrackData() {
      return this._trackData || (this._trackData = new C32.TrackData(null, this)), this._trackData;
    }
    GetName() {
      return this._name;
    }
    SetName(t2) {
      this._name = t2;
    }
    GetTotalTime() {
      return this._totalTime;
    }
    SetTotalTime(t2) {
      this._totalTime = t2;
    }
    GetStep() {
      return this._step;
    }
    SetStep(t2) {
      this._step = t2;
    }
    GetInterpolationMode() {
      return this._interpolationMode;
    }
    SetInterpolationMode(t2) {
      this._interpolationMode = t2;
    }
    GetResultMode() {
      return this._resultMode;
    }
    SetResultMode(t2) {
      this._resultMode = t2;
    }
    GetLoop() {
      return this._loop;
    }
    SetLoop(t2) {
      this._loop = t2;
    }
    GetPingPong() {
      return this._pingPong;
    }
    SetPingPong(t2) {
      this._pingPong = t2;
    }
    GetRepeatCount() {
      return this._repeatCount;
    }
    SetRepeatCount(t2) {
      this._repeatCount = t2;
    }
    GetStartOnLayout() {
      return this._startOnLayout;
    }
    GetTransformWithSceneGraph() {
      return this._transformWithSceneGraph;
    }
    GetUseSystemTimescale() {
      return this._useSystemTimescale;
    }
    _SaveToJson() {
      return { "trackDataJson": this._trackData._SaveToJson(), "name": this._name, "totalTime": this._totalTime, "step": this._step, "interpolationMode": this._interpolationMode, "resultMode": this._resultMode, "loop": this._loop, "pingPong": this._pingPong, "repeatCount": this._repeatCount, "startOnLayout": this._startOnLayout, "transformWithSceneGraph": !!this._transformWithSceneGraph, "useSystemTimescale": this._useSystemTimescale };
    }
    _LoadFromJson(t2) {
      t2 && (this.GetTrackData()._LoadFromJson(t2["trackDataJson"]), this._name = t2["name"], this._totalTime = t2["totalTime"], this._step = t2["step"], this._interpolationMode = t2["interpolationMode"], this._resultMode = t2["resultMode"], this._loop = t2["loop"], this._pingPong = t2["pingPong"], this._repeatCount = t2["repeatCount"], this._startOnLayout = t2["startOnLayout"], this._transformWithSceneGraph = !!t2["transformWithSceneGraph"], this._useSystemTimescale = !!t2["useSystemTimescale"]);
    }
  };
}
{
  const C32 = self.C3, WI_DATA = 0, OC_INDEX = 1, WI_UID = 2, INTERPOLATION_MODE = 1, RESULT_MODE = 2, ENABLED = 3, KEYFRAMES = 4, PROPERTY_TRACKS = 5, ID = 6, NESTED_DATA = 7, START_OFFSET = 0, LOCAL_TOTAL_TIME = 1, WI_ADDITIONAL_DATA = 8, ORIGINAL_WIDTH = 0, ORIGINAL_HEIGHT = 1, TRACK_TYPE = 9, TRACK_NAME = 10;
  class TrackDataItem {
    constructor(t2, a2) {
      this._trackData = a2, this._instanceData = null, this._additionalInstanceData = null, this._instanceUid = NaN, this._objectClassIndex = NaN, this._interpolationMode = "default", this._resultMode = "default", this._enabled = false, this._keyframeData = null, this._propertyTrackData = null, this._id = "", this._nestedData = null, this._startOffset = 0, this._localTotalTime = this._trackData.GetTimelineDataItem().GetTotalTime(), this._type = 0, this._name = "", t2 && (t2[0] && (this._instanceData = t2[0], this._instanceUid = t2[0][2], this._objectClassIndex = t2[0][1]), this._interpolationMode = t2[1], this._resultMode = t2[2], this._enabled = !!t2[3], t2[6] && (this._id = t2[6]), t2[7] && (this._nestedData = t2[7], this._startOffset = t2[7][0], this._localTotalTime = t2[7][1]), t2[8] && (this._additionalInstanceData = t2[8]), t2[8] && (this._additionalInstanceData = t2[8]), t2[9] && (this._type = t2[9]), t2[10] && (this._name = t2[10]), this._keyframeData = new C32.KeyframeData(t2[4], this), this._propertyTrackData = new C32.PropertyTrackData(t2[5], this));
    }
    Release() {
      this._instanceData = null, this._trackData = null, this._keyframeData && (this._keyframeData.Release(), this._keyframeData = null), this._propertyTrackData && (this._propertyTrackData.Release(), this._propertyTrackData = null), this._nestedData = null;
    }
    GetTrackData() {
      return this._trackData;
    }
    GetKeyframeData() {
      return this._keyframeData || (this._keyframeData = new C32.KeyframeData(null, this)), this._keyframeData;
    }
    GetPropertyTrackData() {
      return this._propertyTrackData || (this._propertyTrackData = new C32.PropertyTrackData(null, this)), this._propertyTrackData;
    }
    GetInstanceData() {
      return this._instanceData;
    }
    GetObjectClassIndex() {
      return this._objectClassIndex;
    }
    SetObjectClassIndex(t2) {
      this._objectClassIndex = t2;
    }
    GetInstanceUID() {
      return this._instanceUid;
    }
    SetInstanceUID(t2) {
      this._instanceUid = t2;
    }
    GetInterpolationMode() {
      return this._interpolationMode;
    }
    SetInterpolationMode(t2) {
      this._interpolationMode = t2;
    }
    GetResultMode() {
      return this._resultMode;
    }
    SetResultMode(t2) {
      this._resultMode = t2;
    }
    GetEnable() {
      return this._enabled;
    }
    SetEnable(t2) {
      this._enabled = !!t2;
    }
    GetId() {
      return this._id;
    }
    GetStartOffset() {
      return this._startOffset;
    }
    GetLocalTotalTime() {
      return this._localTotalTime;
    }
    SetLocalTotalTime(t2) {
      this._localTotalTime = t2;
    }
    GetOriginalWidth() {
      return this._additionalInstanceData[0];
    }
    SetOriginalWidth(t2) {
      this._additionalInstanceData || (this._additionalInstanceData = []), this._additionalInstanceData[0] = t2;
    }
    GetOriginalHeight() {
      return this._additionalInstanceData || (this._additionalInstanceData = []), this._additionalInstanceData[1];
    }
    SetOriginalHeight(t2) {
      this._additionalInstanceData || (this._additionalInstanceData = []), this._additionalInstanceData[1] = t2;
    }
    GetType() {
      return this._type;
    }
    GetName() {
      return this._name;
    }
    _SaveToJson() {
      return { "keyframeDataJson": this._keyframeData._SaveToJson(), "propertyTrackDataJson": this._propertyTrackData._SaveToJson(), "instanceData": this._instanceData, "additionalInstanceData": this._additionalInstanceData, "instanceUid": this._instanceUid, "objectClassIndex": this._objectClassIndex, "interpolationMode": this._interpolationMode, "resultMode": this._resultMode, "enabled": this._enabled, "id": this._id, "nestedData": this._nestedData, "type": this._type, "name": this._name };
    }
    _LoadFromJson(t2) {
      t2 && (this._instanceData = t2["instanceData"], this._instanceUid = t2["instanceUid"], this._objectClassIndex = t2["objectClassIndex"], this._interpolationMode = t2["interpolationMode"], this._resultMode = t2["resultMode"], this._enabled = t2["enabled"], this._id = t2["id"], this._type = t2["type"] ? t2["type"] : 0, this._name = t2["name"] ? t2["name"] : "", this._localTotalTime = this._trackData.GetTimelineDataItem().GetTotalTime(), t2["nestedData"] && (this._nestedData = t2["nestedData"], this._startOffset = this._nestedData[0], this._localTotalTime = this._nestedData[1]), t2["additionalInstanceData"] && (this._additionalInstanceData = t2["additionalInstanceData"]), this.GetKeyframeData()._LoadFromJson(t2["keyframeDataJson"]), this.GetPropertyTrackData()._LoadFromJson(t2["propertyTrackDataJson"]));
    }
  }
  C32.TrackData = class {
    constructor(t2, a2) {
      this._timelineDataItem = a2, this._trackDataItems = [], C32.TimelineDataManager._CreateDataItems(this._trackDataItems, t2, TrackDataItem, this);
    }
    Release() {
      this._timelineDataItem = null;
      for (const t2 of this._trackDataItems) t2.Release();
      C32.clearArray(this._trackDataItems), this._trackDataItems = null;
    }
    GetTimelineDataItem() {
      return this._timelineDataItem;
    }
    AddEmptyTrackDataItem() {
      const t2 = new TrackDataItem(null, this);
      return this._trackDataItems.push(t2), t2;
    }
    GetFirstKeyframeDataItem(t2) {
      return t2.GetKeyframeData().GetKeyframeDataItemArray()[0];
    }
    GetLastKeyframeDataItem(t2) {
      return t2.GetKeyframeData().GetKeyframeDataItemArray().at(-1);
    }
    GetKeyFrameDataItemAtTime(t2, a2) {
      const e = a2.GetKeyframeData().GetKeyframeDataItemArray(), s = e.length;
      for (let a3 = 0; a3 < s; a3++) {
        const s2 = e[a3];
        if (s2.GetTime() === t2) return s2;
      }
    }
    GetFirstKeyFrameDataItemHigherThan(t2, a2) {
      const e = a2.GetKeyframeData().GetKeyframeDataItemArray(), s = e.length;
      for (let a3 = 0; a3 < s; a3++) {
        const s2 = e[a3];
        if (s2.GetTime() > t2) return s2;
      }
    }
    GetFirstKeyFrameDataItemHigherOrEqualThan(t2, a2) {
      const e = a2.GetKeyframeData().GetKeyframeDataItemArray(), s = e.length;
      for (let a3 = 0; a3 < s; a3++) {
        const s2 = e[a3];
        if (s2.GetTime() >= t2) return s2;
      }
    }
    GetFirstKeyFrameDataItemLowerOrEqualThan(t2, a2) {
      const e = a2.GetKeyframeData().GetKeyframeDataItemArray();
      for (let a3 = e.length - 1; a3 >= 0; a3--) {
        const s = e[a3];
        if (s.GetTime() <= t2) return s;
      }
    }
    *trackDataItems() {
      for (const t2 of this._trackDataItems) yield t2;
    }
    _SaveToJson() {
      return { "trackDataItemsJson": this._trackDataItems.map((t2) => t2._SaveToJson()) };
    }
    _LoadFromJson(t2) {
      t2 && C32.TimelineDataManager._LoadDataItemsFromJson(this._trackDataItems, t2["trackDataItemsJson"], TrackDataItem, this);
    }
  };
}
{
  const C32 = self.C3, SOURCE_DATA = 0, SOURCE = 0, PROPERTY = 1, TYPE = 2, MIN = 3, MAX = 4, INTERPOLATION_MODE = 5, RESULT_MODE = 6, ENABLED = 7, PROPERTY_KEYFRAMES = 8, CAN_HAVE_PROPERTY_KEYFRAMES = 9;
  class PropertyTrackDataItem {
    constructor(t2, e) {
      this._propertyTrackData = e, this._sourceAdapterId = "", this._sourceAdapterArguments = null, this._property = null, this._type = null, this._min = NaN, this._max = NaN, this._interpolationMode = "default", this._resultMode = "default", this._enabled = false, this._propertyKeyframeData = null, this._canHavePropertyKeyframes = true, t2 && (this._sourceAdapterId = t2[0][0], this._sourceAdapterArguments = t2[0].slice(1), this._property = t2[1], this._type = t2[2], this._min = t2[3], this._max = t2[4], this._interpolationMode = t2[5], this._resultMode = t2[6], this._enabled = !!t2[7], this._propertyKeyframeData = new C32.PropertyKeyframeData(t2[8], this), this._canHavePropertyKeyframes = t2[9]);
    }
    Release() {
      this._propertyKeyframeData.Release(), this._propertyKeyframeData = null, this._propertyTrackData = null, this._sourceAdapterArguments = null;
    }
    GetPropertyTrackData() {
      return this._propertyTrackData;
    }
    GetPropertyKeyframeData() {
      return this._propertyKeyframeData || (this._propertyKeyframeData = new C32.PropertyKeyframeData(null, this)), this._propertyKeyframeData;
    }
    GetSourceAdapterId() {
      return this._sourceAdapterId;
    }
    SetSourceAdapterId(t2) {
      this._sourceAdapterId = t2;
    }
    GetSourceAdapterArguments() {
      return this._sourceAdapterArguments;
    }
    SetSourceAdapterArguments(t2) {
      this._sourceAdapterArguments = t2;
    }
    GetProperty() {
      return this._property;
    }
    SetProperty(t2) {
      this._property = t2;
    }
    GetType() {
      return this._type;
    }
    SetType(t2) {
      this._type = t2;
    }
    GetMin() {
      return this._min;
    }
    SetMin(t2) {
      this._min = t2;
    }
    GetMax() {
      return this._max;
    }
    SetMax(t2) {
      this._max = t2;
    }
    GetInterpolationMode() {
      return this._interpolationMode;
    }
    SetInterpolationMode(t2) {
      this._interpolationMode = t2;
    }
    GetResultMode() {
      return this._resultMode;
    }
    SetResultMode(t2) {
      this._resultMode = t2;
    }
    GetEnable() {
      return this._enabled;
    }
    SetEnable(t2) {
      this._enabled = !!t2;
    }
    CanHavePropertyKeyframes() {
      return !!this._canHavePropertyKeyframes;
    }
    _SaveToJson() {
      return { "propertyKeyframeDataJson": this._propertyKeyframeData._SaveToJson(), "sourceAdapterId": this._sourceAdapterId, "sourceAdapterArguments": this._sourceAdapterArguments, "property": this._property, "type": this._type, "min": this._min, "max": this._max, "interpolationMode": this._interpolationMode, "resultMode": this._resultMode, "enabled": this._enabled, "canHavePropertyKeyframes": this._canHavePropertyKeyframes };
    }
    _LoadFromJson(t2) {
      t2 && (this._sourceAdapterId = t2["sourceAdapterId"], this._sourceAdapterArguments = t2["sourceAdapterArguments"], this._property = t2["property"], this._type = t2["type"], this._min = t2["min"], this._max = t2["max"], this._interpolationMode = t2["interpolationMode"], this._resultMode = t2["resultMode"], this._enabled = t2["enabled"], this._canHavePropertyKeyframes = t2["canHavePropertyKeyframes"], this.GetPropertyKeyframeData()._LoadFromJson(t2["propertyKeyframeDataJson"]));
    }
  }
  C32.PropertyTrackData = class {
    constructor(t2, e) {
      this._trackDataItem = e, this._propertyTrackDataItems = [], C32.TimelineDataManager._CreateDataItems(this._propertyTrackDataItems, t2, PropertyTrackDataItem, this);
    }
    Release() {
      this._trackDataItem = null;
      for (const t2 of this._propertyTrackDataItems) t2.Release();
      C32.clearArray(this._propertyTrackDataItems), this._propertyTrackDataItems = null;
    }
    GetTrackDataItem() {
      return this._trackDataItem;
    }
    AddEmptyPropertyTrackDataItem() {
      const t2 = new PropertyTrackDataItem(null, this);
      return this._propertyTrackDataItems.push(t2), t2;
    }
    GetFirstPropertyKeyframeDataItem(t2) {
      return t2.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray()[0];
    }
    GetLastPropertyKeyframeDataItem(t2) {
      return t2.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray().at(-1);
    }
    GetPropertyKeyFrameDataItemAtTime(t2, e) {
      const r2 = e.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray(), a2 = r2.length;
      for (let e2 = 0; e2 < a2; e2++) {
        const a3 = r2[e2];
        if (a3.GetTime() === t2) return a3;
      }
    }
    GetFirstPropertyKeyFrameDataItemHigherThan(t2, e) {
      const r2 = e.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray(), a2 = r2.length;
      for (let e2 = 0; e2 < a2; e2++) {
        const a3 = r2[e2];
        if (a3.GetTime() > t2) return a3;
      }
    }
    GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(t2, e) {
      const r2 = e.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray(), a2 = r2.length;
      for (let e2 = 0; e2 < a2; e2++) {
        const a3 = r2[e2];
        if (a3.GetTime() >= t2) return a3;
      }
    }
    GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(t2, e) {
      const r2 = e.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray();
      for (let e2 = r2.length - 1; e2 >= 0; e2--) {
        const a2 = r2[e2];
        if (a2.GetTime() <= t2) return a2;
      }
    }
    *propertyTrackDataItems() {
      for (const t2 of this._propertyTrackDataItems) yield t2;
    }
    _SaveToJson() {
      return { "propertyTrackDataItemsJson": this._propertyTrackDataItems.map((t2) => t2._SaveToJson()) };
    }
    _LoadFromJson(t2) {
      t2 && C32.TimelineDataManager._LoadDataItemsFromJson(this._propertyTrackDataItems, t2["propertyTrackDataItemsJson"], PropertyTrackDataItem, this);
    }
  };
}
{
  const C32 = self.C3, TIME = 0, EASE = 1, ENABLE = 2, TAGS = 3;
  class KeyframeDataItem {
    constructor(e, t2) {
      if (this._keyframeData = t2, this._time = -1, this._ease = "noease", this._enable = false, this._tags = null, this._lowerTags = null, !e) return;
      this._time = e[0], this._ease = e[1], this._enable = !!e[2];
      const a2 = e[3];
      this._tags = a2 ? a2.split(" ") : [], this._lowerTags = new Set(this._tags.map((e2) => e2.toLowerCase())), this._next = null, this._last = null;
    }
    Release() {
      this._keyframeData = null, C32.clearArray(this._tags), this._tags = null, this._lowerTags.clear(), this._lowerTags = null, this._next = null;
    }
    GetKeyframeData() {
      return this._keyframeData;
    }
    GetNext() {
      return this._next;
    }
    SetNext(e) {
      this._next = e;
    }
    GetLast() {
      return this._last;
    }
    SetLast(e) {
      this._last = e;
    }
    GetTime() {
      return this._time;
    }
    SetTime(e) {
      this._time = e, this._keyframeData._LinkKeyframeDataItems();
    }
    GetEase() {
      return this._ease;
    }
    SetEase(e) {
      this._ease = e;
    }
    GetEnable() {
      return this._enable;
    }
    SetEnable(e) {
      this._enable = !!e;
    }
    GetTags() {
      return this._tags;
    }
    SetTags(e) {
      this._tags = e ? e.split(" ") : [], this._lowerTags = new Set(this._tags.map((e2) => e2.toLowerCase()));
    }
    GetLowerTags() {
      return this._lowerTags;
    }
    GetTagsString() {
      return Array.from(this._lowerTags).join(",").trim();
    }
    HasTag(e) {
      return this._lowerTags.has(e.toLowerCase());
    }
    _SaveToJson() {
      return { "time": this._time, "ease": this._ease, "enable": this._enable, "tags": this._tags };
    }
    _LoadFromJson(e) {
      e && (this._time = e["time"], this._ease = e["ease"], this._enable = e["enable"], this._tags = e["tags"], this._lowerTags = new Set(this._tags.map((e2) => e2.toLowerCase())));
    }
  }
  C32.KeyframeData = class {
    constructor(e, t2) {
      this._trackDataItem = t2, this._keyframeDataItems = [], C32.TimelineDataManager._CreateDataItems(this._keyframeDataItems, e, KeyframeDataItem, this), this._LinkKeyframeDataItems();
    }
    Release() {
      this._trackDataItem = null;
      for (const e of this._keyframeDataItems) e.Release();
      C32.clearArray(this._keyframeDataItems), this._keyframeDataItems = null;
    }
    _LinkKeyframeDataItems() {
      this._keyframeDataItems.sort((e, t2) => e.GetTime() - t2.GetTime());
      for (let e = 0; e < this._keyframeDataItems.length; e++) {
        const t2 = this._keyframeDataItems[e];
        t2.SetNext(this._keyframeDataItems[e + 1]), t2.SetLast(this._keyframeDataItems[e - 1]);
      }
    }
    GetTrackDataItem() {
      return this._trackDataItem;
    }
    GetKeyframeDataItemCount() {
      return this._keyframeDataItems.length;
    }
    GetKeyframeDataItemArray() {
      return this._keyframeDataItems;
    }
    AddEmptyKeyframeDataItem() {
      const e = new KeyframeDataItem(null, this);
      return this._keyframeDataItems.push(e), this._LinkKeyframeDataItems(), e;
    }
    DeleteKeyframeDataItems(e) {
      for (const t2 of this._keyframeDataItems) {
        if (!e(t2)) continue;
        const a2 = this._keyframeDataItems.indexOf(t2);
        -1 !== a2 && (t2.Release(), this._keyframeDataItems.splice(a2, 1));
      }
      this.SortKeyframeDataItems(), this._LinkKeyframeDataItems();
    }
    SortKeyframeDataItems() {
      this._keyframeDataItems.sort((e, t2) => e.GetTime() - t2.GetTime());
    }
    GetKeyframeDataItemIndex(e) {
      return this._keyframeDataItems.indexOf(e);
    }
    GetKeyframeDataItemFromIndex(e) {
      return this._keyframeDataItems[e];
    }
    *keyframeDataItems() {
      for (const e of this._keyframeDataItems) yield e;
    }
    *keyframeDataItemsReverse() {
      for (let e = this._keyframeDataItems.length - 1; e >= 0; e--) yield this._keyframeDataItems[e];
    }
    _SaveToJson() {
      return { "keyframeDataItemsJson": this._keyframeDataItems.map((e) => e._SaveToJson()) };
    }
    _LoadFromJson(e) {
      e && (C32.TimelineDataManager._LoadDataItemsFromJson(this._keyframeDataItems, e["keyframeDataItemsJson"], KeyframeDataItem, this), this._LinkKeyframeDataItems());
    }
  };
}
{
  const C32 = self.C3, VALUE_DATA = 0, VALUE_DATA_VALUE = 0, VALUE_DATA_ABSOLUTE_VALUE = 1, VALUE_DATA_TYPE = 2, TIME = 1, EASE = 2, ENABLE = 3, ADDONS = 4, PATH_MODE = 5;
  class PropertyKeyframeDataItem {
    constructor(e, t2) {
      this._propertyKeyframeData = t2, this._value = null, this._aValue = null, this._type = "", this._time = NaN, this._ease = "noease", this._enable = false, this._addonData = null, this._addonInstance = void 0, this._pathMode = "line", e && (this._value = e[0][0], this._aValue = e[0][1], this._type = e[0][2], this._time = e[1], this._ease = e[2], this._enable = !!e[3], this._pathMode = e[5], this._addonData = null, e[4] && (this._addonData = new C32.AddonData(e[4], this)), this._next = null, this._prev = null);
    }
    Release() {
      this._propertyKeyframeData = null, this._addonData && (this._addonData.Release(), this._addonData = null), this._next = null, this._prev = null;
    }
    GetAddonData() {
      return this._addonData;
    }
    SetNext(e) {
      this._next = e;
    }
    GetNext() {
      return this._next;
    }
    SetPrevious(e) {
      this._prev = e;
    }
    GetPrevious() {
      return this._prev;
    }
    GetValue() {
      return this._value;
    }
    SetValue(e) {
      "color" === this._type && C32.IsFiniteNumber(e) ? (this._value[0] = C32.GetRValue(e), this._value[1] = C32.GetGValue(e), this._value[2] = C32.GetBValue(e)) : this._value = e;
    }
    GetAbsoluteValue() {
      return this._aValue;
    }
    SetAbsoluteValue(e) {
      "color" === this._type && C32.IsFiniteNumber(e) ? (this._aValue[0] = C32.GetRValue(e), this._aValue[1] = C32.GetGValue(e), this._aValue[2] = C32.GetBValue(e)) : this._aValue = e;
    }
    GetValueWithResultMode() {
      const e = this._propertyKeyframeData.GetPropertyTrackDataItem().GetResultMode();
      return "relative" === e ? this.GetValue() : "absolute" === e ? this.GetAbsoluteValue() : void 0;
    }
    GetType() {
      return this._type;
    }
    SetType(e) {
      this._type = e;
    }
    GetTime() {
      return this._time;
    }
    SetTime(e) {
      this._time = e, this._propertyKeyframeData._LinkPropertyKeyframeDataItems();
    }
    GetEase() {
      return this._ease;
    }
    SetEase(e) {
      this._ease = e;
    }
    GetEnable() {
      return this._enable;
    }
    SetEnable(e) {
      this._enable = !!e;
    }
    GetPathMode() {
      return this._pathMode;
    }
    GetAddOn(e) {
      if (!this._addonData) return;
      if (this._addonInstance || null === this._addonInstance) return this._addonInstance;
      const t2 = this._addonData.GetAddDataItemArray();
      if (!t2) return this._addonInstance = null, this._addonInstance;
      const a2 = t2.length;
      for (let r2 = 0; r2 < a2; r2++) {
        const a3 = t2[r2];
        if (a3.GetId() === e) return this._addonInstance = a3, this._addonInstance;
      }
      return this._addonInstance = null, this._addonInstance;
    }
    _SaveToJson() {
      const e = this._addonData;
      return { "addonDataJson": e ? e._SaveToJson() : e, "value": this._value, "aValue": this._aValue, "type": this._type, "time": this._time, "ease": this._ease, "enable": this._enable };
    }
    _LoadFromJson(e) {
      e && (e["addonDataJson"] && this._addonData._SetFromJson(e["addonDataJson"]), this._value = e["value"], this._aValue = e["aValue"], this._type = e["type"], this._time = e["time"], this._ease = e["ease"], this._enable = e["enable"]);
    }
  }
  C32.PropertyKeyframeData = class {
    constructor(e, t2) {
      this._propertyTrackDataItem = t2, this._propertyKeyframeDataItems = [], this._propertyKeyframeDataItemsIncludingDisabled = [], C32.TimelineDataManager._CreateDataItems(this._propertyKeyframeDataItems, e, PropertyKeyframeDataItem, this), C32.TimelineDataManager._CreateDataItemsIncludingDisabled(this._propertyKeyframeDataItemsIncludingDisabled, e, PropertyKeyframeDataItem, this), this._LinkPropertyKeyframeDataItems();
    }
    Release() {
      this._propertyTrackDataItem = null;
      for (const e of this._propertyKeyframeDataItems) e.Release();
      C32.clearArray(this._propertyKeyframeDataItems), this._propertyKeyframeDataItems = null;
      for (const e of this._propertyKeyframeDataItemsIncludingDisabled) e.Release();
      C32.clearArray(this._propertyKeyframeDataItemsIncludingDisabled), this._propertyKeyframeDataItemsIncludingDisabled = null;
    }
    _LinkPropertyKeyframeDataItems() {
      let e = this._propertyKeyframeDataItems;
      e.sort((e2, t2) => e2.GetTime() - t2.GetTime());
      for (let t2 = 0; t2 < e.length; t2++) {
        const a2 = e[t2];
        t2 + 1 < e.length && a2.SetNext(e[t2 + 1]), t2 - 1 >= 0 && a2.SetPrevious(e[t2 - 1]);
      }
      e = this._propertyKeyframeDataItemsIncludingDisabled, e.sort((e2, t2) => e2.GetTime() - t2.GetTime());
      for (let t2 = 0; t2 < e.length; t2++) {
        const a2 = e[t2];
        t2 + 1 < e.length && a2.SetNext(e[t2 + 1]), t2 - 1 >= 0 && a2.SetPrevious(e[t2 - 1]);
      }
    }
    AddEmptyPropertyKeyframeDataItem() {
      const e = new PropertyKeyframeDataItem(null, this);
      return this._propertyKeyframeDataItems.push(e), this._LinkPropertyKeyframeDataItems(), e;
    }
    DeletePropertyKeyframeDataItems(e) {
      for (const t2 of this._propertyKeyframeDataItems) {
        if (!e(t2)) continue;
        const a2 = this._propertyKeyframeDataItems.indexOf(t2);
        -1 !== a2 && (t2.Release(), this._propertyKeyframeDataItems.splice(a2, 1));
      }
      this.SortPropertyKeyFrameDataItems(), this._LinkPropertyKeyframeDataItems();
    }
    SortPropertyKeyFrameDataItems() {
      this._propertyKeyframeDataItems.sort((e, t2) => e.GetTime() - t2.GetTime());
    }
    GetPropertyTrackDataItem() {
      return this._propertyTrackDataItem;
    }
    GetPropertyKeyframeDataItemCount() {
      return this._propertyKeyframeDataItems.length;
    }
    GetLastPropertyKeyframeDataItem() {
      return this._propertyKeyframeDataItems[this._propertyKeyframeDataItems.length - 1];
    }
    GetPropertyKeyframeDataItemArray() {
      return this._propertyKeyframeDataItems;
    }
    GetPropertyKeyframeDataItemArrayIncludingDisabled() {
      return this._propertyKeyframeDataItemsIncludingDisabled;
    }
    *propertyKeyframeDataItems() {
      for (const e of this._propertyKeyframeDataItems) yield e;
    }
    *propertyKeyframeDataItemsReverse() {
      for (let e = this._propertyKeyframeDataItems.length - 1; e >= 0; e--) yield this._propertyKeyframeDataItems[e];
    }
    _SaveToJson() {
      const e = this._propertyKeyframeDataItems, t2 = this._propertyKeyframeDataItemsIncludingDisabled;
      return { "propertyKeyframeDataItemsJson": e.map((e2) => e2._SaveToJson()), "propertyKeyframeDataItemsIncludingDisabledJson": t2.map((e2) => e2._SaveToJson()) };
    }
    _LoadFromJson(e) {
      e && (C32.TimelineDataManager._LoadDataItemsFromJson(this._propertyKeyframeDataItems, e["propertyKeyframeDataItemsJson"], PropertyKeyframeDataItem, this), C32.TimelineDataManager._LoadDataItemsFromJson(this._propertyKeyframeDataItemsIncludingDisabled, e["propertyKeyframeDataItemsIncludingDisabledJson"], PropertyKeyframeDataItem, this), this._LinkPropertyKeyframeDataItems());
    }
  };
}
{
  const C32 = self.C3, ADDON_ID = 0, ADDON_DATA = 1;
  class AddonDataItem {
    constructor(t2, a2) {
      this._addonData = a2, this._id = t2[0], this._data = t2[1];
    }
    Release() {
      this._addonData = null, this._data = null;
    }
    GetAddonData() {
      return this._addonData;
    }
    GetId() {
      return this._id;
    }
    _SaveToJson() {
      return { "id": this._id, "data": this._data };
    }
    _LoadFromJson(t2) {
      t2 && (this._id = t2["id"], this._data = t2["data"]);
    }
  }
  const START_ANCHOR = 0, START_ENABLE = 1, END_ANCHOR = 2, END_ENABLE = 3;
  class AddonDataCubicBezierItem extends AddonDataItem {
    constructor(t2, a2) {
      super(t2, a2), this._startAnchor = this._data[0], this._startEnable = !!this._data[1], this._endAnchor = this._data[2], this._endEnable = !!this._data[3];
    }
    Release() {
      super.Release();
    }
    GetStartAnchor() {
      return this._startAnchor;
    }
    GetStartEnable() {
      return this._startEnable;
    }
    GetEndAnchor() {
      return this._endAnchor;
    }
    GetEndEnable() {
      return this._endEnable;
    }
    _SaveToJson() {
      return Object.assign(super._SaveToJson(), { "startAnchor": this._startAnchor, "startEnable": !!this._startEnable, "endAnchor": this._endAnchor, "endEnable": !!this._endEnable });
    }
    _LoadFromJson(t2) {
      t2 && (super._LoadFromJson(t2), this._startAnchor = t2["startAnchor"], this._startEnable = !!t2["startEnable"], this._endAnchor = t2["endAnchor"], this._endEnable = !!t2["endEnable"]);
    }
  }
  const DIRECTION = 0, REVOLUTIONS = 1;
  class AddonDataAngleItem extends AddonDataItem {
    constructor(t2, a2) {
      super(t2, a2), this._direction = this._data[0], this._revolutions = this._data[1];
    }
    Release() {
      super.Release();
    }
    GetDirection() {
      return this._direction;
    }
    GetRevolutions() {
      return this._revolutions;
    }
    _SaveToJson() {
      return Object.assign(super._SaveToJson(), { "direction": this._direction, "revolutions": this._revolutions });
    }
    _LoadFromJson(t2) {
      t2 && (super._LoadFromJson(t2), this._direction = t2["direction"], this._revolutions = t2["revolutions"]);
    }
  }
  C32.AddonData = class {
    constructor(t2, a2) {
      this._propertyKeyframeDataItem = a2, this._addonDataItems = [], C32.TimelineDataManager._CreateDataItems(this._addonDataItems, t2, { prop: 0, map: /* @__PURE__ */ new Map([["cubic-bezier", AddonDataCubicBezierItem], ["angle", AddonDataAngleItem]]) }, this);
    }
    Release() {
      this._propertyKeyframeDataItem = null;
      for (const t2 of this._addonDataItems) t2.Release();
      C32.clearArray(this._addonDataItems), this._addonDataItems = null;
    }
    GetPropertyKeyframeDataItem() {
      return this._propertyKeyframeDataItem;
    }
    GetAddDataItemArray() {
      return this._addonDataItems;
    }
    *addonDataItems() {
      for (const t2 of this._addonDataItems) yield t2;
    }
    _SaveToJson() {
      return { "addonDataItemsJson": this._addonDataItems.map((t2) => t2._SaveToJson()) };
    }
    _LoadFromJson(t2) {
      t2 && C32.TimelineDataManager._LoadDataItemsFromJson(this._addonDataItems, t2["addonDataItemsJson"], { prop: "id", map: /* @__PURE__ */ new Map([["cubic-bezier", AddonDataCubicBezierItem], ["angle", AddonDataAngleItem]]) }, this);
    }
  };
}
{
  const C32 = self.C3, INITIAL_VALUE_MODE_START_VALUE = "start-value", INITIAL_VALUE_MODE_CURRENT_STATE = "current-state", PING_PONG_BEGIN = 0, PING_PONG_END = 1;
  let createdTweens = 0;
  C32.TweenState = class extends C32.TimelineState {
    constructor(e, t2) {
      super("tween-" + createdTweens++, e, t2), this._id = "", this._destroyInstanceOnComplete = false, this._initialValueMode = "start-value", this._instance = null, this._on_completed_callbacks = null, this._on_started_callbacks = null, this._releasePromise = null, this._releaseResolve = null, this._behInst = null, this._track = null, this._iTweenState = null;
    }
    Release() {
      this.IsReleased() || (this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensReleased), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweensReleased), this.ResolveReleasePromise(), super.Release(), this._instance = null, this._on_completed_callbacks = null, this._on_started_callbacks = null, this._behInst = null, this._track = null, this._releasePromise = null, this._releaseResolve = null);
    }
    FireReleaseEvent(e) {
      const t2 = C32.New(C32.Event, "tweenstatereleased");
      t2.tweenState = this, e.dispatchEvent(t2);
    }
    GetType() {
      return 1;
    }
    CreateTrackStates() {
      for (const e of this._timelineDataItem.GetTrackData().trackDataItems()) this._tracks.push(C32.TweenTrackState.Create(this, e));
      this._track = this._tracks[0];
    }
    AddTrack() {
      const e = this._timelineDataItem.GetTrackData().AddEmptyTrackDataItem(), t2 = C32.TweenTrackState.Create(this, e);
      return this._tracks.push(t2), this._CacheTrack(), t2;
    }
    _CacheTrack() {
      this._track = this._tracks[0];
    }
    GetPropertyTrack(e) {
      return this._track.GetPropertyTracks()[0];
    }
    SetPropertyType(e) {
      this._propertyType = e;
    }
    GetInstance() {
      const e = this.GetTracks();
      if (!e || !e.length) return;
      const t2 = e[0];
      if (this._track = t2, !t2) return;
      const s = t2.GetInstance();
      return t2.IsInstanceValid() ? s : void 0;
    }
    SetBehaviorInstance(e) {
      this._behInst = e;
    }
    GetReleasePromise() {
      return this._releasePromise || (this._releasePromise = new Promise((e) => {
        this._releaseResolve = e;
      })), this._releasePromise;
    }
    ResolveReleasePromise() {
      this._releasePromise && (this._releaseResolve && this._releaseResolve(), this._releasePromise = null, this._releaseResolve = null);
    }
    AddStartedCallback(e) {
      this._on_started_callbacks || (this._on_started_callbacks = []), this._on_started_callbacks.push(e);
    }
    AddCompletedCallback(e) {
      this._on_completed_callbacks || (this._on_completed_callbacks = []), this._on_completed_callbacks.push(e);
    }
    RemoveStartedCallback(e) {
      if (!this._on_started_callbacks) return;
      const t2 = this._on_started_callbacks.indexOf(e);
      -1 !== t2 && this._on_started_callbacks.splice(t2, 1);
    }
    RemoveCompletedCallback(e) {
      if (!this._on_completed_callbacks) return;
      const t2 = this._on_completed_callbacks.indexOf(e);
      -1 !== t2 && this._on_completed_callbacks.splice(t2, 1);
    }
    SetStartValue(e, t2) {
      for (const s of this._tracks) for (const n of s._propertyTracks) {
        if (n.GetPropertyName() !== t2) continue;
        const s2 = n.GetPropertyTrackData(), i = n.GetPropertyTrackDataItem(), a2 = s2.GetFirstPropertyKeyframeDataItem(i);
        a2.SetValue(e), a2.SetAbsoluteValue(e);
      }
    }
    _GetPropertyTrackState(e) {
      for (const t2 of this._tracks) for (const s of t2._propertyTracks) if (s.GetPropertyName() === e) return s;
    }
    BeforeSetEndValues(e) {
      let t2 = false;
      for (const s of e) {
        const e2 = this._GetPropertyTrackState(s);
        e2 && (this.SetStartValue(e2.GetCurrentState(), s), t2 = true);
      }
      if (t2) {
        if (this.IsForwardPlayBack()) {
          const e2 = this.GetTotalTime() - this.GetTime();
          this.SetTotalTime(e2);
          for (const t3 of this._tracks) t3.SetLocalTotalTime(e2);
          this._SetTime(0);
        } else {
          const e2 = this.GetTime();
          this.SetTotalTime(e2);
          for (const t3 of this._tracks) t3.SetLocalTotalTime(e2);
          this._SetTime(e2);
        }
        this.SetInitialStateFromSetTime();
      }
    }
    SetEndValue(e, t2) {
      const s = this._GetPropertyTrackState(t2);
      if (!s) return;
      const n = s.GetPropertyTrackData(), i = s.GetPropertyTrackDataItem(), a2 = n.GetLastPropertyKeyframeDataItem(i);
      a2.SetTime(this.GetTotalTime()), a2.SetValue(e), a2.SetAbsoluteValue(e);
    }
    SetId(e) {
      this._id = e;
    }
    GetId() {
      return this._id;
    }
    SetInitialValueMode(e) {
      this._initialValueMode = e;
    }
    GetInitialValueMode() {
      return this._initialValueMode;
    }
    SetDestroyInstanceOnComplete(e) {
      this._destroyInstanceOnComplete = e;
    }
    GetDestroyInstanceOnComplete() {
      return this._destroyInstanceOnComplete;
    }
    OnStarted() {
      if (this._on_started_callbacks) for (const e of this._on_started_callbacks) e(this);
      if (!this.IsComplete()) for (const e of this._tracks) e.CompareSaveStateWithCurrent();
    }
    OnCompleted() {
      this._completedTick = this._runtime.GetTickCount();
    }
    FinishTriggers() {
      if (!this._finishedTriggers && (this._finishedTriggers = true, this._on_completed_callbacks)) for (const e of this._on_completed_callbacks) e(this);
    }
    SetTime(e) {
      this._DeleteIntermediateKeyframes(), super.SetTime(e);
    }
    _SetTimeAndReset(e) {
      C32.IsFiniteNumber(e) || (e = this.GetTotalTime()), e < 0 ? this._playheadTime = 0 : e >= this.GetTotalTime() ? this._playheadTime = this.GetTotalTime() : this._playheadTime = e, this._track.SetResetState();
    }
    SetInitialState(e) {
      if (!this.InitialStateSet() && "current-state" === this.GetInitialValueMode()) for (const e2 of this._tracks) e2.CompareInitialStateWithCurrent();
      super.SetInitialState(e);
    }
    Stop(e = false) {
      if (super.Stop(e), !this.IsComplete()) for (const e2 of this._tracks) e2.SaveState();
    }
    Reset(e = true, t2 = false) {
      this._DeleteIntermediateKeyframes(), super.Reset(e, t2);
    }
    _DeleteIntermediateKeyframes() {
      for (const e of this._tracks) {
        const t2 = (e2) => {
          const t3 = e2.GetTime(), s = this.GetTotalTime();
          return 0 !== t3 && t3 !== s;
        };
        e.DeleteKeyframes(t2), e.DeletePropertyKeyframes(t2);
      }
    }
    _OnBeforeChangeLayout() {
      if (this.IsReleased()) return true;
      const e = this.GetInstance();
      return (!e || !e.GetObjectClass().IsGlobal()) && (this._timelineManager.CompleteTimelineBeforeChangeOfLayout(this), this.ResetBeforeChangeLayout(), true);
    }
    Tick(e, t2, s) {
      if (this._instance || (this._instance = this.GetInstance()), !this._instance || this._instance.IsDestroyed()) return this.Stop(true), void this.OnCompleted();
      const n = this._instance.GetTimeScale();
      if (-1 !== n && (e = s * n), 0 === e && 0 === this._lastDelta) return;
      this._lastDelta = e;
      const i = this._playheadTime + this._overshoot + e * this._playbackRate, a2 = this._timelineDataItem._totalTime;
      i < 0 ? (this._playheadTime = 0, this._overshoot = -i) : i >= a2 ? (this._playheadTime = a2, this._overshoot = this._playheadTime - i) : (this._playheadTime = i, this._overshoot = 0);
      let r2 = false, o2 = false;
      const h2 = this.GetLoop(), l = this.GetPingPong();
      if (h2 || l ? h2 && !l ? this._playbackRate > 0 ? this._playheadTime >= a2 && (this._SetTimeAndReset(0), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensLoop), o2 = true) : this._playheadTime <= 0 && (this._SetTimeAndReset(a2), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensLoop), o2 = true) : !h2 && l ? this._playbackRate > 0 ? this._playheadTime >= a2 && (this._SetTime(a2), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), o2 = true, 1 === this._pingPongState ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensLoop), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensPingPong), this.IsPlaying() ? this._pingPongState = 0 : this._resumePingPongState = 0) : (this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensPingPong), r2 = true) : 0 === this._pingPongState && (this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensPingPong), this.IsPlaying() ? this._pingPongState = 1 : this._resumePingPongState = 1)) : this._playheadTime <= 0 && (this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), o2 = true, 1 === this._pingPongState ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensLoop), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensPingPong), this.IsPlaying() ? this._pingPongState = 0 : this._resumePingPongState = 0) : (r2 = true, this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensPingPong)) : 0 === this._pingPongState && (this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensPingPong), this.IsPlaying() ? this._pingPongState = 1 : this._resumePingPongState = 1)) : h2 && l && (this._playbackRate > 0 ? this._playheadTime >= a2 && (this._SetTime(a2), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), o2 = true, 0 === this._pingPongState && (this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensPingPong)), 1 === this._pingPongState && (this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensLoop), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensPingPong)), this.IsPlaying() ? (this._pingPongState++, this._pingPongState = C32.wrap(this._pingPongState, 0, 2)) : (this._resumePingPongState = this._pingPongState + 1, this._resumePingPongState = C32.wrap(this._resumePingPongState, 0, 2))) : this._playheadTime <= 0 && (this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), o2 = true, 0 === this._pingPongState && (this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensPingPong)), 1 === this._pingPongState && (this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensLoop), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensPingPong)), this.IsPlaying() ? (this._pingPongState++, this._pingPongState = C32.wrap(this._pingPongState, 0, 2)) : (this._resumePingPongState = this._pingPongState + 1, this._resumePingPongState = C32.wrap(this._resumePingPongState, 0, 2)))) : this._playbackRate > 0 ? this._playheadTime >= a2 && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._SetTimeAndReset(0), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensLoop), o2 = true) : (this._SetTime(a2), r2 = true)) : this._playheadTime <= 0 && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._SetTimeAndReset(a2), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C32.Behaviors.Tween.Cnds.OnTweensLoop), o2 = true) : (this._SetTime(0), r2 = true)), !this.IsReleased() && this.IsPlaying()) {
        if (r2) return this._track.SetEndState(), this.Stop(true), void this.OnCompleted();
        this._track.Interpolate(this._playheadTime, true, false, o2, this._firstTick, false), this._firstTick && (this._firstTick = false);
      }
    }
    _TweenTrigger(e) {
      const t2 = this.GetInstance();
      this._behInst.PushTriggerTween(this), this._runtime.Trigger(e, t2, this._behInst.GetBehaviorType()), this._behInst.PopTriggerTween();
    }
    _SaveToJson() {
      const e = super._SaveToJson(), t2 = this.GetTimelineDataItem();
      return Object.assign(e, { "tweenDataItemJson": t2._SaveToJson(), "id": this._id, "destroyInstanceOnComplete": this._destroyInstanceOnComplete, "initialValueMode": this._initialValueMode });
    }
    _LoadFromJson(e) {
      if (!e) return;
      this.GetTimelineDataItem()._LoadFromJson(e["tweenDataItemJson"]), super._LoadFromJson(e), this._id = e["id"], this._destroyInstanceOnComplete = e["destroyInstanceOnComplete"], this._initialValueMode = e["initialValueMode"], this._CacheTrack();
    }
    static IsPlaying(e) {
      return e.IsPlaying();
    }
    static IsPaused(e) {
      return e.IsPaused();
    }
    static IsPing(e) {
      return !!e.GetPingPong() && 0 === e.GetPingPongState();
    }
    static IsPong(e) {
      return !!e.GetPingPong() && 1 === e.GetPingPongState();
    }
    static Build(e) {
      const t2 = e.runtime.GetTimelineManager(), s = new C32.TimelineDataItem();
      if (e.json) {
        s._LoadFromJson(e.json["tweenDataItemJson"]);
        const n = new C32.TweenState(s, t2);
        return n._LoadFromJson(e.json), n;
      }
      {
        const n = new C32.TweenState(s, t2);
        C32.IsArray(e.propertyTracksConfig) || (e.propertyTracksConfig = [e.propertyTracksConfig]), n.SetId(e.id), n.SetTags(e.tags), n.SetInitialValueMode(e.initialValueMode), n.SetDestroyInstanceOnComplete(e.releaseOnComplete), n.SetLoop(e.loop), n.SetPingPong(e.pingPong), n.SetTotalTime(e.time), n.SetStep(0), n.SetInterpolationMode("default"), n.SetResultMode(e.propertyTracksConfig[0].resultMode), n.SetRepeatCount(e.repeatCount);
        const i = n.AddTrack();
        i.SetInstanceUID(e.instance.GetUID()), i.SetInterpolationMode("default"), i.SetResultMode(e.propertyTracksConfig[0].resultMode), i.SetEnable(true), i.SetObjectClassIndex(e.instance.GetObjectClass().GetIndex());
        const a2 = e.instance.GetSdkInstance(), r2 = a2.IsOriginalSizeKnown() ? a2.GetOriginalWidth() : e.instance.GetWorldInfo().GetWidth(), o2 = a2.IsOriginalSizeKnown() ? a2.GetOriginalHeight() : e.instance.GetWorldInfo().GetHeight();
        i.SetOriginalWidth(r2), i.SetOriginalHeight(o2);
        const h2 = i.AddKeyframe();
        h2.SetTime(0), h2.SetEase("noease"), h2.SetEnable(true), h2.SetTags("");
        const l = i.AddKeyframe();
        l.SetTime(e.time), l.SetEase("noease"), l.SetEnable(true), l.SetTags("");
        for (const t3 of e.propertyTracksConfig) {
          const s2 = i.AddPropertyTrack();
          s2.SetSourceAdapterId(t3.sourceId), s2.SetSourceAdapterArgs(t3.sourceArgs), s2.SetPropertyName(t3.property), s2.SetPropertyType(t3.type), s2.SetMin(NaN), s2.SetMax(NaN), s2.SetInterpolationMode("default"), s2.SetResultMode(t3.resultMode), s2.SetEnable(true);
          const n2 = s2.AddPropertyKeyframe();
          n2.SetType(t3.valueType), n2.SetTime(0), n2.SetEase(t3.ease), n2.SetEnable(true), n2.SetValue(t3.startValue), n2.SetAbsoluteValue(t3.startValue);
          const a3 = s2.AddPropertyKeyframe();
          a3.SetType(t3.valueType), a3.SetTime(e.time), a3.SetEase(t3.ease), a3.SetEnable(true), a3.SetValue(t3.endValue), a3.SetAbsoluteValue(t3.endValue), s2.GetSourceAdapter();
        }
        return n;
      }
    }
    static SetInstanceUID(e, t2) {
      if (!isNaN(t2)) for (const s of e.GetTracks()) s.SetInstanceUID(t2);
    }
    static SetBehaviorInstance(e, t2) {
      e.SetBehaviorInstance(t2);
    }
    GetITweenState(e, t2) {
      return this._iTweenState || (this._iTweenState = C32.New(self.ITweenState, this, e, t2)), this._iTweenState;
    }
  };
}
{
  const C32 = self.C3;
  C32.TweenTrackState = class extends C32.TrackState {
    constructor(t2, e) {
      super(t2, e), this._firstPropertyTrack = null, this._secondPropertyTrack = null;
    }
    static Create(t2, e) {
      return C32.New(C32.TweenTrackState, t2, e);
    }
    _CachePropertyTracks() {
      1 === this._propertyTracks.length ? this._firstPropertyTrack = this._propertyTracks[0] : (this._firstPropertyTrack = this._propertyTracks[0], this._secondPropertyTrack = this._propertyTracks[1]);
    }
    CreatePropertyTrackStates() {
      for (const t2 of this._trackDataItem.GetPropertyTrackData().propertyTrackDataItems()) this._propertyTracks.push(C32.TweenPropertyTrackState.Create(this, t2));
      this._CachePropertyTracks();
    }
    AddPropertyTrack() {
      const t2 = this._trackDataItem.GetPropertyTrackData().AddEmptyPropertyTrackDataItem(), e = C32.TweenPropertyTrackState.Create(this, t2);
      return this._propertyTracks.push(e), this._CachePropertyTracks(), e;
    }
    SetInitialState() {
      if (this.MaybeGetInstance(), !this.IsInstanceValid() && this.IsInstanceTrack()) return;
      const t2 = this.GetTimeline().IsForwardPlayBack() ? 0 : this.GetLocalTotalTime();
      for (const e of this._propertyTracks) e.SetInitialState(t2), 0 === this._worldInfoChange && 1 === e.GetWorldInfoChange() && (this._worldInfoChange = 1), 0 === this._renderChange && 1 === e.GetRenderChange() && (this._renderChange = 1);
      this._needsBeforeAndAfter = 0;
      this._propertyTracks.some((t3) => t3.GetNeedsBeforeAndAfter()) && (this._needsBeforeAndAfter = 1), this._lastKeyframeDataItem = this._GetLastKeyFrameBeforeTime(t2), this._initialStateOfNestedSet = false, this._endStateOfNestedSet = false, this.Interpolate(t2);
    }
    BeforeInterpolate() {
    }
    Interpolate(t2, e = false, r2 = false, s = false, a2 = false, o2 = false, n = false) {
      if (this._instance || this.GetInstance(), !this._instance) return;
      return !this._instance.IsDestroyed() && ((!o2 || !this.GetObjectClass().IsGlobal()) && (this._secondPropertyTrack ? (this._firstPropertyTrack.Interpolate(t2, r2, s, n), this._secondPropertyTrack.Interpolate(t2, r2, s, n)) : this._firstPropertyTrack.Interpolate(t2, r2, s, n), void (0 !== this._firstPropertyTrack.GetWorldInfoChange() && (this._worldInfo || (this._worldInfo = this._instance.GetWorldInfo()), this._worldInfo && this._worldInfo.SetBboxChanged()))));
    }
    AfterInterpolate() {
    }
    _LoadFromJson(t2) {
      super._LoadFromJson(t2), this._CachePropertyTracks();
    }
  };
}
{
  const C32 = self.C3;
  C32.TweenPropertyTrackState = class extends C32.PropertyTrackState {
    constructor(t2, e) {
      super(t2, e), this._basic = false;
    }
    static Create(t2, e) {
      return C32.New(C32.TweenPropertyTrackState, t2, e);
    }
    Interpolate(t2, e = false, r2 = false, a2 = false) {
      let s, o2;
      if (this._basic) s = this._propertyKeyframeDataItems[0], o2 = this._propertyKeyframeDataItems[1];
      else if (e) s = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(t2, this._propertyTrackDataItem), o2 = s.GetNext();
      else {
        if (this._lastPropertyKeyframeDataItem) {
          const e2 = this.GetTimeline(), r3 = this._lastPropertyKeyframeDataItem.GetNext(), a3 = this._lastPropertyKeyframeDataItem.GetTime(), s2 = r3 ? r3.GetTime() : e2.GetTotalTime();
          (t2 <= a3 || t2 >= s2) && (this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(t2, this._propertyTrackDataItem));
        } else this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(t2, this._propertyTrackDataItem);
        s = this._lastPropertyKeyframeDataItem, o2 = s.GetNext();
      }
      this._sourceAdapter.Interpolate(t2, s, o2, e, r2, a2);
    }
    AddPropertyKeyframe() {
      const t2 = this._propertyTrackDataItem.GetPropertyKeyframeData().AddEmptyPropertyKeyframeDataItem();
      return this._lastPropertyKeyframeDataItem = null, this._basic = this.GetPropertyKeyframeDataItems().length <= 2, t2;
    }
    DeletePropertyKeyframes(t2) {
      this._lastPropertyKeyframeDataItem = null;
      this._propertyTrackDataItem.GetPropertyKeyframeData().DeletePropertyKeyframeDataItems(t2), this._basic = this.GetPropertyKeyframeDataItems().length <= 2;
    }
    _SaveToJson() {
      return { "sourceAdapterJson": this.GetSourceAdapter()._SaveToJson(), "basic": this._basic };
    }
    _LoadFromJson(t2) {
      t2 && (this.GetSourceAdapter()._LoadFromJson(t2["sourceAdapterJson"]), this._basic = t2["basic"]);
    }
  };
}
{
  const C32 = self.C3, Ease = self.Ease, NAME = 0, TRANSITION_KEYFRAMES = 1, LINEAR = 2;
  C32.Transition = class extends C32.DefendedBase {
    constructor(e, t2 = true) {
      super(), this._name = e[0], this._linear = e[2], this._transitionKeyframes = [];
      for (const t3 of e[1]) {
        const e2 = C32.TransitionKeyframe.Create(this, t3);
        this._transitionKeyframes.push(e2);
      }
      for (let e2 = 0; e2 < this._transitionKeyframes.length; e2++) {
        const t3 = this._transitionKeyframes[e2], a2 = this._transitionKeyframes[e2 + 1], s = this._transitionKeyframes[e2 - 1];
        t3.SetNext(a2), t3.SetPrevious(s);
      }
      this._precalculatedSamples = /* @__PURE__ */ new Map(), this._transitionKeyframeCache = /* @__PURE__ */ new Map(), this._PreCalcSamples(), t2 && Ease.AddCustomEase(this._name, (e2, t3, a2, s) => this.Interpolate(e2, t3, a2, s), null, { transition: this });
    }
    static Create(e) {
      return C32.New(C32.Transition, e);
    }
    Release() {
      for (const e of this._transitionKeyframes) e.Release();
      C32.clearArray(this._transitionKeyframes), this._transitionKeyframes = null, this._precalculatedSamples.clear(), this._precalculatedSamples = null, this._transitionKeyframeCache.clear(), this._transitionKeyframeCache = null;
    }
    MakeLinear(e) {
      this._linear = !!e;
    }
    GetTransitionKeyFrameAt(e) {
      const t2 = this._transitionKeyframeCache.get(e);
      if (t2) return t2;
      for (const t3 of this._transitionKeyframes) if (t3.GetValueX() === e) return this._transitionKeyframeCache.set(e, t3), t3;
    }
    GetFirstTransitionKeyFrameLowerOrEqualThan(e) {
      for (let t2 = this._transitionKeyframes.length - 1; t2 >= 0; t2--) {
        const a2 = this._transitionKeyframes[t2], s = a2.GetValueX();
        if (s <= e) {
          let t3 = a2;
          if (s < e) return t3;
          if (s === e) {
            for (; t3; ) {
              const e2 = t3.GetPrevious();
              if (!e2) break;
              if (e2.GetValueX() !== t3.GetValueX()) break;
              t3 = e2;
            }
            return t3;
          }
        }
      }
    }
    Interpolate(e, t2, a2, s) {
      let n = e / s;
      if (this._linear) {
        const n2 = this.GetTransitionKeyFrameAt(0), r3 = this.GetTransitionKeyFrameAt(1), i2 = t2 + (t2 + a2) * n2.GetValueY(), l2 = (t2 + a2) * r3.GetValueY() - i2;
        return 0 === s ? i2 + l2 : Ease.NoEase(e, i2, l2, s);
      }
      0 === s && (n = 1);
      let r2 = this.GetFirstTransitionKeyFrameLowerOrEqualThan(n), i = r2.GetNext();
      if (!i) {
        const e2 = r2.GetPrevious(), t3 = r2;
        r2 = e2, i = t3;
      }
      const l = i.GetValueX() - r2.GetValueX(), o2 = C32.mapToRange(n, r2.GetValueX(), i.GetValueX(), 0, l);
      if (r2.IsSegmentLinear() || 0 === l) {
        const e2 = t2 + (t2 + a2) * r2.GetValueY(), s2 = (t2 + a2) * i.GetValueY() - e2;
        return 0 === l ? 1 === o2 ? e2 + s2 : e2 : Ease.NoEase(o2, e2, s2, l);
      }
      const h2 = r2.GetValueX(), u2 = r2.GetValueY(), c2 = r2.GetValueX() + r2.GetStartAnchorX(), f2 = r2.GetValueY() + r2.GetStartAnchorY(), G = i.GetValueX() + i.GetEndAnchorX(), m2 = i.GetValueY() + i.GetEndAnchorY(), _2 = i.GetValueX(), y2 = i.GetValueY();
      let K = Ease.GetRuntimeEase("spline")(o2, h2, u2, c2, f2, G, m2, _2, y2, this._precalculatedSamples.get(r2));
      return K += r2.GetValueY(), (1 - K) * t2 + K * (t2 + a2);
    }
    _PreCalcSamples() {
      this._precalculatedSamples.clear();
      for (let e = 0; e < this._transitionKeyframes.length - 1; e++) {
        const t2 = this._transitionKeyframes[e];
        if (!t2.GetStartEnable()) continue;
        const a2 = t2, s = this._transitionKeyframes[e + 1];
        if (!s.GetEndEnable()) continue;
        const n = a2.GetValueX(), r2 = a2.GetValueX() + a2.GetStartAnchorX(), i = s.GetValueX() + s.GetEndAnchorX(), l = s.GetValueX();
        this._precalculatedSamples.set(a2, Ease.GetBezierSamples(n, r2, i, l));
      }
    }
  };
}
{
  const C32 = self.C3, VALUE_X = 0, VALUE_Y = 1, START_ANCHOR_X = 2, START_ANCHOR_Y = 3, END_ANCHOR_X = 4, END_ANCHOR_Y = 5, START_ENABLE = 6, END_ENABLE = 7, SEGMENT_MODE = 8;
  C32.TransitionKeyframe = class extends C32.DefendedBase {
    constructor(t2, e) {
      super(), this._transition = t2, this._valueX = e[0], this._valueY = e[1], this._startAnchorX = e[2], this._startAnchorY = e[3], this._endAnchorX = e[4], this._endAnchorY = e[5], this._startEnable = e[6], this._endEnable = e[7], this._segmentMode = e[8], this._next = null, this._prev = null;
    }
    Release() {
      this._transition = null;
    }
    static Create(t2, e) {
      return C32.New(C32.TransitionKeyframe, t2, e);
    }
    SetNext(t2) {
      this._next = t2;
    }
    GetNext() {
      return this._next;
    }
    SetPrevious(t2) {
      this._prev = t2;
    }
    GetPrevious() {
      return this._prev;
    }
    GetValueX() {
      return this._valueX;
    }
    GetValueY() {
      return this._valueY;
    }
    GetStartAnchorX() {
      return this._startAnchorX;
    }
    GetStartAnchorY() {
      return this._startAnchorY;
    }
    GetEndAnchorX() {
      return this._endAnchorX;
    }
    GetEndAnchorY() {
      return this._endAnchorY;
    }
    GetStartEnable() {
      return this._startEnable;
    }
    GetEndEnable() {
      return this._endEnable;
    }
    IsSegmentLinear() {
      return "linear" === this._segmentMode;
    }
    IsSegmentCubic() {
      return "cubic" === this._segmentMode;
    }
  };
}
{
  const C32 = self.C3;
  C32.TransitionManager = class extends C32.DefendedBase {
    constructor(s) {
      super(), this._runtime = s, this._transitions = [];
    }
    Release() {
      for (const s of this._transitions) s.Release();
      C32.clearArray(this._transitions), this._transitions = null;
    }
    Create(s) {
      this._transitions.push(C32.Transition.Create(s));
    }
  };
}
{
  const C32 = self.C3;
  C32.TemplateManager = class extends C32.DefendedBase {
    constructor(e) {
      super(), this._runtime = e, this._templateDataMap = null, this._instanceToTemplateNameMap = null, this._instanceDestroy = (e2) => this._OnInstanceDestroy(e2.instance);
    }
    Release() {
      if (this.RemoveRuntimeListeners(), this._templateDataMap) {
        for (const e of this._templateDataMap.values()) e.clear();
        this._templateDataMap.clear();
      }
      this._templateDataMap = null, this._runtime = null;
    }
    Create(e) {
      if (this._templateDataMap || (this._templateDataMap = /* @__PURE__ */ new Map()), !e) return;
      const t2 = e[0][16][0], a2 = e[1];
      this._templateDataMap.has(a2) || this._templateDataMap.set(a2, /* @__PURE__ */ new Map());
      this._templateDataMap.get(a2).set(t2, e);
    }
    AddRuntimeListeners() {
      const e = this._runtime.Dispatcher();
      e && e.addEventListener("instancedestroy", this._instanceDestroy);
    }
    RemoveRuntimeListeners() {
      const e = this._runtime.Dispatcher();
      e && e.removeEventListener("instancedestroy", this._instanceDestroy);
    }
    HasTemplates() {
      return !!this._templateDataMap && 0 !== this._templateDataMap.size;
    }
    GetTemplateData(e, t2) {
      let a2 = 0;
      if (a2 = e instanceof C32.ObjectClass ? e.GetIndex() : e, !this._templateDataMap.has(a2)) return;
      const s = this._templateDataMap.get(a2).get(t2);
      return s ? JSON.parse(JSON.stringify(s)) : void 0;
    }
    MapInstanceToTemplateName(e, t2) {
      this._instanceToTemplateNameMap || (this._instanceToTemplateNameMap = /* @__PURE__ */ new WeakMap()), this._instanceToTemplateNameMap.has(e) || this._instanceToTemplateNameMap.set(e, t2);
    }
    GetInstanceTemplateName(e) {
      if (!this._instanceToTemplateNameMap) return "";
      const t2 = this._instanceToTemplateNameMap.get(e);
      return t2 || "";
    }
    _OnInstanceDestroy(e) {
      this._instanceToTemplateNameMap && this._instanceToTemplateNameMap.has(e) && this._instanceToTemplateNameMap.delete(e);
    }
  };
}
{
  const C32 = self.C3;
  C32.FlowchartManager = class {
    constructor(a2) {
      this._runtime = a2, this._flowchartDataManager = new C32.FlowchartDataManager();
    }
    Release() {
      this._flowchartDataManager.Release(), this._flowchartDataManager = null, this._runtime = null;
    }
    GetRuntime() {
      return this._runtime;
    }
    Create(a2) {
      this._flowchartDataManager.Add(a2);
    }
    GetFlowchartDataItemByName(a2) {
      return this._flowchartDataManager.Get(a2);
    }
    HasFlowcharts() {
      return this._flowchartDataManager.HasFlowcharts();
    }
  };
}
{
  const C32 = self.C3;
  C32.FlowchartState = class {
    constructor(t2, e, r2, a2, o2, h2, s) {
      this._runtime = o2.GetRuntime(), this._flowchartManager = o2, this._flowchartName = t2, this._startNodeTag = r2, this._flowchartDataItem = a2, this._tag = e, this._pluginInstance = h2, this._pluginUID = s ?? h2.GetInstance().GetUID(), this._SetStartFlowchartNode(), this._currentFlowchartNodeId = this._startFlowchartNode?.GetFlowchartId() ?? -1, this._previousFlowchartNodeIds = [], this._previousFlowchartState = null, this._previousFlowchartStateStartNodeId = NaN, this._referenceFlowchartStates = null, this._currentReferenceFlowchartState = null, this._rootFlowchartState = null, this._previousFlowchartStateTag = "", this._referenceFlowchartStatesJson = null, this._currentReferenceFlowchartStateTag = "", this._rootFlowchartStateTag = "", this._triggerCount = 0, this._markForRelease = false, this._released = false;
    }
    Release() {
      this._released || (C32.clearArray(this._previousFlowchartNodeIds), this._previousFlowchartNodeIds = null, this._runtime = null, this._flowchartManager = null, this._flowchartDataItem = null, this._pluginInstance = null, this._previousFlowchartState = null, this._previousFlowchartStateStartNodeId = NaN, this._referenceFlowchartStates && this._referenceFlowchartStates.clear(), this._referenceFlowchartStates = null, this._currentReferenceFlowchartState = null, this._rootFlowchartState = null, this._previousFlowchartStateTag = "", this._referenceFlowchartStatesJson = null, this._currentReferenceFlowchartStateTag = "", this._rootFlowchartStateTag = "", this._released = true);
    }
    WasReleased() {
      return this._released;
    }
    GetFlowchartManager() {
      return this._flowchartManager;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetName() {
      return this._flowchartName;
    }
    GetFlowchartDataItem() {
      return this._flowchartDataItem;
    }
    GetTag() {
      return this._tag;
    }
    GetPluginInstance() {
      return this._pluginInstance || (this._pluginInstance = this._runtime.GetInstanceByUID(this._pluginUID).GetSdkInstance()), this._pluginInstance;
    }
    GetCurrentNode() {
      return this.GetFlowchartElementById(this._currentFlowchartNodeId);
    }
    GetCurrentNodeTag() {
      const t2 = this.GetCurrentNode();
      return t2 ? t2.GetTag() : "";
    }
    GetCurrentNodeTags() {
      const t2 = this.GetCurrentNode();
      return t2 ? t2.GetTags() : [];
    }
    CurrentNodeHasTags(t2) {
      const e = this.GetCurrentNodeTags();
      if (!e) return false;
      if (!e.length) return false;
      const r2 = C32.FlowchartState._GetTagArray(t2);
      return !(!r2 || !r2.length) && r2.every(C32.FlowchartState._HasTag, e);
    }
    CurrentNodeCompareTags(t2, e) {
      const r2 = this.GetCurrentNodeTags();
      if (!r2) return false;
      if (!r2.length) return false;
      const a2 = C32.FlowchartState._GetTagArray(t2);
      return !(!a2 || !a2.length) && a2.every((t3) => C32.FlowchartState._CompareTag.call(r2, t3, e));
    }
    static _HasTag(t2) {
      const e = this;
      return "" === t2 ? 1 === e.length && "" === e[0] : e.map((t3) => t3.trim().toLowerCase()).includes(t2.trim().toLowerCase());
    }
    static _GetTagArray(t2) {
      return t2.trim().split(" ");
    }
    static _CompareTag(t2, e) {
      const r2 = this;
      return "" === t2 ? 1 === r2.length && "" === r2[0] : r2.some((r3) => C32.compare(r3.trim(), e, t2.trim()));
    }
    GetCurrentNodeParent(t2) {
      const e = this.GetCurrentNode();
      if (e) {
        if (C32.IsFiniteNumber(t2)) {
          const r2 = e.GetParentFlowchartIds(), a2 = r2 ? r2[t2] : void 0;
          if (C32.IsFiniteNumber(a2)) return this.GetFlowchartElementById(a2);
        }
        if ("string" == typeof t2) for (const r2 of e.GetParentFlowchartIds()) {
          const e2 = this.GetFlowchartElementById(r2);
          if (e2.HasTags(t2)) return this.GetFlowchartElementById(e2.GetFlowchartId());
        }
      }
    }
    GetCurrentNodeParentTag(t2) {
      const e = this.GetCurrentNodeParent(t2);
      return e ? e.GetTag() : "";
    }
    GetCurrentNodeParentTags(t2) {
      const e = this.GetCurrentNodeParent(t2);
      return e ? e.GetTags() : "";
    }
    GetCurrentNodeParentIndex(t2) {
      const e = this.GetCurrentNode();
      if (!e) return -1;
      const r2 = e.GetParentFlowchartIds();
      if (!r2) return -1;
      const a2 = this.GetCurrentNodeParent(t2);
      return a2 ? r2.indexOf(a2.GetFlowchartId()) : -1;
    }
    GetCurrentNodeParentCount() {
      const t2 = this.GetCurrentNode();
      if (!t2) return 0;
      const e = t2.GetParentFlowchartIds();
      return e ? e.length : 0;
    }
    GetFlowchartElementById(t2) {
      return this._flowchartDataItem.GetFlowchartElementById(t2);
    }
    Reset() {
      this._GetRootFlowchartState()._Reset(true);
    }
    _Reset(t2) {
      if (this._GetReferenceFlowchartStates()) {
        for (const [t3, e] of this._GetReferenceFlowchartStates().entries()) e._Reset(false);
        this._GetReferenceFlowchartStates().clear();
      }
      if (this._referenceFlowchartStates = null, this._previousFlowchartState = null, this._previousFlowchartStateStartNode = null, this._currentReferenceFlowchartState = null, this._previousFlowchartStateTag = "", this._referenceFlowchartStatesJson = null, this._currentReferenceFlowchartStateTag = "", this._rootFlowchartStateTag = "", this._previousFlowchartNodeIds = [], t2) {
        this._flowchartManager.SetCurrentFlowchartState(this);
        const t3 = this._startFlowchartNode.GetFlowchartId();
        t3 !== this._currentFlowchartNodeId && this._GotoFlowchartNode(t3);
      } else this._currentFlowchartNodeId = this._startFlowchartNode.GetFlowchartId();
    }
    GetCurrentNodeOutputCount() {
      const t2 = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId);
      return t2 ? t2.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItemCount() : 0;
    }
    IsIndexOfDefaultOutput(t2) {
      return !(t2 < 0) && t2 === this.GetDefaultOutputIndex();
    }
    GetDefaultOutputIndex() {
      const t2 = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId);
      if (!t2) return -1;
      let e = t2.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDefault();
      return e ? t2.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItems().indexOf(e) : -1;
    }
    GetCurrentNodeOutputNameAt(t2) {
      const e = this._GetFlowchartNodeOutputAt(t2);
      return e ? e.GetName() : "";
    }
    GetCurrentNodeOutputValueAt(t2) {
      let e;
      return C32.IsFiniteNumber(t2) && (e = this._GetFlowchartNodeOutputAt(t2)), "string" == typeof t2 && (e = this._GetFlowchartNodeOutputByName(t2)), "number" != typeof t2 && "string" != typeof t2 && console.warn("[Flowcharts] unexpected argument type in GetCurrentNodeOutputValueAt expression"), e ? e.GetValue() : "";
    }
    _MaybeByPassNodes(t2, e) {
      if (t2.GetEnable()) return t2.GetFlowchartId();
      {
        const r2 = t2.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDefault();
        if (!r2) return e.GetFlowchartId();
        const a2 = r2.GetConnectedFlowchartNodeFlowchartId();
        if (!C32.IsFiniteNumber(a2)) return e.GetFlowchartId();
        const o2 = this.GetFlowchartElementById(a2);
        return o2 ? this._MaybeByPassNodes(o2, e) : e.GetFlowchartId();
      }
    }
    _MaybeByPassNodesInReferenceFlowchart(t2, e) {
      if (t2.GetEnable()) {
        if ("reference" === t2.GetType()) {
          const e2 = t2.GetReferenceFlowchartName(), r2 = t2.GetReferenceFlowchartStartNodeTag(), a2 = this._flowchartManager.GetFlowchartDataItemByName(e2);
          if (!a2) return [-1, null];
          const o2 = a2.GetFlowchartNodeByTags(r2);
          return o2 ? this._MaybeByPassNodesInReferenceFlowchart(o2, a2) : this._MaybeByPassNodesInReferenceFlowchart(a2.GetFlowchartStartNode(), a2);
        }
        return [t2.GetFlowchartId(), e];
      }
      {
        const r2 = t2.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDefault();
        if (!r2) return [-1, null];
        const a2 = r2.GetConnectedFlowchartNodeFlowchartId();
        if (!C32.IsFiniteNumber(a2)) return [-1, null];
        const o2 = e.GetFlowchartElementById(a2);
        return o2 ? this._MaybeByPassNodesInReferenceFlowchart(o2, e) : [-1, null];
      }
    }
    _ProcessAllByPasses(t2, e) {
      let r2 = this.GetFlowchartElementById(t2);
      if (r2) {
        if (!r2.GetEnable()) {
          const e2 = this.GetFlowchartElementById(this._currentFlowchartNodeId);
          t2 = this._MaybeByPassNodes(r2, e2);
        }
        if (C32.IsFiniteNumber(t2) && t2 !== this._currentFlowchartNodeId) if (r2 = this.GetFlowchartElementById(t2), "reference" === r2.GetType()) {
          const a2 = r2.GetReferenceFlowchartName(), o2 = r2.GetReferenceFlowchartStartNodeTag(), h2 = this._flowchartManager.GetFlowchartDataItemByName(a2);
          let s = h2.GetFlowchartNodeByTags(o2);
          if (s) {
            const r3 = this._MaybeByPassNodesInReferenceFlowchart(s, h2);
            if (-1 === r3[0]) return;
            e(this._currentFlowchartNodeId, t2, r3[1], r3[0]);
          } else e(this._currentFlowchartNodeId, t2);
        } else e(this._currentFlowchartNodeId, t2);
      }
    }
    GotoNextFlowchartNode(t2) {
      let e;
      if (C32.IsFiniteNumber(t2) && (e = this._GetFlowchartNodeOutputAt(t2)), "string" == typeof t2 && (e = this._GetFlowchartNodeOutputByName(t2)), !e) return;
      let r2 = e.GetConnectedFlowchartNodeFlowchartId();
      C32.IsFiniteNumber(r2) && this._ProcessAllByPasses(r2, (t3, e2, r3, a2) => {
        this._previousFlowchartNodeIds.push(t3), this._GotoFlowchartNode(e2, r3, a2);
      });
    }
    GotoNextFlowchartNodeDefault() {
      const t2 = this._GetFlowchartNodeOutputDefault();
      if (!t2) return;
      const e = t2.GetConnectedFlowchartNodeFlowchartId();
      C32.IsFiniteNumber(e) && this._ProcessAllByPasses(e, (t3, e2, r2, a2) => {
        this._previousFlowchartNodeIds.push(t3), this._GotoFlowchartNode(e2, r2, a2);
      });
    }
    GotoAnyFlowchartNode(t2) {
      const e = this._flowchartDataItem.GetFlowchartNodeByTags(t2);
      if (!e) return;
      const r2 = e.GetFlowchartId();
      C32.IsFiniteNumber(r2) && this._ProcessAllByPasses(r2, (t3, e2, r3, a2) => {
        this._previousFlowchartNodeIds.push(t3), this._GotoFlowchartNode(e2, r3, a2);
      });
    }
    GotoPreviousFlowchartNode() {
      const t2 = this._previousFlowchartNodeIds.pop();
      C32.IsFiniteNumber(t2) ? this._GotoFlowchartNode(t2) : this._GetPreviousFlowchartState() && (this._flowchartManager.SetCurrentFlowchartState(this._GetPreviousFlowchartState(), true, false, false), this._GetPreviousFlowchartState()._GotoFlowchartNode(this._GetPreviousFlowchartStateStartNodeId()), this._GetRootFlowchartState()._SetCurrentReferenceFlowchart(this._GetPreviousFlowchartState()));
    }
    GotoParentFlowchartNode(t2) {
      if (!this.GetCurrentNode()) return;
      const e = this.GetCurrentNodeParent(t2);
      if (e) {
        if (!e.GetEnable()) return;
        const t3 = e.GetFlowchartId();
        if (!C32.IsFiniteNumber(t3)) return;
        this._previousFlowchartNodeIds.push(this._currentFlowchartNodeId), this._GotoFlowchartNode(e.GetFlowchartId());
      }
    }
    HasOutput(t2) {
      if (C32.IsFiniteNumber(t2)) {
        return !!this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId).GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItems()[t2];
      }
      if ("string" == typeof t2) {
        const e = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId).GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItems();
        for (let r2 = 0; r2 < e.length; r2++) if (e[r2].GetName() === t2) return true;
        return false;
      }
      return false;
    }
    MarkForRelease() {
      this._markForRelease = true;
    }
    IsInTriggerState() {
      return this._triggerCount > 0;
    }
    PushIsTriggerState() {
      this._triggerCount++;
    }
    PopIsTriggerState() {
      this._triggerCount--, 0 === this._triggerCount && this._markForRelease && this._flowchartManager.RemoveFlowchartState(this);
    }
    _GotoFlowchartNode(t2, e, r2) {
      const a2 = this._currentFlowchartNodeId, o2 = this.GetPluginInstance().GetInstance();
      this.PushIsTriggerState(), this._flowchartManager.PushFlowchartState(this), this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnBeforeAnyNodeChange, o2), this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnBeforeTaggedNodeChange, o2), this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnBeforeAnyNodeChangeInFlowchart, o2), this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnBeforeTaggedNodeChangeInFlowchart, o2), this._currentFlowchartNodeId = t2;
      let h2 = this.GetFlowchartElementById(this._currentFlowchartNodeId);
      if ("dictionary" === h2.GetType()) this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnAnyNodeChange, o2), this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnTaggedNodeChange, o2), this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnAnyNodeChangeInFlowchart, o2), this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnTaggedNodeChangeInFlowchart, o2);
      if (this._flowchartManager.PopFlowchartState(), this.PopIsTriggerState(), !this.WasReleased() && (h2 = this.GetFlowchartElementById(this._currentFlowchartNodeId), "reference" === h2.GetType())) {
        const t3 = e ? e.GetName() : h2.GetReferenceFlowchartName();
        if (this._HasReferenceFlowchartState(h2)) {
          this._previousFlowchartNodeIds.pop();
          const t4 = this._GetReferenceFlowchartState(h2);
          this._flowchartManager.SetCurrentFlowchartState(t4, true, true, false), t4._SetPreviousFlowchart(this, a2);
          this._GetRootFlowchartState()._SetCurrentReferenceFlowchart(t4);
        } else {
          const e2 = "number" == typeof r2 ? r2 : h2.GetReferenceFlowchartStartNodeTag();
          if (t3) {
            this._previousFlowchartNodeIds.pop();
            let r3 = h2.GetReferenceFlowchartTag();
            if (r3) {
              let t4 = this._flowchartManager.GetFlowchartState(r3);
              for (; t4; ) r3 = C32.IncrementNumberAtEndOf(r3), t4 = this._flowchartManager.GetFlowchartState(r3);
            } else {
              r3 = `${t3}-ref`;
              let e3 = this._flowchartManager.GetFlowchartState(r3);
              for (; e3; ) r3 = C32.IncrementNumberAtEndOf(r3), e3 = this._flowchartManager.GetFlowchartState(r3);
            }
            const o3 = this._flowchartManager.AddFlowchartState(t3, e2, r3, this._pluginInstance, true);
            o3._SetPreviousFlowchart(this, a2), this._SetReferenceFlowchartState(h2, o3);
            const s = this._GetRootFlowchartState();
            o3._SetRootFlowchartState(s), s._SetCurrentReferenceFlowchart(o3);
          }
        }
      }
    }
    _GetFlowchartNodeOutputDefault() {
      const t2 = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId);
      return t2 ? t2.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDefault() : null;
    }
    _GetFlowchartNodeOutputAt(t2) {
      const e = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId);
      if (!e) return null;
      const r2 = e.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItems();
      if (!r2) return null;
      const a2 = r2[t2];
      return a2 || null;
    }
    _GetFlowchartNodeOutputByName(t2) {
      const e = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId);
      if (!e) return null;
      const r2 = e.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItemByName(t2);
      return r2 || null;
    }
    _SetStartFlowchartNode(t2) {
      if ("number" == typeof t2) {
        let e = this.GetFlowchartElementById(t2);
        e || (e = this._flowchartDataItem.GetFlowchartStartNode()), this._startFlowchartNode = e;
      } else if ("number" == typeof this._startNodeTag) {
        let t3 = this.GetFlowchartElementById(this._startNodeTag);
        t3 || (t3 = this._flowchartDataItem.GetFlowchartStartNode()), this._startFlowchartNode = t3;
      } else {
        let t3 = this._flowchartDataItem.GetFlowchartNodeByTags(this._startNodeTag);
        t3 || (t3 = this._flowchartDataItem.GetFlowchartStartNode()), this._startFlowchartNode = t3;
      }
    }
    _SaveToJson() {
      return this._markForRelease ? null : { "flowchartName": this._flowchartName, "flowchartTag": this._tag, "startNodeTag": this._startNodeTag, "currentNodeId": this._currentFlowchartNodeId, "previousNodeIds": this._previousFlowchartNodeIds, "pluginUID": this._pluginInstance.GetInstance().GetUID(), "reference": { "previousFlowchartTag": this._GetPreviousFlowchartState() ? this._GetPreviousFlowchartState().GetTag() : "", "previousStartNodeId": C32.IsFiniteNumber(this._GetPreviousFlowchartStateStartNodeId()) ? this._GetPreviousFlowchartStateStartNodeId() : NaN, "referencesJson": this._GetFlowchartReferencesJson(), "currentReferenceFlowchartTag": this.GetCurrentReferenceFlowchart() ? this.GetCurrentReferenceFlowchart().GetTag() : "", "rootFlowchartTag": this._GetRootFlowchartState() ? this._GetRootFlowchartState().GetTag() : "" } };
    }
    _GetFlowchartReferencesJson() {
      if (!this._HasReferenceFlowchartStates()) return null;
      const t2 = [];
      for (const [e, r2] of this._GetReferenceFlowchartStates().entries()) t2.push({ "flowchartElementId": e.GetFlowchartId(), "flowchartStateTag": r2.GetTag() });
      return t2.length ? t2 : null;
    }
    _LoadFromJson(t2) {
      if (t2) {
        if (this._flowchartName = t2["flowchartName"], this._tag = t2["flowchartTag"], this._startNodeTag = t2["startNodeTag"], this._currentFlowchartNodeId = t2["currentNodeId"], this._previousFlowchartNodeIds = t2["previousNodeIds"], this._pluginUID = t2["pluginUID"], t2.hasOwnProperty("reference")) {
          const e = t2["reference"];
          this._previousFlowchartStateTag = e["previousFlowchartTag"], this._previousFlowchartStateStartNodeId = e["previousStartNodeId"], this._referenceFlowchartStatesJson = e["referencesJson"], this._currentReferenceFlowchartStateTag = e["currentReferenceFlowchartTag"], this._rootFlowchartStateTag = e["rootFlowchartTag"];
        }
        this._SetStartFlowchartNode();
      }
    }
    _GetPreviousFlowchartState() {
      return "string" == typeof this._previousFlowchartStateTag && this._previousFlowchartStateTag && (this._previousFlowchartState = this._flowchartManager.GetFlowchartState(this._previousFlowchartStateTag), this._previousFlowchartStateTag = ""), this._previousFlowchartState;
    }
    _GetPreviousFlowchartStateStartNodeId() {
      return this._previousFlowchartStateStartNodeId;
    }
    _SetPreviousFlowchart(t2, e) {
      this._previousFlowchartState = t2, this._previousFlowchartStateStartNodeId = e;
    }
    GetCurrentReferenceFlowchart() {
      return "string" == typeof this._currentReferenceFlowchartStateTag && this._currentReferenceFlowchartStateTag && (this._currentReferenceFlowchartState = this._flowchartManager.GetFlowchartState(this._currentReferenceFlowchartStateTag), this._currentReferenceFlowchartStateTag = ""), this._currentReferenceFlowchartState;
    }
    _SetCurrentReferenceFlowchart(t2) {
      this._currentReferenceFlowchartState = t2, this._currentReferenceFlowchartState === this && (this._currentReferenceFlowchartState = null);
    }
    _GetRootFlowchartState() {
      return "string" == typeof this._rootFlowchartStateTag && this._rootFlowchartStateTag && (this._rootFlowchartState = this._flowchartManager.GetFlowchartState(this._rootFlowchartStateTag), this._rootFlowchartStateTag = ""), this._rootFlowchartState ? this._rootFlowchartState : this;
    }
    _SetRootFlowchartState(t2) {
      this._rootFlowchartState = t2;
    }
    _HasReferenceFlowchartStates() {
      return this._RebuildReferenceFlowchartStates(), !!this._referenceFlowchartStates;
    }
    _HasReferenceFlowchartState(t2) {
      return this._RebuildReferenceFlowchartStates(), this._referenceFlowchartStates && this._referenceFlowchartStates.has(t2);
    }
    _RebuildReferenceFlowchartStates() {
      if (this._referenceFlowchartStatesJson) {
        this._referenceFlowchartStates && this._referenceFlowchartStates.clear(), this._referenceFlowchartStates || (this._referenceFlowchartStates = /* @__PURE__ */ new Map());
        for (const t2 of this._referenceFlowchartStatesJson) {
          const e = this._flowchartManager.GetFlowchartState(t2["flowchartStateTag"]), r2 = e.GetFlowchartElementById(t2["flowchartElementId"]);
          this._referenceFlowchartStates.set(r2, e);
        }
        this._referenceFlowchartStatesJson = null;
      }
    }
    _GetReferenceFlowchartStates() {
      return this._RebuildReferenceFlowchartStates(), this._referenceFlowchartStates;
    }
    _GetReferenceFlowchartState(t2) {
      return this._RebuildReferenceFlowchartStates(), this._referenceFlowchartStates.get(t2);
    }
    _SetReferenceFlowchartState(t2, e) {
      this._referenceFlowchartStates || (this._referenceFlowchartStates = /* @__PURE__ */ new Map()), this._referenceFlowchartStates.set(t2, e);
    }
  };
}
{
  const C32 = self.C3;
  C32.FlowchartStateManager = class {
    constructor(t2) {
      this._runtime = t2, this._flowchartStates = /* @__PURE__ */ new Map(), this._currentFlowchartState = null, this._flowchartStateStack = [], this._on_after_load = () => this._OnAfterLoad(), this._loadJson = null;
    }
    Release() {
      C32.clearArray(this._flowchartStateStack), this._flowchartStateStack = null, this._flowchartStates.clear(), this._flowchartStates = null, this._currentFlowchartState = null, this._runtime = null, this._loadJson = null;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetFlowchartDataItemByName(t2) {
      return this._runtime.GetFlowchartManager().GetFlowchartDataItemByName(t2);
    }
    AddFlowchartState(t2, e, a2, r2, h2, s) {
      const o2 = this._runtime.GetFlowchartManager().GetFlowchartDataItemByName(t2);
      if (!o2) return void console.warn(`[Flowcharts] no flowchart found with name '${t2}'`);
      if (this._flowchartStates.has(a2)) {
        const t3 = this._flowchartStates.get(a2);
        t3 && this.RemoveFlowchartState(t3);
      }
      const n = new C32.FlowchartState(t2, a2, e, o2, this, r2, s);
      return this._flowchartStates.set(a2, n), h2 && this.SetCurrentFlowchartState(n, true), n;
    }
    RemoveFlowchartState(t2) {
      if (t2.MarkForRelease(), t2.IsInTriggerState()) return;
      const e = t2.GetTag();
      this._flowchartStates.delete(e), t2.Release(), this._currentFlowchartState === t2 && (this._currentFlowchartState = null);
    }
    ResetFlowchartState(t2) {
      t2.Reset();
    }
    GetFlowchartState(t2) {
      return this._flowchartStates.get(t2);
    }
    PushFlowchartState(t2) {
      this._flowchartStateStack.push(t2);
    }
    PopFlowchartState() {
      this._flowchartStateStack.pop();
    }
    SetCurrentFlowchartState(t2, e = false, a2 = false, r2 = true) {
      if (r2) {
        const e2 = t2.GetCurrentReferenceFlowchart();
        t2 = e2 || t2;
      }
      t2 !== this._currentFlowchartState && (this._TriggerBeforeFlowchartChange(), this._TriggerAfterFlowchartChange(t2, e, a2));
    }
    GetCurrentFlowchartState(t2) {
      return "string" == typeof t2 ? this.GetFlowchartState(t2) : this._flowchartStateStack.length ? this._flowchartStateStack[this._flowchartStateStack.length - 1] : this._currentFlowchartState;
    }
    _TriggerBeforeFlowchartChange() {
      if (!this._currentFlowchartState) return;
      if (this._currentFlowchartState.WasReleased()) return;
      const t2 = this._currentFlowchartState.GetPluginInstance().GetInstance();
      this._currentFlowchartState.PushIsTriggerState(), this.PushFlowchartState(this._currentFlowchartState), this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnBeforeFlowchartChange, t2), this.PopFlowchartState(), this._currentFlowchartState.PopIsTriggerState();
    }
    _TriggerAfterFlowchartChange(t2, e = false, a2 = false) {
      if (this._currentFlowchartState = t2, !this._currentFlowchartState) return;
      if (this._currentFlowchartState.WasReleased()) return;
      const r2 = this._currentFlowchartState.GetPluginInstance().GetInstance();
      this._currentFlowchartState.PushIsTriggerState(), this.PushFlowchartState(this._currentFlowchartState), this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnFlowchartChange, r2), true !== a2 && "number" != typeof a2 || this._currentFlowchartState._SetStartFlowchartNode(a2), e && (this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnAnyNodeChange, r2), this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnTaggedNodeChange, r2), this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnAnyNodeChangeInFlowchart, r2), this._runtime.Trigger(C32.Plugins.Flowchart.Cnds.OnTaggedNodeChangeInFlowchart, r2)), this.PopFlowchartState(), this._currentFlowchartState.PopIsTriggerState();
    }
    _SaveToJson() {
      return { "flowchartJsonObjects": [...this._flowchartStates.values()].map((t2) => t2._SaveToJson()), "currentFlowchartTag": this._currentFlowchartState ? this._currentFlowchartState.GetTag() : null };
    }
    _LoadFromJson(t2) {
      if (!t2) return;
      this._loadJson = t2;
      const e = /* @__PURE__ */ new Map();
      for (const t3 of this._loadJson["flowchartJsonObjects"]) {
        const a2 = t3["flowchartTag"];
        if (this._flowchartStates.has(a2)) {
          const r2 = this._flowchartStates.get(a2);
          r2._LoadFromJson(t3), e.set(a2, r2);
        } else {
          const a3 = this.AddFlowchartState(t3["flowchartName"], t3["startNodeTag"], t3["flowchartTag"], null, false, t3["pluginUID"]);
          a3._LoadFromJson(t3), e.set(t3["flowchartTag"], a3);
        }
      }
      for (const [t3, a2] of this._flowchartStates.entries()) e.has(t3) || a2.Release();
      this._flowchartStates.clear(), this._flowchartStates = e, this._runtime.IsLoadingState() ? this._runtime.Dispatcher().addEventListener("afterload", this._on_after_load) : this._OnAfterLoad();
    }
    _OnAfterLoad() {
      this._runtime.Dispatcher().removeEventListener("afterload", this._on_after_load);
      const t2 = this._flowchartStates.get(this._loadJson["currentFlowchartTag"]);
      t2 && this.SetCurrentFlowchartState(t2, true), this._loadJson = null;
    }
  };
}
{
  const C32 = self.C3;
  C32.FlowchartDataManager = class {
    constructor() {
      this._flowchartDataItems = /* @__PURE__ */ new Map();
    }
    Release() {
      for (const t2 of this._flowchartDataItems.values()) t2.Release();
      this._flowchartDataItems.clear(), this._flowchartDataItems = null;
    }
    Add(t2) {
      const a2 = new C32.FlowchartDataItem(t2), s = a2.GetName();
      this._flowchartDataItems.set(s, a2);
    }
    Get(t2) {
      return this._flowchartDataItems.get(t2);
    }
    HasFlowcharts() {
      return !!this._flowchartDataItems.size;
    }
    static CreateDataItems(t2, a2, s, e) {
      if (a2) for (const o2 of a2) {
        const a3 = new s(o2, e);
        t2.push(a3);
      }
    }
  };
}
{
  const C32 = self.C3, NAME = 0, NODES = 1;
  C32.FlowchartDataItem = class {
    constructor(t2) {
      this._name = t2[0], this._flowchartNodeData = new C32.FlowchartNodeData(t2[1], this);
    }
    Release() {
      this._flowchartNodeData.Release(), this._flowchartNodeData = null;
    }
    GetFlowchartNodeData() {
      return this._flowchartNodeData;
    }
    GetFlowchartElementById(t2) {
      return this._flowchartNodeData.GetFlowchartElementById(t2);
    }
    GetFlowchartNodeByTags(t2) {
      return this._flowchartNodeData.GetFlowchartNodeByTags(t2);
    }
    GetFlowchartStartNode() {
      return this._flowchartNodeData.GetFlowchartStartNode();
    }
    GetName() {
      return this._name;
    }
  };
}
{
  const C32 = self.C3, FLOWCHART_ID = 0, TAG = 1, PARENT_FLOWCHART_IDS = 2, PARENT_OUTPUT_FLOWCHART_IDS = 3, CHILDREN_FLOWCHART_IDS = 4, OUTPUTS = 5, IS_START = 6, TYPE = 7, DICTIONARY_ENABLE = 8, REFERENCE_FLOWCHART = 8, REFERENCE_FLOWCHART_START_NODE = 9, REFERENCE_FLOWCHART_TAG = 10, REFERENCE_FLOWCHART_ENABLE = 11;
  class FlowchartNodeDataItem {
    constructor(t2, e) {
      this._flowchartNodeData = e, this._type = t2[7], this._flowchartId = t2[0], this._tag = t2[1], this._tag ? this._tags = this._tag.trim().split(" ").map((t3) => t3.trim()) : this._tags = [], this._parentFlowchartIds = t2[2], this._parentOutputFlowchartIds = null, this._childrenFlowchartIds = null, this._enable = false, "dictionary" === this._type && (this._parentOutputFlowchartIds = t2[3], this._childrenFlowchartIds = t2[4], this._enable = t2[8]), this._isStart = t2[6], this._referenceFlowchartName = null, this._referenceFlowchartStartNodeTag = null, this._referenceFlowchartTag = null, "reference" === this._type && (this._referenceFlowchartName = t2[8], this._referenceFlowchartStartNodeTag = t2[9], this._referenceFlowchartTag = t2[10], this._enable = t2[11]), this._flowchartNodeOutputData = new C32.FlowchartNodeOutputData(t2[5], this);
    }
    Release() {
      this._flowchartNodeData = null;
    }
    GetFlowchartNodeData() {
      return this._flowchartNodeData;
    }
    GetFlowchartNodeOutputData() {
      return this._flowchartNodeOutputData;
    }
    GetFlowchartId() {
      return this._flowchartId;
    }
    GetTag() {
      return this._tag;
    }
    GetTags() {
      return this._tags;
    }
    HasTags(t2) {
      if (!this._tags) return false;
      if (!this._tags.length) return false;
      const e = C32.FlowchartState._GetTagArray(t2);
      return !(!e || !e.length) && e.every(C32.FlowchartState._HasTag, this._tags);
    }
    GetIsStart() {
      return this._isStart;
    }
    SetIsStart(t2) {
      this._isStart = !!t2;
    }
    CanBeStartNode() {
      if ("dictionary" === this._type) return true;
      if ("reference" === this._type) return false;
      throw new Error(`unexpected flowchart node type: ${this._type}`);
    }
    GetParentFlowchartIds() {
      return this._parentFlowchartIds;
    }
    GetParentOutputFlowchartIds() {
      return this._parentOutputFlowchartIds;
    }
    GetChildrenFlowchartIds() {
      return this._childrenFlowchartIds;
    }
    GetType() {
      return this._type;
    }
    GetEnable() {
      return this._enable;
    }
    GetReferenceFlowchartName() {
      return this._referenceFlowchartName;
    }
    GetReferenceFlowchartStartNodeTag() {
      return this._referenceFlowchartStartNodeTag;
    }
    GetReferenceFlowchartTag() {
      return this._referenceFlowchartTag;
    }
  }
  C32.FlowchartNodeData = class {
    constructor(t2, e) {
      this._flowchartDataItem = e, this._flowchartNodeItems = [], this._flowchartNodeItemsIdMap = /* @__PURE__ */ new Map(), this._flowchartNodeItemsTagMap = /* @__PURE__ */ new Map(), this._flowchartNodeStartItem = null, C32.FlowchartDataManager.CreateDataItems(this._flowchartNodeItems, t2, FlowchartNodeDataItem, this);
      for (const t3 of this._flowchartNodeItems) {
        const e2 = t3.GetFlowchartId(), a2 = t3.GetTag(), r2 = t3.GetTags(), s = t3.GetIsStart();
        if (this._flowchartNodeItemsIdMap.set(e2, t3), a2) for (const e3 of r2) this._flowchartNodeItemsTagMap.has(e3) || this._flowchartNodeItemsTagMap.set(e3, /* @__PURE__ */ new Set()), this._flowchartNodeItemsTagMap.get(e3).add(t3);
        s && (this._flowchartNodeStartItem = t3);
        const o2 = t3.GetFlowchartNodeOutputData();
        for (const t4 of o2.flowchartNodeOutputDataItems()) {
          const e3 = t4.GetFlowchartId();
          this._flowchartNodeItemsIdMap.set(e3, t4);
        }
      }
      this._flowchartNodeStartItem || this._SetStartNodeIfMissing();
    }
    Release() {
      this._flowchartDataItem = null;
      for (const t2 of this._flowchartNodeItems) t2.Release();
      C32.clearArray(this._flowchartNodeItems), this._flowchartNodeItems = null;
    }
    GetFlowchartDataItem() {
      return this._flowchartDataItem;
    }
    GetFlowchartElementById(t2) {
      return this._flowchartNodeItemsIdMap.get(t2);
    }
    GetFlowchartNodeByTags(t2) {
      if (!t2 || !t2.length) return null;
      const e = [];
      for (const a2 of t2.trim().split(" ")) {
        let t3 = this._flowchartNodeItemsTagMap.get(a2.trim()) ?? /* @__PURE__ */ new Set();
        if (0 === t3.size) return null;
        e.push(t3);
      }
      return [...e.reduce((t3, e2) => e2.size < t3.size ? e2 : t3)].filter((t3) => e.every((e2) => e2.has(t3)))[0];
    }
    GetFlowchartStartNode() {
      return this._flowchartNodeStartItem;
    }
    *flowchartNodeDataItems() {
      for (const t2 of this._flowchartNodeItems) yield t2;
    }
    _SetStartNodeIfMissing() {
      let t2 = 0;
      for (const e of this.flowchartNodeDataItems()) e.GetIsStart() && t2++;
      if (0 === t2) {
        for (const t3 of this.flowchartNodeDataItems()) if (t3.CanBeStartNode() && !t3.GetIsStart()) return void t3.SetIsStart(true);
      } else {
        if (1 === t2) return;
        if (t2 > 1) {
          let t3 = true;
          for (const e of this.flowchartNodeDataItems()) e.CanBeStartNode() && (e.GetIsStart() && t3 ? t3 = false : e.GetIsStart() && !t3 && e.SetIsStart(false));
        }
      }
      for (const t3 of this.flowchartNodeDataItems()) if (t3.CanBeStartNode() && t3.GetIsStart()) return void (this._flowchartNodeStartItem = t3);
    }
  };
}
{
  const C32 = self.C3, FLOWCHART_ID = 0, NAME = 1, VALUE = 2, CONNECTED_FLOWCHART_NODE_FLOWCHART_ID = 3, ENABLE = 4, DEFAULT = 5;
  class FlowchartNodeDataOutputItem {
    constructor(t2, e) {
      this._flowchartNodeOutputData = e, this._flowchartId = t2[0], this._name = t2[1], this._value = t2[2], this._connectedFlowchartNodeFlowchartId = t2[3], this._enable = t2[4], this._default = t2[5];
    }
    Release() {
      this._flowchartNodeOutputData = null;
    }
    GetFlowchartNodeOutputData() {
      return this._flowchartNodeOutputData;
    }
    GetFlowchartId() {
      return this._flowchartId;
    }
    GetName() {
      return this._name;
    }
    GetValue() {
      return this._value;
    }
    GetConnectedFlowchartNodeFlowchartId() {
      return this._connectedFlowchartNodeFlowchartId;
    }
    GetEnable() {
      return this._enable;
    }
    GetDefault() {
      return this._default;
    }
  }
  C32.FlowchartNodeOutputData = class {
    constructor(t2, e) {
      this._flowchartDataNodeItem = e, this._flowchartNodeOutputItems = [], this._flowchartNodeOutputItemsNameMap = /* @__PURE__ */ new Map(), C32.FlowchartDataManager.CreateDataItems(this._flowchartNodeOutputItems, t2, FlowchartNodeDataOutputItem, this), this._enabledFlowchartNodeOutputItems = this._flowchartNodeOutputItems.filter((t3) => t3.GetEnable());
      for (const t3 of this._enabledFlowchartNodeOutputItems) this._flowchartNodeOutputItemsNameMap.set(t3.GetName(), t3);
    }
    Release() {
      this._flowchartDataNodeItem = null;
      for (const t2 of this._flowchartNodeOutputItems) t2.Release();
      C32.clearArray(this._flowchartNodeOutputItems), this._flowchartNodeOutputItems = null, C32.clearArray(this._enabledFlowchartNodeOutputItems), this._enabledFlowchartNodeOutputItems = null;
    }
    GetFlowchartNodeDataItem() {
      return this._flowchartDataNodeItem;
    }
    GetFlowchartNodeOutputDataItemCount() {
      return this._enabledFlowchartNodeOutputItems.length;
    }
    GetFlowchartNodeOutputDataItems() {
      return this._enabledFlowchartNodeOutputItems;
    }
    GetFlowchartNodeOutputDataItemByName(t2) {
      return this._flowchartNodeOutputItemsNameMap.get(t2);
    }
    GetFlowchartNodeOutputDefault() {
      for (const t2 of this._enabledFlowchartNodeOutputItems) if (t2.GetDefault()) return t2;
    }
    *flowchartNodeOutputDataItems() {
      for (const t2 of this._enabledFlowchartNodeOutputItems) yield t2;
    }
  };
}
{
  const C32 = self.C3;
  C32.SolStack = class extends C32.DefendedBase {
    constructor(t2) {
      super(), this._objectClass = t2, this._stack = [], this._stack.push(C32.New(C32.Sol, this)), this._index = 0, this._current = this._stack[0];
    }
    Release() {
      for (const t2 of this._stack) t2.Release();
      C32.clearArray(this._stack), this._current = null, this._objectClass = null;
    }
    GetObjectClass() {
      return this._objectClass;
    }
    GetCurrentSol() {
      return this._current;
    }
    GetOneBelowCurrentSol() {
      return this._stack[this._index - 1];
    }
    Clear() {
      this.GetCurrentSol().Clear();
    }
    PushClean() {
      const t2 = this._stack, s = ++this._index;
      if (s === t2.length) {
        const s2 = C32.New(C32.Sol, this);
        t2.push(s2), this._current = s2;
      } else {
        const e = t2[s];
        e.Reset(), this._current = e;
      }
    }
    PushCopy() {
      const t2 = this._stack, s = ++this._index;
      s === t2.length && t2.push(C32.New(C32.Sol, this));
      const e = t2[s];
      e.Copy(t2[s - 1]), this._current = e;
    }
    Pop() {
      this._current = this._stack[--this._index];
    }
    RemoveInstances(t2) {
      const s = this._stack;
      for (let e = 0, n = s.length; e < n; ++e) s[e].RemoveInstances(t2);
    }
  };
}
{
  const C32 = self.C3;
  C32.Sol = class extends C32.DefendedBase {
    constructor(s) {
      super(), this._stack = s, this._objectClass = this._stack.GetObjectClass(), this._eventStack = this._objectClass.GetRuntime().GetEventStack(), this._selectAll = true, this._instances = [], this._elseInstances = [];
    }
    Release() {
      this.ClearArrays(), this._stack = null, this._objectClass = null, this._eventStack = null;
    }
    ClearArrays() {
      C32.clearArray(this._instances), C32.clearArray(this._elseInstances);
    }
    GetObjectClass() {
      return this._objectClass;
    }
    IsSelectAll() {
      return this._selectAll;
    }
    HasAnyInstances() {
      return this._selectAll ? !!this._objectClass.GetInstanceCount() : !!this._instances.length;
    }
    GetInstances() {
      return this._selectAll ? this._objectClass.GetInstances() : this._instances;
    }
    HasAnyElseInstances() {
      return !!this._elseInstances.length;
    }
    GetElseInstances() {
      return this._elseInstances;
    }
    GetExpressionInstances() {
      const s = this.GetInstances();
      return s.length ? s : this._elseInstances;
    }
    Reset() {
      this._selectAll = true, C32.clearArray(this._elseInstances);
    }
    Clear() {
      this._selectAll = true;
    }
    Copy(s) {
      s.IsSelectAll() ? this.Reset() : (this._selectAll = false, C32.shallowAssignArray(this._instances, s._instances), C32.clearArray(this._elseInstances));
    }
    _PushInstance(s) {
      this._instances.push(s);
    }
    _PushElseInstance(s) {
      this._elseInstances.push(s);
    }
    _SetSelectAll(s) {
      this._selectAll = !!s;
    }
    _GetOwnInstances() {
      return this._instances;
    }
    _GetOwnElseInstances() {
      return this._elseInstances;
    }
    SetSinglePicked(s) {
      this._selectAll = false, C32.clearArray(this._instances), this._instances.push(s);
    }
    SetArrayPicked(s) {
      this._selectAll = false, C32.shallowAssignArray(this._instances, s);
    }
    SetSetPicked(s) {
      this._selectAll = false, C32.clearArray(this._instances);
      for (const e of s) this._instances.push(e);
    }
    AddElseInstances(s, e) {
      for (const t2 of e) s.has(t2) || this._elseInstances.push(t2);
    }
    TransferElseInstancesToOwn(s) {
      for (const e of s) this._instances.push(e);
      C32.arrayRemoveAllInSet(this._elseInstances, s);
    }
    ClearElseInstances() {
      C32.clearArray(this._elseInstances);
    }
    PickOne(s) {
      if (s) if (this._eventStack.GetCurrentStackFrame().GetCurrentEvent().IsOrBlock()) {
        this.IsSelectAll() && (C32.clearArray(this._instances), C32.shallowAssignArray(this._elseInstances, s.GetObjectClass().GetInstances()), this._selectAll = false);
        const e = this._elseInstances.indexOf(s);
        -1 !== e && (this._instances.push(this._elseInstances[e]), this._elseInstances.splice(e, 1));
      } else this.SetSinglePicked(s);
    }
    RemoveInstances(s) {
      C32.arrayRemoveAllInSet(this._instances, s), C32.arrayRemoveAllInSet(this._elseInstances, s);
    }
  };
}
{
  const C32 = self.C3;
  C32.EventStack = class extends C32.DefendedBase {
    constructor(t2) {
      super(), this._eventSheetManager = t2, this._runtime = this._eventSheetManager.GetRuntime(), this._stack = [], this._stack.push(C32.New(C32.EventStackFrame, this, null)), this._index = 0, this._expFuncStack = [];
    }
    Release() {
      for (const t2 of this._stack) t2.Release();
      C32.clearArray(this._stack), C32.clearArray(this._expFuncStack), this._eventSheetManager = null, this._runtime = null;
    }
    GetEventSheetManager() {
      return this._eventSheetManager;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetCurrentStackFrame() {
      return this._stack[this._index];
    }
    GetAllStackFrames() {
      return this._stack;
    }
    GetCurrentStackFrameIndex() {
      return this._index;
    }
    Push(t2) {
      const e = this._stack, n = ++this._index;
      if (n === e.length) {
        const n2 = C32.New(C32.EventStackFrame, this, t2);
        return e.push(n2), n2;
      }
      {
        const s = e[n];
        return s.Reset(t2), s;
      }
    }
    Pop() {
      --this._index;
    }
    PushExpFunc(t2) {
      this._expFuncStack.push(t2);
    }
    PopExpFunc() {
      this._expFuncStack.pop();
    }
    GetCurrentExpFuncStackFrame() {
      const t2 = this._expFuncStack;
      return 0 === t2.length ? null : t2.at(-1);
    }
  };
}
{
  const C32 = self.C3;
  C32.EventStackFrame = class extends C32.DefendedBase {
    constructor(t2, e) {
      super(), this._stack = t2, this._runtime = this._stack.GetRuntime(), this._currentEvent = e, this._cndIndex = 0, this._actIndex = 0, this._lastEventTrue = false, this._elseBranchRan = false, this._expressionObjectClass = null, this._functionReturnType = 0, this._functionReturnValue = 0, this._dynamicSolModifiers = null;
    }
    Release() {
      this.Reset(null), this._stack = null, this._runtime = null;
    }
    Reset(t2) {
      this._currentEvent = t2, this._cndIndex = 0, this._actIndex = 0, this._lastEventTrue = false, this._elseBranchRan = false, this._dynamicSolModifiers = null;
    }
    _Restore(t2, e) {
      this._currentEvent = t2, this._cndIndex = 0, this._actIndex = e;
    }
    ResetQuick() {
      this._cndIndex = 0, this._actIndex = 0;
    }
    GetCurrentEvent() {
      return this._currentEvent;
    }
    SetCurrentEvent(t2) {
      this._currentEvent = t2;
    }
    GetConditionIndex() {
      return this._cndIndex;
    }
    SetConditionIndex(t2) {
      this._cndIndex = t2;
    }
    GetActionIndex() {
      return this._actIndex;
    }
    SetActionIndex(t2) {
      this._actIndex = t2;
    }
    SetLastEventTrue(t2) {
      this._lastEventTrue = !!t2;
    }
    GetLastEventTrue() {
      return this._lastEventTrue;
    }
    SetElseBranchRan(t2) {
      this._elseBranchRan = !!t2;
    }
    GetElseBranchRan() {
      return this._elseBranchRan;
    }
    SetExpressionObjectClass(t2) {
      this._expressionObjectClass = t2;
    }
    GetExpressionObjectClass() {
      return this._expressionObjectClass;
    }
    InitCallFunctionExpression(t2, e) {
      this._functionReturnType = t2, this._functionReturnValue = e;
    }
    GetFunctionReturnType() {
      return this._functionReturnType;
    }
    SetFunctionReturnValue(t2) {
      this._functionReturnValue = t2;
    }
    GetFunctionReturnValue() {
      return this._functionReturnValue;
    }
    IsSolModifierAfterCnds() {
      const t2 = this._currentEvent;
      return !!t2.IsSolWriterAfterCnds() || this._cndIndex < t2.GetConditionCount() - 1 && !!t2.GetSolModifiers().length;
    }
    SetDynamicSolModifiers(t2) {
      this._dynamicSolModifiers = t2;
    }
    GetDynamicSolModifiers() {
      return this._dynamicSolModifiers;
    }
  };
}
{
  const C32 = self.C3;
  C32.LocalVarStack = class extends C32.DefendedBase {
    constructor(t2) {
      super(), this._eventSheetManager = t2, this._runtime = this._eventSheetManager.GetRuntime(), this._stack = [], this._index = -1, this._current = null, this._initialValues = [];
    }
    Release() {
      C32.clearArray(this._stack), this._eventSheetManager = null, this._runtime = null;
    }
    _SetInitialValues(t2) {
      this._initialValues = t2;
      const e = this._initialValues.slice(0);
      this._stack.push(e), this._index = 0, this._current = e;
    }
    GetEventSheetManager() {
      return this._eventSheetManager;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetCurrent() {
      return this._current;
    }
    Push() {
      const t2 = ++this._index, e = this._stack;
      t2 === e.length ? e.push(this._initialValues.slice(0)) : C32.shallowAssignArray(e[t2], this._initialValues), this._current = e[t2];
    }
    Pop() {
      this._current = this._stack[--this._index];
    }
  };
}
{
  const C32 = self.C3;
  C32.LoopStack = class extends C32.DefendedBase {
    constructor(t2) {
      super(), this._eventSheetManager = t2, this._runtime = this._eventSheetManager.GetRuntime(), this._stack = [], this._index = -1;
    }
    Release() {
      C32.clearArray(this._stack), this._eventSheetManager = null, this._runtime = null;
    }
    GetEventSheetManager() {
      return this._eventSheetManager;
    }
    GetRuntime() {
      return this._runtime;
    }
    IsInLoop() {
      return this._index >= 0;
    }
    GetCurrent() {
      return this._stack[this._index];
    }
    Push() {
      if (++this._index, this._index === this._stack.length) {
        const t2 = C32.New(C32.Loop, this);
        return this._stack.push(t2), t2;
      }
      {
        const t2 = this._stack[this._index];
        return t2.Reset(), t2;
      }
    }
    Pop() {
      --this._index;
    }
    FindByName(t2) {
      const e = this._stack;
      for (let s = this._index; s >= 0; --s) {
        const n = e[s];
        if (n.GetName() === t2) return n;
      }
      return null;
    }
    _GetStack() {
      return this._stack.slice(0, this._index + 1);
    }
  };
}
{
  const C32 = self.C3;
  C32.Loop = class extends C32.DefendedBase {
    constructor(e) {
      super(), this._loopStack = e, this._name = "", this._index = 0, this._isStopped = false, this._end = NaN;
    }
    Reset() {
      this._name = "", this._index = 0, this._isStopped = false, this._end = NaN;
    }
    SetName(e) {
      this._name = e;
    }
    GetName() {
      return this._name;
    }
    SetIndex(e) {
      this._index = e;
    }
    GetIndex() {
      return this._index;
    }
    Stop() {
      this._isStopped = true;
    }
    IsStopped() {
      return this._isStopped;
    }
    SetEnd(e) {
      this._end = e;
    }
    GetEnd() {
      return this._end;
    }
  };
}
{
  const C32 = self.C3;
  C32.ArrayStack = class extends C32.DefendedBase {
    constructor() {
      super(), this._stack = [], this._index = -1;
    }
    Release() {
      C32.clearArray(this._stack);
    }
    GetCurrent() {
      return this._stack[this._index];
    }
    Push() {
      if (++this._index, this._index === this._stack.length) {
        const s = [];
        return this._stack.push(s), s;
      }
      return this._stack[this._index];
    }
    Pop() {
      --this._index;
    }
  };
}
{
  let SortSolArray = function(t2, e) {
    return t2.GetIndex() - e.GetIndex();
  }, IsSolArrayIdentical = function(t2, e) {
    for (let s = 0, n = t2.length; s < n; ++s) if (t2[s] !== e[s]) return false;
    return true;
  };
  SortSolArray2 = SortSolArray, IsSolArrayIdentical2 = IsSolArrayIdentical;
  const C32 = self.C3, assert = self.assert;
  C32.EventSheetManager = class extends C32.DefendedBase {
    constructor(t2) {
      super(), this._runtime = t2, this._allSheets = [], this._sheetsByName = /* @__PURE__ */ new Map(), this._allGroups = [], this._groupsByName = /* @__PURE__ */ new Map(), this._blocksBySid = /* @__PURE__ */ new Map(), this._cndsBySid = /* @__PURE__ */ new Map(), this._actsBySid = /* @__PURE__ */ new Map(), this._allUniqueSolModifiers = /* @__PURE__ */ new Map(), this._eventVarsBySid = /* @__PURE__ */ new Map(), this._nextLocalVarIndex = 0, this._allGlobalVars = [], this._allLocalVars = [], this._localVarInitialValues = [], this._functionBlocksByName = /* @__PURE__ */ new Map(), this._customActionBlocksMap = /* @__PURE__ */ new Map(), this._eventStack = C32.New(C32.EventStack, this), this._localVarStack = C32.New(C32.LocalVarStack, this), this._loopStack = C32.New(C32.LoopStack, this), this._triggersToPostInit = [], this._queuedTriggers = [], this._queuedDebugTriggers = [], this._runningEventsDepth = 0, this._executingTriggerDepth = 0, this._blockFlushingDepth = 0, this._scheduledWaits = [], this._asyncActionPromises = [], this._signalTags = [], this._signalPromises = /* @__PURE__ */ new Map(), this._instSignals = /* @__PURE__ */ new Map(), self["c3_callFunction"] = (t3, e) => this._InvokeFunctionFromJS(t3, e);
    }
    Release() {
      this.ClearAllScheduledWaits(), this._eventStack.Release(), this._eventStack = null, this._localVarStack.Release(), this._localVarStack = null, C32.clearArray(this._queuedTriggers), C32.clearArray(this._queuedDebugTriggers), this._runtime = null, C32.clearArray(this._allSheets), this._sheetsByName.clear();
    }
    Create(t2) {
      const e = C32.New(C32.EventSheet, this, t2);
      this._allSheets.push(e), this._sheetsByName.set(e.GetName().toLowerCase(), e);
    }
    _AddTriggerToPostInit(t2) {
      this._triggersToPostInit.push(t2);
    }
    _PostInit() {
      for (const t2 of this._customActionBlocksMap.values()) t2._CheckOverrideState();
      for (const t2 of this._functionBlocksByName.values()) t2._PostInit();
      for (const t2 of this._customActionBlocksMap.values()) t2._PostInit();
      for (const t2 of this._allSheets) t2._PostInit();
      for (const t2 of this._allSheets) t2._UpdateDeepIncludes();
      for (const t2 of this._triggersToPostInit) t2._PostInit(false);
      C32.clearArray(this._triggersToPostInit), this._localVarStack._SetInitialValues(this._localVarInitialValues);
    }
    GetRuntime() {
      return this._runtime;
    }
    GetEventSheetByName(t2) {
      return this._sheetsByName.get(t2.toLowerCase()) || null;
    }
    _RegisterGroup(t2) {
      this._allGroups.push(t2), this._groupsByName.set(t2.GetGroupName(), t2);
    }
    _RegisterEventBlock(t2) {
      this._blocksBySid.set(t2.GetSID(), t2);
    }
    _RegisterCondition(t2) {
      this._cndsBySid.set(t2.GetSID(), t2);
    }
    _RegisterAction(t2) {
      this._actsBySid.set(t2.GetSID(), t2);
    }
    _RegisterFunctionBlock(t2) {
      switch (t2.GetFunctionType()) {
        case 0:
          this._functionBlocksByName.set(t2.GetFunctionName().toLowerCase(), t2);
          break;
        case 1:
          this._customActionBlocksMap.set(t2.GetFunctionName().toLowerCase(), t2);
      }
    }
    _RegisterEventVariable(t2) {
      this._eventVarsBySid.set(t2.GetSID(), t2), t2.IsGlobal() ? this._allGlobalVars.push(t2) : this._allLocalVars.push(t2);
    }
    _DeduplicateSolModifierList(t2) {
      t2.length >= 2 && t2.sort(SortSolArray);
      let e = this._allUniqueSolModifiers.get(t2.length);
      e || (e = [], this._allUniqueSolModifiers.set(t2.length, e));
      for (let s = 0, n = e.length; s < n; ++s) {
        const n2 = e[s];
        if (IsSolArrayIdentical(t2, n2)) return n2;
      }
      return e.push(t2), t2;
    }
    _GetNextLocalVarIndex(t2) {
      return this._localVarInitialValues.push(t2.GetInitialValue()), this._nextLocalVarIndex++;
    }
    GetEventStack() {
      return this._eventStack;
    }
    GetCurrentEventStackFrame() {
      return this.GetEventStack().GetCurrentStackFrame();
    }
    GetCurrentEvent() {
      return this.GetCurrentEventStackFrame().GetCurrentEvent();
    }
    GetCurrentCondition() {
      const t2 = this.GetCurrentEventStackFrame();
      return t2.GetCurrentEvent().GetConditionAt(t2.GetConditionIndex());
    }
    GetCurrentAction() {
      const t2 = this.GetCurrentEventStackFrame();
      return t2.GetCurrentEvent().GetActionAt(t2.GetActionIndex());
    }
    GetLocalVarStack() {
      return this._localVarStack;
    }
    GetLoopStack() {
      return this._loopStack;
    }
    GetAllLocalVariablesInScope(t2) {
      const e = [];
      for (t2 = t2.GetScopeParent(); t2; ) C32.appendArray(e, t2._GetAllLocalVariablesInScope()), t2 = t2.GetScopeParent();
      return e;
    }
    _GetLocalVariablesScriptInterface(t2) {
      const e = {};
      for (const s of this.GetAllLocalVariablesInScope(t2)) e[s.GetJsPropName()] = s._GetScriptInterfaceDescriptor();
      return Object.create(Object.prototype, e);
    }
    GetEventVariableBySID(t2) {
      return this._eventVarsBySid.get(t2) || null;
    }
    GetEventBlockBySID(t2) {
      return this._blocksBySid.get(t2) || null;
    }
    GetConditionBySID(t2) {
      return this._cndsBySid.get(t2) || null;
    }
    GetActionBySID(t2) {
      return this._actsBySid.get(t2) || null;
    }
    GetFunctionBlockByName(t2) {
      return this._functionBlocksByName.get(t2.toLowerCase()) || null;
    }
    GetCustomActionBlockByName(t2, e) {
      let s = this._customActionBlocksMap.get((t2.GetName() + "." + e).toLowerCase());
      if (s) return s;
      if (!t2.IsFamily()) {
        for (const n of t2.GetFamilies()) if (s = this._customActionBlocksMap.get((n.GetName() + "." + e).toLowerCase()), s) return s;
      }
      return null;
    }
    GetAllGlobalVariables() {
      return this._allGlobalVars;
    }
    GetAllLocalVariables() {
      return this._allLocalVars;
    }
    ResetAllGlobalsToInitialValue(t2) {
      for (const t3 of this._allGlobalVars) t3.ResetToInitialValue();
      if (t2) for (const t3 of this._allLocalVars) t3.IsStatic() && t3.ResetToInitialValue();
    }
    GetEventGroupByName(t2) {
      return this._groupsByName.get(t2.toLowerCase()) || null;
    }
    GetEventGroupBySID(t2) {
      const e = this._blocksBySid.get(t2);
      return e && e.IsGroup() ? e : null;
    }
    GetAllGroups() {
      return this._allGroups;
    }
    ResetAllGroupsInitialActivation() {
      for (const t2 of this._allGroups) t2.ResetInitialActivation();
    }
    _ResetAllHasRunFlags() {
      for (const t2 of this._allSheets) t2._ResetHasRunFlag();
    }
    RunEvents(t2) {
      this._ResetAllHasRunFlags(), this._runningEventsDepth++;
      for (const e of t2.runningLayouts()) {
        const t3 = e.GetEventSheet();
        t3 && (this._runtime.PushCurrentLayout(e), t3.Run(), this._runtime.PopCurrentLayout());
      }
      this._runningEventsDepth--;
    }
    async DebugRunEvents(t2) {
      this._ResetAllHasRunFlags(), this._runningEventsDepth++;
      for (const e of this._DebugRunEventsGen(t2)) await this._runtime.DebugBreak(e);
      this._runningEventsDepth--;
    }
    *_DebugRunEventsGen(t2) {
      for (const e of t2.runningLayouts()) {
        const t3 = e.GetEventSheet();
        t3 && (this._runtime.PushCurrentLayout(e), yield* t3.DebugRun(), this._runtime.PopCurrentLayout());
      }
    }
    _Trigger(t2, e, s, n) {
      let i = false;
      if (!t2.GetMainRunningLayout()) return this.QueueTrigger(e, s, n);
      this._executingTriggerDepth++;
      for (const r2 of t2.runningLayouts()) {
        const t3 = r2.GetEventSheet();
        if (!t3) continue;
        this._runtime.PushCurrentLayout(r2);
        for (const r3 of t3.deepIncludes()) {
          const t4 = r3._Trigger(e, s, n);
          i = i || t4;
        }
        const o2 = t3._Trigger(e, s, n);
        i = i || o2, this._runtime.PopCurrentLayout();
      }
      return this._executingTriggerDepth--, i;
    }
    *_DebugTrigger(t2, e, s, n) {
      let i = false;
      if (!t2.GetMainRunningLayout()) return this.QueueTrigger(e, s, n);
      this._executingTriggerDepth++;
      for (const r2 of t2.runningLayouts()) {
        const t3 = r2.GetEventSheet();
        if (!t3) continue;
        this._runtime.PushCurrentLayout(r2);
        for (const r3 of t3.deepIncludes()) {
          const t4 = yield* r3._DebugTrigger(e, s, n);
          i = i || t4;
        }
        const o2 = yield* t3._DebugTrigger(e, s, n);
        i = i || o2, this._runtime.PopCurrentLayout();
      }
      return this._executingTriggerDepth--, i;
    }
    QueueTrigger(t2, e, s) {
      return this._queuedTriggers.push([t2, e, s]), false;
    }
    QueueDebugTrigger(t2, e, s) {
      let n = null;
      const i = new Promise((t3) => n = t3);
      return this._queuedDebugTriggers.push([t2, e, s, n]), i;
    }
    *_RunQueuedDebugTriggersGen() {
      if (this._runtime.HitBreakpoint()) throw new Error("should not be in breakpoint");
      const t2 = this._runtime.GetLayoutManager();
      for (; this._queuedDebugTriggers.length; ) {
        const [e, s, n, i] = this._queuedDebugTriggers.shift();
        i(yield* this._DebugTrigger(t2, e, s, n));
      }
    }
    async RunQueuedDebugTriggersAsync() {
      for (const t2 of this._RunQueuedDebugTriggersGen()) await this._runtime.DebugBreak(t2);
    }
    _FastTrigger(t2, e, s, n) {
      let i = false;
      const r2 = t2.GetMainRunningLayout(), o2 = r2.GetEventSheet();
      if (!o2) return;
      this._executingTriggerDepth++, this._runtime.PushCurrentLayout(r2);
      const a2 = o2.deepIncludes();
      for (let t3 = 0, r3 = a2.length; t3 < r3; ++t3) {
        const r4 = a2[t3]._FastTrigger(e, s, n);
        i = i || r4;
      }
      const l = o2._FastTrigger(e, s, n);
      return i = i || l, this._runtime.PopCurrentLayout(), this._executingTriggerDepth--, i;
    }
    *_DebugFastTrigger(t2, e, s, n) {
      let i = false;
      const r2 = t2.GetMainRunningLayout(), o2 = r2.GetEventSheet();
      if (!o2) return;
      this._executingTriggerDepth++, this._runtime.PushCurrentLayout(r2);
      const a2 = o2.deepIncludes();
      for (let t3 = 0, r3 = a2.length; t3 < r3; ++t3) {
        const r4 = yield* a2[t3]._DebugFastTrigger(e, s, n);
        i = i || r4;
      }
      const l = yield* o2._DebugFastTrigger(e, s, n);
      return i = i || l, this._runtime.PopCurrentLayout(), this._executingTriggerDepth--, i;
    }
    GetTriggerDepth() {
      return this._executingTriggerDepth;
    }
    IsInTrigger() {
      return this.GetTriggerDepth() > 0;
    }
    _IncTriggerDepth() {
      return ++this._executingTriggerDepth;
    }
    _DecTriggerDepth() {
      --this._executingTriggerDepth;
    }
    IsRunningEvents() {
      return this._runningEventsDepth > 0;
    }
    IsInEventEngine() {
      return this.IsRunningEvents() || this.IsInTrigger();
    }
    _RunQueuedTriggers(t2) {
      for (const [e, s, n] of this._queuedTriggers) this._Trigger(t2, e, s, n);
      C32.clearArray(this._queuedTriggers);
    }
    BlockFlushingInstances(t2) {
      t2 ? this._blockFlushingDepth++ : this._blockFlushingDepth--;
    }
    IsFlushingBlocked() {
      return this._blockFlushingDepth > 0;
    }
    ClearSol(t2) {
      for (let e = 0, s = t2.length; e < s; ++e) t2[e].GetSolStack().Clear();
    }
    PushCleanSol(t2) {
      for (let e = 0, s = t2.length; e < s; ++e) t2[e].GetSolStack().PushClean();
    }
    PushCopySol(t2) {
      for (let e = 0, s = t2.length; e < s; ++e) t2[e].GetSolStack().PushCopy();
    }
    PopSol(t2) {
      for (let e = 0, s = t2.length; e < s; ++e) t2[e].GetSolStack().Pop();
    }
    GetDynamicSolModifiersSet(t2) {
      const e = /* @__PURE__ */ new Set(), s = this._eventStack.GetAllStackFrames(), n = this._eventStack.GetCurrentStackFrameIndex();
      for (let i = 0; i <= n; ++i) {
        const n2 = s[i].GetDynamicSolModifiers();
        if (n2) for (const s2 of n2) t2 && t2.has(s2) || e.add(s2);
      }
      return e;
    }
    PushCleanSolDynamic(t2) {
      const e = /* @__PURE__ */ new Set([...t2]), s = this.GetDynamicSolModifiersSet(e);
      if (s.size > 0) {
        for (const t3 of s) t3.GetSolStack().PushClean();
        return [...s];
      }
      return null;
    }
    AddScheduledWait() {
      const t2 = C32.New(C32.ScheduledWait, this);
      return this._scheduledWaits.push(t2), t2;
    }
    scheduledWaits() {
      return this._scheduledWaits;
    }
    RunScheduledWaits() {
      if (!this._scheduledWaits.length) return;
      const t2 = this.GetCurrentEventStackFrame();
      let e = false;
      this._runningEventsDepth++;
      for (let s = 0, n = this._scheduledWaits.length; s < n; ++s) {
        const n2 = this._scheduledWaits[s];
        n2._ShouldRun() && n2._Run(t2), n2.ShouldRelease() && (e = true);
      }
      e && (this._FilterScheduledWaitsToRelease(), t2.Reset(null)), this._runningEventsDepth--;
    }
    async DebugRunScheduledWaits() {
      if (!this._scheduledWaits.length) return;
      const t2 = this.GetCurrentEventStackFrame();
      let e = false;
      this._runningEventsDepth++;
      for (let s = 0, n = this._scheduledWaits.length; s < n; ++s) {
        const n2 = this._scheduledWaits[s];
        n2._ShouldRun() && await n2._DebugRun(t2), n2.ShouldRelease() && (e = true);
      }
      e && (this._FilterScheduledWaitsToRelease(), t2.Reset(null)), this._runningEventsDepth--;
    }
    _FilterScheduledWaitsToRelease() {
      const t2 = C32.arrayFilterOut(this._scheduledWaits, (t3) => t3.ShouldRelease());
      for (const e of t2) e.Release();
    }
    ClearAllScheduledWaits() {
      for (const t2 of this._scheduledWaits) t2.Release();
      C32.clearArray(this._scheduledWaits);
    }
    _OnInstancesReleased(t2) {
      for (const e of this._scheduledWaits) e.RemoveInstances(t2);
      for (const e of t2) {
        const t3 = this._instSignals.get(e);
        if (this._instSignals.delete(e), t3) for (const { resolve: e2 } of t3.signalPromises.values()) e2(true);
      }
    }
    AddAsyncActionPromise(t2) {
      this._asyncActionPromises.push({ promise: t2, triggerDepth: this.GetTriggerDepth() });
    }
    ClearAsyncActionPromises() {
      C32.clearArray(this._asyncActionPromises);
    }
    GetPromiseForAllAsyncActions() {
      const t2 = this.GetTriggerDepth(), e = Promise.all(this._asyncActionPromises.filter((e2) => e2.triggerDepth === t2).map((t3) => t3.promise));
      return this._asyncActionPromises = this._asyncActionPromises.filter((e2) => e2.triggerDepth < t2), e;
    }
    Signal(t2) {
      const e = t2.toLowerCase();
      this._signalTags.push(e), this._runtime.Trigger(C32.Plugins.System.Cnds.OnSignal, null), this._signalTags.pop();
      for (const t3 of this._runtime.GetEventSheetManager().scheduledWaits()) t3.IsSignal() && t3.GetSignalTag() === e && t3.SetSignalled();
      const s = this._signalPromises.get(e);
      s && (s.resolve(), this._signalPromises.delete(e));
    }
    WaitForSignal(t2) {
      const e = t2.toLowerCase(), s = this._signalPromises.get(e);
      if (s) return s.promise;
      {
        let t3 = null;
        const s2 = new Promise((e2) => t3 = e2);
        return this._signalPromises.set(e, { promise: s2, resolve: t3 }), s2;
      }
    }
    GetCurrentSignalTag() {
      if (0 === this._signalTags.length) throw new Error("not in a signal");
      return this._signalTags.at(-1);
    }
    _GetInstanceSignalState(t2) {
      let e = this._instSignals.get(t2);
      return e || (e = { signalTags: [], signalPromises: /* @__PURE__ */ new Map() }, this._instSignals.set(t2, e)), e;
    }
    InstanceSignal(t2, e) {
      const s = this._GetInstanceSignalState(t2), n = e.toLowerCase();
      s.signalTags.push(n), this._runtime.Trigger(t2.GetPlugin().GetConstructor().Cnds.OnInstanceSignal, t2), s.signalTags.pop();
      for (const e2 of this._runtime.GetEventSheetManager().scheduledWaits()) e2.IsInstanceSignals() && e2.GetSignalTag() === n && e2.SetInstanceSignalled(t2);
      const i = s.signalPromises.get(n);
      i && (i.resolve(false), s.signalPromises.delete(n)), 0 === s.signalTags.length && 0 === s.signalPromises.size && this._instSignals.delete(t2);
    }
    WaitForInstanceSignal(t2, e) {
      const s = this._GetInstanceSignalState(t2), n = e.toLowerCase(), i = s.signalPromises.get(n);
      if (i) return i.promise;
      {
        let t3 = null;
        const e2 = new Promise((e3) => t3 = e3);
        return s.signalPromises.set(n, { promise: e2, resolve: t3 }), e2;
      }
    }
    GetCurrentInstanceSignalTag(t2) {
      const e = this._GetInstanceSignalState(t2);
      if (!e || 0 === e.signalTags.length) throw new Error("not in a signal");
      return e.signalTags.at(-1);
    }
    _SaveToJson() {
      return { "groups": this._SaveGroupsToJson(), "cnds": this._SaveCndsToJson(), "acts": this._SaveActsToJson(), "vars": this._SaveVarsToJson(), "waits": this._SaveScheduledWaitsToJson() };
    }
    _LoadFromJson(t2) {
      this._LoadGroupsFromJson(t2["groups"]), this._LoadCndsFromJson(t2["cnds"]), this._LoadActsFromJson(t2["acts"]), this._LoadVarsFromJson(t2["vars"]), this._LoadScheduledWaitsFromJson(t2["waits"]);
    }
    _SaveGroupsToJson() {
      const t2 = {};
      for (const e of this.GetAllGroups()) t2[e.GetSID().toString()] = e.IsGroupActive();
      return t2;
    }
    _LoadGroupsFromJson(t2) {
      for (const [e, s] of Object.entries(t2)) {
        const t3 = parseInt(e, 10), n = this.GetEventGroupBySID(t3);
        n && n.SetGroupActive(s);
      }
    }
    _SaveCndsToJson() {
      const t2 = {};
      for (const [e, s] of this._cndsBySid) {
        const n = s._SaveToJson();
        n && (t2[e.toString()] = n);
      }
      return t2;
    }
    _LoadCndsFromJson(t2) {
      const e = /* @__PURE__ */ new Map();
      for (const [s, n] of Object.entries(t2)) e.set(parseInt(s, 10), n);
      for (const [t3, s] of this._cndsBySid) s._LoadFromJson(e.get(t3) || null);
    }
    _SaveActsToJson() {
      const t2 = {};
      for (const [e, s] of this._actsBySid) {
        const n = s._SaveToJson();
        n && (t2[e.toString()] = n);
      }
      return t2;
    }
    _LoadActsFromJson(t2) {
      const e = /* @__PURE__ */ new Map();
      for (const [s, n] of Object.entries(t2)) e.set(parseInt(s, 10), n);
      for (const [t3, s] of this._actsBySid) s._LoadFromJson(e.get(t3) || null);
    }
    _SaveVarsToJson() {
      const t2 = {};
      for (const [e, s] of this._eventVarsBySid) s.IsConstant() || !s.IsGlobal() && !s.IsStatic() || (t2[e.toString()] = s.GetValue());
      return t2;
    }
    _LoadVarsFromJson(t2) {
      for (const [e, s] of Object.entries(t2)) {
        const t3 = parseInt(e, 10), n = this.GetEventVariableBySID(t3);
        n && n.SetValue(s);
      }
    }
    _SaveScheduledWaitsToJson() {
      return this._scheduledWaits.filter((t2) => !t2.IsPromise()).map((t2) => t2._SaveToJson());
    }
    _LoadScheduledWaitsFromJson(t2) {
      this.ClearAllScheduledWaits();
      for (const e of t2) {
        const t3 = C32.ScheduledWait._CreateFromJson(this, e);
        t3 && this._scheduledWaits.push(t3);
      }
    }
    _GetPerfRecords() {
      return [...this._runtime.GetLayoutManager().runningLayouts()].map((t2) => t2.GetEventSheet()).filter((t2) => t2).map((t2) => t2._GetPerfRecord());
    }
    FindFirstFunctionBlockParent(t2) {
      for (; t2; ) {
        const e = t2.GetScopeParent();
        if (e instanceof C32.FunctionBlock) return e;
        t2 = e;
      }
      return null;
    }
    _InvokeFunctionFromJS(t2, e) {
      Array.isArray(e) || (e = []);
      const s = this.GetFunctionBlockByName(t2.toLowerCase());
      if (!s) return null;
      if (!s.IsEnabled()) return s.GetDefaultReturnValue();
      const n = s.GetFunctionParameters();
      if (e.length < n.length) {
        e = e.slice(0);
        do {
          e.push(n[e.length].GetInitialValue());
        } while (e.length < n.length);
      }
      const i = s.GetEventBlock();
      return i.RunAsExpressionFunctionCall(i.GetSolModifiersIncludingParents(), false, s.GetReturnType(), s.GetDefaultReturnValue(), ...e);
    }
  };
}
var SortSolArray2;
var IsSolArrayIdentical2;
{
  const C32 = self.C3;
  C32.EventSheet = class extends C32.DefendedBase {
    constructor(e, t2) {
      super(), this._eventSheetManager = e, this._runtime = e.GetRuntime(), this._name = t2[0], this._events = [], this._triggers = /* @__PURE__ */ new Map(), this._fastTriggers = /* @__PURE__ */ new Map(), this._eventsByDisplayNumber = /* @__PURE__ */ new Map(), this._hasRun = false, this._shallowIncludes = [], this._deepIncludes = [], this._alreadyIncludedSheets = /* @__PURE__ */ new Set();
      for (const e2 of t2[1]) this._CreateEvent(e2, null, this._events);
      this._perfRecord = this._runtime.IsDebug() ? { type: "sheet", name: this._name, totalTimeCounter: 0, children: [] } : null;
    }
    Release() {
      this._eventSheetManager = null, this._runtime = null;
    }
    _CreateEvent(e, t2, s) {
      switch (e[0]) {
        case 0:
        case 3:
          this._CreateEventBlock(e, t2, s);
          break;
        case 1:
          this._CreateEventVariable(e, t2, s);
          break;
        case 2:
          this._CreateInclude(e, t2, s);
          break;
        case 4:
          this._CreateFunctionBlock(e, t2);
          break;
        case 5:
          this._CreateScriptBlock(e, t2, s);
          break;
        case 6:
          this._CreateCustomACEBlock(e, t2);
          break;
        default:
          throw new Error("invalid event type");
      }
    }
    _CreateEventBlock(e, t2, s) {
      const n = C32.EventBlock.Create(this, t2, e);
      if (n.IsOrBlock()) {
        s.push(n);
        const e2 = n.GetConditions();
        for (let t3 = 0, s2 = e2.length; t3 < s2; ++t3) e2[t3].IsTrigger() && this._InitTrigger(n, t3);
      } else n.IsTrigger() ? this._InitTrigger(n, 0) : s.push(n);
    }
    _CreateFunctionBlock(e, t2) {
      const s = C32.FunctionBlock.CreateFunctionBlock(this, t2, e);
      this._eventSheetManager._RegisterFunctionBlock(s);
    }
    _CreateCustomACEBlock(e, t2) {
      const s = C32.FunctionBlock.CreateCustomACEBlock(this, t2, e);
      this._eventSheetManager._RegisterFunctionBlock(s);
    }
    _CreateEventVariable(e, t2, s) {
      const n = C32.EventVariable.Create(this, t2, e);
      s.push(n);
    }
    _CreateInclude(e, t2, s) {
      const n = C32.EventInclude.Create(this, t2, e);
      s.push(n);
    }
    _CreateScriptBlock(e, t2, s) {
      const n = C32.EventScript.Create(this, t2, e);
      s.push(n);
    }
    _InitTrigger(e, t2) {
      e.IsOrBlock() || this._eventSheetManager._AddTriggerToPostInit(e);
      const s = e.GetConditionAt(t2), n = s._GetFunc(), r2 = s.GetObjectClass();
      if (s.IsFastTrigger()) {
        let i = this._fastTriggers.get(r2);
        i || (i = /* @__PURE__ */ new Map(), this._fastTriggers.set(r2, i));
        const l = s.GetFastTriggerValue().toLowerCase();
        let o2 = i.get(n);
        o2 || (o2 = /* @__PURE__ */ new Map(), i.set(n, o2));
        let a2 = o2.get(l);
        a2 || (a2 = [], o2.set(l, a2)), a2.push([e, t2]);
      } else {
        let i = this._triggers.get(r2);
        i || (i = { methodMap: /* @__PURE__ */ new Map(), behaviors: /* @__PURE__ */ new Map() }, this._triggers.set(r2, i));
        const l = s.GetBehaviorType();
        let o2;
        l ? (o2 = i.behaviors.get(l), o2 || (o2 = /* @__PURE__ */ new Map(), i.behaviors.set(l, o2))) : o2 = i.methodMap;
        let a2 = o2.get(n);
        a2 || (a2 = [], o2.set(n, a2)), a2.push([e, t2]);
      }
    }
    _PostInit() {
      const e = this._events;
      for (let t2 = 0, s = e.length; t2 < s; ++t2) {
        const n = t2 < s - 1 && e[t2 + 1] instanceof C32.EventBlock && e[t2 + 1].IsElseBlock();
        e[t2]._PostInit(n);
      }
    }
    _AddShallowInclude(e) {
      this._shallowIncludes.push(e);
    }
    _UpdateDeepIncludes() {
      C32.clearArray(this._deepIncludes), this._AddDeepIncludes(this), this._alreadyIncludedSheets.clear();
    }
    _AddDeepIncludes(e) {
      const t2 = e._deepIncludes, s = e._alreadyIncludedSheets;
      for (const n of this._shallowIncludes) {
        const r2 = n.GetIncludeSheet();
        n.IsActive() && e !== r2 && !s.has(r2) && (s.add(r2), r2._AddDeepIncludes(e), t2.push(r2));
      }
    }
    deepIncludes() {
      return this._deepIncludes;
    }
    GetEventSheetManager() {
      return this._eventSheetManager;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetName() {
      return this._name;
    }
    _RegisterEventByDisplayNumber(e, t2) {
      this._eventsByDisplayNumber.set(t2, e);
    }
    _GetEventByDisplayNumber(e) {
      return this._eventsByDisplayNumber.get(e) || null;
    }
    _ResetHasRunFlag() {
      this._hasRun = false;
    }
    Run() {
      if (this._hasRun) return;
      const e = this._runtime, t2 = e.IsCPUProfiling(), s = t2 ? performance.now() : 0;
      this._hasRun = true;
      const n = this.GetEventSheetManager(), r2 = n.GetCurrentEventStackFrame();
      for (const t3 of this._events) t3.Run(r2), n.ClearSol(t3.GetSolModifiers()), n.ClearAsyncActionPromises(), e.FlushPendingInstances();
      r2.Reset(null), t2 && (this._perfRecord.totalTimeCounter += performance.now() - s);
    }
    *DebugRun() {
      if (this._hasRun) return;
      this._hasRun = true;
      const e = this._runtime, t2 = this.GetEventSheetManager(), s = t2.GetCurrentEventStackFrame();
      for (const n of this._events) yield* n.DebugRun(s), t2.ClearSol(n.GetSolModifiers()), t2.ClearAsyncActionPromises(), e.FlushPendingInstances();
      s.Reset(null);
    }
    _Trigger(e, t2, s) {
      if (!t2) return this._TriggerForClass(e, t2, null, null);
      {
        const n = t2.GetObjectClass();
        let r2 = false, i = this._TriggerForClass(e, t2, n, s);
        r2 = r2 || i;
        for (const l of n.GetFamilies()) i = this._TriggerForClass(e, t2, l, s), r2 = r2 || i;
      }
    }
    _TriggerForClass(e, t2, s, n) {
      const r2 = this._triggers.get(s);
      if (!r2) return false;
      const i = n ? r2.behaviors.get(n) : r2.methodMap;
      if (!i) return false;
      const l = i.get(e);
      if (!l) return false;
      let o2 = false;
      for (const [e2, s2] of l) {
        const n2 = this._ExecuteTrigger(t2, e2, s2);
        o2 = o2 || n2;
      }
      return o2;
    }
    *_DebugTrigger(e, t2, s) {
      if (!t2) return yield* this._DebugTriggerForClass(e, t2, null, null);
      {
        const n = t2.GetObjectClass();
        let r2 = false, i = yield* this._DebugTriggerForClass(e, t2, n, s);
        r2 = r2 || i;
        for (const l of n.GetFamilies()) i = yield* this._DebugTriggerForClass(e, t2, l, s), r2 = r2 || i;
      }
    }
    *_DebugTriggerForClass(e, t2, s, n) {
      const r2 = this._triggers.get(s);
      if (!r2) return false;
      const i = n ? r2.behaviors.get(n) : r2.methodMap;
      if (!i) return false;
      const l = i.get(e);
      if (!l) return false;
      let o2 = false;
      for (const [e2, s2] of l) {
        let n2;
        n2 = e2.DebugCanRunFast() ? this._ExecuteTrigger(t2, e2, s2) : yield* this._DebugExecuteTrigger(t2, e2, s2), o2 = o2 || n2;
      }
      return o2;
    }
    _FastTrigger(e, t2, s) {
      const n = t2.GetObjectClass(), r2 = this._fastTriggers.get(n);
      if (!r2) return false;
      const i = r2.get(e);
      if (!i) return false;
      const l = i.get(s);
      if (!l) return false;
      let o2 = false;
      for (let e2 = 0, t3 = l.length; e2 < t3; ++e2) {
        const t4 = l[e2], s2 = this._ExecuteTrigger(null, t4[0], t4[1]);
        o2 = o2 || s2;
      }
      return o2;
    }
    *_DebugFastTrigger(e, t2, s) {
      const n = t2.GetObjectClass(), r2 = this._fastTriggers.get(n);
      if (!r2) return false;
      const i = r2.get(e);
      if (!i) return false;
      const l = i.get(s);
      if (!l) return false;
      let o2 = false;
      for (let e2 = 0, t3 = l.length; e2 < t3; ++e2) {
        const t4 = l[e2], s2 = t4[0], n2 = t4[1];
        let r3;
        r3 = s2.DebugCanRunFast() ? this._ExecuteTrigger(null, s2, n2) : yield* this._DebugExecuteTrigger(null, s2, n2), o2 = o2 || r3;
      }
      return o2;
    }
    _ExecuteTrigger(e, t2, s) {
      const n = this._runtime, r2 = this._eventSheetManager, i = r2.GetCurrentEvent(), l = r2.GetEventStack(), o2 = r2.GetTriggerDepth();
      let a2 = false;
      i && r2.PushCleanSol(i.GetSolModifiersIncludingParents()), r2.PushCleanSol(t2.GetSolModifiersIncludingParents());
      const c2 = o2 > 1;
      c2 && r2.GetLocalVarStack().Push();
      const u2 = l.Push(t2);
      if (e) {
        t2.GetConditions()[s].GetObjectClass().GetCurrentSol().SetSinglePicked(e), e.IsInContainer() && e.SetSiblingsSinglePicked();
      }
      let g2 = true;
      if (t2.GetParent()) {
        const e2 = t2.GetTriggerParents();
        for (let t3 = 0, s2 = e2.length; t3 < s2; ++t3) if (!e2[t3].RunPreTrigger(u2)) {
          g2 = false;
          break;
        }
      }
      return g2 && (t2.IsOrBlock() ? t2.RunOrBlockTrigger(u2, s) : t2.Run(u2), a2 = u2.GetLastEventTrue()), l.Pop(), c2 && r2.GetLocalVarStack().Pop(), r2.PopSol(t2.GetSolModifiersIncludingParents()), i && r2.PopSol(i.GetSolModifiersIncludingParents()), i || 1 !== o2 || (r2.ClearAsyncActionPromises(), r2.IsFlushingBlocked() || n.FlushPendingInstances()), a2;
    }
    *_DebugExecuteTrigger(e, t2, s) {
      const n = this._runtime, r2 = this._eventSheetManager, i = r2.GetCurrentEvent(), l = r2.GetEventStack(), o2 = r2.GetTriggerDepth();
      let a2 = false;
      i && r2.PushCleanSol(i.GetSolModifiersIncludingParents()), r2.PushCleanSol(t2.GetSolModifiersIncludingParents());
      const c2 = o2 > 1;
      c2 && r2.GetLocalVarStack().Push();
      const u2 = l.Push(t2);
      if (e) {
        t2.GetConditions()[s].GetObjectClass().GetCurrentSol().SetSinglePicked(e), e.IsInContainer() && e.SetSiblingsSinglePicked();
      }
      let g2 = true;
      if (t2.GetParent()) {
        const e2 = t2.GetTriggerParents();
        for (let t3 = 0, s2 = e2.length; t3 < s2; ++t3) if (!(yield* e2[t3].DebugRunPreTrigger(u2))) {
          g2 = false;
          break;
        }
      }
      return g2 && (t2.IsOrBlock() ? yield* t2.DebugRunOrBlockTrigger(u2, s) : yield* t2.DebugRun(u2), a2 = u2.GetLastEventTrue()), l.Pop(), c2 && r2.GetLocalVarStack().Pop(), r2.PopSol(t2.GetSolModifiersIncludingParents()), i && r2.PopSol(i.GetSolModifiersIncludingParents()), i || 1 !== o2 || (r2.ClearAsyncActionPromises(), r2.IsFlushingBlocked() || n.FlushPendingInstances()), a2;
    }
    _GetPerfRecord() {
      return this._perfRecord;
    }
  };
}
{
  let NoActions = function(t2, e) {
    return true;
  };
  NoActions2 = NoActions;
  const C32 = self.C3, EMPTY_ARRAY = [];
  function* DebugNoActions(t2, e) {
    return true;
  }
  C32.EventBlock = class extends C32.DefendedBase {
    constructor(t2, e, n) {
      super(), this._eventSheet = t2, this._runtime = t2.GetRuntime(), this._parent = e, this._scopeParent = null, this._eventStack = this._runtime.GetEventSheetManager().GetEventStack(), this._solModifiers = [], this._solModifiersIncludingParents = [], this._hasGotSolModifiersIncludingParents = false, this._isSolWriterAfterCnds = false, this._isTopLevelGroup = false, this._hasElseBlock = false, this._isOrBlock = !!n[2], this._isElseBlock = false, this._triggerParents = null, this._conditions = [], this._actions = [], this._subEvents = [], this._RunActions = NoActions, this._DebugRunActions = DebugNoActions, this._isGroup = false, this._isInitiallyActive = false, this._groupName = "", this._isGroupActive = false, this._containedIncludes = null, this._perfRecord = null, this._sid = n[4], this._displayNumber = n[5], this._eventSheet._RegisterEventByDisplayNumber(this, this._displayNumber), this._debugData = this._runtime.IsDebug() ? { isBreakpoint: n[3][0], isBreakable: n[3][1], canRunAllConditionsFast: false, canRunAllActionsFast: false, canRunAllSubEventsFast: false, canRunSelfFast: false } : null, this.GetEventSheetManager()._RegisterEventBlock(this), 3 === n[0] && this._InitGroup(n[1]);
      let s = 0;
      for (const t3 of n[6]) {
        const e2 = C32.Condition.Create(this, t3, s++);
        this._conditions.push(e2), this._AddSolModifier(e2.GetObjectClass());
      }
      s = 0;
      for (const t3 of n[7]) {
        const e2 = C32.Action.Create(this, t3, s++);
        this._actions.push(e2);
      }
      if (9 === n.length) {
        const t3 = n[8];
        for (const e2 of t3) this._eventSheet._CreateEvent(e2, this, this._subEvents);
      }
      this._conditions.length && (this._isElseBlock = null === this._conditions[0].GetObjectClass() && this._conditions[0]._GetFunc() === C32.Plugins.System.Cnds.Else), 0 === this._conditions.length && (this._conditions = EMPTY_ARRAY), 0 === this._actions.length && (this._actions = EMPTY_ARRAY), 0 === this._subEvents.length && (this._subEvents = EMPTY_ARRAY);
    }
    static Create(t2, e, n) {
      return C32.New(C32.EventBlock, t2, e, n);
    }
    _InitGroup(t2) {
      this._isGroup = true, this._isInitiallyActive = !!t2[0], this._isGroupActive = this._isInitiallyActive, this._groupName = t2[1].toLowerCase(), this._containedIncludes = [], this.GetEventSheetManager()._RegisterGroup(this), this._runtime.IsDebug() && (this._perfRecord = { type: "group", name: t2[1], totalTimeCounter: 0, children: [] });
    }
    _AddContainedInclude(t2) {
      this._containedIncludes.push(t2);
    }
    _AddContainerSolModifierToList(t2, e) {
      for (const n of t2.GetContainer().objectTypes()) e.includes(n) || e.push(n);
    }
    _AddSolModifierToList(t2, e) {
      if (t2) if (e.includes(t2) || e.push(t2), t2.IsFamily()) for (const n of t2.GetFamilyMembers()) n.IsInContainer() && this._AddContainerSolModifierToList(n, e);
      else t2.IsInContainer() && this._AddContainerSolModifierToList(t2, e);
    }
    _AddSolModifier(t2) {
      this._AddSolModifierToList(t2, this._solModifiers);
    }
    _AddParentSolModifier(t2) {
      this._AddSolModifierToList(t2, this._solModifiersIncludingParents);
    }
    SetAllSolModifiers() {
      this._solModifiers = this._runtime.GetAllObjectClasses();
    }
    _PostInit(t2) {
      this._hasElseBlock = !!t2, this._IdentifyTopLevelGroup(), this._IdentifyTriggerParents();
      for (const t3 of this._conditions) t3._PostInit();
      if (this._actions.length > 0) {
        let t3 = false;
        for (const e2 of this._actions) e2._PostInit(), e2.HasReturnType() && (t3 = true);
        t3 ? (this._RunActions = this._RunActions_ReturnValue, this._DebugRunActions = this._DebugRunActions_ReturnValue) : (this._RunActions = this._RunActions_Fast, this._DebugRunActions = this._DebugRunActions_Fast);
      }
      const e = this._subEvents;
      for (let t3 = 0, n = e.length; t3 < n; ++t3) {
        const s = t3 < n - 1 && e[t3 + 1] instanceof C32.EventBlock && e[t3 + 1].IsElseBlock();
        e[t3]._PostInit(s);
      }
      this._debugData && this._UpdateCanRunFast(), this._perfRecord && this._GetPerfRecordParent()._GetPerfRecord().children.push(this._perfRecord);
    }
    _GetPerfRecord() {
      return this._perfRecord;
    }
    _GetPerfRecordParent() {
      let t2 = this.GetParent();
      for (; t2; ) {
        if (t2.IsGroup()) return t2;
        t2 = t2.GetParent();
      }
      return this._eventSheet;
    }
    _UpdateCanRunFast() {
      const t2 = this._debugData;
      t2.canRunAllConditionsFast = this._conditions.every((t3) => t3.DebugCanRunFast()), t2.canRunAllActionsFast = this._actions.every((t3) => t3.DebugCanRunFast()), t2.canRunAllSubEventsFast = this._subEvents.every((t3) => t3.DebugCanRunFast()), t2.canRunSelfFast = t2.canRunAllConditionsFast && t2.canRunAllActionsFast && t2.canRunAllSubEventsFast;
    }
    _UpdateCanRunFastRecursive() {
      let t2 = this;
      do {
        t2._UpdateCanRunFast(), t2 = t2.GetParent();
      } while (t2);
    }
    _IdentifyTopLevelGroup() {
      if (!this.IsGroup()) return;
      let t2 = this.GetParent();
      for (this._isTopLevelGroup = true; t2; ) {
        if (!t2.IsGroup()) {
          this._isTopLevelGroup = false;
          break;
        }
        t2 = t2.GetParent();
      }
    }
    _IdentifySolModifiersIncludingParents() {
      const t2 = this._runtime.GetAllObjectClasses();
      if (this._solModifiers === t2) this._solModifiersIncludingParents = t2;
      else {
        this._solModifiersIncludingParents = C32.cloneArray(this._solModifiers);
        let t3 = this.GetParent();
        for (; t3; ) {
          for (const e2 of t3._solModifiers) this._AddParentSolModifier(e2);
          t3 = t3.GetParent();
        }
        const e = this.GetEventSheetManager();
        this._solModifiers = e._DeduplicateSolModifierList(this._solModifiers), this._solModifiersIncludingParents = e._DeduplicateSolModifierList(this._solModifiersIncludingParents);
      }
    }
    _IdentifyTriggerParents() {
      if (!this.HasAnyTriggeredCondition()) return;
      this._triggerParents = [];
      let t2 = this.GetParent();
      for (; t2; ) this._triggerParents.push(t2), t2 = t2.GetParent();
      this._triggerParents.reverse();
    }
    SetSolWriterAfterCnds() {
      this._isSolWriterAfterCnds = true, this._parent && this._parent.SetSolWriterAfterCnds();
    }
    IsSolWriterAfterCnds() {
      return this._isSolWriterAfterCnds;
    }
    GetSolModifiers() {
      return this._solModifiers;
    }
    GetSolModifiersIncludingParents() {
      return this._hasGotSolModifiersIncludingParents || (this._hasGotSolModifiersIncludingParents = true, this._IdentifySolModifiersIncludingParents()), this._solModifiersIncludingParents;
    }
    HasSolModifier(t2) {
      return this._solModifiers.includes(t2);
    }
    GetTriggerParents() {
      return this._triggerParents;
    }
    GetEventSheet() {
      return this._eventSheet;
    }
    GetEventSheetManager() {
      return this._eventSheet.GetEventSheetManager();
    }
    GetRuntime() {
      return this._runtime;
    }
    GetParent() {
      return this._parent;
    }
    _SetScopeParent(t2) {
      this._scopeParent = t2;
    }
    GetScopeParent() {
      return this._scopeParent || this._parent;
    }
    GetDisplayNumber() {
      return this._displayNumber;
    }
    IsDebugBreakable() {
      return this._debugData && this._debugData.isBreakable;
    }
    IsDebugBreakpoint() {
      return this.IsDebugBreakable() && this._debugData.isBreakpoint;
    }
    _SetDebugBreakpoint(t2) {
      this._debugData.isBreakpoint = !!t2, this._UpdateCanRunFastRecursive();
    }
    IsGroup() {
      return this._isGroup;
    }
    IsTopLevelGroup() {
      return this._isTopLevelGroup;
    }
    IsElseBlock() {
      return this._isElseBlock;
    }
    HasElseBlock() {
      return this._hasElseBlock;
    }
    GetGroupName() {
      return this._groupName;
    }
    IsGroupActive() {
      return this._isGroupActive;
    }
    ResetInitialActivation() {
      this.SetGroupActive(this._isInitiallyActive);
    }
    SetGroupActive(t2) {
      if (t2 = !!t2, !this._isGroup) throw new Error("not a group");
      if (this._isGroupActive !== t2) {
        this._isGroupActive = t2;
        for (const t3 of this._containedIncludes) t3.UpdateActive();
        if (this._containedIncludes.length) {
          const t3 = this._runtime.GetCurrentLayout().GetEventSheet();
          t3 && t3._UpdateDeepIncludes();
        }
      }
    }
    GetSID() {
      return this._sid;
    }
    IsOrBlock() {
      return this._isOrBlock;
    }
    IsTrigger() {
      return this._conditions.length && this._conditions[0].IsTrigger();
    }
    IsForFunctionBlock() {
      return this._scopeParent && this._scopeParent instanceof C32.FunctionBlock;
    }
    HasAnyTriggeredCondition() {
      return this.IsForFunctionBlock() || this._conditions.some((t2) => t2.IsTrigger());
    }
    GetConditions() {
      return this._conditions;
    }
    GetConditionCount() {
      return this._conditions.length;
    }
    GetConditionAt(t2) {
      if ((t2 = Math.floor(t2)) < 0 || t2 >= this._conditions.length) throw new RangeError("invalid condition index");
      return this._conditions[t2];
    }
    GetConditionByDebugIndex(t2) {
      return this.GetConditionAt(t2);
    }
    IsFirstConditionOfType(t2) {
      let e = t2.GetIndex();
      if (0 === e) return true;
      --e;
      const n = t2.IsSystemOrSingleGlobalCondition() ? t2.GetFirstObjectParameterObjectClass() : t2.GetObjectClass();
      for (; e >= 0; --e) {
        const t3 = this._conditions[e];
        if (n === t3.GetObjectClass() || t3.IsSystemOrSingleGlobalCondition() && t3.GetFirstObjectParameterObjectClass() === n) return false;
      }
      return true;
    }
    GetActions() {
      return this._actions;
    }
    GetActionCount() {
      return this._actions.length;
    }
    GetActionAt(t2) {
      if ((t2 = Math.floor(t2)) < 0 || t2 >= this._actions.length) throw new RangeError("invalid action index");
      return this._actions[t2];
    }
    GetActionByDebugIndex(t2) {
      t2 = Math.floor(t2);
      const e = this._actions.find((e2) => e2.GetDebugIndex() === t2);
      if (!e) throw new RangeError("invalid action debug index");
      return e;
    }
    _HasActionIndex(t2) {
      return (t2 = Math.floor(t2)) >= 0 && t2 < this._actions.length;
    }
    GetSubEvents() {
      return this._subEvents;
    }
    _GetAllLocalVariablesInScope() {
      return this._subEvents.filter((t2) => t2 instanceof C32.EventVariable);
    }
    RunPreTrigger(t2) {
      t2.SetCurrentEvent(this);
      const e = this._conditions;
      let n = 0 === e.length;
      for (let s = 0, i = e.length; s < i; ++s) {
        const i2 = e[s];
        if (t2.SetConditionIndex(s), i2.IsLooping()) throw new Error("trigger cannot be used as sub-event to a loop");
        if (i2.Run()) n = true;
        else if (!this._isOrBlock) return false;
      }
      return !this._isOrBlock || n;
    }
    RunOrBlockTrigger(t2, e) {
      t2.SetCurrentEvent(this), t2.SetConditionIndex(e), this._conditions[e].Run() && (this._RunActions(t2, 0) && this._RunSubEvents(t2), t2.SetLastEventTrue(true));
    }
    *DebugRunPreTrigger(t2) {
      t2.SetCurrentEvent(this);
      const e = this._conditions;
      let n = 0 === e.length;
      for (let s = 0, i = e.length; s < i; ++s) {
        const i2 = e[s];
        if (t2.SetConditionIndex(s), i2.IsLooping()) throw new Error("trigger cannot be used as sub-event to a loop");
        let o2;
        if (o2 = i2.DebugCanRunFast() ? i2.Run() : yield* i2.DebugRun(), o2) n = true;
        else if (!this._isOrBlock) return false;
      }
      return !this._isOrBlock || n;
    }
    *DebugRunOrBlockTrigger(t2, e) {
      t2.SetCurrentEvent(this), t2.SetConditionIndex(e);
      const n = this._conditions[e];
      let s;
      if (s = n.DebugCanRunFast() ? n.Run() : yield* n.DebugRun(), s) {
        let e2;
        e2 = this.DebugCanRunActionsFast() ? this._RunActions(t2, 0) : yield* this._DebugRunActions(t2, 0), e2 && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents()), t2.SetLastEventTrue(true);
      }
    }
    Run(t2) {
      t2.SetCurrentEvent(this), this._isElseBlock || t2.SetElseBranchRan(false), this._isOrBlock ? this._RunOrBlock(t2) : this._RunAndBlock(t2);
    }
    *DebugRun(t2) {
      (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), t2.SetCurrentEvent(this), this._isElseBlock || t2.SetElseBranchRan(false), this._isOrBlock ? yield* this._DebugRunOrBlock(t2) : yield* this._DebugRunAndBlock(t2);
    }
    _RunOrBlock(t2) {
      const e = this._conditions;
      let n = 0 === e.length;
      for (let s = 0, i = e.length; s < i; ++s) {
        const i2 = e[s];
        if (i2.IsTrigger()) continue;
        t2.SetConditionIndex(s);
        const o2 = i2.Run();
        n = n || o2;
      }
      t2.SetLastEventTrue(n), n && (this._RunActions(t2, 0) && this._RunSubEvents(t2), this._hasElseBlock && t2.SetElseBranchRan(true));
    }
    *_DebugRunOrBlock(t2) {
      const e = this._conditions;
      let n = 0 === e.length;
      for (let s = 0, i = e.length; s < i; ++s) {
        const i2 = e[s];
        if (i2.IsTrigger()) continue;
        let o2;
        t2.SetConditionIndex(s), o2 = i2.DebugCanRunFast() ? i2.Run() : yield* i2.DebugRun(), n = n || o2;
      }
      if (t2.SetLastEventTrue(n), n) {
        let e2;
        e2 = this.DebugCanRunActionsFast() ? this._RunActions(t2, 0) : yield* this._DebugRunActions(t2, 0), e2 && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents()), this._hasElseBlock && t2.SetElseBranchRan(true);
      }
    }
    _RunAndBlock(t2) {
      const e = this._conditions;
      for (let n = 0, s = e.length; n < s; ++n) {
        const s2 = e[n];
        t2.SetConditionIndex(n);
        if (!s2.Run()) return void t2.SetLastEventTrue(false);
      }
      t2.SetLastEventTrue(true), this._RunActions(t2, 0) && this._RunSubEvents(t2), t2.GetLastEventTrue() && this._hasElseBlock && t2.SetElseBranchRan(true);
    }
    *_DebugRunAndBlock(t2) {
      const e = this._conditions;
      for (let n2 = 0, s = e.length; n2 < s; ++n2) {
        const s2 = e[n2];
        let i;
        if (t2.SetConditionIndex(n2), i = s2.DebugCanRunFast() ? s2.Run() : yield* s2.DebugRun(), !i) return void t2.SetLastEventTrue(false);
      }
      let n;
      t2.SetLastEventTrue(true), n = this.DebugCanRunActionsFast() ? this._RunActions(t2, 0) : yield* this._DebugRunActions(t2, 0), n && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents()), t2.GetLastEventTrue() && this._hasElseBlock && t2.SetElseBranchRan(true);
    }
    _RunActions_Fast(t2, e) {
      const n = this._actions;
      for (let s = e, i = n.length; s < i; ++s) {
        const e2 = n[s];
        t2.SetActionIndex(s), e2.Run();
      }
      return true;
    }
    *_DebugRunActions_Fast(t2, e) {
      const n = this._actions;
      for (let s = e, i = n.length; s < i; ++s) {
        const e2 = n[s];
        t2.SetActionIndex(s), e2.DebugCanRunFast() ? e2.Run() : yield* e2.DebugRun();
      }
      return true;
    }
    _RunActions_ReturnValue(t2, e) {
      const n = this.GetEventSheetManager(), s = this._actions;
      for (let i = e, o2 = s.length; i < o2; ++i) {
        const e2 = s[i];
        t2.SetActionIndex(i);
        const o3 = e2.Run();
        if (e2.CanBailOut() && true === o3) return false;
        e2.IsAsync() && o3 instanceof Promise && n.AddAsyncActionPromise(o3);
      }
      return true;
    }
    *_DebugRunActions_ReturnValue(t2, e) {
      const n = this.GetEventSheetManager(), s = this._actions;
      for (let i = e, o2 = s.length; i < o2; ++i) {
        const e2 = s[i];
        let o3;
        if (t2.SetActionIndex(i), o3 = e2.DebugCanRunFast() ? e2.Run() : yield* e2.DebugRun(), e2.CanBailOut() && true === o3) return false;
        e2.IsAsync() && o3 instanceof Promise && n.AddAsyncActionPromise(o3);
      }
      return true;
    }
    _ResumeActionsAndSubEvents(t2) {
      this._RunActions(t2, t2.GetActionIndex()) && this._RunSubEvents();
    }
    *_DebugResumeActionsAndSubEvents(t2) {
      (yield* this._DebugRunActions(t2, t2.GetActionIndex())) && (yield* this._DebugRunSubEvents());
    }
    _RunSubEvents() {
      if (!this._subEvents.length) return;
      const t2 = this.IsGroup() && this._runtime.IsCPUProfiling(), e = t2 ? performance.now() : 0, n = this._eventStack, s = n.Push(this);
      this._isSolWriterAfterCnds ? this._RunSubEvents_SolWriterAfterCnds(s) : this._RunSubEvents_Fast(s), n.Pop(), t2 && (this._perfRecord.totalTimeCounter += performance.now() - e);
    }
    _RunSubEvents_SolWriterAfterCnds(t2) {
      const e = this._isGroup, n = this._isTopLevelGroup, s = this.GetEventSheetManager(), i = this._subEvents;
      for (let o2 = 0, r2 = i.length, u2 = r2 - 1; o2 < r2; ++o2) {
        const r3 = i[o2], l = r3.GetSolModifiers(), a2 = !n || !e && o2 < u2;
        a2 && s.PushCopySol(l), r3.Run(t2), a2 ? s.PopSol(l) : s.ClearSol(l);
      }
    }
    _RunSubEvents_Fast(t2) {
      const e = this._subEvents;
      for (let n = 0, s = e.length; n < s; ++n) e[n].Run(t2);
    }
    *_DebugRunSubEvents() {
      if (!this._subEvents.length) return;
      const t2 = this._eventStack, e = t2.Push(this);
      this._isSolWriterAfterCnds ? yield* this._DebugRunSubEvents_SolWriterAfterCnds(e) : yield* this._DebugRunSubEvents_Fast(e), t2.Pop();
    }
    *_DebugRunSubEvents_SolWriterAfterCnds(t2) {
      const e = this._isGroup, n = this._isTopLevelGroup, s = this.GetEventSheetManager(), i = this._subEvents;
      for (let o2 = 0, r2 = i.length, u2 = r2 - 1; o2 < r2; ++o2) {
        const r3 = i[o2], l = r3.GetSolModifiers(), a2 = !n || !e && o2 < u2;
        a2 && s.PushCopySol(l), yield* r3.DebugRun(t2), a2 ? s.PopSol(l) : s.ClearSol(l);
      }
    }
    *_DebugRunSubEvents_Fast(t2) {
      const e = this._subEvents;
      for (let n = 0, s = e.length; n < s; ++n) yield* e[n].DebugRun(t2);
    }
    Retrigger(t2, e) {
      e.ResetQuick();
      const n = this._conditions;
      if (!this.IsOrBlock()) for (let s = t2.GetConditionIndex() + 1, i = n.length; s < i; ++s) {
        const t3 = n[s];
        e.SetConditionIndex(s);
        if (!t3.Run()) return false;
      }
      return this._RunActions(e, 0) && this._RunSubEvents(e), true;
    }
    *DebugRetrigger(t2, e) {
      e.ResetQuick();
      const n = this._conditions;
      if (!this.IsOrBlock()) for (let s2 = t2.GetConditionIndex() + 1, i = n.length; s2 < i; ++s2) {
        const t3 = n[s2];
        let i2;
        if (e.SetConditionIndex(s2), i2 = t3.DebugCanRunFast() ? t3.Run() : yield* t3.DebugRun(), !i2) return false;
      }
      let s;
      return s = this.DebugCanRunActionsFast() ? this._RunActions(e, 0) : yield* this._DebugRunActions(e, 0), s && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents()), true;
    }
    DebugCanRunFast() {
      return !this.IsDebugBreakpoint() && !this._runtime.DebugBreakNext() && this._debugData.canRunSelfFast;
    }
    DebugCanRunActionsFast() {
      return !this._runtime.DebugBreakNext() && this._debugData.canRunAllActionsFast;
    }
    DebugCanRunSubEventsFast() {
      return !this._runtime.DebugBreakNext() && this._debugData.canRunAllSubEventsFast;
    }
    _CheckParentsOKToRun(t2) {
      if (this.GetParent()) {
        const e = this.GetTriggerParents();
        for (let n = 0, s = e.length; n < s; ++n) if (!e[n].RunPreTrigger(t2)) return false;
      }
      return true;
    }
    *_DebugCheckParentsOKToRun(t2) {
      if (this.GetParent()) {
        const e = this.GetTriggerParents();
        for (let n = 0, s = e.length; n < s; ++n) if (!(yield* e[n].DebugRunPreTrigger(t2))) return false;
      }
      return true;
    }
    _EvaluateFunctionCallParameters(t2, e, n) {
      if (e.length > 0) if (n) {
        const n2 = e.map((t3) => t3.Get(0));
        t2.GetLocalVarStack().Push(), this._scopeParent.SetFunctionParameters(n2);
      } else this._scopeParent.EvaluateFunctionParameters(e);
      else n && t2.GetLocalVarStack().Push();
    }
    RunAsFunctionCall(t2, e, n, s) {
      let i, o2;
      const r2 = t2.length > 0;
      let u2 = null;
      const l = this._runtime, a2 = this._eventStack, h2 = l.GetEventSheetManager(), c2 = this._scopeParent, _2 = c2.IsAsync(), d2 = h2._IncTriggerDepth() > 1;
      if (this._EvaluateFunctionCallParameters(h2, e, d2), r2 && (n ? h2.PushCopySol(t2) : h2.PushCleanSol(t2)), null !== s) {
        if (s.copyFromObjectClass) {
          const t3 = n ? s.copyFromObjectClass.GetCurrentSol() : s.copyFromObjectClass.GetSolStack().GetOneBelowCurrentSol(), e2 = s.copyToObjectClass.GetCurrentSol();
          e2.SetArrayPicked(t3.GetInstances()), e2.ClearElseInstances(), n || s.copyToObjectClass.ApplySolToContainer();
        } else if (s.pickObjectClass) {
          const t3 = s.pickObjectClass.GetCurrentSol();
          t3.SetArrayPicked(s.pickInstances), t3.ClearElseInstances();
        }
        s.pushCleanSolDynamic && (u2 = h2.PushCleanSolDynamic(t2));
      }
      const g2 = a2.Push(this);
      return n && g2.SetDynamicSolModifiers(t2), this._CheckParentsOKToRun(g2) && (g2.SetCurrentEvent(this), _2 && ([o2, i] = c2.StartAsyncFunctionCall()), this._RunAndBlock(g2), _2 && c2.MaybeFinishAsyncFunctionCall(o2)), a2.Pop(), d2 && h2.GetLocalVarStack().Pop(), null !== u2 && h2.PopSol(u2), r2 && h2.PopSol(t2), h2._DecTriggerDepth(), i;
    }
    *DebugRunAsFunctionCall(t2, e, n, s) {
      let i, o2;
      (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) && (yield this);
      const r2 = t2.length > 0;
      let u2 = null;
      const l = this._runtime, a2 = this._eventStack, h2 = l.GetEventSheetManager(), c2 = this._scopeParent, _2 = c2.IsAsync(), d2 = h2._IncTriggerDepth() > 1;
      if (this._EvaluateFunctionCallParameters(h2, e, d2), r2 && (n ? h2.PushCopySol(t2) : h2.PushCleanSol(t2)), null !== s) {
        if (s.copyFromObjectClass) {
          const t3 = n ? s.copyFromObjectClass.GetCurrentSol() : s.copyFromObjectClass.GetSolStack().GetOneBelowCurrentSol(), e2 = s.copyToObjectClass.GetCurrentSol();
          e2.SetArrayPicked(t3.GetInstances()), e2.ClearElseInstances(), n || s.copyToObjectClass.ApplySolToContainer();
        } else if (s.pickObjectClass) {
          const t3 = s.pickObjectClass.GetCurrentSol();
          t3.SetArrayPicked(s.pickInstances), t3.ClearElseInstances();
        }
        s.pushCleanSolDynamic && (u2 = h2.PushCleanSolDynamic(t2));
      }
      const g2 = a2.Push(this);
      return n && g2.SetDynamicSolModifiers(t2), (yield* this._DebugCheckParentsOKToRun(g2)) && (g2.SetCurrentEvent(this), _2 && ([o2, i] = c2.StartAsyncFunctionCall()), yield* this._DebugRunAndBlock(g2), _2 && c2.MaybeFinishAsyncFunctionCall(o2)), a2.Pop(), d2 && h2.GetLocalVarStack().Pop(), null !== u2 && h2.PopSol(u2), r2 && h2.PopSol(t2), h2._DecTriggerDepth(), i;
    }
    RunAsMappedFunctionCall(t2, e) {
      const n = this.GetSolModifiersIncludingParents(), s = n.length > 0, i = this._runtime, o2 = this._eventStack, r2 = i.GetEventSheetManager(), u2 = r2._IncTriggerDepth() > 1;
      u2 && r2.GetLocalVarStack().Push(), this._scopeParent.SetFunctionParameters(t2), s && (e ? r2.PushCopySol(n) : r2.PushCleanSol(n));
      const l = o2.Push(this);
      this._CheckParentsOKToRun(l) && (l.SetCurrentEvent(this), this._RunAndBlock(l)), o2.Pop(), u2 && r2.GetLocalVarStack().Pop(), s && r2.PopSol(n), r2._DecTriggerDepth();
    }
    *DebugRunAsMappedFunctionCall(t2, e) {
      (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) && (yield this);
      const n = this.GetSolModifiersIncludingParents(), s = n.length > 0, i = this._runtime, o2 = this._eventStack, r2 = i.GetEventSheetManager(), u2 = r2._IncTriggerDepth() > 1;
      u2 && r2.GetLocalVarStack().Push(), this._scopeParent.SetFunctionParameters(t2), s && (e ? r2.PushCopySol(n) : r2.PushCleanSol(n));
      const l = o2.Push(this);
      (yield* this._DebugCheckParentsOKToRun(l)) && (l.SetCurrentEvent(this), yield* this._DebugRunAndBlock(l)), o2.Pop(), u2 && r2.GetLocalVarStack().Pop(), s && r2.PopSol(n), r2._DecTriggerDepth();
    }
    RunAsExpressionFunctionCall(t2, e, n, s, ...i) {
      let o2, r2;
      const u2 = t2.length > 0, l = this._runtime, a2 = this._eventStack, h2 = l.GetEventSheetManager(), c2 = this._scopeParent, _2 = c2.IsAsync(), d2 = h2._IncTriggerDepth() > 1;
      d2 && h2.GetLocalVarStack().Push(), i.length > 0 && this._scopeParent.SetFunctionParameters(i), u2 && (e ? h2.PushCopySol(t2) : h2.PushCleanSol(t2));
      const g2 = a2.Push(this);
      return g2.InitCallFunctionExpression(n, s), a2.PushExpFunc(g2), l.SetDebuggingEnabled(false), this._CheckParentsOKToRun(g2) && (g2.SetCurrentEvent(this), _2 && ([r2, o2] = c2.StartAsyncFunctionCall()), this._RunAndBlock(g2), _2 && c2.MaybeFinishAsyncFunctionCall(r2)), l.SetDebuggingEnabled(true), a2.Pop(), a2.PopExpFunc(), d2 && h2.GetLocalVarStack().Pop(), u2 && h2.PopSol(t2), h2._DecTriggerDepth(), o2 || g2.GetFunctionReturnValue();
    }
  };
}
var NoActions2;
{
  const C32 = self.C3, EMPTY_SOL_MODIFIERS = [];
  let hadUserScriptException = false;
  C32.EventScript = class extends C32.DefendedBase {
    constructor(e, t2, i) {
      super();
      const r2 = e.GetRuntime(), n = e.GetEventSheetManager();
      this._eventSheet = e, this._eventSheetManager = n, this._runtime = e.GetRuntime(), this._parent = t2;
      const s = r2.GetObjectReference(i[1]);
      this._func = s, this._displayNumber = i[2], this._eventSheet._RegisterEventByDisplayNumber(this, this._displayNumber), this._debugData = r2.IsDebug() ? { isBreakpoint: i[3][0], isBreakable: i[3][1] } : null;
    }
    static Create(e, t2, i) {
      return C32.New(C32.EventScript, e, t2, i);
    }
    _PostInit() {
      const e = this._func, t2 = this._runtime.GetEventSheetManager()._GetLocalVariablesScriptInterface(this);
      this._func = e.bind(null, this._runtime.GetIRuntime(), t2);
    }
    GetParent() {
      return this._parent;
    }
    GetScopeParent() {
      return this._parent;
    }
    GetEventSheet() {
      return this._eventSheet;
    }
    GetDisplayNumber() {
      return this._displayNumber;
    }
    IsDebugBreakable() {
      return this._debugData && this._debugData.isBreakable;
    }
    IsDebugBreakpoint() {
      return this.IsDebugBreakable() && this._debugData.isBreakpoint;
    }
    _SetDebugBreakpoint(e) {
      this._debugData.isBreakpoint = !!e;
    }
    IsElseBlock() {
      return false;
    }
    GetSolModifiers() {
      return EMPTY_SOL_MODIFIERS;
    }
    GetSolModifiersIncludingParents() {
      return this._parent ? this._parent.GetSolModifiersIncludingParents() : EMPTY_SOL_MODIFIERS;
    }
    Run(e) {
      e.SetCurrentEvent(this), this._eventSheetManager.AddAsyncActionPromise(this._RunUserScript());
    }
    async _RunUserScript() {
      try {
        await this._func();
      } catch (e) {
        console.error(`Unhandled exception running script %c${this.GetEventSheet().GetName()}, event ${this.GetDisplayNumber()}:`, "font-size: 1.2em; font-weight: bold;", e), self.C3Debugger && self.C3Debugger._SetLastErrorScript(this), hadUserScriptException || (console.info("%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()", "font-weight: bold; text-decoration: underline", "", "font-weight: bold"), hadUserScriptException = true);
      }
    }
    *DebugRun(e) {
      e.SetCurrentEvent(this), (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this.Run(e);
    }
    DebugCanRunFast() {
      return !this.IsDebugBreakpoint() && !this._runtime.DebugBreakNext();
    }
    static HadUserScriptException() {
      return hadUserScriptException;
    }
    static SetHadUserScriptException() {
      hadUserScriptException = true;
    }
  };
}
{
  const C32 = self.C3, assert = self.assert;
  C32.FunctionBlock = class extends C32.DefendedBase {
    constructor(t2, e, s) {
      super(), this._eventSheet = t2, this._runtime = t2.GetRuntime(), this._parent = e, this._functionType = 0, this._functionName = "", this._returnType = 0, this._functionParameters = [], this._isEnabled = true, this._aceName = "", this._objectClass = null, this._hasOverrides = false, this._innerLocalVariables = [], this._isCopyPicked = false, this._isAsync = false, this._nextAsyncId = 0, this._currentAsyncId = -1, this._asyncMap = /* @__PURE__ */ new Map(), this._eventBlock = C32.EventBlock.Create(t2, e, s), this._eventBlock._SetScopeParent(this);
    }
    InitFunctionBlock(t2) {
      this._functionType = 0, this._functionName = t2[0], this._returnType = t2[1], this._functionParameters = t2[2].map((t3) => C32.EventVariable.Create(this._eventSheet, this, t3)), this._isEnabled = t2[3], this._isAsync = t2[4], this._isCopyPicked = t2[5];
    }
    InitCustomACEBlock(t2) {
      this._functionType = 1, this._aceName = t2[1], this._objectClass = this._runtime.GetObjectClassByIndex(t2[2]), this._eventBlock._AddSolModifier(this._objectClass), this._functionName = this._objectClass.GetName() + "." + this._aceName, this._returnType = t2[3], this._functionParameters = t2[4].map((t3) => C32.EventVariable.Create(this._eventSheet, this, t3)), this._isEnabled = t2[5], this._isAsync = t2[6], this._isCopyPicked = t2[7], this._objectClass.AddCustomAction(this);
    }
    static CreateFunctionBlock(t2, e, s) {
      const n = C32.New(C32.FunctionBlock, t2, e, s), i = s[1];
      return n.InitFunctionBlock(i), n;
    }
    static CreateCustomACEBlock(t2, e, s) {
      const n = C32.New(C32.FunctionBlock, t2, e, s), i = s[1];
      return n.InitCustomACEBlock(i), n;
    }
    _CheckOverrideState() {
      if (this._objectClass && this._objectClass.IsFamily()) {
        for (const t2 of this._objectClass.GetFamilyMembers()) if (t2.HasOwnCustomActionByName(this._aceName)) {
          this._hasOverrides = true;
          break;
        }
      }
    }
    _PostInit() {
      for (const t2 of this._functionParameters) t2._PostInit();
      this._eventBlock._PostInit(false);
    }
    GetFunctionType() {
      return this._functionType;
    }
    _GetAllLocalVariablesInScope() {
      return this._functionParameters;
    }
    GetFunctionParameters() {
      return this._functionParameters;
    }
    GetFunctionParameterCount() {
      return this._functionParameters.length;
    }
    _RegisterLocalVariable(t2) {
      this._innerLocalVariables.push(t2);
    }
    _GetAllInnerLocalVariables() {
      return this._innerLocalVariables;
    }
    EvaluateFunctionParameters(t2) {
      const e = this._functionParameters;
      for (let s = 0, n = e.length; s < n; ++s) e[s].SetValue(t2[s].Get(0));
    }
    SetFunctionParameters(t2) {
      const e = this._functionParameters;
      for (let s = 0, n = e.length; s < n; ++s) e[s].SetValue(t2[s]);
    }
    CaptureFunctionParameters() {
      return this._functionParameters.map((t2) => t2.GetValue());
    }
    GetParent() {
      return this._parent;
    }
    GetScopeParent() {
      return this._parent;
    }
    GetFunctionName() {
      return this._functionName;
    }
    GetACEName() {
      return this._aceName;
    }
    HasCustomACEOverrides() {
      return this._hasOverrides;
    }
    GetReturnType() {
      return this._returnType;
    }
    GetObjectClass() {
      return this._objectClass;
    }
    IsEnabled() {
      return this._isEnabled;
    }
    GetDefaultReturnValue() {
      switch (this._returnType) {
        case 0:
          return null;
        case 2:
          return "";
        default:
          return 0;
      }
    }
    GetEventBlock() {
      return this._eventBlock;
    }
    IsCopyPicked() {
      return this._isCopyPicked;
    }
    IsAsync() {
      return this._isAsync;
    }
    StartAsyncFunctionCall() {
      const t2 = this._nextAsyncId++;
      let e;
      this._currentAsyncId = t2;
      const s = new Promise((t3) => e = t3);
      return this._asyncMap.set(t2, { resolve: e, pauseCount: 0 }), [t2, s];
    }
    MaybeFinishAsyncFunctionCall(t2) {
      const e = this._asyncMap.get(t2);
      0 === e.pauseCount && (e.resolve(), this._asyncMap.delete(t2)), this._currentAsyncId = -1;
    }
    PauseCurrentAsyncFunction() {
      return this._asyncMap.get(this._currentAsyncId).pauseCount++, this._currentAsyncId;
    }
    ResumeAsyncFunction(t2) {
      this._currentAsyncId = t2;
      this._asyncMap.get(t2).pauseCount--;
    }
    RunAsFamilyCustomActionWithOverrides(t2, e) {
      const s = /* @__PURE__ */ new Map(), n = [];
      for (const t3 of this._objectClass.GetCurrentSol().GetInstances()) {
        const e2 = t3.GetObjectClass();
        if (e2.HasOwnCustomActionByName(this._aceName)) {
          const n2 = s.get(e2);
          Array.isArray(n2) ? n2.push(t3) : s.set(e2, [t3]);
        } else n.push(t3);
      }
      if (n.length > 0 && this._eventBlock.RunAsFunctionCall(t2, e, this._isCopyPicked, { pickObjectClass: this._objectClass, pickInstances: n }), s.size > 0) for (const [n2, i] of s) {
        const s2 = n2.GetOwnCustomActionByName(this._aceName).GetEventBlock(), a2 = [.../* @__PURE__ */ new Set([...t2, ...s2.GetSolModifiers()])];
        s2.RunAsFunctionCall(a2, e, this._isCopyPicked, { pickObjectClass: n2, pickInstances: i });
      }
    }
    *DebugRunAsFamilyCustomActionWithOverrides(t2, e) {
      const s = /* @__PURE__ */ new Map(), n = [];
      for (const t3 of this._objectClass.GetCurrentSol().GetInstances()) {
        const e2 = t3.GetObjectClass();
        if (e2.HasOwnCustomActionByName(this._aceName)) {
          const n2 = s.get(e2);
          Array.isArray(n2) ? n2.push(t3) : s.set(e2, [t3]);
        } else n.push(t3);
      }
      if (n.length > 0 && (yield* this._eventBlock.DebugRunAsFunctionCall(t2, e, this._isCopyPicked, { pickObjectClass: this._objectClass, pickInstances: n })), s.size > 0) for (const [n2, i] of s) {
        const s2 = n2.GetOwnCustomActionByName(this._aceName).GetEventBlock(), a2 = [.../* @__PURE__ */ new Set([...t2, ...s2.GetSolModifiers()])];
        yield* s2.DebugRunAsFunctionCall(a2, e, this._isCopyPicked, { pickObjectClass: n2, pickInstances: i });
      }
    }
  };
}
{
  const C32 = self.C3, EMPTY_SOL_MODIFIERS = [];
  C32.EventVariable = class extends C32.DefendedBase {
    constructor(t2, e, s) {
      super();
      const i = t2.GetEventSheetManager();
      this._eventSheet = t2, this._eventSheetManager = i, this._runtime = t2.GetRuntime(), this._parent = e, this._localVarStack = i.GetLocalVarStack(), this._name = s[1], this._type = s[2], this._initialValue = s[3], this._isStatic = !!s[4], this._isConstant = !!s[5], this._isFunctionParameter = e instanceof C32.FunctionBlock, this._sid = s[6], this._jsPropName = this._runtime.GetJsPropName(s[8]), this._scriptSetter = (t3) => this.SetValue(t3), this._scriptGetter = () => this.GetTypedValue(), this._hasSingleValue = !this._parent || this._isStatic || this._isConstant, this._value = this._initialValue, this._localIndex = -1, this.IsBoolean() && (this._value = this._value ? 1 : 0), !this.IsLocal() || this.IsStatic() || this.IsConstant() || (this._localIndex = i._GetNextLocalVarIndex(this)), i._RegisterEventVariable(this);
    }
    static Create(t2, e, s) {
      return C32.New(C32.EventVariable, t2, e, s);
    }
    _PostInit() {
      if (this.IsLocal() && !this.IsStatic() && !this.IsConstant() && !this.IsFunctionParameter()) {
        const t2 = this._eventSheetManager.FindFirstFunctionBlockParent(this);
        t2 && t2._RegisterLocalVariable(this);
      }
    }
    GetName() {
      return this._name;
    }
    GetJsPropName() {
      return this._jsPropName;
    }
    GetParent() {
      return this._parent;
    }
    GetScopeParent() {
      return this.GetParent();
    }
    IsGlobal() {
      return !this.GetParent();
    }
    IsLocal() {
      return !this.IsGlobal();
    }
    IsFunctionParameter() {
      return this._isFunctionParameter;
    }
    IsStatic() {
      return this._isStatic;
    }
    IsConstant() {
      return this._isConstant;
    }
    IsNumber() {
      return 0 === this._type;
    }
    IsString() {
      return 1 === this._type;
    }
    IsBoolean() {
      return 2 === this._type;
    }
    IsElseBlock() {
      return false;
    }
    GetSID() {
      return this._sid;
    }
    GetInitialValue() {
      return this._initialValue;
    }
    GetSolModifiers() {
      return EMPTY_SOL_MODIFIERS;
    }
    Run(t2) {
      !this.IsLocal() || this.IsStatic() || this.IsConstant() || this.SetValue(this.GetInitialValue());
    }
    DebugCanRunFast() {
      return true;
    }
    *DebugRun(t2) {
      this.Run(t2);
    }
    SetValue(t2) {
      this.IsNumber() ? "number" != typeof t2 && (t2 = parseFloat(t2)) : this.IsString() ? "string" != typeof t2 && (t2 = t2.toString()) : this.IsBoolean() && (t2 = t2 ? 1 : 0), this._hasSingleValue ? this._value = t2 : this._localVarStack.GetCurrent()[this._localIndex] = t2;
    }
    GetValue() {
      return this._hasSingleValue ? this._value : this._localVarStack.GetCurrent()[this._localIndex];
    }
    GetTypedValue() {
      let t2 = this.GetValue();
      return this.IsBoolean() && (t2 = !!t2), t2;
    }
    ResetToInitialValue() {
      this._value = this._initialValue;
    }
    _GetScriptInterfaceDescriptor() {
      return { configurable: false, enumerable: true, get: this._scriptGetter, set: this._scriptSetter };
    }
  };
}
{
  const C32 = self.C3, assert = self.assert, EMPTY_SOL_MODIFIERS = [];
  C32.EventInclude = class extends C32.DefendedBase {
    constructor(e, t2, n) {
      super();
      const s = e.GetEventSheetManager();
      this._eventSheet = e, this._eventSheetManager = s, this._runtime = e.GetRuntime(), this._parent = t2, this._includeSheet = null, this._includeSheetName = n[1], this._isActive = true;
    }
    static Create(e, t2, n) {
      return C32.New(C32.EventInclude, e, t2, n);
    }
    _PostInit() {
      this._includeSheet = this._eventSheetManager.GetEventSheetByName(this._includeSheetName), this._eventSheet._AddShallowInclude(this);
      let e = this.GetParent();
      for (; e; ) e instanceof C32.EventBlock && e.IsGroup() && e._AddContainedInclude(this), e = e.GetParent();
      this.UpdateActive(), this._runtime.IsDebug() && this._eventSheet._GetPerfRecord().children.push(this._includeSheet._GetPerfRecord());
    }
    GetParent() {
      return this._parent;
    }
    GetSolModifiers() {
      return EMPTY_SOL_MODIFIERS;
    }
    GetIncludeSheet() {
      return this._includeSheet;
    }
    Run(e) {
      const t2 = !!this.GetParent(), n = this._runtime.GetAllObjectClasses();
      t2 && this._eventSheetManager.PushCleanSol(n), this._includeSheet.Run(), t2 && this._eventSheetManager.PopSol(n);
    }
    *DebugRun(e) {
      const t2 = !!this.GetParent(), n = this._runtime.GetAllObjectClasses();
      t2 && this._eventSheetManager.PushCleanSol(n), yield* this._includeSheet.DebugRun(), t2 && this._eventSheetManager.PopSol(n);
    }
    DebugCanRunFast() {
      return false;
    }
    IsActive() {
      return this._isActive;
    }
    UpdateActive() {
      let e = this.GetParent();
      for (; e; ) {
        if (e instanceof C32.EventBlock && e.IsGroup() && !e.IsGroupActive()) return void (this._isActive = false);
        e = e.GetParent();
      }
      this._isActive = true;
    }
  };
}
{
  let WrapIndex = function(e, t2) {
    return e >= t2 ? e % t2 : e < 0 ? (e <= -t2 && (e %= t2), e < 0 && (e += t2), e) : e;
  };
  WrapIndex2 = WrapIndex;
  const C32 = self.C3, assert = self.assert;
  C32.ExpNode = class extends C32.DefendedBase {
    constructor(e) {
      super(), this._owner = e, this._runtime = e.GetRuntime();
    }
    _PostInit() {
    }
    static CreateNode(e, t2) {
      const s = t2[0], n = [BehaviorExpressionNode, ObjectExpressionNode, InstVarExpressionNode, EventVarExpNode, SystemExpressionExpNode, CallFunctionExpressionExpNode];
      return C32.New(n[s], e, t2);
    }
  };
  class SystemExpressionExpNode extends C32.ExpNode {
    constructor(e, t2) {
      super(e), this._systemPlugin = this._runtime.GetSystemPlugin(), this._func = this._runtime.GetObjectReference(t2[1]), this._func !== C32.Plugins.System.Exps.random && this._func !== C32.Plugins.System.Exps.choose || this._owner.SetVariesPerInstance();
    }
    GetBoundMethod() {
      return this._systemPlugin._GetBoundACEMethod(this._func, this._systemPlugin);
    }
  }
  class CallFunctionExpressionExpNode extends C32.ExpNode {
    constructor(e, t2) {
      super(e), this._functionBlock = null, this._functionName = t2[1], this._owner.SetVariesPerInstance();
    }
    _PostInit() {
      const e = this._runtime.GetEventSheetManager();
      this._functionBlock = e.GetFunctionBlockByName(this._functionName), this._functionName = null;
      const t2 = this._owner.GetEventBlock(), s = this._functionBlock.GetEventBlock();
      this._combinedSolModifiers = [.../* @__PURE__ */ new Set([...t2.GetSolModifiersIncludingParents(), ...s.GetSolModifiersIncludingParents()])], this._combinedSolModifiers = e._DeduplicateSolModifierList(this._combinedSolModifiers);
    }
    GetBoundMethod() {
      const e = this._functionBlock;
      if (e.IsEnabled()) {
        const t2 = e.GetEventBlock();
        return C32.EventBlock.prototype.RunAsExpressionFunctionCall.bind(t2, this._combinedSolModifiers, e.IsCopyPicked(), e.GetReturnType(), e.GetDefaultReturnValue());
      }
      {
        const t2 = e.GetDefaultReturnValue();
        return () => t2;
      }
    }
  }
  class ObjectExpressionNode extends C32.ExpNode {
    constructor(e, t2) {
      super(e), this._objectClass = this._runtime.GetObjectClassByIndex(t2[1]), this._func = this._runtime.GetObjectReference(t2[2]), this._returnsString = !!t2[3], this._eventStack = this._runtime.GetEventSheetManager().GetEventStack(), this._owner._MaybeVaryFor(this._objectClass);
    }
    GetBoundMethod() {
      return this._objectClass.GetPlugin()._GetBoundACEMethod(this._func, this._objectClass.GetSingleGlobalInstance().GetSdkInstance());
    }
    ExpObject(...e) {
      const t2 = this._objectClass, s = t2.GetCurrentSol().GetExpressionInstances(), n = s.length;
      if (0 === n) return this._returnsString ? "" : 0;
      const r2 = WrapIndex(this._owner.GetSolIndex(), n);
      return this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(t2), this._func.apply(s[r2].GetSdkInstance(), e);
    }
    ExpObject_InstExpr(e, ...t2) {
      const s = this._objectClass, n = s.GetInstances(), r2 = n.length;
      if (0 === r2 || "number" != typeof e) return this._returnsString ? "" : 0;
      const i = WrapIndex(e, r2);
      return this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(s), this._func.apply(n[i].GetSdkInstance(), t2);
    }
  }
  class InstVarExpressionNode extends C32.ExpNode {
    constructor(e, t2) {
      super(e), this._objectClass = this._runtime.GetObjectClassByIndex(t2[1]), this._varIndex = t2[3], this._returnsString = !!t2[2], this._owner._MaybeVaryFor(this._objectClass);
    }
    ExpInstVar() {
      const e = this._objectClass.GetCurrentSol().GetExpressionInstances(), t2 = e.length;
      if (0 === t2) return this._returnsString ? "" : 0;
      return e[WrapIndex(this._owner.GetSolIndex(), t2)]._GetInstanceVariableValueUnchecked(this._varIndex);
    }
    ExpInstVar_Family() {
      const e = this._objectClass, t2 = e.GetCurrentSol().GetExpressionInstances(), s = t2.length;
      if (0 === s) return this._returnsString ? "" : 0;
      const n = t2[WrapIndex(this._owner.GetSolIndex(), s)], r2 = n.GetObjectClass().GetFamilyInstanceVariableOffset(e.GetFamilyIndex());
      return n._GetInstanceVariableValueUnchecked(this._varIndex + r2);
    }
    ExpInstVar_InstExpr(e) {
      const t2 = this._objectClass, s = t2.GetInstances(), n = s.length;
      if (0 === n || "number" != typeof e) return this._returnsString ? "" : 0;
      const r2 = s[WrapIndex(e, n)];
      let i = 0;
      return t2.IsFamily() && (i = r2.GetObjectClass().GetFamilyInstanceVariableOffset(t2.GetFamilyIndex())), r2._GetInstanceVariableValueUnchecked(this._varIndex + i);
    }
  }
  class BehaviorExpressionNode extends C32.ExpNode {
    constructor(e, t2) {
      super(e), this._objectClass = this._runtime.GetObjectClassByIndex(t2[1]), this._behaviorType = this._objectClass.GetBehaviorTypeByName(t2[2]), this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(t2[2]), this._func = this._runtime.GetObjectReference(t2[3]), this._returnsString = !!t2[4], this._eventStack = this._runtime.GetEventSheetManager().GetEventStack(), this._owner._MaybeVaryFor(this._objectClass);
    }
    ExpBehavior(...e) {
      const t2 = this._objectClass, s = t2.GetCurrentSol().GetExpressionInstances(), n = s.length;
      if (0 === n) return this._returnsString ? "" : 0;
      const r2 = WrapIndex(this._owner.GetSolIndex(), n);
      this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(t2);
      const i = s[r2];
      let o2 = 0;
      return t2.IsFamily() && (o2 = i.GetObjectClass().GetFamilyBehaviorOffset(t2.GetFamilyIndex())), this._func.apply(i.GetBehaviorInstances()[this._behaviorIndex + o2].GetSdkInstance(), e);
    }
    ExpBehavior_InstExpr(e, ...t2) {
      const s = this._objectClass, n = s.GetInstances(), r2 = n.length;
      if (0 === r2 || "number" != typeof e) return this._returnsString ? "" : 0;
      const i = WrapIndex(e, r2);
      this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(s);
      const o2 = n[i];
      let a2 = 0;
      return s.IsFamily() && (a2 = o2.GetObjectClass().GetFamilyBehaviorOffset(s.GetFamilyIndex())), this._func.apply(o2.GetBehaviorInstances()[this._behaviorIndex + a2].GetSdkInstance(), t2);
    }
  }
  class EventVarExpNode extends C32.ExpNode {
    constructor(e, t2) {
      super(e), this._eventVar = null, this._eventVarSid = t2[1];
    }
    _PostInit() {
      this._eventVar = this._runtime.GetEventSheetManager().GetEventVariableBySID(this._eventVarSid);
    }
    GetVar() {
      return this._eventVar;
    }
  }
}
var WrapIndex2;
{
  let GetExpressionFunc = function(t2) {
    const e = self.C3_ExpressionFuncs[t2];
    if (!e) throw new Error("invalid expression number");
    return e;
  };
  GetExpressionFunc2 = GetExpressionFunc;
  const C32 = self.C3, assert = self.assert;
  C32.Parameter = class extends C32.DefendedBase {
    constructor(t2, e, s) {
      super(), this._owner = t2, this._index = s, this._type = e, this.Get = null, this._variesPerInstance = false, this._isConstant = false;
    }
    static Create(t2, e, s) {
      const r2 = e[0], n = [ExpressionParameter, StringExpressionParameter, FileParameter, ComboParameter, ObjectParameter, LayerExpressionParameter, LayoutParameter, ExpressionParameter, ComboParameter, ComboParameter, InstVarParameter, EventVarParameter, FileParameter, VariadicParameter, StringExpressionParameter, TimelineParameter, BooleanParameter, FunctionParameter, EaseParameter, TilemapBrushParameter, TemplateExpressionParameter, FlowchartParameter];
      return C32.New(n[r2], t2, r2, s, e);
    }
    _PostInit() {
    }
    SetVariesPerInstance() {
      this._variesPerInstance = true;
    }
    _MaybeVaryFor(t2) {
      this._variesPerInstance || t2 && (t2.GetPlugin().IsSingleGlobal() || (this._variesPerInstance = true));
    }
    VariesPerInstance() {
      return this._variesPerInstance;
    }
    GetIndex() {
      return this._index;
    }
    GetRuntime() {
      return this._owner.GetRuntime();
    }
    GetEventBlock() {
      return this._owner.GetEventBlock();
    }
    IsConstant() {
      return this._isConstant;
    }
    IsObjectParameter() {
      return 4 === this._type;
    }
  };
  class ExpressionParameter extends C32.Parameter {
    constructor(t2, e, s, r2) {
      super(t2, e, s), this._solIndex = 0;
      const n = r2[1];
      this._expressionNumber = n[0], this._numberedNodes = [], this._expressionFunc = null;
      for (let t3 = 1, e2 = n.length; t3 < e2; ++t3) this._numberedNodes.push(C32.ExpNode.CreateNode(this, n[t3]));
      this._numberedNodes.length ? this.Get = this.GetExpression : (this.Get = GetExpressionFunc(this._expressionNumber), this._isConstant = true);
    }
    _GetNode(t2) {
      if (t2 < 0 || t2 >= this._numberedNodes.length) throw new RangeError("invalid numbered node");
      return this._numberedNodes[t2];
    }
    _PostInit() {
      for (const t3 of this._numberedNodes) t3._PostInit();
      const t2 = GetExpressionFunc(this._expressionNumber);
      this._numberedNodes.length ? this._expressionFunc = t2(this) : this._expressionFunc = t2;
    }
    GetSolIndex() {
      return this._solIndex;
    }
    GetExpression(t2) {
      return this._solIndex = t2, this._expressionFunc();
    }
  }
  class StringExpressionParameter extends ExpressionParameter {
    constructor(t2, e, s, r2) {
      super(t2, e, s, r2), this.Get = this.GetStringExpression, 14 === e && (this.GetEventBlock().SetAllSolModifiers(), this._owner instanceof C32.Action && this.GetEventBlock().SetSolWriterAfterCnds());
    }
    GetStringExpression(t2) {
      this._solIndex = t2;
      const e = this._expressionFunc();
      return "string" == typeof e ? e : "";
    }
    _GetFastTriggerValue() {
      return GetExpressionFunc(this._expressionNumber)();
    }
  }
  class LayerExpressionParameter extends ExpressionParameter {
    constructor(t2, e, s, r2) {
      super(t2, e, s, r2), t2.GetImplementationSdkVersion() >= 2 ? this.Get = this.GetILayer : this.Get = this.GetLayer, this._isConstant = false;
    }
    GetLayer(t2) {
      this._solIndex = t2;
      const e = this._expressionFunc();
      return this.GetRuntime().GetCurrentLayout().GetLayer(e);
    }
    GetILayer(t2) {
      const e = this.GetLayer(t2);
      return e ? e.GetILayer() : null;
    }
  }
  class ComboParameter extends C32.Parameter {
    constructor(t2, e, s, r2) {
      super(t2, e, s), this._combo = r2[1], this.Get = this.GetCombo, this._isConstant = true;
    }
    GetCombo() {
      return this._combo;
    }
  }
  class BooleanParameter extends C32.Parameter {
    constructor(t2, e, s, r2) {
      super(t2, e, s), this._bool = r2[1], this.Get = this.GetBoolean, this._isConstant = true;
    }
    GetBoolean() {
      return this._bool;
    }
  }
  class ObjectParameter extends C32.Parameter {
    constructor(t2, e, s, r2) {
      super(t2, e, s), this._objectClass = this.GetRuntime().GetObjectClassByIndex(r2[1]), t2.GetImplementationSdkVersion() >= 2 ? this.Get = this.GetIObjectClass : this.Get = this.GetObjectClass;
      const n = this.GetEventBlock();
      n._AddSolModifier(this._objectClass), this._owner instanceof C32.Action ? n.SetSolWriterAfterCnds() : n.GetParent() && n.GetParent().SetSolWriterAfterCnds(), this._isConstant = true;
    }
    GetObjectClass() {
      return this._objectClass;
    }
    GetIObjectClass() {
      return this._objectClass ? this._objectClass.GetIObjectClass() : null;
    }
  }
  class LayoutParameter extends C32.Parameter {
    constructor(t2, e, s, r2) {
      super(t2, e, s), this._layout = this.GetRuntime().GetLayoutManager().GetLayoutByName(r2[1]), t2.GetImplementationSdkVersion() >= 2 ? this.Get = this.GetILayout : this.Get = this.GetLayout, this._isConstant = true;
    }
    GetLayout() {
      return this._layout;
    }
    GetILayout() {
      return this._layout ? this._layout.GetILayout() : null;
    }
  }
  class TimelineParameter extends C32.Parameter {
    constructor(t2, e, s, r2) {
      super(t2, e, s), this._timeline = this.GetRuntime().GetTimelineManager().GetTimelineByName(r2[1]), t2.GetImplementationSdkVersion() >= 2 ? this.Get = this.GetITimelineState : this.Get = this.GetTimeline, this._isConstant = true;
    }
    GetTimeline() {
      return this._timeline;
    }
    GetITimelineState() {
      return this._timeline ? this._timeline.GetITimelineState() : null;
    }
  }
  class FileParameter extends C32.Parameter {
    constructor(t2, e, s, r2) {
      super(t2, e, s), this._fileInfo = r2[1], this.Get = this.GetFile, this._isConstant = true;
    }
    GetFile() {
      return this._fileInfo;
    }
  }
  class InstVarParameter extends C32.Parameter {
    constructor(t2, e, s, r2) {
      super(t2, e, s), this._instVarIndex = r2[1];
      const n = this._owner.GetObjectClass();
      this._owner instanceof C32.Condition && this._owner.IsStatic() ? (this.Get = this.GetInstanceVariable, this._isConstant = true) : n && n.IsFamily() ? (this.Get = this.GetFamilyInstanceVariable, this.SetVariesPerInstance()) : (this.Get = this.GetInstanceVariable, this._isConstant = true);
    }
    GetInstanceVariable() {
      return this._instVarIndex;
    }
    GetFamilyInstanceVariable(t2) {
      t2 = t2 || 0;
      const e = this._owner.GetObjectClass(), s = e.GetCurrentSol(), r2 = s.GetInstances();
      let n = null;
      if (r2.length) n = r2[t2 % r2.length].GetObjectClass();
      else if (s.HasAnyElseInstances()) {
        const e2 = s.GetElseInstances();
        n = e2[t2 % e2.length].GetObjectClass();
      } else {
        if (!(e.GetInstanceCount() > 0)) return 0;
        {
          const s2 = e.GetInstances();
          n = s2[t2 % s2.length].GetObjectClass();
        }
      }
      return this._instVarIndex + n.GetFamilyInstanceVariableOffset(e.GetFamilyIndex());
    }
  }
  class EventVarParameter extends C32.Parameter {
    constructor(t2, e, s, r2) {
      super(t2, e, s), this._eventVarSid = r2[1], this._eventVar = null, t2.GetImplementationSdkVersion() >= 2 ? this.Get = this.GetIEventVariable : this.Get = this.GetEventVariable, this._isConstant = true;
    }
    _PostInit() {
      this._eventVar = this.GetRuntime().GetEventSheetManager().GetEventVariableBySID(this._eventVarSid);
    }
    GetEventVariable() {
      return this._eventVar;
    }
    GetIEventVariable() {
      return null;
    }
  }
  class FunctionParameter extends C32.Parameter {
    constructor(t2, e, s, r2) {
      super(t2, e, s), this._functionBlockName = r2[1], this._functionBlock = null, t2.GetImplementationSdkVersion() >= 2 ? this.Get = this.GetIFunction : this.Get = this.GetFunction, this._isConstant = true;
    }
    _PostInit() {
      this._functionBlock = this.GetRuntime().GetEventSheetManager().GetFunctionBlockByName(this._functionBlockName), this._functionBlockName = null;
    }
    GetFunction() {
      return this._functionBlock;
    }
    GetIFunction() {
      return null;
    }
  }
  class VariadicParameter extends C32.Parameter {
    constructor(t2, e, s, r2) {
      super(t2, e, s), this._subParams = [], this._variadicRet = [], this._isConstant = true;
      for (let t3 = 1, e2 = r2.length; t3 < e2; ++t3) {
        const e3 = C32.Parameter.Create(this._owner, r2[t3], 0);
        this._subParams.push(e3), this._variadicRet.push(0), e3.IsConstant() || (this._isConstant = false);
      }
      this.Get = this.GetVariadic;
    }
    _PostInit() {
      for (const t2 of this._subParams) t2._PostInit();
    }
    GetVariadic() {
      const t2 = this._subParams, e = this._variadicRet;
      for (let s = 0, r2 = t2.length; s < r2; ++s) e[s] = t2[s].Get(0);
      return e;
    }
  }
  class EaseParameter extends C32.Parameter {
    constructor(t2, e, s, r2) {
      super(t2, e, s), this._easeIndex = r2[1], this.Get = this.GetEase, this._isConstant = true;
    }
    GetEase() {
      return this._easeIndex;
    }
  }
  class TilemapBrushParameter extends C32.Parameter {
    constructor(t2, e, s, r2) {
      super(t2, e, s), this._brushIndex = r2[1], this.Get = this.GetTilemapBrush, this._isConstant = true;
    }
    GetTilemapBrush() {
      return this._brushIndex;
    }
  }
  class TemplateExpressionParameter extends ExpressionParameter {
    constructor(t2, e, s, r2) {
      super(t2, e, s, r2), this.Get = this.GetTemplateName, this._isConstant = false;
    }
    GetTemplateName() {
      return this._expressionFunc();
    }
  }
  class FlowchartParameter extends C32.Parameter {
    constructor(t2, e, s, r2) {
      super(t2, e, s), this._flowchartDataItem = this.GetRuntime().GetFlowchartManager().GetFlowchartDataItemByName(r2[1]), this.Get = this.GetFlowchartName, this._isConstant = true;
    }
    GetFlowchartName() {
      return this._flowchartDataItem.GetName();
    }
  }
}
var GetExpressionFunc2;
{
  let EvalParams = function(t2, e) {
    for (let s = 0, n = t2.length; s < n; ++s) e[s] = t2[s].Get(0);
  };
  EvalParams2 = EvalParams;
  const C32 = self.C3, assert = self.assert;
  const EMPTY_PARAMS_ARRAY = [], noop = function() {
  };
  C32.Condition = class extends C32.DefendedBase {
    constructor(t2, e, s) {
      if (super(), this._eventBlock = t2, this._runtime = t2.GetRuntime(), this._index = s, this._func = this._runtime.GetObjectReference(e[1]), this._isTrigger = e[3] > 0, this._isFastTrigger = 2 === e[3], this._isLooping = !!e[4], this._isInverted = !!e[5], this._isStatic = !!e[6], this._sid = e[7], this._isInOrBlock = this._eventBlock.IsOrBlock(), this._objectClass = null, this._behaviorType = null, this._behaviorIndex = -1, this._systemPlugin = null, this.Run = noop, this.DebugRun = noop, this._parameters = [], this._results = [], this._anyParamVariesPerInstance = false, this._savedData = null, this._unsavedData = null, this._debugData = this._runtime.IsDebug() ? { isBreakpoint: e[8][0], canDebug: e[8][1] } : null, -1 === e[0] ? this._systemPlugin = this._runtime.GetSystemPlugin() : (this._objectClass = this._runtime.GetObjectClassByIndex(e[0]), e[2] && (this._behaviorType = this._objectClass.GetBehaviorTypeByName(e[2]), this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(e[2])), this._eventBlock.GetParent() && this._eventBlock.GetParent().SetSolWriterAfterCnds()), 10 === e.length) {
        let t3 = e[9];
        for (let e2 of t3) this._parameters.push(C32.Parameter.Create(this, e2, this._parameters.length)), this._results.push(0);
      }
      0 === this._parameters.length && (this._parameters = EMPTY_PARAMS_ARRAY, this._results = EMPTY_PARAMS_ARRAY), this._eventBlock.GetEventSheetManager()._RegisterCondition(this);
    }
    static Create(t2, e, s) {
      return C32.New(C32.Condition, t2, e, s);
    }
    _PostInit() {
      for (const t2 of this._parameters) t2._PostInit(), t2.VariesPerInstance() && (this._anyParamVariesPerInstance = true);
      this._isFastTrigger ? (this.Run = this._RunFastTrigger, this.DebugRun = this._DebugRunFastTrigger) : this._systemPlugin ? (this._SetSystemRunMethod(), this.DebugRun = this._DebugRunSystem) : this._objectClass.GetPlugin().IsSingleGlobal() ? (this._SetSingleGlobalRunMethod(), this.DebugRun = this._DebugRunSingleGlobal) : this._isStatic ? (this.Run = this._RunStatic, this.DebugRun = this._DebugRunStatic) : (this.Run = this._RunObject, this.DebugRun = this._DebugRunObject);
    }
    _SetSystemRunMethod() {
      const t2 = this._systemPlugin, e = this._systemPlugin;
      this._SetRunMethodForBoundFunc(t2, e, this._RunSystem);
    }
    _SetSingleGlobalRunMethod() {
      const t2 = this._objectClass.GetPlugin(), e = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
      this._SetRunMethodForBoundFunc(t2, e, this._RunSingleGlobal);
    }
    _SetRunMethodForBoundFunc(t2, e, s) {
      const n = this._func, i = this._isInverted, r2 = this._parameters;
      if (0 === r2.length) {
        const s2 = t2._GetBoundACEMethod(n, e);
        this.Run = i ? function() {
          return C32.xor(s2(), i);
        } : s2;
      } else if (1 === r2.length) {
        const s2 = r2[0];
        if (!i && s2.IsConstant()) this.Run = t2._GetBoundACEMethod_1param(n, e, s2.Get(0));
        else {
          const r3 = t2._GetBoundACEMethod(n, e);
          this.Run = function() {
            return C32.xor(r3(s2.Get(0)), i);
          };
        }
      } else if (2 === r2.length) {
        const s2 = r2[0], a2 = r2[1];
        if (!i && s2.IsConstant() && a2.IsConstant()) this.Run = t2._GetBoundACEMethod_2params(n, e, s2.Get(0), a2.Get(0));
        else {
          const r3 = t2._GetBoundACEMethod(n, e);
          this.Run = function() {
            return C32.xor(r3(s2.Get(0), a2.Get(0)), i);
          };
        }
      } else if (3 === r2.length) {
        const s2 = r2[0], a2 = r2[1], h2 = r2[2];
        if (!i && s2.IsConstant() && a2.IsConstant() && h2.IsConstant()) this.Run = t2._GetBoundACEMethod_3params(n, e, s2.Get(0), a2.Get(0), h2.Get(0));
        else {
          const r3 = t2._GetBoundACEMethod(n, e);
          this.Run = function() {
            return C32.xor(r3(s2.Get(0), a2.Get(0), h2.Get(0)), i);
          };
        }
      } else this.Run = s;
    }
    GetSID() {
      return this._sid;
    }
    _GetFunc() {
      return this._func;
    }
    GetObjectClass() {
      return this._objectClass;
    }
    GetBehaviorType() {
      return this._behaviorType;
    }
    GetImplementationAddon() {
      return this._behaviorType ? this._behaviorType.GetBehavior() : this._objectClass ? this._objectClass.GetPlugin() : null;
    }
    GetImplementationSdkVersion() {
      const t2 = this.GetImplementationAddon();
      return t2 ? t2.GetSdkVersion() : 1;
    }
    GetEventBlock() {
      return this._eventBlock;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetIndex() {
      return this._index;
    }
    GetDebugIndex() {
      return this.GetIndex();
    }
    IsTrigger() {
      return this._isTrigger;
    }
    IsFastTrigger() {
      return this._isFastTrigger;
    }
    IsInverted() {
      return this._isInverted;
    }
    IsLooping() {
      return this._isLooping;
    }
    IsStatic() {
      return this._isStatic;
    }
    IsBreakpoint() {
      return this._debugData.isBreakpoint;
    }
    IsSystemCondition() {
      return !!this._systemPlugin;
    }
    IsSystemOrSingleGlobalCondition() {
      return this.IsSystemCondition() || this._objectClass.GetPlugin().IsSingleGlobal();
    }
    GetFirstObjectParameterObjectClass() {
      for (const t2 of this._parameters) if (t2.IsObjectParameter()) return t2.GetObjectClass();
      return null;
    }
    _SetBreakpoint(t2) {
      this._debugData.isBreakpoint = !!t2, this._eventBlock._UpdateCanRunFastRecursive();
    }
    _DebugReturnsGenerator() {
      return this._debugData.canDebug;
    }
    DebugCanRunFast() {
      return !this.IsBreakpoint() && !this._runtime.DebugBreakNext() && !this._DebugReturnsGenerator();
    }
    GetSavedDataMap() {
      return this._savedData || (this._savedData = /* @__PURE__ */ new Map()), this._savedData;
    }
    GetUnsavedDataMap() {
      return this._unsavedData || (this._unsavedData = /* @__PURE__ */ new Map()), this._unsavedData;
    }
    _RunSystem() {
      const t2 = this._results;
      return EvalParams(this._parameters, t2), C32.xor(this._func.apply(this._systemPlugin, t2), this._isInverted);
    }
    *_DebugRunSystem() {
      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
        const t2 = this._results;
        EvalParams(this._parameters, t2);
        let e = this._func.apply(this._systemPlugin, t2);
        return C32.IsIterator(e) && (e = yield* e), C32.xor(e, this._isInverted);
      }
      return this.Run();
    }
    _RunSingleGlobal() {
      const t2 = this._results;
      EvalParams(this._parameters, t2);
      const e = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
      return C32.xor(this._func.apply(e, t2), this._isInverted);
    }
    *_DebugRunSingleGlobal() {
      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
        const t2 = this._results;
        EvalParams(this._parameters, t2);
        const e = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
        let s = this._func.apply(e, t2);
        return C32.IsIterator(s) && (s = yield* s), C32.xor(s, this._isInverted);
      }
      return this.Run();
    }
    _RunFastTrigger() {
      return true;
    }
    *_DebugRunFastTrigger() {
      return (this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), true;
    }
    _GetStaticConditionThis() {
      return this._behaviorType ? this._behaviorType.GetBehavior().GetSdkVersion() >= 2 ? this._behaviorType.GetIBehaviorType() : this._behaviorType : this._objectClass.GetPlugin().GetSdkVersion() >= 2 ? this._objectClass.GetIObjectClass() : this._objectClass;
    }
    _RunStatic() {
      const t2 = this._results;
      EvalParams(this._parameters, t2);
      const e = this._func.apply(this._GetStaticConditionThis(), t2);
      return this._objectClass.ApplySolToContainer(), e;
    }
    *_DebugRunStatic() {
      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
        const t2 = this._results;
        EvalParams(this._parameters, t2);
        let e = this._func.apply(this._GetStaticConditionThis(), t2);
        return C32.IsIterator(e) && (e = yield* e), this._objectClass.ApplySolToContainer(), e;
      }
      return this.Run();
    }
    _RunObject() {
      const t2 = this._parameters, e = this._results, s = this._objectClass.GetCurrentSol();
      for (let s2 = 0, n = t2.length; s2 < n; ++s2) {
        const n2 = t2[s2];
        n2.VariesPerInstance() || (e[s2] = n2.Get(0));
      }
      return s.IsSelectAll() ? this._RunObject_FirstFilter(s) : this._RunObject_NextFilter(s);
    }
    *_DebugRunObject() {
      return (this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._RunObject();
    }
    _EvaluateVaryingParameters(t2) {
      const e = this._parameters, s = this._results;
      for (let n = 0, i = e.length; n < i; ++n) {
        const i2 = e[n];
        i2.VariesPerInstance() && (s[n] = i2.Get(t2));
      }
    }
    _RunObject_FirstFilter(t2) {
      const e = this._objectClass, s = e.IsFamily(), n = e.GetFamilyIndex(), i = this._behaviorIndex, r2 = i >= 0, a2 = e.GetInstances(), h2 = this._anyParamVariesPerInstance, o2 = this._results, l = this._func, u2 = this._isInverted, _2 = this._isInOrBlock && !this._isTrigger;
      t2.ClearArrays();
      for (let e2 = 0, c2 = a2.length; e2 < c2; ++e2) {
        const c3 = a2[e2];
        let g2;
        if (h2 && this._EvaluateVaryingParameters(e2), r2) {
          const t3 = s ? c3.GetObjectClass().GetFamilyBehaviorOffset(n) : 0;
          g2 = l.apply(c3.GetBehaviorInstances()[i + t3].GetSdkInstance(), o2);
        } else g2 = l.apply(c3.GetSdkInstance(), o2);
        C32.xor(g2, u2) ? t2._PushInstance(c3) : _2 && t2._PushElseInstance(c3);
      }
      return e.FinishCondition(true), t2._SetSelectAll(false), e.ApplySolToContainer(), t2.HasAnyInstances();
    }
    _RunObject_NextFilter(t2) {
      const e = this._objectClass, s = e.IsFamily(), n = e.GetFamilyIndex(), i = e.IsInContainer(), r2 = this._behaviorIndex, a2 = r2 >= 0, h2 = this._anyParamVariesPerInstance, o2 = this._results, l = this._func, u2 = this._isInverted, _2 = this._isInOrBlock && !this._isTrigger, c2 = t2._GetOwnInstances(), g2 = t2._GetOwnElseInstances(), d2 = _2 && !this._eventBlock.IsFirstConditionOfType(this), I2 = d2 ? g2 : c2;
      let G = 0, b2 = false;
      for (let t3 = 0, e2 = I2.length; t3 < e2; ++t3) {
        const e3 = I2[t3];
        let m3;
        if (h2 && this._EvaluateVaryingParameters(t3), a2) {
          const t4 = s ? e3.GetObjectClass().GetFamilyBehaviorOffset(n) : 0;
          m3 = l.apply(e3.GetBehaviorInstances()[r2 + t4].GetSdkInstance(), o2);
        } else m3 = l.apply(e3.GetSdkInstance(), o2);
        C32.xor(m3, u2) ? (b2 = true, d2 ? (c2.push(e3), i && e3._PushSiblingsToSolInstances()) : (I2[G] = e3, i && e3._SetSiblingsToSolInstancesIndex(G), ++G)) : d2 ? (I2[G] = e3, i && e3._SetSiblingsToSolElseInstancesIndex(G), ++G) : _2 && (g2.push(e3), i && e3._PushSiblingsToSolElseInstances());
      }
      C32.truncateArray(I2, G), i && e._TruncateContainerSols(d2, G);
      const m2 = b2;
      return d2 && !b2 && (b2 = this._OrBlockCheckInstances(c2)), e.FinishCondition(m2 || _2), _2 ? b2 : t2.HasAnyInstances();
    }
    _OrBlockCheckInstances(t2) {
      const e = this._objectClass, s = e.IsFamily(), n = e.GetFamilyIndex(), i = this._anyParamVariesPerInstance, r2 = this._behaviorIndex, a2 = r2 >= 0, h2 = this._results, o2 = this._func, l = this._isInverted;
      for (let e2 = 0, u2 = t2.length; e2 < u2; ++e2) {
        const u3 = t2[e2];
        let _2;
        if (i && this._EvaluateVaryingParameters(e2), a2) {
          const t3 = s ? u3.GetObjectClass().GetFamilyBehaviorOffset(n) : 0;
          _2 = o2.apply(u3.GetBehaviorInstances()[r2 + t3].GetSdkInstance(), h2);
        } else _2 = o2.apply(u3.GetSdkInstance(), h2);
        if (C32.xor(_2, l)) return true;
      }
      return false;
    }
    ReevaluateParameter(t2, e) {
      return this._parameters[t2].Get(e);
    }
    GetFastTriggerValue() {
      const t2 = this._parameters;
      if (!t2.length) throw new Error("no parameters");
      return t2[0]._GetFastTriggerValue();
    }
    _SaveToJson() {
      if (!this._savedData || !this._savedData.size) return null;
      const t2 = {};
      for (const [e, s] of this._savedData.entries()) {
        let n = s;
        "collmemory" === e && (n = [...s.entries()].map((t3) => [t3[0].GetUID(), t3[1].GetUID(), t3[2]])), t2[e] = n;
      }
      return { "ex": t2 };
    }
    _LoadFromJson(t2) {
      if (this._savedData && (this._savedData.clear(), this._savedData = null), !t2) return;
      const e = this._runtime, s = t2["ex"];
      if (s) {
        const t3 = this.GetSavedDataMap();
        t3.clear();
        for (const [n, i] of Object.entries(s)) {
          let s2 = i;
          "collmemory" === n && (s2 = C32.New(C32.PairMap, i.map((t4) => [e.GetInstanceByUID(t4[0]), e.GetInstanceByUID(t4[1]), t4[2]]).filter((t4) => t4[0] && t4[1]))), t3.set(n, s2);
        }
      }
    }
  };
}
var EvalParams2;
{
  let EvalParams = function(t2, e) {
    for (let s = 0, n = t2.length; s < n; ++s) e[s] = t2[s].Get(0);
  };
  EvalParams2 = EvalParams;
  const C32 = self.C3, assert = self.assert;
  const EMPTY_PARAMS_ARRAY = [], noop = function() {
  }, noopGenerator = function* () {
  }, FLAG_CANPICKANYOBJECTCLASS = 1, FLAG_COPYPICKED = 2, FLAG_CUSTOM_ACE = 4, FLAG_IS_ASYNC = 8, FLAG_CAN_BAIL_OUT = 16;
  C32.Action = class extends C32.DefendedBase {
    constructor(t2, e, s) {
      super(), this._eventBlock = t2;
      const n = t2.GetRuntime();
      this._runtime = n, this._index = s, this._sid = e.length >= 4 ? e[3] : -1, this._actionType = e.length >= 5 ? 255 & e[4] : 0, this._flags = e.length >= 5 ? e[4] >> 8 : 0, this._func = null, this._objectClass = null, this._behaviorType = null, this._behaviorIndex = -1, this._systemPlugin = null, this._callFunctionName = "", this._callCustomAceObjectClass = null, this._callEventBlock = null, this.Run = noop, this.DebugRun = noop, this._parameters = [], this._results = [], this._anyParamVariesPerInstance = false, this._savedData = null, this._unsavedData = null;
      const i = -3 === e[0], a2 = i ? e[2] : e[5];
      if (this._debugData = n.IsDebug() || i ? { isBreakpoint: a2[0], canDebug: a2[1], index: a2[2] } : null, -1 === e[0]) this._systemPlugin = n.GetSystemPlugin(), this._func = n.GetObjectReference(e[1]);
      else if (-2 === e[0]) this._callFunctionName = e[1];
      else if (i) {
        const t3 = n.GetObjectReference(e[1]);
        this._func = t3, this.Run = this.RunUserScript, this.DebugRun = this.DebugRunUserScript, this._flags |= 8;
      } else this._objectClass = n.GetObjectClassByIndex(e[0]), 4 & this._flags ? (this._callFunctionName = e[1], this._callCustomAceObjectClass = n.GetObjectClassByIndex(e[2])) : (e[2] && (this._behaviorType = this._objectClass.GetBehaviorTypeByName(e[2]), this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(e[2])), this._func = n.GetObjectReference(e[1]));
      if (7 === e.length) {
        const t3 = e[6];
        for (const e2 of t3) this._parameters.push(C32.Parameter.Create(this, e2, this._parameters.length)), this._results.push(0);
      }
      0 === this._parameters.length && (this._parameters = EMPTY_PARAMS_ARRAY, this._results = EMPTY_PARAMS_ARRAY), this.CanPickAnyObjectClass() && (this._eventBlock.SetAllSolModifiers(), this._eventBlock.SetSolWriterAfterCnds()), this._eventBlock.GetEventSheetManager()._RegisterAction(this);
    }
    static Create(t2, e, s) {
      return C32.New(C32.Action, t2, e, s);
    }
    _PostInit() {
      for (const t2 of this._parameters) t2._PostInit(), t2.VariesPerInstance() && (this._anyParamVariesPerInstance = true);
      if (this._systemPlugin) this._SetSystemRunMethod(), this.DebugRun = this._DebugRunSystem;
      else if (this._callFunctionName) 4 & this._flags ? this._SetCallCustomActionRunMethod() : this._SetCallFunctionRunMethod(), this._callFunctionName = "", this._callCustomAceObjectClass = null;
      else if (this.Run === this.RunUserScript) {
        const t2 = this._func, e = this._runtime.GetEventSheetManager()._GetLocalVariablesScriptInterface(this._eventBlock);
        this._func = t2.bind(null, this._runtime.GetIRuntime(), e);
      } else this._behaviorType ? this.IsAsync() ? (this.Run = this._RunBehavior_Async, this.DebugRun = this._DebugRunBehavior_Async) : (this.Run = this._RunBehavior, this.DebugRun = this._DebugRunBehavior) : this._objectClass.GetPlugin().IsSingleGlobal() ? (this._SetSingleGlobalRunMethod(), this.DebugRun = this._DebugRunSingleGlobal) : this.IsStatic() ? (this.Run = this._RunObject_Static, this.DebugRun = this._DebugRunObject_Static) : this.IsAsync() ? (this.Run = this._RunObject_Async, this.DebugRun = this._DebugRunObject_Async) : this.CallBeforeAfterHooks() ? (this.Run = this._RunObject_BeforeAfterHooks, this.DebugRun = this._DebugRunObject_BeforeAfterHooks) : this._parameters.length ? this._parameters.every((t2) => t2.VariesPerInstance()) ? (this.Run = this._RunObject_AllParamsVary, this.DebugRun = this._DebugRunObject_AllParamsVary) : this._anyParamVariesPerInstance ? (this.Run = this._RunObject_SomeParamsVary, this.DebugRun = this._DebugRunObject_SomeParamsVary) : this._parameters.every((t2) => t2.IsConstant()) ? (EvalParams(this._parameters, this._results), this.Run = this._RunObject_ParamsConst, this.DebugRun = this._DebugRunObject_ParamsConst) : (this.Run = this._RunObject_ParamsDontVary, this.DebugRun = this._DebugRunObject_ParamsDontVary) : (this.Run = this._RunObject_ParamsConst, this.DebugRun = this._DebugRunObject_ParamsConst);
    }
    _SetSystemRunMethod() {
      const t2 = this._systemPlugin, e = this._systemPlugin;
      this._SetRunMethodForBoundFunc(t2, e, this._RunSystem);
    }
    _SetSingleGlobalRunMethod() {
      const t2 = this._objectClass.GetPlugin(), e = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
      this._SetRunMethodForBoundFunc(t2, e, this._RunSingleGlobal);
    }
    _SetCallFunctionRunMethod() {
      const t2 = this._eventBlock.GetEventSheetManager(), e = t2.GetFunctionBlockByName(this._callFunctionName);
      if (e.IsEnabled()) {
        const s = !!(2 & this._flags);
        this._callEventBlock = e.GetEventBlock();
        let n = [.../* @__PURE__ */ new Set([...this._eventBlock.GetSolModifiersIncludingParents(), ...this._callEventBlock.GetSolModifiersIncludingParents()])];
        n = t2._DeduplicateSolModifierList(n);
        const i = !e.IsCopyPicked() && this._HasCopyPickedParent() ? { pushCleanSolDynamic: true } : null;
        if (this.Run = C32.EventBlock.prototype.RunAsFunctionCall.bind(this._callEventBlock, n, this._parameters, s, i), this._runtime.IsDebug()) {
          const t3 = this;
          this.DebugRun = function* () {
            (t3.IsBreakpoint() || t3._runtime.DebugBreakNext()) && (yield t3);
            return yield* t3._callEventBlock.DebugRunAsFunctionCall(n, t3._parameters, s, i);
          };
        } else this.DebugRun = noopGenerator;
      } else this.Run = noop, this.DebugRun = noopGenerator;
    }
    _SetCallCustomActionRunMethod() {
      const t2 = this._eventBlock.GetEventSheetManager(), e = t2.GetCustomActionBlockByName(this._callCustomAceObjectClass, this._callFunctionName);
      if (e.IsEnabled()) {
        const s = !!(2 & this._flags);
        this._callEventBlock = e.GetEventBlock();
        let n = [.../* @__PURE__ */ new Set([...this._eventBlock.GetSolModifiersIncludingParents(), ...this._callEventBlock.GetSolModifiersIncludingParents(), this._objectClass, e.GetObjectClass()])];
        n = t2._DeduplicateSolModifierList(n);
        const i = !this._objectClass.IsFamily() && !e.GetObjectClass().IsFamily(), a2 = !this._objectClass.IsFamily() && e.GetObjectClass().IsFamily(), r2 = this._objectClass.IsFamily();
        let o2 = null;
        if (!e.IsCopyPicked() && this._HasCopyPickedParent() && (o2 = o2 || {}, o2.pushCleanSolDynamic = true), !a2 && s || (o2 = o2 || {}, o2.copyFromObjectClass = this._objectClass, o2.copyToObjectClass = e.GetObjectClass()), i || a2 || r2 && !e.HasCustomACEOverrides() ? this.Run = C32.EventBlock.prototype.RunAsFunctionCall.bind(this._callEventBlock, n, this._parameters, s, o2) : r2 && (this.Run = C32.FunctionBlock.prototype.RunAsFamilyCustomActionWithOverrides.bind(e, n, this._parameters)), this._runtime.IsDebug()) {
          const t3 = this;
          i || a2 || r2 && !e.HasCustomACEOverrides() ? this.DebugRun = function* () {
            (t3.IsBreakpoint() || t3._runtime.DebugBreakNext()) && (yield t3);
            return yield* t3._callEventBlock.DebugRunAsFunctionCall(n, t3._parameters, s, o2);
          } : r2 && (this.DebugRun = function* () {
            (t3.IsBreakpoint() || t3._runtime.DebugBreakNext()) && (yield t3);
            return yield* e.DebugRunAsFamilyCustomActionWithOverrides(n, t3._parameters);
          });
        } else this.DebugRun = noopGenerator;
      } else this.Run = noop, this.DebugRun = noopGenerator;
    }
    _SetRunMethodForBoundFunc(t2, e, s) {
      const n = this._func, i = this._parameters;
      if (0 === i.length) this.Run = t2._GetBoundACEMethod(n, e);
      else if (1 === i.length) {
        const s2 = i[0];
        if (s2.IsConstant()) this.Run = t2._GetBoundACEMethod_1param(n, e, s2.Get(0));
        else {
          const i2 = t2._GetBoundACEMethod(n, e);
          this.Run = function() {
            return i2(s2.Get(0));
          };
        }
      } else if (2 === i.length) {
        const s2 = i[0], a2 = i[1];
        if (s2.IsConstant() && a2.IsConstant()) this.Run = t2._GetBoundACEMethod_2params(n, e, s2.Get(0), a2.Get(0));
        else {
          const i2 = t2._GetBoundACEMethod(n, e);
          this.Run = function() {
            return i2(s2.Get(0), a2.Get(0));
          };
        }
      } else if (3 === i.length) {
        const s2 = i[0], a2 = i[1], r2 = i[2];
        if (s2.IsConstant() && a2.IsConstant() && r2.IsConstant()) this.Run = t2._GetBoundACEMethod_3params(n, e, s2.Get(0), a2.Get(0), r2.Get(0));
        else {
          const i2 = t2._GetBoundACEMethod(n, e);
          this.Run = function() {
            return i2(s2.Get(0), a2.Get(0), r2.Get(0));
          };
        }
      } else this.Run = s;
    }
    GetSID() {
      return this._sid;
    }
    IsAsync() {
      return !!(8 & this._flags);
    }
    CanBailOut() {
      return !!(16 & this._flags);
    }
    CallBeforeAfterHooks() {
      return 1 === this._actionType;
    }
    IsStatic() {
      return 2 === this._actionType;
    }
    CanPickAnyObjectClass() {
      return !!(1 & this._flags);
    }
    HasReturnType() {
      return this.IsAsync() || this.CanBailOut();
    }
    GetObjectClass() {
      return this._objectClass;
    }
    GetImplementationAddon() {
      return this._behaviorType ? this._behaviorType.GetBehavior() : this._objectClass ? this._objectClass.GetPlugin() : null;
    }
    GetImplementationSdkVersion() {
      const t2 = this.GetImplementationAddon();
      return t2 ? t2.GetSdkVersion() : 1;
    }
    GetEventBlock() {
      return this._eventBlock;
    }
    _HasCopyPickedParent() {
      let t2 = this._eventBlock;
      do {
        if (t2 instanceof C32.FunctionBlock && t2.IsCopyPicked()) return true;
        t2 = t2.GetScopeParent();
      } while (t2);
      return false;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetIndex() {
      return this._index;
    }
    GetDebugIndex() {
      return this._debugData.index;
    }
    IsBreakpoint() {
      return this._debugData.isBreakpoint;
    }
    _SetBreakpoint(t2) {
      this._debugData.isBreakpoint = !!t2, this._eventBlock._UpdateCanRunFastRecursive();
    }
    _DebugReturnsGenerator() {
      return this._debugData.canDebug;
    }
    DebugCanRunFast() {
      return !this.IsBreakpoint() && !this._runtime.DebugBreakNext() && !this._DebugReturnsGenerator();
    }
    GetSavedDataMap() {
      return this._savedData || (this._savedData = /* @__PURE__ */ new Map()), this._savedData;
    }
    GetUnsavedDataMap() {
      return this._unsavedData || (this._unsavedData = /* @__PURE__ */ new Map()), this._unsavedData;
    }
    _RunSystem() {
      const t2 = this._results;
      return EvalParams(this._parameters, t2), this._func.apply(this._systemPlugin, t2);
    }
    *_DebugRunSystem() {
      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
        const t2 = this._results;
        EvalParams(this._parameters, t2);
        return yield* this._func.apply(this._systemPlugin, t2);
      }
      return this.Run();
    }
    _RunSingleGlobal() {
      const t2 = this._results;
      return EvalParams(this._parameters, t2), this._func.apply(this._objectClass.GetSingleGlobalInstance().GetSdkInstance(), t2);
    }
    *_DebugRunSingleGlobal() {
      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
        const t2 = this._results;
        EvalParams(this._parameters, t2);
        return yield* this._func.apply(this._objectClass.GetSingleGlobalInstance().GetSdkInstance(), t2);
      }
      return this.Run();
    }
    _RunObject_ParamsConst() {
      const t2 = this._results, e = this._objectClass.GetCurrentSol().GetInstances();
      for (let s = 0, n = e.length; s < n; ++s) this._func.apply(e[s].GetSdkInstance(), t2);
    }
    *_DebugRunObject_ParamsConst() {
      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
        const t2 = this._results, e = this._objectClass.GetCurrentSol().GetInstances();
        for (let s = 0, n = e.length; s < n; ++s) yield* this._func.apply(e[s].GetSdkInstance(), t2);
      } else this._RunObject_ParamsConst();
    }
    _RunObject_ParamsDontVary() {
      const t2 = this._results;
      EvalParams(this._parameters, t2);
      const e = this._objectClass.GetCurrentSol().GetInstances();
      for (let s = 0, n = e.length; s < n; ++s) this._func.apply(e[s].GetSdkInstance(), t2);
    }
    *_DebugRunObject_ParamsDontVary() {
      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
        const t2 = this._results;
        EvalParams(this._parameters, t2);
        const e = this._objectClass.GetCurrentSol().GetInstances();
        for (let s = 0, n = e.length; s < n; ++s) yield* this._func.apply(e[s].GetSdkInstance(), t2);
      } else this._RunObject_ParamsDontVary();
    }
    _RunObject_AllParamsVary() {
      const t2 = this._parameters, e = this._results, s = this._func, n = this._objectClass.GetCurrentSol().GetInstances();
      for (let i = 0, a2 = n.length; i < a2; ++i) {
        const a3 = n[i];
        for (let s2 = 0, n2 = t2.length; s2 < n2; ++s2) e[s2] = t2[s2].Get(i);
        s.apply(a3.GetSdkInstance(), e);
      }
    }
    *_DebugRunObject_AllParamsVary() {
      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
        const t2 = this._parameters, e = this._results, s = this._func, n = this._objectClass.GetCurrentSol().GetInstances();
        for (let i = 0, a2 = n.length; i < a2; ++i) {
          const a3 = n[i];
          for (let s2 = 0, n2 = t2.length; s2 < n2; ++s2) e[s2] = t2[s2].Get(i);
          yield* s.apply(a3.GetSdkInstance(), e);
        }
      } else this._RunObject_AllParamsVary();
    }
    _RunObject_SomeParamsVary() {
      const t2 = this._parameters, e = this._results, s = this._func, n = this._objectClass.GetCurrentSol().GetInstances();
      for (let s2 = 0, n2 = t2.length; s2 < n2; ++s2) {
        const n3 = t2[s2];
        n3.VariesPerInstance() || (e[s2] = n3.Get(0));
      }
      for (let i = 0, a2 = n.length; i < a2; ++i) {
        const a3 = n[i];
        for (let s2 = 0, n2 = t2.length; s2 < n2; ++s2) {
          const n3 = t2[s2];
          n3.VariesPerInstance() && (e[s2] = n3.Get(i));
        }
        s.apply(a3.GetSdkInstance(), e);
      }
    }
    *_DebugRunObject_SomeParamsVary() {
      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
        const t2 = this._parameters, e = this._results, s = this._func, n = this._objectClass.GetCurrentSol().GetInstances();
        for (let s2 = 0, n2 = t2.length; s2 < n2; ++s2) {
          const n3 = t2[s2];
          n3.VariesPerInstance() || (e[s2] = n3.Get(0));
        }
        for (let i = 0, a2 = n.length; i < a2; ++i) {
          const a3 = n[i];
          for (let s2 = 0, n2 = t2.length; s2 < n2; ++s2) {
            const n3 = t2[s2];
            n3.VariesPerInstance() && (e[s2] = n3.Get(i));
          }
          yield* s.apply(a3.GetSdkInstance(), e);
        }
      } else this._RunObject_SomeParamsVary();
    }
    _RunObject_BeforeAfterHooks() {
      const t2 = this._parameters, e = this._results, s = this._func, n = this._objectClass, i = n.GetSdkType(), a2 = n.GetCurrentSol().GetInstances();
      i.BeforeRunAction(s);
      for (let n2 = 0, i2 = a2.length; n2 < i2; ++n2) {
        const i3 = a2[n2];
        for (let s2 = 0, i4 = t2.length; s2 < i4; ++s2) e[s2] = t2[s2].Get(n2);
        s.apply(i3.GetSdkInstance(), e);
      }
      i.AfterRunAction(s);
    }
    *_DebugRunObject_BeforeAfterHooks() {
      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
        const t2 = this._parameters, e = this._results, s = this._func, n = this._objectClass, i = n.GetSdkType(), a2 = n.GetCurrentSol().GetInstances();
        i.BeforeRunAction(s);
        for (let n2 = 0, i2 = a2.length; n2 < i2; ++n2) {
          const i3 = a2[n2];
          for (let s2 = 0, i4 = t2.length; s2 < i4; ++s2) e[s2] = t2[s2].Get(n2);
          yield* s.apply(i3.GetSdkInstance(), e);
        }
        i.AfterRunAction(s);
      } else this._RunObject_BeforeAfterHooks();
    }
    _GetStaticActionThis() {
      return this._behaviorType ? this._behaviorType.GetBehavior().GetSdkVersion() >= 2 ? this._behaviorType.GetIBehaviorType() : this._behaviorType : this._objectClass.GetPlugin().GetSdkVersion() >= 2 ? this._objectClass.GetIObjectClass() : this._objectClass;
    }
    _RunObject_Static() {
      const t2 = this._results;
      return EvalParams(this._parameters, t2), this._func.apply(this._GetStaticActionThis(), t2);
    }
    *_DebugRunObject_Static() {
      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
        const t2 = this._results;
        EvalParams(this._parameters, t2);
        let e = this._func.apply(this._GetStaticActionThis(), t2);
        return C32.IsIterator(e) && (e = yield* e), e;
      }
      return this._RunObject_Static();
    }
    _RunBehavior() {
      const t2 = this._objectClass, e = t2.IsFamily(), s = t2.GetFamilyIndex(), n = this._parameters, i = this._anyParamVariesPerInstance, a2 = this._results, r2 = this._func, o2 = this._behaviorIndex, l = t2.GetCurrentSol().GetInstances();
      for (let t3 = 0, e2 = n.length; t3 < e2; ++t3) {
        const e3 = n[t3];
        e3.VariesPerInstance() || (a2[t3] = e3.Get(0));
      }
      for (let t3 = 0, h2 = l.length; t3 < h2; ++t3) {
        const h3 = l[t3];
        if (i) for (let e2 = 0, s2 = n.length; e2 < s2; ++e2) {
          const s3 = n[e2];
          s3.VariesPerInstance() && (a2[e2] = s3.Get(t3));
        }
        const u2 = e ? h3.GetObjectClass().GetFamilyBehaviorOffset(s) : 0;
        r2.apply(h3.GetBehaviorInstances()[o2 + u2].GetSdkInstance(), a2);
      }
    }
    *_DebugRunBehavior() {
      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
        const t2 = this._objectClass, e = t2.IsFamily(), s = t2.GetFamilyIndex(), n = this._parameters, i = this._anyParamVariesPerInstance, a2 = this._results, r2 = this._func, o2 = this._behaviorIndex, l = t2.GetCurrentSol().GetInstances();
        for (let t3 = 0, e2 = n.length; t3 < e2; ++t3) {
          const e3 = n[t3];
          e3.VariesPerInstance() || (a2[t3] = e3.Get(0));
        }
        for (let t3 = 0, h2 = l.length; t3 < h2; ++t3) {
          const h3 = l[t3];
          if (i) for (let e2 = 0, s2 = n.length; e2 < s2; ++e2) {
            const s3 = n[e2];
            s3.VariesPerInstance() && (a2[e2] = s3.Get(t3));
          }
          const u2 = e ? h3.GetObjectClass().GetFamilyBehaviorOffset(s) : 0;
          yield* r2.apply(h3.GetBehaviorInstances()[o2 + u2].GetSdkInstance(), a2);
        }
      } else this._RunBehavior();
    }
    _RunObject_Async() {
      const t2 = this._parameters, e = this._results, s = this._func, n = this._objectClass.GetCurrentSol().GetInstances(), i = [];
      for (let a2 = 0, r2 = n.length; a2 < r2; ++a2) {
        const r3 = n[a2];
        for (let s2 = 0, n2 = t2.length; s2 < n2; ++s2) e[s2] = t2[s2].Get(a2);
        i.push(s.apply(r3.GetSdkInstance(), e));
      }
      return Promise.all(i);
    }
    *_DebugRunObject_Async() {
      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
        const t2 = this._parameters, e = this._results, s = this._func, n = this._objectClass.GetCurrentSol().GetInstances(), i = [];
        for (let a2 = 0, r2 = n.length; a2 < r2; ++a2) {
          const r3 = n[a2];
          for (let s2 = 0, n2 = t2.length; s2 < n2; ++s2) e[s2] = t2[s2].Get(a2);
          i.push(yield* s.apply(r3.GetSdkInstance(), e));
        }
        return Promise.all(i);
      }
      return this._RunObject_Async();
    }
    _RunBehavior_Async() {
      const t2 = this._objectClass, e = t2.IsFamily(), s = t2.GetFamilyIndex(), n = this._parameters, i = this._results, a2 = this._func, r2 = this._behaviorIndex, o2 = t2.GetCurrentSol().GetInstances(), l = [];
      for (let t3 = 0, h2 = o2.length; t3 < h2; ++t3) {
        const h3 = o2[t3];
        for (let e2 = 0, s2 = n.length; e2 < s2; ++e2) i[e2] = n[e2].Get(t3);
        const u2 = e ? h3.GetObjectClass().GetFamilyBehaviorOffset(s) : 0;
        l.push(a2.apply(h3.GetBehaviorInstances()[r2 + u2].GetSdkInstance(), i));
      }
      return Promise.all(l);
    }
    *_DebugRunBehavior_Async() {
      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {
        const t2 = this._objectClass, e = t2.IsFamily(), s = t2.GetFamilyIndex(), n = this._parameters, i = this._results, a2 = this._func, r2 = this._behaviorIndex, o2 = t2.GetCurrentSol().GetInstances(), l = [];
        for (let t3 = 0, h2 = o2.length; t3 < h2; ++t3) {
          const h3 = o2[t3];
          for (let e2 = 0, s2 = n.length; e2 < s2; ++e2) i[e2] = n[e2].Get(t3);
          const u2 = e ? h3.GetObjectClass().GetFamilyBehaviorOffset(s) : 0;
          l.push(yield* a2.apply(h3.GetBehaviorInstances()[r2 + u2].GetSdkInstance(), i));
        }
        return Promise.all(l);
      }
      return this._RunBehavior_Async();
    }
    async RunUserScript() {
      try {
        await this._func();
      } catch (t2) {
        console.error(`Unhandled exception running script %c${this._eventBlock.GetEventSheet().GetName()}, event ${this._eventBlock.GetDisplayNumber()}, action ${this.GetDebugIndex() + 1}:`, "font-size: 1.2em; font-weight: bold;", t2), self.C3Debugger && self.C3Debugger._SetLastErrorScript(this), C32.EventScript.HadUserScriptException() || (console.info("%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()", "font-weight: bold; text-decoration: underline", "", "font-weight: bold"), C32.EventScript.SetHadUserScriptException());
      }
    }
    *DebugRunUserScript() {
      return (this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this.RunUserScript();
    }
    _SaveToJson() {
      return this._savedData && this._savedData.size ? { "ex": C32.ToSuperJSON(this._savedData) } : null;
    }
    _LoadFromJson(t2) {
      if (this._savedData && (this._savedData.clear(), this._savedData = null), !t2) return;
      const e = t2["ex"];
      e && (this._savedData = C32.FromSuperJSON(e));
    }
  };
}
var EvalParams2;
{
  let GetInst = function(t2) {
    return t2 instanceof IInstance ? runtime._UnwrapScriptInterface(t2) : t2.GetInstance();
  }, GetWorldInfo = function(t2) {
    return GetInst(t2).GetWorldInfo();
  }, GetInst_SDKv2 = function(t2) {
    return runtime._UnwrapScriptInterface(t2);
  }, GetWorldInfo_SDKv2 = function(t2) {
    return GetInst_SDKv2(t2).GetWorldInfo();
  }, GetObjectClass = function(t2) {
    return t2 instanceof IObjectClass ? runtime._UnwrapScriptInterface(t2) : t2;
  }, GetLayer = function(t2) {
    return t2 instanceof ILayer ? runtime._UnwrapScriptInterface(t2) : t2;
  }, CollMemory_Add = function(t2, e, n, o2) {
    e.GetUID() < n.GetUID() ? t2.Set(e, n, o2) : t2.Set(n, e, o2);
  }, CollMemory_Remove = function(t2, e, n) {
    e.GetUID() < n.GetUID() ? t2.Delete(e, n) : t2.Delete(n, e);
  }, CollMemory_RemoveInstance = function(t2, e) {
    t2.DeleteEither(e);
  }, CollMemory_Get = function(t2, e, n) {
    return e.GetUID() < n.GetUID() ? t2.Get(e, n) : t2.Get(n, e);
  }, DoOverlapCondition = function(t2, e, n, o2) {
    if (!e) return false;
    const s = 0 !== n || 0 !== o2, i = t2.GetWorldInfo(), r2 = runtime.GetCollisionEngine(), a2 = runtime.GetCurrentCondition(), l = a2.GetEventBlock().IsOrBlock(), c2 = a2.GetObjectClass(), u2 = a2.IsInverted(), S2 = e.GetCurrentSol(), f2 = c2 !== e;
    let G;
    rPickType = e, needsCollisionFinish = f2 && !u2, rPickFromElseInstances = false;
    let d2 = 0, I2 = 0, C2 = false;
    S2.IsSelectAll() ? (tempRect.copy(i.GetBoundingBox()), tempRect.offset(n, o2), r2.GetCollisionCandidates(i.GetLayer(), e, tempRect, tempCandidates2), G = tempCandidates2) : l ? runtime.IsCurrentConditionFirst() && !S2._GetOwnElseInstances().length && S2._GetOwnInstances().length ? G = S2._GetOwnInstances() : (G = S2._GetOwnElseInstances(), rPickFromElseInstances = true) : G = S2._GetOwnInstances(), s && (d2 = i.GetX(), I2 = i.GetY(), i.OffsetXY(n, o2), i.SetBboxChanged());
    for (const e2 of G) if (r2.TestOverlap(t2, e2)) {
      if (C2 = true, u2) break;
      f2 && rToPick.add(e2);
    }
    return s && (i.SetXY(d2, I2), i.SetBboxChanged()), C32.clearArray(tempCandidates2), C2;
  }, FinishCollisionConditionPicking = function(t2) {
    const e = runtime.GetCurrentEvent().IsOrBlock(), n = rPickType.GetCurrentSol(), o2 = n._GetOwnInstances(), s = n._GetOwnElseInstances();
    n.IsSelectAll() ? (n.SetSetPicked(rToPick), e && (C32.clearArray(s), n.AddElseInstances(rToPick, rPickType.GetInstances()))) : e ? rPickFromElseInstances ? n.TransferElseInstancesToOwn(rToPick) : (n.AddElseInstances(rToPick, o2), n.SetSetPicked(rToPick)) : n.SetSetPicked(rToPick), rPickType.ApplySolToContainer();
  }, FinishCollisionCondition = function(t2, e) {
    needsCollisionFinish && (e && FinishCollisionConditionPicking(t2), rToPick.clear(), rPickType = null, needsCollisionFinish = false);
  }, PickByUID_Normal = function(t2, e) {
    const n = runtime.GetInstanceByUID(e);
    if (!n) return false;
    const o2 = t2.GetCurrentSol();
    if (!o2.IsSelectAll() && !o2._GetOwnInstances().includes(n)) return false;
    if (t2.IsFamily()) {
      if (n.GetObjectClass().BelongsToFamily(t2)) return o2.PickOne(n), t2.ApplySolToContainer(), true;
    } else if (n.GetObjectClass() === t2) return o2.PickOne(n), t2.ApplySolToContainer(), true;
    return false;
  }, PickByUID_Inverted = function(t2, e) {
    const n = t2.GetCurrentSol();
    if (n.IsSelectAll()) {
      n._SetSelectAll(false), n.ClearArrays();
      const o2 = t2.GetInstances();
      for (let t3 = 0, s = o2.length; t3 < s; ++t3) {
        const s2 = o2[t3];
        s2.GetUID() === e ? n._PushElseInstance(s2) : n._PushInstance(s2);
      }
      return t2.ApplySolToContainer(), !!n._GetOwnInstances().length;
    }
    {
      const o2 = n._GetOwnInstances();
      let s = 0;
      for (let t3 = 0, i = o2.length; t3 < i; ++t3) {
        const i2 = o2[t3];
        o2[s] = i2, i2.GetUID() === e ? n._PushElseInstance(i2) : ++s;
      }
      return C32.truncateArray(o2, s), t2.ApplySolToContainer(), !!o2.length;
    }
  };
  GetInst2 = GetInst, GetWorldInfo2 = GetWorldInfo, GetInst_SDKv22 = GetInst_SDKv2, GetWorldInfo_SDKv22 = GetWorldInfo_SDKv2, GetObjectClass2 = GetObjectClass, GetLayer2 = GetLayer, CollMemory_Add2 = CollMemory_Add, CollMemory_Remove2 = CollMemory_Remove, CollMemory_RemoveInstance2 = CollMemory_RemoveInstance, CollMemory_Get2 = CollMemory_Get, DoOverlapCondition2 = DoOverlapCondition, FinishCollisionConditionPicking2 = FinishCollisionConditionPicking, FinishCollisionCondition2 = FinishCollisionCondition, PickByUID_Normal2 = PickByUID_Normal, PickByUID_Inverted2 = PickByUID_Inverted;
  const C32 = self.C3, tempColor = new C32.Color(), AnySDK = {}, SDKv1 = {}, SDKv2 = {};
  let runtime = null;
  C32.CommonACES_SetRuntime = function(t2) {
    runtime = t2;
  };
  const IInstance = self.IInstance, IObjectClass = self.IObjectClass, ILayer = self.ILayer;
  SDKv1.CompareX = function(t2, e) {
    return C32.compare(this.GetWorldInfo().GetX(), t2, e);
  }, SDKv2.CompareX = function(t2, e) {
    return C32.compare(this.x, t2, e);
  }, SDKv1.CompareY = function(t2, e) {
    return C32.compare(this.GetWorldInfo().GetY(), t2, e);
  }, SDKv2.CompareY = function(t2, e) {
    return C32.compare(this.y, t2, e);
  }, SDKv1.IsOnScreen = function() {
    return this.GetWorldInfo().IsInViewport2();
  }, SDKv2.IsOnScreen = function() {
    return this.isOnScreen();
  }, AnySDK.IsOutsideLayout = function() {
    const t2 = GetWorldInfo(this), e = t2.GetLayout(), n = t2.GetBoundingBox();
    return n.getRight() < 0 || n.getBottom() < 0 || n.getLeft() > e.GetWidth() || n.getTop() > e.GetHeight();
  }, AnySDK.PickDistance = function(t2, e, n) {
    const o2 = GetObjectClass(this).GetCurrentSol(), s = o2.GetInstances();
    if (!s.length) return false;
    let i = s[0], r2 = i.GetWorldInfo(), a2 = i, l = C32.distanceSquared(r2.GetX(), r2.GetY(), e, n);
    for (let o3 = 1, c2 = s.length; o3 < c2; ++o3) {
      i = s[o3], r2 = i.GetWorldInfo();
      const c3 = C32.distanceSquared(r2.GetX(), r2.GetY(), e, n);
      (0 === t2 && c3 < l || 1 === t2 && c3 > l) && (l = c3, a2 = i);
    }
    return o2.PickOne(a2), true;
  }, SDKv1.SetX = function(t2) {
    const e = this.GetWorldInfo();
    e.GetX() !== t2 && (e.SetX(t2), e.SetBboxChanged());
  }, SDKv2.SetX = function(t2) {
    this.x = +t2;
  }, SDKv1.SetY = function(t2) {
    const e = this.GetWorldInfo();
    e.GetY() !== t2 && (e.SetY(t2), e.SetBboxChanged());
  }, SDKv2.SetY = function(t2) {
    this.y = +t2;
  }, SDKv1.SetPos = function(t2, e) {
    const n = this.GetWorldInfo();
    n.EqualsXY(t2, e) || (n.SetXY(t2, e), n.SetBboxChanged());
  }, SDKv2.SetPos = function(t2, e) {
    this.setPosition(t2, e);
  }, AnySDK.SetPosToObject = function(t2, e) {
    if (!(t2 = GetObjectClass(t2))) return;
    const n = GetInst(this), o2 = t2.GetPairedInstance(n);
    if (!o2) return;
    const [s, i] = o2.GetImagePoint(e), r2 = n.GetWorldInfo();
    r2.GetX() === s && r2.GetY() === i || (r2.SetXY(s, i), r2.SetBboxChanged());
  }, AnySDK.MoveForward = function(t2) {
    if (0 === t2) return;
    const e = GetWorldInfo(this);
    e.OffsetXY(e.GetCosAngle() * t2, e.GetSinAngle() * t2), e.SetBboxChanged();
  }, SDKv1.MoveAtAngle = function(t2, e) {
    if (0 === e) return;
    const n = this.GetWorldInfo();
    t2 = C32.toRadians(t2), n.OffsetXY(Math.cos(t2) * e, Math.sin(t2) * e), n.SetBboxChanged();
  }, SDKv2.MoveAtAngle = function(t2, e) {
    0 !== e && (t2 = C32.toRadians(t2), this.offsetPosition(Math.cos(t2) * e, Math.sin(t2) * e));
  }, SDKv1.GetX = function() {
    return this.GetWorldInfo().GetX();
  }, SDKv2.GetX = function() {
    return this.x;
  }, SDKv1.GetY = function() {
    return this.GetWorldInfo().GetY();
  }, SDKv2.GetY = function() {
    return this.y;
  }, AnySDK.GetDt = function() {
    return runtime.GetDt(GetInst(this));
  }, SDKv1.CompareWidth = function(t2, e) {
    return C32.compare(this.GetWorldInfo().GetWidth(), t2, e);
  }, SDKv2.CompareWidth = function(t2, e) {
    return C32.compare(this.width, t2, e);
  }, SDKv1.CompareHeight = function(t2, e) {
    return C32.compare(this.GetWorldInfo().GetHeight(), t2, e);
  }, SDKv2.CompareHeight = function(t2, e) {
    return C32.compare(this.height, t2, e);
  }, SDKv1.SetWidth = function(t2) {
    const e = this.GetWorldInfo();
    e.GetWidth() !== t2 && (e.SetWidth(t2), e.SetBboxChanged());
  }, SDKv2.SetWidth = function(t2) {
    this.width = t2;
  }, SDKv1.SetHeight = function(t2) {
    const e = this.GetWorldInfo();
    e.GetHeight() !== t2 && (e.SetHeight(t2), e.SetBboxChanged());
  }, SDKv2.SetHeight = function(t2) {
    this.height = t2;
  }, SDKv1.SetSize = function(t2, e) {
    const n = GetWorldInfo(this);
    n.GetWidth() === t2 && n.GetHeight() === e || (n.SetSize(t2, e), n.SetBboxChanged());
  }, SDKv2.SetSize = function(t2, e) {
    this.setSize(t2, e);
  }, SDKv1.GetWidth = function() {
    return this.GetWorldInfo().GetWidth();
  }, SDKv2.GetWidth = function() {
    return this.width;
  }, SDKv1.GetHeight = function() {
    return this.GetWorldInfo().GetHeight();
  }, SDKv2.GetHeight = function() {
    return this.height;
  }, AnySDK.GetBboxLeft = function() {
    return GetWorldInfo(this).GetBoundingBox().getLeft();
  }, AnySDK.GetBboxTop = function() {
    return GetWorldInfo(this).GetBoundingBox().getTop();
  }, AnySDK.GetBboxRight = function() {
    return GetWorldInfo(this).GetBoundingBox().getRight();
  }, AnySDK.GetBboxBottom = function() {
    return GetWorldInfo(this).GetBoundingBox().getBottom();
  }, AnySDK.GetBboxMidX = function() {
    const t2 = GetWorldInfo(this).GetBoundingBox();
    return (t2.getLeft() + t2.getRight()) / 2;
  }, AnySDK.GetBboxMidY = function() {
    const t2 = GetWorldInfo(this).GetBoundingBox();
    return (t2.getTop() + t2.getBottom()) / 2;
  }, AnySDK.IsAngleWithin = function(t2, e) {
    return C32.angleDiff(GetWorldInfo(this).GetAngle(), C32.toRadians(e)) <= C32.toRadians(t2);
  }, AnySDK.IsAngleClockwiseFrom = function(t2) {
    return C32.angleClockwise(GetWorldInfo(this).GetAngle(), C32.toRadians(t2));
  }, AnySDK.IsBetweenAngles = function(t2, e) {
    const n = C32.toRadians(t2), o2 = C32.toRadians(e), s = GetWorldInfo(this).GetAngle();
    return !C32.angleClockwise(o2, n) ? !(!C32.angleClockwise(s, n) && C32.angleClockwise(s, o2)) : C32.angleClockwise(s, n) && !C32.angleClockwise(s, o2);
  }, SDKv1.SetAngle = function(t2) {
    const e = this.GetWorldInfo(), n = C32.clampAngle(C32.toRadians(t2));
    isNaN(n) || e.GetAngle() === n || (e.SetAngle(n), e.SetBboxChanged());
  }, SDKv2.SetAngle = function(t2) {
    this.angleDegrees = t2;
  }, AnySDK.RotateClockwise = function(t2) {
    if (isNaN(t2) || 0 === t2) return;
    const e = GetWorldInfo(this);
    e.SetAngle(e.GetAngle() + C32.toRadians(t2)), e.SetBboxChanged();
  }, AnySDK.RotateCounterclockwise = function(t2) {
    if (isNaN(t2) || 0 === t2) return;
    const e = GetWorldInfo(this);
    e.SetAngle(e.GetAngle() - C32.toRadians(t2)), e.SetBboxChanged();
  }, AnySDK.RotateTowardAngle = function(t2, e) {
    const n = GetWorldInfo(this), o2 = n.GetAngle(), s = C32.angleRotate(o2, C32.toRadians(e), C32.toRadians(t2));
    isNaN(s) || o2 === s || (n.SetAngle(s), n.SetBboxChanged());
  }, AnySDK.RotateTowardPosition = function(t2, e, n) {
    const o2 = GetWorldInfo(this), s = o2.GetAngle(), i = e - o2.GetX(), r2 = n - o2.GetY(), a2 = Math.atan2(r2, i), l = C32.angleRotate(s, a2, C32.toRadians(t2));
    isNaN(l) || s === l || (o2.SetAngle(l), o2.SetBboxChanged());
  }, AnySDK.SetTowardPosition = function(t2, e) {
    const n = GetWorldInfo(this), o2 = n.GetAngle(), s = t2 - n.GetX(), i = e - n.GetY(), r2 = Math.atan2(i, s);
    isNaN(r2) || o2 === r2 || (n.SetAngle(r2), n.SetBboxChanged());
  }, SDKv1.GetAngle = function() {
    return C32.toDegrees(this.GetWorldInfo().GetAngle());
  }, SDKv2.GetAngle = function() {
    return this.angleDegrees;
  }, AnySDK.CompareOpacity = function(t2, e) {
    return C32.compare(C32.roundToDp(100 * GetWorldInfo(this).GetOpacity(), 6), t2, e);
  }, SDKv1.IsVisible = function() {
    return this.GetWorldInfo().IsVisible();
  }, SDKv2.IsVisible = function() {
    return this.isVisible;
  }, AnySDK.SetVisible = function(t2) {
    const e = GetWorldInfo(this);
    t2 = 2 === t2 ? !e.IsVisible() : 0 !== t2, e.IsVisible() !== t2 && (e.SetVisible(t2), runtime.UpdateRender());
  }, AnySDK.SetOpacity = function(t2) {
    const e = C32.clamp(t2 / 100, 0, 1), n = GetWorldInfo(this);
    if (n.GetTransformWithParentOpacity()) {
      if (n._GetSceneGraphInfo().GetOwnOpacity() === e) return;
    } else if (n.GetOpacity() === e) return;
    n.SetOpacity(e), runtime.UpdateRender();
  }, AnySDK.SetDefaultColor = function(t2) {
    tempColor.setFromRgbValue(t2);
    const e = GetWorldInfo(this);
    e.GetUnpremultipliedColor().equalsIgnoringAlpha(tempColor) || (e.SetUnpremultipliedColor(tempColor), runtime.UpdateRender());
  }, AnySDK.GetColor = function() {
    const t2 = GetWorldInfo(this).GetUnpremultipliedColor();
    return C32.PackRGBAEx(t2.getR(), t2.getG(), t2.getB(), t2.getA());
  }, AnySDK.GetOpacity = function() {
    return C32.roundToDp(100 * GetWorldInfo(this).GetOpacity(), 6);
  }, AnySDK.IsOnLayer = function(t2) {
    return !!(t2 = GetLayer(t2)) && GetWorldInfo(this).GetLayer() === t2;
  }, AnySDK.PickTopBottom = function(t2) {
    const e = GetObjectClass(this).GetCurrentSol(), n = e.GetInstances();
    if (!n.length) return false;
    let o2 = n[0];
    for (let e2 = 1, s = n.length; e2 < s; ++e2) {
      const s2 = n[e2], i = s2.GetWorldInfo(), r2 = o2.GetWorldInfo(), a2 = i.GetLayer().GetIndex(), l = r2.GetLayer().GetIndex();
      0 === t2 ? (a2 > l || a2 === l && i.GetZIndex() > r2.GetZIndex()) && (o2 = s2) : (a2 < l || a2 === l && i.GetZIndex() < r2.GetZIndex()) && (o2 = s2);
    }
    return e.PickOne(o2), true;
  }, SDKv1.CompareZElevation = function(t2, e, n) {
    const o2 = this.GetWorldInfo(), s = 0 === t2 ? o2.GetZElevation() : o2.GetTotalZElevation();
    return C32.compare(s, e, n);
  }, SDKv2.CompareZElevation = function(t2, e, n) {
    const o2 = 0 === t2 ? this.zElevation : this.totalZElevation;
    return C32.compare(o2, e, n);
  }, SDKv1.MoveToTop = function() {
    this.GetWorldInfo().ZOrderMoveToTop();
  }, SDKv2.MoveToTop = function() {
    this.moveToTop();
  }, SDKv1.MoveToBottom = function() {
    this.GetWorldInfo().ZOrderMoveToBottom();
  }, SDKv2.MoveToBottom = function() {
    this.moveToBottom();
  }, AnySDK.MoveToLayer = function(t2) {
    (t2 = GetLayer(t2)) && GetWorldInfo(this).ZOrderMoveToLayer(t2);
  }, AnySDK.ZMoveToObject = function(t2, e) {
    const n = 0 === t2;
    if (!(e = GetObjectClass(e))) return;
    const o2 = GetInst(this), s = e.GetFirstPicked(o2);
    s && o2.GetWorldInfo().ZOrderMoveAdjacentToInstance(s, n);
  }, SDKv1.SetZElevation = function(t2) {
    const e = this.GetWorldInfo();
    e.GetZElevation() !== t2 && (e.SetZElevation(t2), runtime.UpdateRender());
  }, SDKv2.SetZElevation = function(t2) {
    this.zElevation = t2;
  }, AnySDK.LayerNumber = function() {
    return GetWorldInfo(this).GetLayer().GetIndex();
  }, AnySDK.LayerName = function() {
    return GetWorldInfo(this).GetLayer().GetName();
  }, SDKv1.ZIndex = function() {
    return this.GetWorldInfo().GetZIndex();
  }, SDKv2.ZIndex = function() {
    return this.zIndex;
  }, SDKv1.ZElevation = function() {
    return this.GetWorldInfo().GetZElevation();
  }, SDKv2.ZElevation = function() {
    return this.zElevation;
  }, SDKv1.TotalZElevation = function() {
    return this.GetWorldInfo().GetTotalZElevation();
  }, SDKv2.TotalZElevation = function() {
    return this.totalZElevation;
  }, AnySDK.IsEffectEnabled = function(t2) {
    const e = GetInst(this), n = e.GetObjectClass().GetEffectList().GetEffectTypeByName(t2);
    if (!n) return;
    const o2 = n.GetIndex();
    return e.GetWorldInfo().GetInstanceEffectList().IsEffectIndexActive(o2);
  }, AnySDK.SetEffectEnabled = function(t2, e) {
    const n = GetInst(this), o2 = n.GetObjectClass().GetEffectList().GetEffectTypeByName(e);
    if (!o2) return;
    const s = o2.GetIndex(), i = 1 === t2, r2 = n.GetWorldInfo().GetInstanceEffectList();
    r2.IsEffectIndexActive(s) !== i && (r2.SetEffectIndexActive(s, i), r2.UpdateActiveEffects(), runtime.UpdateRender());
  }, AnySDK.SetEffectParam = function(t2, e, n) {
    const o2 = GetInst(this), s = o2.GetObjectClass().GetEffectList().GetEffectTypeByName(t2);
    if (!s) return;
    e = Math.floor(e);
    const i = s.GetShaderProgram().GetParameterType(e);
    if (!i) return;
    "color" === i ? (tempColor.setFromRgbValue(n), n = tempColor) : "percent" === i && (n /= 100);
    const r2 = s.GetIndex(), a2 = o2.GetWorldInfo().GetInstanceEffectList();
    a2.SetEffectParameter(r2, e, n) && a2.IsEffectIndexActive(r2) && runtime.UpdateRender();
  };
  const tempRect = C32.New(C32.Rect), tempCandidates1 = [], tempCandidates2 = [];
  let needsCollisionFinish = false, rPickType = null, rPickFromElseInstances = false;
  const rToPick = /* @__PURE__ */ new Set();
  function* DebugOnCollision(t2) {
    if (!t2) return false;
    const e = this.GetRuntime(), n = e.GetCollisionEngine(), o2 = e.GetEventSheetManager(), s = o2.GetEventStack(), i = o2.GetCurrentCondition(), r2 = i.GetObjectClass(), a2 = i.GetSavedDataMap(), l = i.GetUnsavedDataMap(), c2 = s.GetCurrentStackFrame(), u2 = e.GetTickCount(), S2 = u2 - 1, f2 = c2.GetCurrentEvent(), G = s.Push(f2);
    let d2 = a2.get("collmemory");
    d2 || (d2 = C32.New(C32.PairMap), a2.set("collmemory", d2)), l.get("collisionCreatedDestroyCallback") || (l.set("collisionCreatedDestroyCallback", true), e.Dispatcher().addEventListener("instancedestroy", (t3) => CollMemory_RemoveInstance(d2, t3.instance)));
    const I2 = r2.GetCurrentSol(), C2 = t2.GetCurrentSol(), h2 = I2.GetInstances();
    let m2 = null;
    for (let e2 = 0; e2 < h2.length; ++e2) {
      const s2 = h2[e2];
      C2.IsSelectAll() ? (n.GetCollisionCandidates(s2.GetWorldInfo().GetLayer(), t2, s2.GetWorldInfo().GetBoundingBox(), tempCandidates1), m2 = tempCandidates1, n.AddRegisteredCollisionCandidates(s2, t2, m2)) : m2 = C2.GetInstances();
      for (let e3 = 0; e3 < m2.length; ++e3) {
        const i2 = m2[e3];
        if (n.TestOverlap(s2, i2) || n.CheckRegisteredCollision(s2, i2)) {
          const e4 = CollMemory_Get(d2, s2, i2);
          let n2 = false, a3 = -2;
          "number" == typeof e4 && (n2 = true, a3 = e4);
          const l2 = !n2 || a3 < S2;
          if (CollMemory_Add(d2, s2, i2, u2), l2) {
            const e5 = f2.GetSolModifiers();
            o2.PushCopySol(e5);
            const n3 = r2.GetCurrentSol(), a4 = t2.GetCurrentSol();
            if (n3._SetSelectAll(false), a4._SetSelectAll(false), r2 === t2) {
              const t3 = n3._GetOwnInstances();
              C32.clearArray(t3), t3.push(s2), t3.push(i2), r2.ApplySolToContainer();
            } else {
              const e6 = n3._GetOwnInstances(), o3 = a4._GetOwnInstances();
              C32.clearArray(e6), C32.clearArray(o3), e6.push(s2), o3.push(i2), r2.ApplySolToContainer(), t2.ApplySolToContainer();
            }
            yield* f2.DebugRetrigger(c2, G), o2.PopSol(e5);
          }
        } else CollMemory_Remove(d2, s2, i2);
      }
      C32.clearArray(tempCandidates1);
    }
    return s.Pop(), false;
  }
  AnySDK.OnCollision = function(t2) {
    const e = GetObjectClass(this);
    t2 = GetObjectClass(t2);
    const n = e.GetRuntime();
    if (n.IsDebugging()) return DebugOnCollision.call(e, t2);
    if (!t2) return false;
    const o2 = n.GetCollisionEngine(), s = n.GetEventSheetManager(), i = s.GetEventStack(), r2 = s.GetCurrentCondition(), a2 = r2.GetObjectClass(), l = r2.GetSavedDataMap(), c2 = r2.GetUnsavedDataMap(), u2 = i.GetCurrentStackFrame(), S2 = n.GetTickCount(), f2 = S2 - 1, G = u2.GetCurrentEvent(), d2 = i.Push(G);
    let I2 = l.get("collmemory");
    I2 || (I2 = C32.New(C32.PairMap), l.set("collmemory", I2)), c2.get("collisionCreatedDestroyCallback") || (c2.set("collisionCreatedDestroyCallback", true), n.Dispatcher().addEventListener("instancedestroy", (t3) => CollMemory_RemoveInstance(I2, t3.instance)));
    const C2 = a2.GetCurrentSol(), h2 = t2.GetCurrentSol(), m2 = C2.GetInstances();
    let g2 = null;
    for (let e2 = 0; e2 < m2.length; ++e2) {
      const n2 = m2[e2];
      h2.IsSelectAll() ? (o2.GetCollisionCandidates(n2.GetWorldInfo().GetLayer(), t2, n2.GetWorldInfo().GetBoundingBox(), tempCandidates1), g2 = tempCandidates1, o2.AddRegisteredCollisionCandidates(n2, t2, g2)) : g2 = h2.GetInstances();
      for (let e3 = 0; e3 < g2.length; ++e3) {
        const i2 = g2[e3];
        if (o2.TestOverlap(n2, i2) || o2.CheckRegisteredCollision(n2, i2)) {
          const e4 = CollMemory_Get(I2, n2, i2);
          let o3 = false, r3 = -2;
          "number" == typeof e4 && (o3 = true, r3 = e4);
          const l2 = !o3 || r3 < f2;
          if (CollMemory_Add(I2, n2, i2, S2), l2) {
            const e5 = G.GetSolModifiers();
            s.PushCopySol(e5);
            const o4 = a2.GetCurrentSol(), r4 = t2.GetCurrentSol();
            if (o4._SetSelectAll(false), r4._SetSelectAll(false), a2 === t2) {
              const t3 = o4._GetOwnInstances();
              C32.clearArray(t3), t3.push(n2), t3.push(i2), a2.ApplySolToContainer();
            } else {
              const e6 = o4._GetOwnInstances(), s2 = r4._GetOwnInstances();
              C32.clearArray(e6), C32.clearArray(s2), e6.push(n2), s2.push(i2), a2.ApplySolToContainer(), t2.ApplySolToContainer();
            }
            G.Retrigger(u2, d2), s.PopSol(e5);
          }
        } else CollMemory_Remove(I2, n2, i2);
      }
      C32.clearArray(tempCandidates1);
    }
    return i.Pop(), false;
  }, AnySDK.IsOverlapping = function(t2) {
    return t2 = GetObjectClass(t2), DoOverlapCondition(GetInst(this), t2, 0, 0);
  }, AnySDK.IsOverlappingOffset = function(t2, e, n) {
    return t2 = GetObjectClass(t2), DoOverlapCondition(GetInst(this), t2, e, n);
  }, AnySDK.OnHierarchyReady = function() {
    return true;
  }, AnySDK.HasParent = function() {
    return GetWorldInfo(this).HasParent();
  }, AnySDK.HasChildren = function() {
    return GetWorldInfo(this).HasChildren();
  }, AnySDK.PickParent = function(t2, e) {
    const n = GetObjectClass(this);
    t2 = GetObjectClass(t2);
    const o2 = n.GetRuntime(), s = this.GetCurrentSol().GetInstances();
    if (0 === s.length) return false;
    const i = t2.GetCurrentSol();
    let r2 = i.GetInstances();
    if (i.IsSelectAll()) {
      const e2 = [...o2.instancesPendingCreateForObjectClass(t2)];
      e2.length > 0 && (r2 = r2.concat(e2));
    }
    if (0 === r2.length) return false;
    const a2 = i.IsSelectAll() ? null : new Set(r2), l = /* @__PURE__ */ new Set();
    for (let n2 = 0, o3 = s.length; n2 < o3; ++n2) {
      const o4 = s[n2];
      if (1 === e) for (const e2 of o4.parents()) e2.BelongsToObjectClass(t2) && (null === a2 || a2.has(e2)) && l.add(e2);
      else {
        let n3;
        if (0 === e) {
          if (n3 = o4.GetParent(), null === n3) continue;
        } else n3 = o4.GetTopParent();
        n3.BelongsToObjectClass(t2) && (null === a2 || a2.has(n3)) && l.add(n3);
      }
    }
    return 0 !== l.size && (i.SetSetPicked(l), t2.ApplySolToContainer(), true);
  }, AnySDK.PickChildren = function(t2, e) {
    const n = GetObjectClass(this);
    t2 = GetObjectClass(t2);
    const o2 = n.GetRuntime(), s = n.GetCurrentSol().GetInstances();
    if (0 === s.length) return false;
    const i = t2.GetCurrentSol();
    let r2 = i.GetInstances();
    if (i.IsSelectAll()) {
      const e2 = [...o2.instancesPendingCreateForObjectClass(t2)];
      e2.length > 0 && (r2 = r2.concat(e2));
    }
    if (0 === r2.length) return false;
    const a2 = i.IsSelectAll() ? null : new Set(r2), l = /* @__PURE__ */ new Set();
    for (let n2 = 0, o3 = s.length; n2 < o3; ++n2) {
      const o4 = s[n2];
      2 !== e || o4.HasChildren() || !o4.BelongsToObjectClass(t2) || null !== a2 && !a2.has(o4) || l.add(o4);
      for (const n3 of 0 === e ? o4.children() : o4.allChildren()) 2 === e && n3.HasChildren() || n3.BelongsToObjectClass(t2) && (null === a2 || a2.has(n3)) && l.add(n3);
    }
    return 0 !== l.size && (i.SetSetPicked(l), t2.ApplySolToContainer(), true);
  }, AnySDK.PickNthChild = function(t2, e, n) {
    const o2 = GetObjectClass(this);
    t2 = GetObjectClass(t2);
    const s = o2.GetRuntime(), i = o2.GetCurrentSol().GetInstances();
    if (0 === i.length) return false;
    const r2 = t2.GetCurrentSol();
    let a2 = r2.GetInstances();
    if (r2.IsSelectAll()) {
      const e2 = [...s.instancesPendingCreateForObjectClass(t2)];
      e2.length > 0 && (a2 = a2.concat(e2));
    }
    if (0 === a2.length) return false;
    const l = r2.IsSelectAll() ? null : new Set(a2), c2 = [];
    for (let o3 = 0, s2 = i.length; o3 < s2; ++o3) {
      const s3 = i[o3];
      if (0 === e) {
        const e2 = s3.GetChildAt(n);
        null !== e2 && e2.BelongsToObjectClass(t2) && (null === l || l.has(e2)) && c2.push(e2);
      } else if (1 === e) {
        for (const e2 of s3.children()) if (e2.BelongsToObjectClass(t2)) {
          if (0 === n) {
            (null === l || l.has(e2)) && c2.push(e2);
            break;
          }
          --n;
        }
      }
    }
    return 0 !== c2.length && (r2.SetArrayPicked(c2), t2.ApplySolToContainer(), true);
  }, AnySDK.CompareChildCount = function(t2, e, n) {
    const o2 = GetInst(this);
    switch (t2) {
      case 0:
      default:
        return C32.compare(o2.GetChildCount(), e, n);
      case 1:
        return C32.compare(o2.GetAllChildCount(), e, n);
    }
  }, AnySDK.AddChild = function(t2, e, n, o2, s, i, r2, a2, l, c2) {
    t2 = GetObjectClass(t2);
    const u2 = GetInst(this), S2 = runtime.GetCurrentAction().GetObjectClass();
    for (const f2 of t2.allCorrespondingInstances(u2, S2)) {
      if (!f2.GetPlugin().SupportsSceneGraph()) return;
      u2.AddChild(f2, { transformX: e, transformY: n, transformWidth: o2, transformHeight: s, transformAngle: i, transformOpacity: r2, transformZElevation: a2, transformVisibility: l, destroyWithParent: c2 });
    }
  }, AnySDK.RemoveChild = function(t2) {
    t2 = GetObjectClass(t2);
    const e = GetInst(this), n = runtime.GetCurrentAction().GetObjectClass();
    for (const o2 of t2.allCorrespondingInstances(e, n)) e.RemoveChild(o2);
  }, AnySDK.RemoveFromParent = function() {
    const t2 = GetInst(this);
    if (!t2.HasParent()) return;
    t2.GetParent().RemoveChild(t2);
  }, AnySDK.ParentUID = function() {
    const t2 = GetInst(this).GetParent();
    return t2 ? t2.GetUID() : -1;
  }, AnySDK.ChildCount = function() {
    return GetInst(this).GetChildCount();
  }, AnySDK.AllChildCount = function() {
    return GetInst(this).GetAllChildCount();
  }, AnySDK.SetMeshSize = function(t2, e) {
    t2 = Math.floor(t2), e = Math.floor(e);
    const n = GetWorldInfo(this);
    t2 < 2 || e < 2 || !isFinite(t2) || !isFinite(e) ? (n.ReleaseMesh(), n.SetBboxChanged()) : n.CreateMesh(t2, e);
  }, AnySDK.SetMeshPoint = function(t2, e, n, o2, s, i, r2, a2) {
    const l = GetWorldInfo(this);
    l.SetMeshPoint(t2, e, { mode: 0 === n ? "absolute" : "relative", x: o2, y: s, zElevation: i, u: r2, v: a2 }) && l.SetBboxChanged();
  }, AnySDK.MeshColumns = function() {
    const t2 = GetWorldInfo(this);
    return t2.HasMesh() ? t2.GetSourceMesh().GetHSize() : 0;
  }, AnySDK.MeshRows = function() {
    const t2 = GetWorldInfo(this);
    return t2.HasMesh() ? t2.GetSourceMesh().GetVSize() : 0;
  }, AnySDK.SetElementVisible = function(t2) {
    const e = GetWorldInfo(this);
    t2 = 2 === t2 ? !e.IsVisible() : 0 !== t2, e.IsVisible() !== t2 && e.SetVisible(t2);
  }, AnySDK.SetElementCSSStyle = function(t2, e) {
    this instanceof self.IInstance ? this.setElementCSSStyle(t2, e) : this.SetElementCSSStyle(t2, e);
  }, AnySDK.SetElementAttribute = function(t2, e) {
    this instanceof self.IInstance ? this.setElementAttribute(t2, "" + e) : this.SetElementAttribute(t2, "" + e);
  }, AnySDK.RemoveElementAttribute = function(t2) {
    this instanceof self.IInstance ? this.removeElementAttribute(t2) : this.RemoveElementAttribute(t2);
  }, AnySDK.SetElementFocus = function() {
    this instanceof self.IInstance ? this.focusElement() : this.FocusElement();
  }, AnySDK.SetElementBlur = function() {
    this instanceof self.IInstance ? this.blurElement() : this.BlurElement();
  }, AnySDK.IsElementFocused = function() {
    return this instanceof self.IInstance ? this.isElementFocused() : this.IsElementFocused();
  }, AnySDK.SetElementEnabled = function(t2) {
    this instanceof self.IInstance ? this._setEnabled(0 !== t2) : this._SetEnabled(0 !== t2);
  }, AnySDK.IsElementEnabled = function() {
    return this instanceof self.IInstance ? this._isEnabled() : this._IsEnabled();
  }, SDKv1.CompareInstanceVar = function(t2, e, n) {
    return C32.compare(this.GetInstance().GetInstanceVariableValue(t2), e, n);
  }, SDKv2.CompareInstanceVar = function(t2, e, n) {
    return C32.compare(GetInst_SDKv2(this).GetInstanceVariableValue(t2), e, n);
  }, SDKv1.IsBoolInstanceVarSet = function(t2) {
    return !!this.GetInstance().GetInstanceVariableValue(t2);
  }, SDKv2.IsBoolInstanceVarSet = function(t2) {
    return !!GetInst_SDKv2(this).GetInstanceVariableValue(t2);
  }, AnySDK.PickInstVarHiLow = function(t2, e) {
    const n = GetObjectClass(this), o2 = n.GetCurrentSol(), s = o2.GetInstances();
    if (!s.length) return false;
    const i = n.IsFamily();
    let r2 = null, a2 = 0;
    for (let o3 = 0, l = s.length; o3 < l; ++o3) {
      const l2 = s[o3], c2 = i ? l2.GetObjectClass().GetFamilyInstanceVariableOffset(n.GetFamilyIndex()) : 0, u2 = l2.GetInstanceVariableValue(c2 + e);
      (null === r2 || 0 === t2 && u2 < a2 || 1 === t2 && u2 > a2) && (a2 = u2, r2 = l2);
    }
    return o2.PickOne(r2), true;
  }, AnySDK.PickByUID = function(t2) {
    const e = GetObjectClass(this);
    return e.GetRuntime().GetCurrentCondition().IsInverted() ? PickByUID_Inverted(e, t2) : PickByUID_Normal(e, t2);
  }, AnySDK.HasTags = function(t2) {
    const e = new Set(C32.splitStringAndNormalize(t2)), n = GetInst(this).GetTagsSet();
    return e.isSubsetOf(n);
  }, AnySDK.Tags = function() {
    return GetInst(this).GetTagsString();
  }, AnySDK.TagsCount = function() {
    return GetInst(this).GetTagsSet().size;
  }, AnySDK.TagAt = function(t2) {
    return GetInst(this).GetTagAt(t2);
  }, AnySDK.ChangeTags = function(t2, e) {
    const n = C32.splitStringAndNormalize(e);
    if (0 === n.length) return;
    const o2 = GetInst(this), s = new Set(o2.GetTagsSet());
    if (0 === t2) for (const t3 of n) s.add(t3);
    else if (1 === t2) for (const t3 of n) s.delete(t3);
    o2.SetTagsSet(s);
  }, AnySDK.Destroy = function() {
    runtime.DestroyInstance(GetInst(this));
  }, AnySDK.OnCreated = function() {
    return true;
  }, AnySDK.OnDestroyed = function() {
    return true;
  }, SDKv1.SetInstanceVar = function(t2, e) {
    this.GetInstance().SetInstanceVariableValue(t2, e);
  }, SDKv2.SetInstanceVar = function(t2, e) {
    GetInst_SDKv2(this).SetInstanceVariableValue(t2, e);
  }, SDKv1.AddInstanceVar = function(t2, e) {
    const n = this.GetInstance(), o2 = n.GetInstanceVariableValue(t2);
    "number" == typeof o2 && "number" != typeof e ? e = parseFloat(e) : "string" == typeof o2 && "string" != typeof e && (e = e.toString()), n.SetInstanceVariableValue(t2, o2 + e);
  }, SDKv2.AddInstanceVar = function(t2, e) {
    const n = GetInst_SDKv2(this), o2 = n.GetInstanceVariableValue(t2);
    "number" == typeof o2 && "number" != typeof e ? e = parseFloat(e) : "string" == typeof o2 && "string" != typeof e && (e = e.toString()), n.SetInstanceVariableValue(t2, o2 + e);
  }, SDKv1.SubInstanceVar = function(t2, e) {
    const n = this.GetInstance(), o2 = n.GetInstanceVariableValue(t2);
    "number" == typeof o2 && ("number" != typeof e && (e = parseFloat(e)), n.SetInstanceVariableValue(t2, o2 - e));
  }, SDKv2.SubInstanceVar = function(t2, e) {
    const n = GetInst_SDKv2(this), o2 = n.GetInstanceVariableValue(t2);
    "number" == typeof o2 && ("number" != typeof e && (e = parseFloat(e)), n.SetInstanceVariableValue(t2, o2 - e));
  }, SDKv1.SetBoolInstanceVar = function(t2, e) {
    this.GetInstance().SetInstanceVariableValue(t2, e ? 1 : 0);
  }, SDKv2.SetBoolInstanceVar = function(t2, e) {
    GetInst_SDKv2(this).SetInstanceVariableValue(t2, e ? 1 : 0);
  }, SDKv1.ToggleBoolInstanceVar = function(t2) {
    const e = this.GetInstance();
    e.SetInstanceVariableValue(t2, 0 === e.GetInstanceVariableValue(t2) ? 1 : 0);
  }, SDKv2.ToggleBoolInstanceVar = function(t2) {
    const e = GetInst_SDKv2(this);
    e.SetInstanceVariableValue(t2, 0 === e.GetInstanceVariableValue(t2) ? 1 : 0);
  }, AnySDK.LoadFromJsonString = function(t2) {
    let e;
    try {
      e = JSON.parse(t2);
    } catch (t3) {
      return void console.error("Failed to load from JSON string: ", t3);
    }
    const n = GetInst(this), o2 = "state";
    runtime.ClearIntancesNeedingAfterLoad(), n._OnBeforeLoad(o2), n.LoadFromJson(e, o2), runtime.DoAfterLoad(o2, { setFromJson: true });
  }, AnySDK.AsJSON = function() {
    return JSON.stringify(GetInst(this).SaveToJson("state"));
  }, AnySDK.ObjectTypeName = function() {
    return GetInst(this).GetObjectClass().GetName();
  }, AnySDK.Count = function() {
    const t2 = runtime.GetCurrentEventStackFrame().GetExpressionObjectClass();
    let e = t2.GetInstanceCount();
    for (const n of runtime.instancesPendingCreateForObjectClass(t2)) ++e;
    return e;
  }, AnySDK.PickedCount = function() {
    return runtime.GetCurrentEventStackFrame().GetExpressionObjectClass().GetCurrentSol().GetInstances().length;
  }, SDKv1.GetIID = function() {
    return this.GetInstance().GetIID();
  }, SDKv2.GetIID = function() {
    return GetInst_SDKv2(this).GetIID();
  }, SDKv1.GetUID = function() {
    return this.GetInstance().GetUID();
  }, SDKv2.GetUID = function() {
    return GetInst_SDKv2(this).GetUID();
  }, AnySDK.OnInstanceSignal = function(t2) {
    const e = GetInst(this);
    return t2.toLowerCase() === runtime.GetEventSheetManager().GetCurrentInstanceSignalTag(e);
  }, AnySDK.InstanceSignal = function(t2) {
    const e = GetInst(this);
    runtime.GetEventSheetManager().InstanceSignal(e, t2);
  }, AnySDK.InstanceWaitForSignal = function(t2) {
    const e = GetObjectClass(this);
    return runtime.GetEventSheetManager().AddScheduledWait().InitInstanceSignals(e.GetCurrentSol().GetInstances(), t2), true;
  }, AnySDK.TemplateName = function() {
    return GetInst(this).GetTemplateName();
  }, C32.AddCommonACEs = function(t2, e, n) {
    const o2 = t2[1], s = t2[3], i = t2[4], r2 = t2[5], a2 = t2[6], l = t2[7], c2 = t2[8], u2 = t2[10], S2 = t2[11], f2 = t2[12], G = t2[13], d2 = t2[14], I2 = t2[15], C2 = t2[16], h2 = e.Cnds, m2 = e.Acts, g2 = e.Exps, y2 = Object.assign({}, AnySDK, n >= 2 ? SDKv2 : SDKv1);
    s && (h2.CompareX = y2.CompareX, h2.CompareY = y2.CompareY, h2.IsOnScreen = y2.IsOnScreen, h2.IsOutsideLayout = y2.IsOutsideLayout, h2.PickDistance = y2.PickDistance, m2.SetX = y2.SetX, m2.SetY = y2.SetY, m2.SetPos = y2.SetPos, m2.SetPosToObject = y2.SetPosToObject, m2.MoveForward = y2.MoveForward, m2.MoveAtAngle = y2.MoveAtAngle, g2.X = y2.GetX, g2.Y = y2.GetY, g2.dt = y2.GetDt), i && (h2.CompareWidth = y2.CompareWidth, h2.CompareHeight = y2.CompareHeight, m2.SetWidth = y2.SetWidth, m2.SetHeight = y2.SetHeight, m2.SetSize = y2.SetSize, g2.Width = y2.GetWidth, g2.Height = y2.GetHeight, g2.BBoxLeft = y2.GetBboxLeft, g2.BBoxTop = y2.GetBboxTop, g2.BBoxRight = y2.GetBboxRight, g2.BBoxBottom = y2.GetBboxBottom, g2.BBoxMidX = y2.GetBboxMidX, g2.BBoxMidY = y2.GetBboxMidY), r2 && (h2.AngleWithin = y2.IsAngleWithin, h2.IsClockwiseFrom = y2.IsAngleClockwiseFrom, h2.IsBetweenAngles = y2.IsBetweenAngles, m2.SetAngle = y2.SetAngle, m2.RotateClockwise = y2.RotateClockwise, m2.RotateCounterclockwise = y2.RotateCounterclockwise, m2.RotateTowardAngle = y2.RotateTowardAngle, m2.RotateTowardPosition = y2.RotateTowardPosition, m2.SetTowardPosition = y2.SetTowardPosition, g2.Angle = y2.GetAngle), a2 && (h2.IsVisible = y2.IsVisible, h2.CompareOpacity = y2.CompareOpacity, m2.SetVisible = y2.SetVisible, m2.SetOpacity = y2.SetOpacity, m2.SetDefaultColor = y2.SetDefaultColor, g2.Opacity = y2.GetOpacity, g2.ColorValue = y2.GetColor), l && (h2.IsOnLayer = y2.IsOnLayer, h2.PickTopBottom = y2.PickTopBottom, h2.CompareZElevation = y2.CompareZElevation, m2.MoveToTop = y2.MoveToTop, m2.MoveToBottom = y2.MoveToBottom, m2.MoveToLayer = y2.MoveToLayer, m2.ZMoveToObject = y2.ZMoveToObject, m2.SetZElevation = y2.SetZElevation, g2.LayerNumber = y2.LayerNumber, g2.LayerName = y2.LayerName, g2.ZIndex = y2.ZIndex, g2.ZElevation = y2.ZElevation, g2.TotalZElevation = y2.TotalZElevation), c2 && (h2.IsEffectEnabled = y2.IsEffectEnabled, m2.SetEffectEnabled = y2.SetEffectEnabled, m2.SetEffectParam = y2.SetEffectParam), G && (h2.OnHierarchyReady = y2.OnHierarchyReady, h2.HasParent = y2.HasParent, h2.HasChildren = y2.HasChildren, h2.PickParent = y2.PickParent, h2.PickChildren = y2.PickChildren, h2.PickNthChild = y2.PickNthChild, h2.CompareChildCount = y2.CompareChildCount, m2.AddChild = y2.AddChild, m2.RemoveChild = y2.RemoveChild, m2.RemoveFromParent = y2.RemoveFromParent, g2.ParentUID = y2.ParentUID, g2.ChildCount = y2.ChildCount, g2.AllChildCount = y2.AllChildCount), d2 && (m2.SetMeshSize = y2.SetMeshSize, m2.SetMeshPoint = y2.SetMeshPoint, g2.MeshColumns = y2.MeshColumns, g2.MeshRows = y2.MeshRows), u2 && (h2.IsVisible = y2.IsVisible, m2.SetVisible = y2.SetElementVisible, m2.SetCSSStyle = y2.SetElementCSSStyle, m2.SetElemAttribute = y2.SetElementAttribute, m2.RemoveElemAttribute = y2.RemoveElementAttribute), S2 && (h2.IsFocused = y2.IsElementFocused, m2.SetFocus = y2.SetElementFocus, m2.SetBlur = y2.SetElementBlur), f2 && (h2.IsEnabled = y2.IsElementEnabled, m2.SetEnabled = y2.SetElementEnabled), I2 && (h2.OnCollision = y2.OnCollision, h2.IsOverlapping = y2.IsOverlapping, h2.IsOverlappingOffset = y2.IsOverlappingOffset, e.FinishCollisionCondition = FinishCollisionCondition), o2 || (h2.CompareInstanceVar = y2.CompareInstanceVar, h2.IsBoolInstanceVarSet = y2.IsBoolInstanceVarSet, h2.PickInstVarHiLow = y2.PickInstVarHiLow, h2.PickByUID = y2.PickByUID, h2.HasTags = y2.HasTags, m2.SetInstanceVar = y2.SetInstanceVar, m2.AddInstanceVar = y2.AddInstanceVar, m2.SubInstanceVar = y2.SubInstanceVar, m2.SetBoolInstanceVar = y2.SetBoolInstanceVar, m2.ToggleBoolInstanceVar = y2.ToggleBoolInstanceVar, m2.ChangeTags = y2.ChangeTags, h2.OnCreated = y2.OnCreated, h2.OnDestroyed = y2.OnDestroyed, m2.Destroy = y2.Destroy, m2.LoadFromJsonString || (m2.LoadFromJsonString = y2.LoadFromJsonString), g2.AsJSON || (g2.AsJSON = y2.AsJSON), g2.Count = y2.Count, g2.PickedCount = y2.PickedCount, g2.IID = y2.GetIID, g2.UID = y2.GetUID, g2.ObjectTypeName = y2.ObjectTypeName, g2.Tags = y2.Tags, g2.TagsCount = y2.TagsCount, g2.TagAt = y2.TagAt, h2.OnInstanceSignal = y2.OnInstanceSignal, m2.InstanceSignal = y2.InstanceSignal, m2.InstanceWaitForSignal = y2.InstanceWaitForSignal), C2 && (g2.TemplateName = y2.TemplateName);
  };
}
var GetInst2;
var GetWorldInfo2;
var GetInst_SDKv22;
var GetWorldInfo_SDKv22;
var GetObjectClass2;
var GetLayer2;
var CollMemory_Add2;
var CollMemory_Remove2;
var CollMemory_RemoveInstance2;
var CollMemory_Get2;
var DoOverlapCondition2;
var FinishCollisionConditionPicking2;
var FinishCollisionCondition2;
var PickByUID_Normal2;
var PickByUID_Inverted2;
{
  const C32 = self.C3;
  C32.ScheduledWait = class extends C32.DefendedBase {
    constructor(t2) {
      super(), this._eventSheetManager = t2, this._type = "", this._time = -1, this._signalTag = "", this._isSignalled = false, this._event = null, this._actIndex = 0, this._solModifiers = [], this._dynamicSolModifiers = null, this._sols = /* @__PURE__ */ new Map(), this._pendingInstances = null, this._callingFunctionBlock = null, this._asyncId = -1, this._functionParameters = null, this._functionInnerLocalVars = null, this._shouldRelease = false;
    }
    Release() {
      this._type = "", this._time = -1, this._signalTag = "", this._event = null, this._callingFunctionBlock = null, this._functionParameters = null, this._functionInnerLocalVars = null, this._asyncId = -1, C32.clearArray(this._solModifiers), this._dynamicSolModifiers && (this._dynamicSolModifiers.clear(), this._dynamicSolModifiers = null);
      for (const t2 of this._sols.values()) t2.Release();
      this._sols.clear(), this._pendingInstances = null;
    }
    _Init() {
      const t2 = this._eventSheetManager, e = t2.GetRuntime().GetAllObjectClasses(), s = t2.GetCurrentEventStackFrame();
      this._event = s.GetCurrentEvent(), this._actIndex = s.GetActionIndex() + 1;
      const i = t2.FindFirstFunctionBlockParent(this._event);
      i && (this._callingFunctionBlock = i, this._functionParameters = i.CaptureFunctionParameters(), this._functionInnerLocalVars = i._GetAllInnerLocalVariables().map((t3) => t3.GetValue()), i.IsAsync() && (this._asyncId = i.PauseCurrentAsyncFunction()));
      for (const t3 of e) {
        const e2 = t3.GetCurrentSol();
        e2.IsSelectAll() && !this._event.HasSolModifier(t3) || (this._solModifiers.push(t3), this._sols.set(t3, C32.New(C32.SolState, e2)));
      }
      const n = t2.GetDynamicSolModifiersSet();
      this._dynamicSolModifiers = n.size > 0 ? n : null;
    }
    InitTimer(t2) {
      this._type = "timer", this._Init(), this._time = this._eventSheetManager.GetRuntime().GetGameTime() + t2;
    }
    InitWallTimer(t2) {
      this._type = "walltimer", this._Init(), this._time = this._eventSheetManager.GetRuntime().GetWallTime() + t2;
    }
    InitSignal(t2) {
      this._type = "signal", this._Init(), this._signalTag = t2.toLowerCase();
    }
    InitInstanceSignals(t2, e) {
      this._type = "instance-signals", this._Init(), this._signalTag = e.toLowerCase(), this._pendingInstances = new Set(t2);
    }
    InitPromise(t2) {
      this._type = "promise", this._Init(), t2.then(() => this.SetSignalled()).catch((t3) => {
        console.warn("[C3 runtime] Promise rejected in 'Wait for previous actions to complete': ", t3), this.SetSignalled();
      });
    }
    IsTimer() {
      return "timer" === this._type;
    }
    IsWallTimer() {
      return "walltimer" === this._type;
    }
    IsSignal() {
      return "signal" === this._type;
    }
    IsInstanceSignals() {
      return "instance-signals" === this._type;
    }
    IsPromise() {
      return "promise" === this._type;
    }
    GetSignalTag() {
      return this._signalTag;
    }
    IsSignalled() {
      return this._isSignalled;
    }
    SetSignalled() {
      this._isSignalled = true;
    }
    SetInstanceSignalled(t2) {
      this._pendingInstances.delete(t2), 0 === this._pendingInstances.size && this.SetSignalled();
    }
    _ShouldRun() {
      return this.IsTimer() ? this._time <= this._eventSheetManager.GetRuntime().GetGameTime() : this.IsWallTimer() ? this._time <= this._eventSheetManager.GetRuntime().GetWallTime() : this.IsSignalled();
    }
    _RestoreState(t2) {
      t2._Restore(this._event, this._actIndex);
      for (const [t3, e2] of this._sols.entries()) {
        const s = t3.GetCurrentSol();
        e2._Restore(s);
      }
      this._dynamicSolModifiers && t2.SetDynamicSolModifiers([...this._dynamicSolModifiers]);
      const e = this._callingFunctionBlock;
      e && (e.SetFunctionParameters(this._functionParameters), e._GetAllInnerLocalVariables().map((t3, e2) => t3.SetValue(this._functionInnerLocalVars[e2])), e.IsAsync() && e.ResumeAsyncFunction(this._asyncId));
    }
    _Run(t2) {
      this._RestoreState(t2), this._event._ResumeActionsAndSubEvents(t2), this._callingFunctionBlock && this._callingFunctionBlock.IsAsync() && this._callingFunctionBlock.MaybeFinishAsyncFunctionCall(this._asyncId), this._eventSheetManager.ClearSol(this._solModifiers), this._shouldRelease = true;
    }
    async _DebugRun(t2) {
      this._RestoreState(t2);
      for (const e of this._event._DebugResumeActionsAndSubEvents(t2)) await this._eventSheetManager.GetRuntime().DebugBreak(e);
      this._callingFunctionBlock && this._callingFunctionBlock.IsAsync() && this._callingFunctionBlock.MaybeFinishAsyncFunctionCall(this._asyncId), this._eventSheetManager.ClearSol(this._solModifiers), this._shouldRelease = true;
    }
    ShouldRelease() {
      return this._shouldRelease;
    }
    RemoveInstances(t2) {
      for (const e of this._sols.values()) e.RemoveInstances(t2);
      if ("instance-signals" === this._type) {
        for (const e of t2) this._pendingInstances.delete(e);
        0 === this._pendingInstances.size && this.SetSignalled();
      }
    }
    _SaveToJson() {
      const t2 = {}, e = { "wt": this._type, "t": this._time, "st": this._signalTag, "s": this._isSignalled, "ev": this._event.GetSID(), "sm": this._solModifiers.map((t3) => t3.GetSID()), "dsm": this._dynamicSolModifiers ? [...this._dynamicSolModifiers].map((t3) => t3.GetSID()) : null, "sols": t2 };
      this._event._HasActionIndex(this._actIndex) && (e["act"] = this._event.GetActionAt(this._actIndex).GetSID());
      for (const [e2, s] of this._sols) t2[e2.GetSID().toString()] = s._SaveToJson();
      return "instance-signals" === this._type && (e["pi"] = [...this._pendingInstances].map((t3) => t3.GetUID())), e;
    }
    static _CreateFromJson(t2, e) {
      const s = t2.GetRuntime(), i = t2.GetEventBlockBySID(e["ev"]);
      if (!i) return null;
      let n = 0;
      if (e.hasOwnProperty("act")) {
        const s2 = t2.GetActionBySID(e["act"]);
        if (!s2) return null;
        n = s2.GetIndex();
      }
      const a2 = C32.New(C32.ScheduledWait, t2);
      a2._time = e["t"], e.hasOwnProperty("wt") ? a2._type = e["wt"] : a2._type = -1 === a2._time ? "signal" : "timer", a2._signalTag = e["st"], a2._isSignalled = e["s"], a2._event = i, a2._actIndex = n;
      for (const t3 of e["sm"]) {
        const e2 = s.GetObjectClassBySID(t3);
        e2 && a2._solModifiers.push(e2);
      }
      if (Array.isArray(e["dsm"])) for (const t3 of e["dsm"]) {
        const e2 = s.GetObjectClassBySID(t3);
        e2 && (a2._dynamicSolModifiers || (a2._dynamicSolModifiers = /* @__PURE__ */ new Set()), a2._dynamicSolModifiers.add(e2));
      }
      for (const [i2, n2] of Object.entries(e["sols"])) {
        const e2 = parseInt(i2, 10), l = s.GetObjectClassBySID(e2);
        if (!l) continue;
        const o2 = C32.New(C32.SolState, null);
        o2._LoadFromJson(t2, n2), a2._sols.set(l, o2);
      }
      if ("instance-signals" === a2._type) {
        a2._pendingInstances = /* @__PURE__ */ new Set();
        for (const t3 of e["pi"]) {
          const e2 = s.GetInstanceByUID(t3);
          e2 && a2._pendingInstances.add(e2);
        }
      }
      return a2;
    }
  };
}
{
  const C32 = self.C3;
  C32.SolState = class extends C32.DefendedBase {
    constructor(s) {
      super(), this._objectClass = null, this._isSelectAll = true, this._instances = [], s && (this._objectClass = s.GetObjectClass(), this._isSelectAll = s.IsSelectAll(), C32.shallowAssignArray(this._instances, s._GetOwnInstances()));
    }
    Release() {
      this._objectClass = null, C32.clearArray(this._instances);
    }
    _Restore(s) {
      s._SetSelectAll(this._isSelectAll), C32.shallowAssignArray(s._GetOwnInstances(), this._instances);
    }
    RemoveInstances(s) {
      C32.arrayRemoveAllInSet(this._instances, s);
    }
    _SaveToJson() {
      return { "sa": this._isSelectAll, "insts": this._instances.map((s) => s.GetUID()) };
    }
    _LoadFromJson(s, e) {
      const t2 = s.GetRuntime();
      this._isSelectAll = !!e["sa"], C32.clearArray(this._instances);
      for (const s2 of e["insts"]) {
        const e2 = t2.GetInstanceByUID(s2);
        e2 && this._instances.push(e2);
      }
    }
  };
}
{
  let GetNextParamMap = function(t2, e) {
    let s = t2.get(e);
    return s || (s = /* @__PURE__ */ new Map(), t2.set(e, s)), s;
  };
  GetNextParamMap2 = GetNextParamMap;
  const C32 = self.C3;
  C32.SDKPluginBase = class extends C32.DefendedBase {
    constructor(t2) {
      super(), this._runtime = t2.runtime, this._id = t2.id, this._name = t2.name ?? "", this._isSingleGlobal = !!t2.isSingleGlobal, this._isWorldType = !!t2.isWorld, this._isRotatable = !!t2.isRotatable, this._mustPredraw = !!t2.mustPredraw, this._hasEffects = !!t2.hasEffects, this._supportsSceneGraph = !!t2.supportsSceneGraph, this._supportsMesh = !!t2.supportsMesh, this._isHTMLElementType = !!t2.isHTMLElementType, this._is3d = !!t2.is3d, this._sdkVersion = t2.sdkVersion, this._exportData = t2.exportData, this._singleGlobalObjectClass = null, this._boundACEMethodCache = /* @__PURE__ */ new Map(), this._boundACEMethodCache_1param = /* @__PURE__ */ new Map(), this._boundACEMethodCache_2params = /* @__PURE__ */ new Map(), this._boundACEMethodCache_3params = /* @__PURE__ */ new Map(), this._scriptInterfaceClass = t2.scriptInterfaceClass, this._iPlugin = null;
    }
    Release() {
      this._runtime = null;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetID() {
      return this._id;
    }
    GetName() {
      return this._name;
    }
    OnCreate() {
    }
    GetConstructor() {
      return this.GetSdkVersion() >= 2 ? this._iPlugin.constructor : this.constructor;
    }
    GetSdkVersion() {
      return this._sdkVersion;
    }
    GetScriptInterfaceClass(t2 = false) {
      let e = this._scriptInterfaceClass;
      return t2 && "function" != typeof e && this.GetSdkVersion() >= 2 && (e = globalThis.ISDKPluginBase), e;
    }
    GetExportData() {
      return this._exportData;
    }
    IsSingleGlobal() {
      return this._isSingleGlobal;
    }
    IsWorldType() {
      return this._isWorldType;
    }
    IsHTMLElementType() {
      return this._isHTMLElementType;
    }
    Is3D() {
      return this._is3d;
    }
    IsRotatable() {
      return this._isRotatable;
    }
    MustPreDraw() {
      return this._mustPredraw;
    }
    HasEffects() {
      return this._hasEffects;
    }
    SupportsSceneGraph() {
      return this._supportsSceneGraph;
    }
    SupportsMesh() {
      return this._supportsMesh;
    }
    _GetBoundACEMethod(t2, e) {
      if (!e) throw new Error("missing 'this' binding");
      let s = this._boundACEMethodCache.get(t2);
      return s || (s = t2.bind(e), this._boundACEMethodCache.set(t2, s), s);
    }
    _GetBoundACEMethod_1param(t2, e, s) {
      if (!e) throw new Error("missing 'this' binding");
      const i = GetNextParamMap(this._boundACEMethodCache_1param, t2);
      let n = i.get(s);
      return n || (n = t2.bind(e, s), i.set(s, n), n);
    }
    _GetBoundACEMethod_2params(t2, e, s, i) {
      if (!e) throw new Error("missing 'this' binding");
      const n = GetNextParamMap(this._boundACEMethodCache_2params, t2), r2 = GetNextParamMap(n, s);
      let a2 = r2.get(i);
      return a2 || (a2 = t2.bind(e, s, i), r2.set(i, a2), a2);
    }
    _GetBoundACEMethod_3params(t2, e, s, i, n) {
      if (!e) throw new Error("missing 'this' binding");
      const r2 = GetNextParamMap(this._boundACEMethodCache_3params, t2), a2 = GetNextParamMap(r2, s), l = GetNextParamMap(a2, i);
      let o2 = l.get(n);
      return o2 || (o2 = t2.bind(e, s, i, n), l.set(n, o2), o2);
    }
    _SetSingleGlobalObjectClass(t2) {
      if (!this.IsSingleGlobal()) throw new Error("must be single-global plugin");
      this._singleGlobalObjectClass = t2;
    }
    GetSingleGlobalObjectClass() {
      if (!this.IsSingleGlobal()) throw new Error("must be single-global plugin");
      return this._singleGlobalObjectClass;
    }
    GetSingleGlobalInstance() {
      if (!this.IsSingleGlobal()) throw new Error("must be single-global plugin");
      return this._singleGlobalObjectClass.GetSingleGlobalInstance();
    }
    _InitScriptInterface() {
      const t2 = this.GetSdkVersion();
      C32.AddonManager._PushInitObject(this, t2);
      const e = this.GetScriptInterfaceClass(true);
      if (e) {
        if (this._iPlugin = new e(), !(this._iPlugin instanceof self.IPlugin)) throw new TypeError("plugin class must derive from IPlugin");
      } else this._iPlugin = new self.IPlugin();
      C32.AddonManager._PopInitObject(t2);
    }
    GetIPlugin() {
      return this._iPlugin;
    }
  };
}
var GetNextParamMap2;
{
  const C32 = self.C3;
  C32.SDKDOMPluginBase = class extends C32.SDKPluginBase {
    constructor(e, s) {
      super(e), this._domComponentId = s, this._nextElementId = 0, this._instMap = /* @__PURE__ */ new Map(), this.AddElementMessageHandler("elem-focused", (e2) => e2._OnElemFocused()), this.AddElementMessageHandler("elem-blurred", (e2) => {
        e2 && e2._OnElemBlurred();
      });
    }
    Release() {
      super.Release();
    }
    _AddElement(e) {
      const s = this._nextElementId++;
      return this._instMap.set(s, e), s;
    }
    _RemoveElement(e) {
      this._instMap.delete(e);
    }
    AddElementMessageHandler(e, s) {
      this._runtime.AddDOMComponentMessageHandler(this._domComponentId, e, (e2) => {
        const t2 = this._instMap.get(e2["elementId"]);
        s(t2, e2);
      });
    }
  };
}
{
  const C32 = self.C3;
  C32.SDKTypeBase = class extends C32.DefendedBase {
    constructor(e) {
      super(), this._objectClass = e, this._runtime = e.GetRuntime(), this._plugin = e.GetPlugin();
    }
    Release() {
      this._objectClass = null, this._runtime = null, this._plugin = null;
    }
    GetObjectClass() {
      return this._objectClass;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetPlugin() {
      return this._plugin;
    }
    GetImageInfo() {
      return this._objectClass.GetImageInfo();
    }
    OnCreate() {
    }
    FinishCondition(e) {
    }
    BeforeRunAction(e) {
    }
    AfterRunAction(e) {
    }
    LoadTextures(e) {
    }
    ReleaseTextures() {
    }
    OnDynamicTextureLoadComplete() {
    }
    PreloadTexturesWithInstances(e) {
    }
    LoadTilemapData() {
    }
    GetScriptInterfaceClass() {
      return null;
    }
    DispatchScriptEvent(e, t2, s) {
      const n = C32.New(C32.Event, e, t2);
      n.objectClass = this, s && Object.assign(n, s), this.GetObjectClass().DispatchUserScriptEvent(n);
    }
  };
}
{
  const C32 = self.C3;
  C32.SDKInstanceBase = class extends C32.DefendedBase {
    constructor(e, t2) {
      super(), this._inst = e, this._domComponentId = t2, this._wrapperComponentId = null, this._runtime = e.GetRuntime(), this._objectClass = this._inst.GetObjectClass(), this._sdkType = this._objectClass.GetSdkType(), this._tickFunc = null, this._tick2Func = null, this._isTicking = false, this._isTicking2 = false, this._disposables = null, this._wasReleased = false;
    }
    Release() {
      this._wasReleased = true, this._StopTicking(), this._StopTicking2(), this._tickFunc = null, this._tick2Func = null, this._disposables && (this._disposables.Release(), this._disposables = null), this._inst = null, this._runtime = null, this._objectClass = null, this._sdkType = null;
    }
    WasReleased() {
      return this._wasReleased;
    }
    GetInstance() {
      return this._inst;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetObjectClass() {
      return this._objectClass;
    }
    GetPlugin() {
      return this._sdkType.GetPlugin();
    }
    GetSdkType() {
      return this._sdkType;
    }
    GetScriptInterface() {
      return this._inst.GetInterfaceClass();
    }
    Trigger(e) {
      return this._runtime.Trigger(e, this._inst, null);
    }
    DebugTrigger(e) {
      return this._runtime.DebugTrigger(e, this._inst, null);
    }
    TriggerAsync(e) {
      return this._runtime.TriggerAsync(e, this._inst, null);
    }
    FastTrigger(e, t2) {
      return this._runtime.FastTrigger(e, this._inst, t2);
    }
    DebugFastTrigger(e, t2) {
      return this._runtime.DebugFastTrigger(e, this._inst, t2);
    }
    ScheduleTriggers(e) {
      return this._runtime.ScheduleTriggers(e);
    }
    AddDOMMessageHandler(e, t2) {
      this._runtime.AddDOMComponentMessageHandler(this._domComponentId, e, t2);
    }
    AddDOMMessageHandlers(e) {
      for (const [t2, i] of e) this.AddDOMMessageHandler(t2, i);
    }
    PostToDOM(e, t2) {
      this._runtime.PostComponentMessageToDOM(this._domComponentId, e, t2);
    }
    PostToDOMAsync(e, t2) {
      return this._runtime.PostComponentMessageToDOMAsync(this._domComponentId, e, t2);
    }
    _PostToDOMMaybeSync(e, t2) {
      if (!this._runtime.IsInWorker()) return window["c3_runtimeInterface"]["_OnMessageFromRuntime"]({ "type": "event", "component": this._domComponentId, "handler": e, "data": t2, "responseId": null });
      this.PostToDOM(e, t2);
    }
    SetWrapperExtensionComponentId(e) {
      if (!e) throw new Error("cannot set empty component id");
      this._wrapperComponentId = e;
    }
    IsWrapperExtensionAvailable() {
      if (!this._wrapperComponentId) throw new Error("wrapper extension component id not set");
      return this._runtime.HasWrapperComponentId(this._wrapperComponentId);
    }
    AddWrapperExtensionMessageHandler(e, t2) {
      if (!this._wrapperComponentId) throw new Error("wrapper extension component id not set");
      this._runtime.AddWrapperExtensionMessageHandler(this._wrapperComponentId, e, t2);
    }
    AddWrapperExtensionMessageHandlers(e) {
      for (const [t2, i] of e) this.AddWrapperExtensionMessageHandler(t2, i);
    }
    SendWrapperExtensionMessage(e, t2) {
      if (!this._wrapperComponentId) throw new Error("wrapper extension component id not set");
      this._runtime.SendWrapperExtensionMessage(this._wrapperComponentId, e, t2);
    }
    SendWrapperExtensionMessageAsync(e, t2) {
      if (!this._wrapperComponentId) throw new Error("wrapper extension component id not set");
      return this._runtime.SendWrapperExtensionMessageAsync(this._wrapperComponentId, e, t2);
    }
    Tick() {
    }
    Tick2() {
    }
    _StartTicking() {
      if (!this._isTicking) {
        if (!this._tickFunc) if (this._runtime.IsDebug()) {
          const e = globalThis.C3Debugger, t2 = this.GetPlugin();
          this._tickFunc = () => {
            const i = performance.now();
            this.Tick(), e.AddIndividualPluginTickTime(t2, performance.now() - i);
          };
        } else this._tickFunc = () => this.Tick();
        this._runtime.Dispatcher().addEventListener("tick", this._tickFunc), this._isTicking = true;
      }
    }
    _StopTicking() {
      this._isTicking && (this._runtime.Dispatcher().removeEventListener("tick", this._tickFunc), this._isTicking = false);
    }
    IsTicking() {
      return this._isTicking;
    }
    _StartTicking2() {
      if (!this._isTicking2) {
        if (!this._tick2Func) if (this._runtime.IsDebug()) {
          const e = globalThis.C3Debugger, t2 = this.GetPlugin();
          this._tick2Func = () => {
            const i = performance.now();
            this.Tick2(), e.AddIndividualPluginTickTime(t2, performance.now() - i);
          };
        } else this._tick2Func = () => this.Tick2();
        this._runtime.Dispatcher().addEventListener("tick2", this._tick2Func), this._isTicking2 = true;
      }
    }
    _StopTicking2() {
      this._isTicking2 && (this._runtime.Dispatcher().removeEventListener("tick2", this._tick2Func), this._isTicking2 = false);
    }
    IsTicking2() {
      return this._isTicking2;
    }
    GetDebuggerProperties() {
      return [];
    }
    SaveToJson() {
      return null;
    }
    LoadFromJson(e) {
    }
    GetPropertyValueByIndex(e) {
    }
    SetPropertyValueByIndex(e, t2) {
    }
    OffsetPropertyValueByIndex(e, t2, i) {
      if (0 === t2) return;
      const n = this.GetPropertyValueByIndex(e);
      if ("number" != typeof n) throw new Error("expected number");
      this.SetPropertyValueByIndex(e, n + t2, i);
    }
    SetPropertyColorOffsetValueByIndex(e, t2, i, n) {
    }
    CallAction(e, ...t2) {
      e.call(this, ...t2);
    }
    CallExpression(e, ...t2) {
      return e.call(this, ...t2);
    }
    GetScriptInterfaceClass() {
      return null;
    }
    DispatchScriptEvent(e, t2, i) {
      if (!this._inst.HasScriptInterface()) return;
      const n = this.GetScriptInterface(), s = C32.New(C32.Event, e, t2);
      s.instance = n, i && Object.assign(s, i), n.dispatchEvent(s);
    }
    MustPreDraw() {
      return false;
    }
  };
}
{
  const C32 = self.C3;
  C32.SDKWorldInstanceBase = class extends C32.SDKInstanceBase {
    constructor(e, t2) {
      super(e, t2), this._worldInfo = e.GetWorldInfo(), this._renderercontextlost_handler = null, this._renderercontextrestored_handler = null;
    }
    Release() {
      if (this._renderercontextlost_handler) {
        const e = this._runtime.Dispatcher();
        e.removeEventListener("renderercontextlost", this._renderercontextlost_handler), e.removeEventListener("renderercontextrestored", this._renderercontextrestored_handler), this._renderercontextlost_handler = null, this._renderercontextrestored_handler = null;
      }
      this._worldInfo = null, super.Release();
    }
    HandleWebGLContextLoss() {
      this.HandleRendererContextLoss();
    }
    OnWebGLContextLost() {
    }
    OnWebGLContextRestored() {
    }
    HandleRendererContextLoss() {
      if (this._renderercontextlost_handler) return;
      this._renderercontextlost_handler = () => this.OnRendererContextLost(), this._renderercontextrestored_handler = () => this.OnRendererContextRestored();
      const e = this._runtime.Dispatcher();
      e.addEventListener("renderercontextlost", this._renderercontextlost_handler), e.addEventListener("renderercontextrestored", this._renderercontextrestored_handler);
    }
    OnRendererContextLost() {
      this.OnWebGLContextLost();
    }
    OnRendererContextRestored() {
      this.OnWebGLContextRestored();
    }
    GetWorldInfo() {
      return this._worldInfo;
    }
    IsOriginalSizeKnown() {
      return false;
    }
    GetOriginalWidth() {
      if (!this.IsOriginalSizeKnown()) throw new Error("original size not known");
      const e = this.GetCurrentImageInfo();
      if (e) return e.GetWidth();
    }
    GetOriginalHeight() {
      if (!this.IsOriginalSizeKnown()) throw new Error("original size not known");
      const e = this.GetCurrentImageInfo();
      if (e) return e.GetHeight();
    }
    GetCurrentImageInfo() {
      return null;
    }
    GetCurrentSurfaceSize() {
      const e = this.GetCurrentImageInfo();
      if (e) {
        const t2 = e.GetTexture();
        if (t2) return [t2.GetWidth(), t2.GetHeight()];
      }
      return [100, 100];
    }
    GetCurrentTexRect() {
      const e = this.GetCurrentImageInfo();
      return e ? e.GetTexRect() : null;
    }
    GetCurrentTexQuad() {
      const e = this.GetCurrentImageInfo();
      return e ? e.GetTexQuad() : null;
    }
    IsCurrentTexRotated() {
      const e = this.GetCurrentImageInfo();
      return !!e && e.IsRotated();
    }
    GetImagePoint(e) {
      const t2 = this._inst.GetWorldInfo();
      return [t2.GetX(), t2.GetY(), t2.GetTotalZElevation()];
    }
    LoadTilemapData(e, t2, r2) {
    }
    TestPointOverlapTile(e, t2) {
    }
    RendersToOwnZPlane() {
      return true;
    }
  };
}
{
  const C32 = self.C3, tempRect = C32.New(C32.Rect);
  C32.SDKDOMInstanceBase = class extends C32.SDKWorldInstanceBase {
    constructor(t2, e) {
      super(t2, e), this._elementId = this.GetPlugin()._AddElement(this), this._isElementShowing = true, this._elemHasFocus = false, this._autoFontSize = false, this._autoFontSizeOffset = -0.2, this._lastRect = C32.New(C32.Rect, 0, 0, -1, -1);
      const s = this._runtime.GetCanvasManager();
      this._lastWindowWidth = s.GetLastWidth(), this._lastWindowHeight = s.GetLastHeight(), this._lastHTMLIndex = -1, this._lastHTMLZIndex = -1, this._isPendingUpdateState = false, this._StartTicking();
    }
    Release() {
      this.GetPlugin()._RemoveElement(this._elementId), this.PostToDOMElement("destroy"), this._elementId = -1, super.Release();
    }
    _GetElementInDOMMode() {
      if (this._runtime.IsInWorker()) throw new Error("not valid in worker mode");
      return this._PostToDOMElementMaybeSync("get-element");
    }
    PostToDOMElement(t2, e) {
      e || (e = {}), e["elementId"] = this._elementId, this.PostToDOM(t2, e);
    }
    _PostToDOMElementMaybeSync(t2, e) {
      return e || (e = {}), e["elementId"] = this._elementId, this._PostToDOMMaybeSync(t2, e);
    }
    PostToDOMElementAsync(t2, e) {
      return e || (e = {}), e["elementId"] = this._elementId, this.PostToDOMAsync(t2, e);
    }
    CreateElement(t2) {
      t2 || (t2 = {});
      const e = this.GetWorldInfo();
      t2["elementId"] = this._elementId, t2["isVisible"] = e.IsVisible(), t2["htmlIndex"] = e.GetLayer().GetHTMLIndex(), t2["htmlZIndex"] = e.GetHTMLZIndex(), Object.assign(t2, this.GetElementState()), this._isElementShowing = !!t2["isVisible"], this._PostToDOMMaybeSync("create", t2), this._UpdatePosition(true);
    }
    SetElementVisible(t2) {
      t2 = !!t2, this._isElementShowing !== t2 && (this._isElementShowing = t2, this.PostToDOMElement("set-visible", { "isVisible": t2 }));
    }
    Tick() {
      this._UpdatePosition(false);
    }
    _ShouldPreserveElement() {
      const t2 = this._runtime.GetCanvasManager().GetFullscreenMode();
      return "Android" === C32.Platform.OS && ("scale-inner" === t2 || "scale-outer" === t2 || "crop" === t2);
    }
    _UpdatePosition(t2) {
      if (this.GetInstance().IsDestroyed()) return;
      const e = this.GetWorldInfo(), s = e.GetLayer(), i = e.GetBoundingBox();
      let [n, l] = s.LayerToCanvasCss(i.getLeft(), i.getTop()), [o2, h2] = s.LayerToCanvasCss(i.getRight(), i.getBottom());
      const a2 = this._runtime.GetCanvasManager(), d2 = a2.GetCssWidth(), m2 = a2.GetCssHeight();
      if (!e.IsVisible() || !s.IsVisible()) return void this.SetElementVisible(false);
      if (!this._ShouldPreserveElement() && (o2 <= 0 || h2 <= 0 || n >= d2 || l >= m2)) return void this.SetElementVisible(false);
      tempRect.set(n, l, o2, h2);
      const r2 = a2.GetLastWidth(), _2 = a2.GetLastHeight(), c2 = s.GetHTMLIndex(), u2 = e.GetHTMLZIndex();
      if (!t2 && tempRect.equals(this._lastRect) && this._lastWindowWidth === r2 && this._lastWindowHeight === _2 && this._lastHTMLIndex === c2 && this._lastHTMLZIndex === u2) return void this.SetElementVisible(true);
      this._lastRect.copy(tempRect), this._lastWindowWidth = r2, this._lastWindowHeight = _2, this._lastHTMLIndex = c2, this._lastHTMLZIndex = u2, this.SetElementVisible(true);
      let M2 = null;
      this._autoFontSize && (M2 = s.GetDisplayScale() + this._autoFontSizeOffset), this._PostToDOMElementMaybeSync("update-position", { "left": Math.round(this._lastRect.getLeft()), "top": Math.round(this._lastRect.getTop()), "width": Math.round(this._lastRect.width()), "height": Math.round(this._lastRect.height()), "htmlIndex": c2, "htmlZIndex": u2, "fontSize": M2 });
    }
    FocusElement() {
      this._PostToDOMElementMaybeSync("focus", { "focus": true });
    }
    BlurElement() {
      this._PostToDOMElementMaybeSync("focus", { "focus": false });
    }
    _OnElemFocused() {
      this._elemHasFocus = true;
    }
    _OnElemBlurred() {
      this._elemHasFocus = false;
    }
    IsElementFocused() {
      return this._elemHasFocus;
    }
    SetElementCSSStyle(t2, e) {
      this.PostToDOMElement("set-css-style", { "prop": C32.CSSToCamelCase(t2), "val": e });
    }
    SetElementAttribute(t2, e) {
      this.PostToDOMElement("set-attribute", { "name": t2, "val": e });
    }
    RemoveElementAttribute(t2) {
      this.PostToDOMElement("remove-attribute", { "name": t2 });
    }
    UpdateElementState() {
      this._isPendingUpdateState || (this._isPendingUpdateState = true, Promise.resolve().then(() => {
        this._isPendingUpdateState = false, this.PostToDOMElement("update-state", this.GetElementState());
      }));
    }
    GetElementState() {
    }
    GetElementId() {
      return this._elementId;
    }
  };
}
{
  const C32 = self.C3, IBehavior = self.IBehavior;
  C32.SDKBehaviorBase = class extends C32.DefendedBase {
    constructor(e) {
      super(), this._runtime = e.runtime, this._id = e.id, this._name = e.name ?? "", this._myObjectClasses = C32.New(C32.ArraySet), this._myInstances = C32.New(C32.ArraySet), this._sdkVersion = e.sdkVersion, this._scriptInterfaceClass = e.scriptInterfaceClass, this._iBehavior = null;
    }
    Release() {
      this._myInstances.Release(), this._myObjectClasses.Release(), this._runtime = null;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetID() {
      return this._id;
    }
    GetName() {
      return this._name;
    }
    OnCreate() {
    }
    GetSdkVersion() {
      return this._sdkVersion;
    }
    GetScriptInterfaceClass(e = false) {
      let s = this._scriptInterfaceClass;
      return e && "function" != typeof s && this.GetSdkVersion() >= 2 && (s = globalThis.ISDKBehaviorBase), s;
    }
    _AddObjectClass(e) {
      this._myObjectClasses.Add(e);
    }
    GetObjectClasses() {
      return this._myObjectClasses.GetArray();
    }
    _AddInstance(e) {
      this._myInstances.Add(e);
    }
    _RemoveInstance(e) {
      this._myInstances.Delete(e);
    }
    GetInstances() {
      return this._myInstances.GetArray();
    }
    _InitScriptInterface() {
      const e = this.GetSdkVersion();
      C32.AddonManager._PushInitObject(this, e);
      const s = this.GetScriptInterfaceClass(true);
      if (s) {
        if (this._iBehavior = new s(), !(this._iBehavior instanceof IBehavior)) throw new TypeError("behavior class must derive from IBehavior");
      } else this._iBehavior = new IBehavior();
      C32.AddonManager._PopInitObject(e);
    }
    GetIBehavior() {
      return this._iBehavior;
    }
  };
}
{
  const C32 = self.C3;
  C32.SDKBehaviorTypeBase = class extends C32.DefendedBase {
    constructor(e) {
      super(), this._runtime = e.GetRuntime(), this._behaviorType = e, this._objectClass = e.GetObjectClass(), this._behavior = e.GetBehavior(), this._behavior._AddObjectClass(this._objectClass);
    }
    Release() {
      this._runtime = null, this._behaviorType = null, this._objectClass = null, this._behavior = null;
    }
    OnCreate() {
    }
    GetBehaviorType() {
      return this._behaviorType;
    }
    GetObjectClass() {
      return this._objectClass;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetBehavior() {
      return this._behavior;
    }
  };
}
{
  const C32 = self.C3;
  C32.SDKBehaviorInstanceBase = class extends C32.DefendedBase {
    constructor(t2, i) {
      super(), this._behInst = t2, this._domComponentId = i, this._inst = t2.GetObjectInstance(), this._runtime = t2.GetRuntime(), this._behaviorType = t2.GetBehaviorType(), this._sdkType = this._behaviorType.GetSdkType(), this._isTicking = false, this._isTicking2 = false, this._isPostTicking = false, this._disposables = null;
    }
    Release() {
      this._StopTicking(), this._StopTicking2(), this._StopPostTicking(), this._disposables && (this._disposables.Release(), this._disposables = null), this._behInst = null, this._inst = null, this._runtime = null, this._behaviorType = null, this._sdkType = null;
    }
    GetBehavior() {
      return this._behaviorType.GetBehavior();
    }
    GetBehaviorInstance() {
      return this._behInst;
    }
    GetObjectInstance() {
      return this._inst;
    }
    GetObjectClass() {
      return this._inst.GetObjectClass();
    }
    GetWorldInfo() {
      return this._inst.GetWorldInfo();
    }
    GetRuntime() {
      return this._runtime;
    }
    GetBehaviorType() {
      return this._behaviorType;
    }
    GetSdkType() {
      return this._sdkType;
    }
    GetScriptInterface() {
      return this._behInst.GetScriptInterface();
    }
    Trigger(t2) {
      return this._runtime.Trigger(t2, this._inst, this._behaviorType);
    }
    DebugTrigger(t2) {
      return this._runtime.DebugTrigger(t2, this._inst, this._behaviorType);
    }
    TriggerAsync(t2) {
      return this._runtime.TriggerAsync(t2, this._inst, this._behaviorType);
    }
    PostCreate() {
    }
    Tick() {
    }
    Tick2() {
    }
    PostTick() {
    }
    _StartTicking() {
      this._isTicking || (this._runtime._AddBehInstToTick(this), this._isTicking = true);
    }
    _StopTicking() {
      this._isTicking && (this._runtime._RemoveBehInstToTick(this), this._isTicking = false);
    }
    IsTicking() {
      return this._isTicking;
    }
    _StartTicking2() {
      this._isTicking2 || (this._runtime._AddBehInstToTick2(this), this._isTicking2 = true);
    }
    _StopTicking2() {
      this._isTicking2 && (this._runtime._RemoveBehInstToTick2(this), this._isTicking2 = false);
    }
    IsTicking2() {
      return this._isTicking2;
    }
    _StartPostTicking() {
      this._isPostTicking || (this._runtime._AddBehInstToPostTick(this), this._isPostTicking = true);
    }
    _StopPostTicking() {
      this._isPostTicking && (this._runtime._RemoveBehInstToPostTick(this), this._isPostTicking = false);
    }
    IsPostTicking() {
      return this._isPostTicking;
    }
    GetDebuggerProperties() {
      return [];
    }
    AddDOMMessageHandler(t2, i) {
      this._runtime.AddDOMComponentMessageHandler(this._domComponentId, t2, i);
    }
    OnSpriteFrameChanged(t2, i) {
    }
    SaveToJson() {
      return null;
    }
    LoadFromJson(t2) {
    }
    GetPropertyValueByIndex(t2) {
    }
    SetPropertyValueByIndex(t2, i) {
    }
    OffsetPropertyValueByIndex(t2, i) {
      if (0 === i) return;
      const e = this.GetPropertyValueByIndex(t2);
      if ("number" != typeof e) throw new Error("expected number");
      this.SetPropertyValueByIndex(t2, e + i);
    }
    SetPropertyColorOffsetValueByIndex(t2, i, e, s) {
    }
    CallAction(t2, ...i) {
      t2.call(this, ...i);
    }
    CallExpression(t2, ...i) {
      return t2.call(this, ...i);
    }
    GetScriptInterfaceClass() {
      return null;
    }
    DispatchScriptEvent(t2, i, e) {
      if (!this._behInst.HasScriptInterface()) return;
      const s = this.GetScriptInterface(), n = C32.New(C32.Event, t2, i);
      n.behaviorInstance = s, n.instance = s.instance, e && Object.assign(n, e), s.dispatchEvent(n);
    }
  };
}
{
  let ValidateInternalAPIToken = function(t2) {
    if (t2 !== internalApiToken) throw new Error("invalid internal API token");
  };
  ValidateInternalAPIToken2 = ValidateInternalAPIToken;
  const C32 = self.C3;
  C32.Plugins = {}, C32.Behaviors = {};
  const internalApiToken = C32._GetInternalAPIToken();
  let initObjectStack = [], initObjectStack2 = [], initPropertiesStack = [], originalPushInitObject = null, originalPopInitObject = null, originalGetInitObject = null, originalGetInitObject2 = null;
  const pluginsByCtor = /* @__PURE__ */ new Map(), behaviorsByCtor = /* @__PURE__ */ new Map();
  C32.AddonManager = class extends C32.DefendedBase {
    #t = null;
    #e = [];
    #i = null;
    #n = [];
    #r = /* @__PURE__ */ new Map();
    #o = null;
    #a = null;
    #s;
    constructor(t2, e) {
      super(), this.#t = t2, this.#s = new Set(e);
    }
    CreatePlugin(t2) {
      const e = t2[19], i = this.#t.GetObjectReference(t2[0]);
      if (!i) throw new Error("missing plugin");
      C32.AddCommonACEs(t2, i, e);
      const n = e >= 2 ? C32.SDKPluginBase : i, r2 = C32.New(n, { runtime: this.#t, isSingleGlobal: t2[1], isWorld: t2[2], isRotatable: t2[5], hasEffects: t2[8], mustPredraw: t2[9], supportsSceneGraph: t2[13], supportsMesh: t2[14], isHTMLElementType: t2[17], is3d: t2[18], sdkVersion: e, id: t2[20], name: t2[21], scriptInterfaceClass: e >= 2 ? i : null, exportData: t2[22] });
      r2.OnCreate(), this.#e.push(r2), pluginsByCtor.set(i, r2);
    }
    CreateSystemPlugin() {
      this.#i = C32.New(C32.Plugins.System, { runtime: this.#t, isSingleGlobal: true }), this.#i.OnCreate();
    }
    CreateBehavior(t2) {
      const e = t2[1], i = t2[2], n = t2[3], r2 = this.#t.GetObjectReference(t2[0]);
      if (!r2) throw new Error("missing behavior");
      this.#r.set(r2, () => {
        const t3 = e >= 2 ? C32.SDKBehaviorBase : r2, o2 = C32.New(t3, { runtime: this.#t, id: i, name: n, sdkVersion: e, scriptInterfaceClass: e >= 2 ? r2 : null });
        o2.OnCreate(), this.#n.push(o2), behaviorsByCtor.set(r2, o2), !this.#o && C32.Behaviors.solid && o2 instanceof C32.Behaviors.solid ? this.#o = o2 : !this.#a && C32.Behaviors.jumpthru && o2 instanceof C32.Behaviors.jumpthru && (this.#a = o2), o2._InitScriptInterface();
      });
    }
    _DelayCreateBehavior(t2) {
      const e = this.#r.get(t2);
      e && (e(), this.#r.delete(t2));
    }
    static _PushInitObject(t2, e = 1) {
      if (C32.AddonManager._PushInitObject !== originalPushInitObject) throw new Error("invalid method");
      1 === e && initObjectStack.push(t2), initObjectStack2.push(t2);
    }
    static _PopInitObject(t2 = 1) {
      if (C32.AddonManager._PopInitObject !== originalPopInitObject) throw new Error("invalid method");
      1 === t2 && initObjectStack.pop(), initObjectStack2.pop();
    }
    static _GetInitObject() {
      if (C32.AddonManager._GetInitObject !== originalGetInitObject) throw new Error("invalid method");
      if (0 === initObjectStack.length) throw new Error("no init object set");
      return initObjectStack.at(-1);
    }
    static _GetInitObject2(t2) {
      if (C32.AddonManager._GetInitObject2 !== originalGetInitObject2) throw new Error("invalid method");
      if (ValidateInternalAPIToken(t2), 0 === initObjectStack2.length) throw new Error("no init object set");
      return initObjectStack2.at(-1);
    }
    static _PushInitProperties(t2) {
      initPropertiesStack.push(t2);
    }
    static _PopInitProperties() {
      initPropertiesStack.pop();
    }
    static _GetInitProperties() {
      if (0 === initPropertiesStack.length) throw new Error("no init properties set");
      return initPropertiesStack.at(-1);
    }
    _InitAddonScriptInterfaces() {
      for (const t2 of this.#e) t2._InitScriptInterface();
    }
    static GetPluginByConstructorFunction(t2) {
      return pluginsByCtor.get(t2) || null;
    }
    static GetBehaviorByConstructorFunction(t2) {
      return behaviorsByCtor.get(t2) || null;
    }
    GetSystemPlugin() {
      return this.#i;
    }
    GetSolidBehavior() {
      return this.#o;
    }
    GetJumpthruBehavior() {
      return this.#a;
    }
    HasWrapperComponentId(t2) {
      return this.#s.has(t2);
    }
  }, originalPushInitObject = C32.AddonManager._PushInitObject, originalPopInitObject = C32.AddonManager._PopInitObject, originalGetInitObject = C32.AddonManager._GetInitObject, originalGetInitObject2 = C32.AddonManager._GetInitObject2;
}
var ValidateInternalAPIToken2;
{
  const C32 = self.C3, allImageInfos = /* @__PURE__ */ new Set();
  C32.ImageInfo = class extends C32.DefendedBase {
    constructor() {
      super(), this._generation = 0, this._url = "", this._size = 0, this._offsetX = 0, this._offsetY = 0, this._width = 0, this._height = 0, this._isRotated = false, this._hasMetaData = false, this._imageAsset = null, this._textureState = "", this._rcTex = C32.New(C32.Rect), this._quadTex = C32.New(C32.Quad), this._blobUrl = "", this._iImageInfo = new self.IImageInfo(this), allImageInfos.add(this);
    }
    Release() {
      this.ReleaseTexture(), this._imageAsset && 0 === this._imageAsset.GetRefCount() && this._imageAsset.Release(), this._imageAsset = null, allImageInfos.delete(this), this.ReleaseBlobURL();
    }
    static OnRendererContextLost() {
      for (const t2 of allImageInfos) t2._textureState = "", t2._rcTex.set(0, 0, 0, 0), t2._quadTex.setFromRect(t2._rcTex);
    }
    LoadData(t2) {
      this._url = t2[0], this._size = t2[1], this._offsetX = t2[2], this._offsetY = t2[3], this._width = t2[4], this._height = t2[5], this._isRotated = t2[6], this._hasMetaData = true;
    }
    LoadDynamicAsset(t2, e, s) {
      if (s = !!s, this._imageAsset) throw new Error("already loaded asset");
      this._url = e;
      const i = { isTiled: s };
      return C32.IsAbsoluteURL(e) && (i.loadPolicy = "remote"), this.LoadAsset(t2, i), this._imageAsset.Load();
    }
    LoadDynamicBlobAsset(t2, e) {
      if (this._imageAsset) throw new Error("already loaded asset");
      this._url = "", this._size = e.size, this._imageAsset = C32.New(C32.ImageAsset, t2.GetAssetManager(), { blob: e, size: this._size, loadPolicy: "local" });
    }
    ReplaceWith(t2) {
      if (t2 === this) throw new Error("cannot replace with self");
      this._generation++, this.ReleaseTexture(), this._url = t2._url, this._size = t2._size, this._offsetX = t2._offsetX, this._offsetY = t2._offsetY, this._width = t2._width, this._height = t2._height, this._isRotated = t2._isRotated, this._hasMetaData = t2._hasMetaData, this._imageAsset = t2._imageAsset, this._textureState = t2._textureState, this._rcTex = t2._rcTex, this._quadTex = t2._quadTex, this.ReleaseBlobURL();
    }
    GetURL() {
      return this._url;
    }
    GetSize() {
      return this._size;
    }
    GetOffsetX() {
      return this._offsetX;
    }
    GetOffsetY() {
      return this._offsetY;
    }
    IsRotated() {
      return this._isRotated;
    }
    GetWidth() {
      return this._width;
    }
    GetHeight() {
      return this._height;
    }
    GetSheetWidth() {
      return this._imageAsset.GetWidth();
    }
    GetSheetHeight() {
      return this._imageAsset.GetHeight();
    }
    LoadAsset(t2, e) {
      if (this._imageAsset) throw new Error("already got asset");
      e = Object.assign({}, e, { url: this.GetURL(), size: this.GetSize() }), this._imageAsset = t2.LoadImage(e);
    }
    IsLoaded() {
      return this._imageAsset && this._imageAsset.IsLoaded();
    }
    async LoadStaticTexture(t2, e) {
      if (!this._imageAsset) throw new Error("no asset");
      if (this._textureState) throw new Error("already loaded texture");
      const s = this._generation;
      this._textureState = "loading";
      const i = await this._imageAsset.LoadStaticTexture(t2, e);
      if (this._generation !== s) return null;
      if (!i) return this._textureState = "", null;
      this._textureState = "loaded", this._hasMetaData || (this._width = i.GetWidth(), this._height = i.GetHeight(), this._hasMetaData = true);
      const h2 = this._isRotated ? this._height : this._width, a2 = this._isRotated ? this._width : this._height;
      return this._rcTex.set(this._offsetX, this._offsetY, this._offsetX + h2, this._offsetY + a2), this._rcTex.divide(i.GetWidth(), i.GetHeight()), this._quadTex.setFromRect(this._rcTex), this._isRotated && this._quadTex.rotatePointsAnticlockwise(), i;
    }
    ReleaseTexture() {
      this._textureState && (this._imageAsset && this._imageAsset.ReleaseTexture(), this._textureState = "", this._rcTex.set(0, 0, 0, 0), this._quadTex.setFromRect(this._rcTex));
    }
    GetTexture() {
      return this._imageAsset && "loaded" === this._textureState ? this._imageAsset.GetTexture() : null;
    }
    GetTexRect() {
      return this._rcTex;
    }
    GetTexQuad() {
      return this._quadTex;
    }
    GetIImageInfo() {
      return this._iImageInfo;
    }
    GetImageAsset() {
      return this._imageAsset;
    }
    async ExtractImageToCanvas(t2) {
      t2 || (t2 = await this._imageAsset.LoadToDrawable()), this._hasMetaData || (this._width = t2.width, this._height = t2.height, this._hasMetaData = true);
      const e = C32.CreateCanvas(this._width, this._height), s = e.getContext("2d");
      return this._isRotated ? (s.rotate(Math.PI / -2), s.translate(-this._height, 0), s.drawImage(t2, this._offsetX, this._offsetY, this._height, this._width, 0, 0, this._height, this._width)) : s.drawImage(t2, this._offsetX, this._offsetY, this._width, this._height, 0, 0, this._width, this._height), e;
    }
    async ExtractImageToBlobURL(t2) {
      if (this._blobUrl) return this._blobUrl;
      const e = await this.ExtractImageToCanvas(t2), s = await C32.CanvasToBlob(e);
      return this._blobUrl = URL.createObjectURL(s), this._blobUrl;
    }
    ReleaseBlobURL() {
      this._blobUrl && (URL.revokeObjectURL(this._blobUrl), this._blobUrl = "");
    }
  };
}
{
  const C32 = self.C3;
  C32.AnimationInfo = class extends C32.DefendedBase {
    constructor(e) {
      super(), this._name = e[0], this._speed = e[1], this._isLooping = !!e[2], this._repeatCount = e[3], this._repeatTo = e[4], this._isPingPong = !!e[5], this._sid = e[6], this._frames = e[7].map((e2) => C32.New(C32.AnimationFrameInfo, e2)), this._iAnimation = new self.IAnimation(this);
    }
    static CreateDynamic(e, t2) {
      const r2 = C32.New(C32.AnimationInfo, [t2, 0, false, 0, 0, false, Math.floor(1e15 * Math.random()), []]);
      return r2._frames.push(C32.AnimationFrameInfo.CreateDynamic(e)), r2;
    }
    Release() {
      for (const e of this._frames) e.Release();
      C32.clearArray(this._frames);
    }
    LoadAllAssets(e) {
      for (const t2 of this._frames) t2.GetImageInfo().LoadAsset(e);
    }
    LoadAllTextures(e, t2) {
      return Promise.all(this._frames.map((r2) => r2.GetImageInfo().LoadStaticTexture(e, t2)));
    }
    ReleaseAllTextures() {
      for (const e of this._frames) e.GetImageInfo().ReleaseTexture();
    }
    GetName() {
      return this._name;
    }
    GetSID() {
      return this._sid;
    }
    GetFrameCount() {
      return this._frames.length;
    }
    GetFrames() {
      return this._frames;
    }
    GetFrameAt(e) {
      if ((e = Math.floor(e)) < 0 || e >= this._frames.length) throw new RangeError("invalid frame");
      return this._frames[e];
    }
    InsertFrameAt(e, t2) {
      (t2 = Math.floor(t2)) < 0 ? this._frames.unshift(e) : t2 >= this._frames.length ? this._frames.push(e) : this._frames.splice(t2, 0, e);
    }
    RemoveFrameAt(e) {
      if ((e = Math.floor(e)) < 0 || e >= this._frames.length) throw new RangeError("invalid frame");
      this._frames[e].Release(), this._frames.splice(e, 1);
    }
    GetFrameIndexByTag(e) {
      for (let t2 = 0, r2 = this._frames.length; t2 < r2; ++t2) if (C32.equalsNoCase(this._frames[t2].GetTag(), e)) return t2;
      return -1;
    }
    FrameTagOrIndexToIndex(e) {
      if ("string" == typeof e) {
        const t2 = this.GetFrameIndexByTag(e);
        if (-1 === t2) throw new Error(`cannot find animation frame with tag ${e}`);
        return t2;
      }
      return e;
    }
    GetSpeed() {
      return this._speed;
    }
    IsLooping() {
      return this._isLooping;
    }
    GetRepeatCount() {
      return this._repeatCount;
    }
    GetRepeatTo() {
      return this._repeatTo;
    }
    IsPingPong() {
      return this._isPingPong;
    }
    GetIAnimation() {
      return this._iAnimation;
    }
  };
}
{
  const C32 = self.C3, EMPTY_IMAGE_BLOB = (() => {
    const t2 = atob("iVBORw0KGgoAAAANSUhEUgAAAGQAAABkAQMAAABKLAcXAAAAAXNSR0IArs4c6QAAAANQTFRFAAAAp3o92gAAAAF0Uk5TAEDm2GYAAAATSURBVBgZYxgFo2AUjIJRQFcAAAV4AAHcRQIbAAAAAElFTkSuQmCC"), i = new Uint8Array(t2.length);
    for (let e = 0, n = t2.length; e < n; ++e) i[e] = t2.charCodeAt(e);
    return new Blob([i], { type: "image/png" });
  })();
  C32.AnimationFrameInfo = class extends C32.DefendedBase {
    constructor(t2) {
      super(), this._imageInfo = C32.New(C32.ImageInfo), this._imageInfo.LoadData(t2), this._duration = t2[7], this._origin = C32.New(C32.Vector2, t2[8], t2[9]), this._imagePoints = t2[10].map((t3) => C32.New(C32.ImagePoint, this, t3)), this._imagePointsByName = /* @__PURE__ */ new Map();
      for (const t3 of this._imagePoints) this._imagePointsByName.set(t3.GetName().toLowerCase(), t3);
      this._collisionPoly = null;
      const i = t2[11];
      i.length >= 6 && (this._collisionPoly = C32.New(C32.CollisionPoly, i)), this._tag = t2[12] ? t2[12] : "", this._iAnimationFrame = new self.IAnimationFrame(this);
    }
    static CreateDynamic(t2) {
      const i = C32.New(C32.AnimationFrameInfo, ["", 0, 0, 0, 100, 100, false, 1, 0, 0, [], [], ""]);
      return i._imageInfo.LoadDynamicBlobAsset(t2, EMPTY_IMAGE_BLOB), i;
    }
    Release() {
      this._collisionPoly && (this._collisionPoly.Release(), this._collisionPoly = null), this._imageInfo.Release(), this._imageInfo = null;
    }
    GetImageInfo() {
      return this._imageInfo;
    }
    GetDuration() {
      return this._duration;
    }
    GetOriginX() {
      return this._origin.getX();
    }
    GetOriginY() {
      return this._origin.getY();
    }
    GetCollisionPoly() {
      return this._collisionPoly;
    }
    GetImagePointByName(t2) {
      return this._imagePointsByName.get(t2.toLowerCase()) || null;
    }
    GetImagePointByIndex(t2) {
      return (t2 = Math.floor(t2)) < 0 || t2 >= this._imagePoints.length ? null : this._imagePoints[t2];
    }
    GetImagePointCount() {
      return this._imagePoints.length;
    }
    GetTag() {
      return this._tag;
    }
    GetIAnimationFrame() {
      return this._iAnimationFrame;
    }
  };
}
{
  const C32 = self.C3;
  C32.ImagePoint = class extends C32.DefendedBase {
    constructor(e, t2) {
      super(), this._afi = e, this._name = t2[0], this._pos = C32.New(C32.Vector2, t2[1], t2[2]);
    }
    Release() {
    }
    GetName() {
      return this._name;
    }
    GetX() {
      return this._pos.getX();
    }
    GetY() {
      return this._pos.getY();
    }
    GetVec2() {
      return this._pos;
    }
  };
}
{
  const C32 = globalThis.C3, C3Debugger = globalThis.C3Debugger, IObjectClass = globalThis.IObjectClass, IObjectType = globalThis.IObjectType, IFamily = globalThis.IFamily, assert = globalThis.assert;
  C32.ObjectClass = class extends C32.DefendedBase {
    constructor(t2, e, s) {
      super();
      const i = t2.GetObjectReference(s[1]);
      this._runtime = t2, this._plugin = C32.AddonManager.GetPluginByConstructorFunction(i), this._sdkType = null, this._instSdkCtor = i.Instance, this._index = e, this._sid = s[11], this._name = s[0], this._jsPropName = this._runtime.GetJsPropName(s[14]), this._isGlobal = !!s[9], this._isFamily = !!s[2], this._isOnLoaderLayout = !!s[10], this._instVars = s[3].map((e2) => ({ sid: e2[0], type: e2[1], name: e2[2], jsPropName: t2.GetJsPropName(e2[3]) })), this._behaviorsCount = s[4], this._effectsCount = s[5], this._isWorldType = this._plugin.IsWorldType(), this._dispatcher = C32.New(C32.Event.Dispatcher), this._effectList = null;
      const [n, a2] = t2.GetCollisionEngine().GetCollisionCellSize();
      if (this._collisionGrid = C32.New(C32.SparseGrid, n, a2), this._anyCollisionCellChanged = true, this._familyMembers = null, this._familyMembersSet = null, this._familyIndex = -1, this._families = null, this._familiesSet = null, this._familyInstVarMap = null, this._familyBehaviorMap = null, this._familyEffectMap = null, this._isInContainer = false, this._container = null, this._behaviorTypes = s[8].map((t3) => C32.BehaviorType.Create(this, t3)), this._behaviorTypesIncludingInherited = [], this._behaviorsByName = /* @__PURE__ */ new Map(), this._behaviorNameToIndex = /* @__PURE__ */ new Map(), this._usedBehaviorCtors = /* @__PURE__ */ new Set(), this._customActionMap = /* @__PURE__ */ new Map(), this._solStack = C32.New(C32.SolStack, this), this._defaultInstanceData = null, this._defaultLayerIndex = 0, this._isContained = false, this._container = null, this._imageInfo = null, this._animations = null, this._animationsByName = null, this._animationsBySid = null, this._textureRefCount = 0, this._savedData = /* @__PURE__ */ new Map(), this._unsavedData = /* @__PURE__ */ new Map(), this._instances = [], this._worldInfosByLayer = /* @__PURE__ */ new Map(), this._iidsStale = true, this._plugin.HasEffects() && (this._effectList = C32.New(C32.EffectList, this, s[12])), s[6] && (this._imageInfo = C32.New(C32.ImageInfo), this._imageInfo.LoadData(s[6])), s[7]) {
        this._animations = s[7].map((t3) => C32.New(C32.AnimationInfo, t3)), this._animationsByName = /* @__PURE__ */ new Map(), this._animationsBySid = /* @__PURE__ */ new Map();
        for (const t3 of this._animations) this._animationsByName.set(t3.GetName().toLowerCase(), t3), this._animationsBySid.set(t3.GetSID(), t3);
      }
      this._isFamily ? (this._familyMembers = [], this._familyMembersSet = /* @__PURE__ */ new Set(), this._familyIndex = this._runtime._GetNextFamilyIndex()) : (this._families = [], this._familiesSet = /* @__PURE__ */ new Set(), this._familyInstVarMap = [], this._familyBehaviorMap = [], this._familyEffectMap = []);
      const r2 = this._plugin.GetSdkVersion();
      if (r2 < 2 && (this._sdkType = C32.New(i.Type, this, s[15]), !(this._sdkType instanceof C32.SDKTypeBase))) throw new Error("v1 sdk type must derive from SDKTypeBase");
      let o2;
      if (this._iObjectClass = null, this._instanceUserScriptClass = null, this._userScriptDispatcher = C32.New(C32.Event.Dispatcher), C32.AddonManager._PushInitObject(this, r2), r2 >= 2 ? (o2 = i.Type, o2 || (o2 = globalThis.ISDKObjectTypeBase)) : o2 = this._sdkType.GetScriptInterfaceClass(), o2 && !this._isFamily) {
        if (this._iObjectClass = new o2(r2 < 2 ? this : null), r2 < 2 && !(this._iObjectClass instanceof IObjectType)) throw new TypeError("script interface class must derive from IObjectType");
        if (r2 >= 2 && !(this._iObjectClass instanceof globalThis.ISDKObjectTypeBase)) throw new TypeError("script interface class must derive from ISDKObjectTypeBase");
      } else {
        const t3 = this._isFamily ? IFamily : IObjectType;
        this._iObjectClass = new t3();
      }
      if (C32.AddonManager._PopInitObject(r2), s[13]) {
        const t3 = s[13];
        if (t3) {
          const e2 = t3[0], s2 = t3[1], i2 = t3[2];
          this._sdkType.LoadTilemapData(e2, s2, i2);
        }
      }
      this._runtime.UsesLoaderLayout() && !this._isFamily && !this._isOnLoaderLayout && this._isWorldType || this.OnCreate(), this._plugin.IsSingleGlobal() && (this._plugin._SetSingleGlobalObjectClass(this), this._CreateSingleGlobalInstance(s)), this._loadInstancesJson = null;
    }
    static Create(t2, e, s) {
      return C32.New(C32.ObjectClass, t2, e, s);
    }
    Release() {
      if (this._dispatcher.Release(), this._dispatcher = null, this._imageInfo && (this._imageInfo.Release(), this._imageInfo = null), this._animations) {
        for (const t2 of this._animations) t2.Release();
        C32.clearArray(this._animations), this._animationsByName.clear(), this._animationsBySid.clear();
      }
      this._loadInstancesJson = null, this._solStack.Release(), this._solStack = null, this._savedData.clear(), this._unsavedData.clear(), this._container = null, this._runtime = null;
    }
    _LoadFamily(t2) {
      for (let e = 1, s = t2.length; e < s; ++e) {
        const s2 = this._runtime.GetObjectClassByIndex(t2[e]);
        this._familyMembers.push(s2), this._familyMembersSet.add(s2), s2._families.push(this), s2._familiesSet.add(this);
      }
    }
    _SetContainer(t2) {
      this._isInContainer = true, this._container = t2;
    }
    IsInContainer() {
      return this._isInContainer;
    }
    GetContainer() {
      return this._container;
    }
    _OnAfterCreate() {
      let t2 = 0;
      if (!this._isFamily) for (const e of this._families) for (const s of e.GetBehaviorTypes()) {
        const e2 = s.GetName().toLowerCase();
        this._behaviorsByName.set(e2, s), this._behaviorNameToIndex.set(e2, t2), this._behaviorTypesIncludingInherited.push(s), ++t2;
      }
      for (const e of this.GetBehaviorTypes()) {
        const s = e.GetName().toLowerCase();
        this._behaviorsByName.set(s, e), this._behaviorNameToIndex.set(s, t2), this._behaviorTypesIncludingInherited.push(e), ++t2;
      }
      for (const t3 of this._behaviorTypesIncludingInherited) this._usedBehaviorCtors.add(t3.GetBehavior().constructor);
      if (!this._isFamily && this._families.length) {
        const t3 = this._runtime.GetFamilyCount();
        C32.extendArray(this._familyInstVarMap, t3, 0), C32.extendArray(this._familyBehaviorMap, t3, 0), C32.extendArray(this._familyEffectMap, t3, 0);
        const e = [];
        let s = 0, i = 0, n = 0;
        for (const t4 of this._families) {
          const a2 = t4.GetFamilyIndex();
          this._familyInstVarMap[a2] = s, s += t4.GetInstanceVariablesCount(), this._familyBehaviorMap[a2] = i, i += t4.GetBehaviorTypesCount(), this._familyEffectMap[a2] = n, n += t4.GetEffectTypesCount();
          const r2 = t4.GetEffectList();
          if (r2 && this._effectList) for (const t5 of r2.GetAllEffectTypes()) e.push(t5.Clone(this._effectList));
        }
        this._effectList && this._effectList.PrependEffectTypes(e);
      }
    }
    _CreateSingleGlobalInstance(t2) {
      const e = C32.IsFiniteNumber(t2[17]) ? t2[17] : this._runtime._GetNewUID(), s = C32.New(C32.Instance, { runtime: this._runtime, objectType: this, uid: e });
      s._CreateSdkInstance(t2[16], []), this._runtime._MapInstanceByUID(e, s), this._instances.push(s);
    }
    GetSdkType() {
      return this._sdkType;
    }
    IsOnLoaderLayout() {
      return this._isOnLoaderLayout;
    }
    Dispatcher() {
      return this._dispatcher;
    }
    OnCreate() {
      this._isFamily || (this._sdkType ? this._sdkType.OnCreate() : this._iObjectClass._onCreate());
    }
    HasLoadedTextures() {
      return this._textureRefCount > 0;
    }
    async LoadTextures(t2) {
      this._isFamily || (this._textureRefCount++, 1 === this._textureRefCount && (this._sdkType ? await this._sdkType.LoadTextures(t2) : await this._iObjectClass._loadTextures(this._runtime.GetCanvasManager().GetIRenderer())));
    }
    ReleaseTextures() {
      if (!this._isFamily) {
        if (this._textureRefCount--, this._textureRefCount < 0) throw new Error("released textures too many times");
        0 === this._textureRefCount && (this._sdkType ? this._sdkType.ReleaseTextures() : this._iObjectClass._releaseTextures(this._runtime.GetCanvasManager().GetIRenderer()));
      }
    }
    OnDynamicTextureLoadComplete() {
      if (this._isFamily) throw new Error("not applicable to family");
      this._sdkType ? this._sdkType.OnDynamicTextureLoadComplete() : this._iObjectClass._onDynamicTextureLoadComplete();
    }
    async PreloadTexturesWithInstances(t2) {
      this._isFamily || (this._sdkType ? await this._sdkType.PreloadTexturesWithInstances(t2) : await this._iObjectClass._preloadTexturesWithInstances(this._runtime.GetCanvasManager().GetIRenderer()));
    }
    GetRuntime() {
      return this._runtime;
    }
    GetPlugin() {
      return this._plugin;
    }
    GetInstanceSdkCtor() {
      return this._instSdkCtor;
    }
    GetName() {
      return this._name;
    }
    GetJsPropName() {
      return this._jsPropName;
    }
    GetIndex() {
      return this._index;
    }
    GetSID() {
      return this._sid;
    }
    IsFamily() {
      return this._isFamily;
    }
    IsGlobal() {
      return this._isGlobal;
    }
    IsWorldType() {
      return this._isWorldType;
    }
    GetFamilyIndex() {
      return this._familyIndex;
    }
    GetBehaviorTypes() {
      return this._behaviorTypes;
    }
    GetBehaviorTypesCount() {
      return this._behaviorsCount;
    }
    UsesBehaviorByCtor(t2) {
      return t2 && this._usedBehaviorCtors.has(t2);
    }
    GetInstanceVariablesCount() {
      return this._instVars.length;
    }
    GetInstanceVariableSIDs() {
      return this._instVars.map((t2) => t2.sid);
    }
    GetInstanceVariableIndexBySID(t2) {
      return this._instVars.findIndex((e) => e.sid === t2);
    }
    GetInstanceVariableIndexByName(t2) {
      return this._instVars.findIndex((e) => e.name === t2);
    }
    _GetAllInstanceVariableNames() {
      return this._instVars.map((t2) => t2.name);
    }
    _GetAllInstanceVariableJsPropNames() {
      return this._instVars.map((t2) => t2.jsPropName);
    }
    GetInstanceVariableType(t2) {
      if ((t2 = Math.floor(t2)) < 0 || t2 >= this._instVars.length) throw new RangeError("invalid instance variable index");
      return this._instVars[t2].type;
    }
    GetInstanceVariableName(t2) {
      if ((t2 = Math.floor(t2)) < 0 || t2 >= this._instVars.length) throw new RangeError("invalid instance variable index");
      return this._instVars[t2].name;
    }
    GetEffectTypesCount() {
      return this._effectsCount;
    }
    GetBehaviorTypesIncludingInherited() {
      return this._behaviorTypesIncludingInherited;
    }
    GetBehaviorTypeByName(t2) {
      return this._behaviorsByName.get(t2.toLowerCase()) || null;
    }
    GetBehaviorIndexByName(t2) {
      const e = this._behaviorNameToIndex.get(t2.toLowerCase());
      return void 0 === e ? -1 : e;
    }
    GetEffectList() {
      return this._effectList;
    }
    HasEffects() {
      return this._plugin.HasEffects();
    }
    UsesEffects() {
      return this._effectList && this._effectList.HasAnyEffectType();
    }
    GetSolStack() {
      return this._solStack;
    }
    GetCurrentSol() {
      return this._solStack.GetCurrentSol();
    }
    GetImageInfo() {
      return this._imageInfo;
    }
    SetDefaultInstanceData(t2) {
      this._defaultInstanceData = t2;
    }
    GetDefaultInstanceData() {
      return this._defaultInstanceData;
    }
    _SetDefaultLayerIndex(t2) {
      this._defaultLayerIndex = t2;
    }
    GetDefaultLayerIndex() {
      return this._defaultLayerIndex;
    }
    GetAnimations() {
      return this._animations;
    }
    GetAnimationCount() {
      return this._animations.length;
    }
    GetFamilies() {
      return this._families;
    }
    BelongsToFamily(t2) {
      return this._familiesSet.has(t2);
    }
    GetFamilyMembers() {
      return this._familyMembers;
    }
    FamilyHasMember(t2) {
      return this._familyMembersSet.has(t2);
    }
    GetFamilyBehaviorOffset(t2) {
      return this._familyBehaviorMap[t2];
    }
    GetFamilyInstanceVariableOffset(t2) {
      return this._familyInstVarMap[t2];
    }
    AddCustomAction(t2) {
      this._customActionMap.set(t2.GetACEName().toLowerCase(), t2);
    }
    HasOwnCustomActionByName(t2) {
      return !!this.GetOwnCustomActionByName(t2);
    }
    GetOwnCustomActionByName(t2) {
      const e = this._customActionMap.get(t2.toLowerCase());
      return e && e.IsEnabled() ? e : null;
    }
    GetAllAnimations() {
      return this._animations;
    }
    GetAnimationByName(t2) {
      if (!this._animations) throw new Error("no animations");
      return this._animationsByName.get(t2.toLowerCase()) || null;
    }
    GetAnimationBySID(t2) {
      if (!this._animations) throw new Error("no animations");
      return this._animationsBySid.get(t2) || null;
    }
    AddAnimation(t2) {
      if (this.GetAnimationByName(t2)) throw new Error(`animation name '${t2}' already exists`);
      const e = C32.AnimationInfo.CreateDynamic(this.GetRuntime(), t2);
      return this._animations.push(e), this._animationsByName.set(e.GetName().toLowerCase(), e), this._animationsBySid.set(e.GetSID(), e), e;
    }
    RemoveAnimation(t2) {
      const e = this.GetAnimationByName(t2);
      if (!e) throw new Error(`animation name '${t2}' does not exist`);
      if (1 === this._animations.length) throw new Error("cannot remove last animation");
      const s = this._animations.indexOf(e);
      this._animations.splice(s, 1), this._animationsByName.delete(e.GetName().toLowerCase()), this._animationsBySid.delete(e.GetSID()), e.Release();
    }
    GetFirstAnimation() {
      if (!this._animations) throw new Error("no animations");
      return this._animations[0];
    }
    GetFirstAnimationFrame() {
      return this.GetFirstAnimation().GetFrameAt(0);
    }
    GetDefaultInstanceSize() {
      if (this._animations) {
        const t2 = this.GetFirstAnimationFrame().GetImageInfo();
        return [t2.GetWidth(), t2.GetHeight()];
      }
      return this._imageInfo ? [this._imageInfo.GetWidth(), this._imageInfo.GetHeight()] : [100, 100];
    }
    GetSingleGlobalInstance() {
      if (!this._plugin.IsSingleGlobal()) throw new Error("not a single-global plugin");
      return this._instances[0];
    }
    GetInstances() {
      return this._instances;
    }
    *instances() {
      yield* this._instances;
    }
    *instancesIncludingPendingCreate() {
      yield* this._instances, yield* this._runtime.instancesPendingCreateForObjectClass(this);
    }
    GetInstanceCount() {
      return this._instances.length;
    }
    _AddInstance(t2) {
      this._instances.push(t2);
    }
    _SetIIDsStale() {
      this._iidsStale = true;
    }
    _UpdateIIDs() {
      if (!this._iidsStale || this._isFamily) return;
      const t2 = this._instances;
      let e = 0;
      for (let s2 = t2.length; e < s2; ++e) t2[e]._SetIID(e);
      const s = this._runtime._GetInstancesPendingCreate();
      for (const t3 of s) t3.GetObjectClass() === this && t3._SetIID(e++);
      this._iidsStale = false;
    }
    GetInstanceByIID(t2) {
      const e = this._instances;
      if (t2 < e.length) return e[t2];
      t2 -= e.length;
      const s = this._runtime._GetInstancesPendingCreate();
      for (const e2 of s) if (e2.GetObjectClass() === this) {
        if (0 === t2) return e2;
        --t2;
      }
      return null;
    }
    GetFirstPicked(t2) {
      if (t2 && t2.IsInContainer() && t2.GetObjectClass() !== this) {
        for (const e2 of t2.siblings()) if (e2.GetObjectClass() === this) return e2;
      }
      const e = this.GetCurrentSol().GetInstances();
      return e.length ? e[0] : null;
    }
    GetPairedInstance(t2) {
      const e = this.GetCurrentSol().GetInstances();
      return e.length > 0 ? e[t2.GetIID() % e.length] : null;
    }
    *allCorrespondingInstances(t2, e) {
      const s = this.GetCurrentSol().GetInstances(), i = s.length, n = e.GetCurrentSol(), a2 = e.GetCurrentSol().GetInstances(), r2 = a2.length;
      let o2 = t2.GetIID();
      !e.IsFamily() && n.IsSelectAll() || (o2 = a2.indexOf(t2));
      const h2 = Math.ceil(i / r2), l = i % r2;
      let _2 = 0, c2 = 0;
      0 === l || o2 < l ? (_2 = o2 * h2, c2 = h2) : (_2 = l * h2 + (o2 - l) * (h2 - 1), c2 = h2 - 1);
      for (let t3 = _2, e2 = _2 + c2; t3 < e2; ++t3) yield s[t3];
    }
    FinishCondition(t2) {
      this._sdkType?.FinishCondition(t2);
    }
    ApplySolToContainer() {
      if (!this._isInContainer || this._isFamily) return;
      this._UpdateIIDs();
      const t2 = this.GetCurrentSol(), e = t2._GetOwnInstances(), s = t2.IsSelectAll(), i = this._runtime.GetCurrentEventStackFrame(), n = i && i.GetCurrentEvent() && i.GetCurrentEvent().IsOrBlock();
      for (const i2 of this._container.objectTypes()) {
        if (i2 === this) continue;
        i2._UpdateIIDs();
        const a2 = i2.GetCurrentSol();
        if (a2._SetSelectAll(s), !s) {
          const s2 = a2._GetOwnInstances();
          C32.clearArray(s2);
          for (const t3 of e) s2.push(i2.GetInstanceByIID(t3.GetIID()));
          if (n) {
            const e2 = t2._GetOwnElseInstances(), s3 = a2._GetOwnElseInstances();
            C32.clearArray(s3);
            for (const t3 of e2) s3.push(i2.GetInstanceByIID(t3.GetIID()));
          }
        }
      }
    }
    _TruncateContainerSols(t2, e) {
      for (const s of this.GetContainer().objectTypes()) {
        const i = s.GetCurrentSol();
        t2 ? C32.truncateArray(i._GetOwnElseInstances(), e) : C32.truncateArray(i._GetOwnInstances(), e);
      }
    }
    _GetCollisionCellGrid() {
      return this._collisionGrid;
    }
    _SetAnyCollisionCellChanged(t2) {
      this._anyCollisionCellChanged = !!t2;
    }
    _UpdateAllCollisionCells() {
      if (this._anyCollisionCellChanged && this._isWorldType) {
        for (const t2 of this._instances) t2.GetWorldInfo()._UpdateCollisionCell();
        for (const t2 of this._runtime._GetInstancesPendingCreate()) t2.GetObjectClass() === this && t2.GetWorldInfo()._UpdateCollisionCell();
        this._anyCollisionCellChanged = false;
      }
    }
    _OnWorldInstanceLayerChanged(t2, e, s) {
      if (e) {
        const s2 = this._worldInfosByLayer.get(e);
        s2 && (s2.delete(t2), 0 === s2.size && this._worldInfosByLayer.delete(e));
      }
      if (s) {
        let e2 = this._worldInfosByLayer.get(s);
        e2 || (e2 = /* @__PURE__ */ new Set(), this._worldInfosByLayer.set(s, e2)), e2.add(t2);
      }
    }
    *layersHasInstancesOn() {
      if (this.IsFamily()) {
        const t2 = /* @__PURE__ */ new Set();
        for (const e of this._familyMembers) for (const s of e.layersHasInstancesOn()) t2.add(s);
        yield* t2.values();
      } else for (const t2 of this._worldInfosByLayer.keys()) t2.WasReleased() || (yield t2);
    }
    GetSavedDataMap() {
      return this._savedData || (this._savedData = /* @__PURE__ */ new Map()), this._savedData;
    }
    GetUnsavedDataMap() {
      return this._unsavedData || (this._unsavedData = /* @__PURE__ */ new Map()), this._unsavedData;
    }
    HasSolidBehavior() {
      return this.UsesBehaviorByCtor(C32.Behaviors.solid);
    }
    HasJumpthruBehavior() {
      return this.UsesBehaviorByCtor(C32.Behaviors.jumpthru);
    }
    HasNoSaveBehavior() {
      return this.UsesBehaviorByCtor(C32.Behaviors.NoSave);
    }
    HasPersistBehavior() {
      return this.UsesBehaviorByCtor(C32.Behaviors.Persist);
    }
    _SaveToJson() {
      const t2 = { "instances": this._instances.map((t3) => t3.SaveToJson()) };
      return this._savedData && this._savedData.size && (t2["ex"] = C32.ToSuperJSON(this._savedData)), t2;
    }
    _LoadFromJson(t2, e) {
      this._savedData && (this._savedData.clear(), this._savedData = null);
      const s = t2["ex"];
      s && (this._savedData = C32.FromSuperJSON(s));
      const i = this._instances, n = t2["instances"];
      for (let t3 = 0, e2 = Math.min(i.length, n.length); t3 < e2; ++t3) i[t3].LoadFromJson(n[t3]);
      for (let t3 = n.length, e2 = i.length; t3 < e2; ++t3) this._runtime.DestroyInstance(i[t3]);
      for (let t3 = i.length, s2 = n.length; t3 < s2; ++t3) {
        const s3 = n[t3];
        let i2 = null;
        if (this.IsWorldType() && (i2 = this._runtime.GetMainRunningLayout().GetLayerBySID(s3["w"]["l"]), !i2)) continue;
        const a2 = this._runtime.CreateInstanceFromData(this._defaultInstanceData || this, i2, false, 0, 0, true);
        a2.LoadFromJson(s3), e && e.add(a2);
      }
      this._loadInstancesJson = n, this._SetIIDsStale();
    }
    _GetLoadInstancesJson() {
      return this._loadInstancesJson;
    }
    _ClearLoadInstancesJson() {
      this._loadInstancesJson = null;
    }
    _SetupSceneGraphConnectionsOnChangeOfLayout() {
      for (let t2 = 0, e = this._instances; t2 < e; ++t2) this._instances[t2]._SetupSceneGraphConnectionsOnChangeOfLayout();
    }
    GetIObjectClass() {
      return this._iObjectClass;
    }
    UserScriptDispatcher() {
      return this._userScriptDispatcher;
    }
    _GetUserScriptInstanceClass() {
      return this._instanceUserScriptClass;
    }
    _SetUserScriptInstanceClass(t2) {
      this._instanceUserScriptClass = t2;
    }
    DispatchUserScriptEvent(t2) {
      const e = this._runtime, s = e.IsDebug() && !e.GetEventSheetManager().IsInEventEngine();
      s && C3Debugger.StartMeasuringScriptTime(), this._userScriptDispatcher.dispatchEvent(t2), s && C3Debugger.AddScriptTime();
    }
  };
}
{
  const C32 = self.C3;
  C32.Container = class extends C32.DefendedBase {
    constructor(e, t2) {
      super(), this._runtime = e, this._objectTypes = t2;
      for (const e2 of this._objectTypes) e2._SetContainer(this);
    }
    Release() {
      this._runtime = null;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetObjectTypes() {
      return this._objectTypes;
    }
    objectTypes() {
      return this._objectTypes;
    }
    HasAnyWorldType() {
      return this._objectTypes.some((e) => e.IsWorldType());
    }
  };
}
{
  const C32 = self.C3, C3Debugger = self.C3Debugger, IInstance = self.IInstance, originalAddonManager = C32.AddonManager, EMPTY_ARRAY = [];
  let nextPuid = 0;
  const savedDataMaps = /* @__PURE__ */ new WeakMap(), unsavedDataMaps = /* @__PURE__ */ new WeakMap(), FLAG_DESTROYED = 1, FLAG_TILEMAP = 2, FLAG_MUST_PREDRAW = 4, FLAG_SOLID_ENABLED = 8, FLAG_JUMPTHRU_ENABLED = 16, FLAG_MUST_MITIGATE_Z_FIGHTING = 32, FLAG_IS_DRAWING_WITH_EFFECTS = 64;
  C32.Instance = class extends C32.DefendedBase {
    constructor(t2) {
      if (C32.AddonManager !== originalAddonManager) throw new Error("invalid addon manager");
      super(), this._runtime = t2.runtime, this._objectType = t2.objectType, this._worldInfo = null, this._sdkInst = null, this._iScriptInterface = null, this._iid = 0, this._uid = t2.uid, this._puid = nextPuid++, this._flags = 0, this._tagsSet = null;
      const e = C32.splitStringAndNormalize(t2.tags);
      e.length > 0 && (this._tagsSet = new Set(e)), this._instVarValues = EMPTY_ARRAY, this._behaviorInstances = EMPTY_ARRAY;
      const s = this._objectType.GetBehaviorTypesIncludingInherited();
      s.length > 0 && (this._behaviorInstances = s.map((t3, e2) => C32.New(C32.BehaviorInstance, { runtime: this._runtime, behaviorType: t3, instance: this, index: e2 }))), this._siblings = this._objectType.IsInContainer() ? [] : null, this._timeScale = -1, this._dispatcher = null;
      const n = this.GetPlugin();
      if (n.MustPreDraw() && (this._flags |= 4), n.IsWorldType()) if (this._worldInfo = C32.New(C32.WorldInfo, this, t2.layer), t2.worldData) this._worldInfo.Init(t2.worldData);
      else {
        this._worldInfo.InitNoData();
        const [t3, e2] = this._objectType.GetDefaultInstanceSize();
        this._worldInfo.SetSize(t3, e2), this.GetObjectClass().UsesEffects() && this._worldInfo.GetInstanceEffectList().LoadDefaultEffectParameters();
      }
      t2.instVarData ? this._LoadInstanceVariableData(t2.instVarData) : this._LoadDefaultInstanceVariables();
    }
    Release() {
      if (this._iScriptInterface && (this._iScriptInterface._release(), this._iScriptInterface = null), this._behaviorInstances.length > 0) {
        for (const t3 of this._behaviorInstances) t3.Release();
        C32.clearArray(this._behaviorInstances);
      }
      this._sdkInst && (this._sdkInst.Release(), this._sdkInst = null);
      const t2 = savedDataMaps.get(this);
      t2 && (t2.clear(), savedDataMaps.delete(this));
      const e = unsavedDataMaps.get(this);
      e && (e.clear(), unsavedDataMaps.delete(this)), this._siblings && C32.clearArray(this._siblings), this._dispatcher && (this._dispatcher.Release(), this._dispatcher = null), this._tagsSet && this._tagsSet.clear(), this._tagsSet = null, this._runtime = null, this._objectType = null, this._instVarValues.length > 0 && C32.clearArray(this._instVarValues), this._worldInfo && (this._worldInfo.Release(), this._worldInfo = null);
    }
    _LoadInstanceVariableData(t2) {
      t2.length > 0 && (this._instVarValues = [], C32.shallowAssignArray(this._instVarValues, t2));
    }
    _LoadDefaultInstanceVariables() {
      const t2 = this._objectType.GetInstanceVariablesCount();
      if (0 === t2) return;
      this._instVarValues = [];
      const e = [0, 0, ""];
      for (let s = 0; s < t2; ++s) this._instVarValues.push(e[this._objectType.GetInstanceVariableType(s)]);
    }
    _CreateSdkInstance(t2, e) {
      if (this._sdkInst) throw new Error("already got sdk instance");
      for (let t3 = 0, s = this._behaviorInstances.length; t3 < s; ++t3) {
        this._behaviorInstances[t3]._CreateSdkInstance(e ? e[t3] : null);
      }
      if (this.GetPlugin().GetSdkVersion() < 2) {
        if (this._sdkInst = C32.New(this._objectType.GetInstanceSdkCtor(), this, t2), !(this._sdkInst instanceof C32.SDKInstanceBase)) throw new Error("sdk type must derive from SDKInstanceBase");
        !this.GetPlugin().IsWorldType() && this._objectType._GetUserScriptInstanceClass() && this.GetInterfaceClass();
      } else {
        const e2 = this.GetPlugin().GetScriptInterfaceClass();
        this._InitUserScriptInterface(e2.Instance, t2);
      }
    }
    GetSdkInstance() {
      return this._sdkInst ?? this._iScriptInterface;
    }
    GetWorldInfo() {
      return this._worldInfo;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetTimeScale() {
      return this._timeScale;
    }
    GetActiveTimeScale() {
      const t2 = this._timeScale;
      return -1 === t2 ? this.GetRuntime().GetTimeScale() : t2;
    }
    SetTimeScale(t2) {
      ((t2 = +t2) < 0 || !isFinite(t2)) && (t2 = 0), this._timeScale = t2, this.GetObjectClass().UsesEffects() && this._runtime._SetTrackingInstanceTime(this, true);
    }
    RestoreTimeScale() {
      this._timeScale = -1, this.GetObjectClass().UsesEffects() && this._runtime._SetTrackingInstanceTime(this, false);
    }
    GetInstanceGameTime() {
      return this._runtime._GetInstanceGameTime(this);
    }
    Dispatcher() {
      return this._dispatcher || (this._dispatcher = C32.New(C32.Event.Dispatcher)), this._dispatcher;
    }
    Draw(t2) {
      this._sdkInst ? this._sdkInst.Draw(t2) : this._iScriptInterface._draw(this._runtime.GetCanvasManager().GetIRenderer());
    }
    OnCreate(t2) {
      this._sdkInst.OnCreate(t2);
    }
    _SetHasTilemap() {
      this._flags |= 2;
    }
    HasTilemap() {
      return !!(2 & this._flags);
    }
    _MarkDestroyed() {
      this._flags |= 1;
    }
    IsDestroyed() {
      return !!(1 & this._flags);
    }
    MustPreDraw() {
      return !!(4 & this._flags) || (this._sdkInst ? this._sdkInst.MustPreDraw() : this._iScriptInterface._mustPreDraw());
    }
    SetMustMitigateZFighting() {
      this._flags |= 32;
    }
    MustMitigateZFighting() {
      return !!(32 & this._flags);
    }
    _IsSolidEnabled() {
      return !!(8 & this._flags);
    }
    _SetSolidEnabled(t2) {
      t2 ? this._flags |= 8 : this._flags &= -9;
    }
    _IsJumpthruEnabled() {
      return !!(16 & this._flags);
    }
    _SetJumpthruEnabled(t2) {
      t2 ? this._flags |= 16 : this._flags &= -17;
    }
    _IsDrawingWithEffects() {
      return !!(64 & this._flags);
    }
    _SetIsDrawingWithEffects(t2) {
      t2 ? this._flags |= 64 : this._flags &= -65;
    }
    SetFlag(t2, e) {
      t2 <<= 16, e ? this._flags |= t2 : this._flags &= ~t2;
    }
    GetFlag(t2) {
      return !!(this._flags & t2 << 16);
    }
    GetCurrentImageInfo() {
      return this._sdkInst ? this._sdkInst.GetCurrentImageInfo() : null;
    }
    GetCurrentSurfaceSize() {
      return this._sdkInst ? this._sdkInst.GetCurrentSurfaceSize() : null;
    }
    GetCurrentTexRect() {
      return this._sdkInst ? this._sdkInst.GetCurrentTexRect() : null;
    }
    GetCurrentTexQuad() {
      return this._sdkInst ? this._sdkInst.GetCurrentTexQuad() : null;
    }
    IsCurrentTexRotated() {
      return !!this._sdkInst && this._sdkInst.IsCurrentTexRotated();
    }
    GetImagePoint(t2) {
      return this._sdkInst ? this._sdkInst.GetImagePoint(t2) : [this._iScriptInterface.x, this._iScriptInterface.y, this._iScriptInterface.totalZElevation];
    }
    GetObjectClass() {
      return this._objectType;
    }
    RendersToOwnZPlane() {
      return this._sdkInst ? this._sdkInst.RendersToOwnZPlane() : this._iScriptInterface._rendersToOwnZPlane();
    }
    BelongsToObjectClass(t2) {
      return t2.IsFamily() ? t2.FamilyHasMember(this.GetObjectClass()) : this.GetObjectClass() === t2;
    }
    CollectInstancesToPick(t2, e, s) {
      const n = (e2, s2) => {
        const n2 = s2 || e2.GetObjectClass(), i = t2.get(n2);
        i ? i.add(e2) : t2.set(n2, /* @__PURE__ */ new Set([e2]));
      };
      if (n(this, e), this.IsInContainer()) for (const t3 of this.siblings()) n(t3);
      if (s) for (const t3 of this.allChildren()) n(t3);
    }
    VerifySupportsSceneGraph() {
      if (!this.GetPlugin().SupportsSceneGraph()) throw new Error("object does not support scene graph");
    }
    HasParent() {
      return null !== this.GetParent();
    }
    GetParent() {
      const t2 = this.GetWorldInfo();
      if (!t2) return null;
      const e = t2.GetParent();
      return e ? e.GetInstance() : null;
    }
    GetTopParent() {
      const t2 = this.GetWorldInfo();
      if (!t2) return null;
      const e = t2.GetTopParent();
      return e ? e.GetInstance() : null;
    }
    *parents() {
      const t2 = this.GetWorldInfo();
      if (t2) for (const e of t2.parents()) yield e.GetInstance();
    }
    HasChild(t2) {
      if (!t2) return false;
      for (const e of this.children()) if (e === t2) return true;
      return false;
    }
    HasChildren() {
      const t2 = this.GetWorldInfo();
      return !!t2 && t2.HasChildren();
    }
    GetChildrenOfObjectClass(t2) {
      const e = this.GetWorldInfo();
      if (!e) return [];
      const s = t2.GetName();
      return e.GetChildren().map((t3) => t3.GetInstance()).filter((t3) => t3.GetObjectClass().GetName() === s);
    }
    GetChildren() {
      const t2 = this.GetWorldInfo();
      return t2 ? t2.GetChildren().map((t3) => t3.GetInstance()) : [];
    }
    *children() {
      const t2 = this.GetWorldInfo();
      if (t2) for (const e of t2.children()) yield e.GetInstance();
    }
    *allChildren() {
      const t2 = this.GetWorldInfo();
      if (t2) for (const e of t2.allChildren()) yield e.GetInstance();
    }
    GetChildCount() {
      const t2 = this.GetWorldInfo();
      return t2 ? t2.GetChildCount() : 0;
    }
    GetParentCount() {
      return [...this.parents()].length;
    }
    GetAllChildCount() {
      const t2 = this.GetWorldInfo();
      return t2 ? t2.GetAllChildCount() : 0;
    }
    GetChildAt(t2) {
      const e = this.GetWorldInfo();
      if (!e) return null;
      const s = e.GetChildAt(t2);
      return s ? s.GetInstance() : null;
    }
    GetIndexInParent() {
      const t2 = this.GetWorldInfo();
      if (!t2) return NaN;
      const e = t2.GetParent();
      return e ? e.GetChildIndex(t2) : NaN;
    }
    HasChildWithUID(t2) {
      for (const e of this.GetWorldInfo().GetChildren()) if (e.GetInstance().GetUID() === t2) return true;
      return false;
    }
    AddChild(t2, e) {
      this.VerifySupportsSceneGraph(), t2.VerifySupportsSceneGraph(), this.GetWorldInfo().AddChild(t2.GetWorldInfo(), e || {});
    }
    RemoveChild(t2) {
      const e = this.GetWorldInfo();
      e && e.RemoveChild(t2.GetWorldInfo());
    }
    GetDestroyWithParent() {
      const t2 = this.GetWorldInfo();
      return !!t2 && t2.GetDestroyWithParent();
    }
    SetupInitialSceneGraphConnections() {
      const t2 = this.GetWorldInfo();
      if (!t2) return;
      const e = t2.GetSceneGraphChildrenExportData();
      if (e) for (const t3 of e) {
        const e2 = this._runtime.GetInstanceByUID(t3[2]);
        if (e2) {
          const s = t3[3];
          this.AddChild(e2, { transformX: !!(1 & s), transformY: !!(s >> 1 & 1), transformWidth: !!(s >> 2 & 1), transformHeight: !!(s >> 3 & 1), transformAngle: !!(s >> 4 & 1), destroyWithParent: !!(s >> 5 & 1), transformZElevation: !!(s >> 6 & 1), transformOpacity: !!(s >> 7 & 1), transformVisibility: !!(s >> 8 & 1) });
        }
      }
    }
    SetupPersistedSceneGraphConnections(t2, e) {
      const s = t2.get(this);
      if (s) for (const t3 of s["sceneGraphJson"]["children"]) {
        const s2 = e.get(t3["index"]);
        if (!s2) continue;
        const n = t3["flags"];
        this.AddChild(s2, { transformX: !!(1 & n), transformY: !!(n >> 1 & 1), transformWidth: !!(n >> 2 & 1), transformHeight: !!(n >> 3 & 1), transformAngle: !!(n >> 4 & 1), destroyWithParent: !!(n >> 5 & 1), transformZElevation: !!(n >> 6 & 1), transformOpacity: !!(n >> 7 & 1), transformVisibility: !!(n >> 8 & 1) });
      }
    }
    GetTemplateName() {
      const t2 = this._runtime.GetTemplateManager();
      return t2 ? t2.GetInstanceTemplateName(this) : "";
    }
    IsInContainer() {
      return null !== this._siblings;
    }
    _ClearSiblings() {
      C32.clearArray(this._siblings);
    }
    _AddSibling(t2) {
      this._siblings.push(t2);
    }
    GetSiblings() {
      return this._siblings;
    }
    HasSibling(t2) {
      return !!this.GetSibling(t2);
    }
    GetSibling(t2) {
      const e = this.siblings();
      if (null === e || 0 === e.length) return false;
      for (const s of e) if (s.GetObjectClass() === t2) return s;
      return null;
    }
    siblings() {
      return this._siblings;
    }
    SetSiblingsSinglePicked() {
      for (const t2 of this.siblings()) t2.GetObjectClass().GetCurrentSol().SetSinglePicked(t2);
    }
    _PushSiblingsToSolInstances() {
      for (const t2 of this.siblings()) t2.GetObjectClass().GetCurrentSol()._PushInstance(t2);
    }
    _SetSiblingsToSolInstancesIndex(t2) {
      for (const e of this.siblings()) e.GetObjectClass().GetCurrentSol()._GetOwnInstances()[t2] = e;
    }
    _PushSiblingsToSolElseInstances() {
      for (const t2 of this.siblings()) t2.GetObjectClass().GetCurrentSol()._PushElseInstance(t2);
    }
    _SetSiblingsToSolElseInstancesIndex(t2) {
      for (const e of this.siblings()) e.GetObjectClass().GetCurrentSol()._GetOwnElseInstances()[t2] = e;
    }
    GetPlugin() {
      return this._objectType.GetPlugin();
    }
    _SetIID(t2) {
      this._iid = t2;
    }
    GetIID() {
      return this._objectType._UpdateIIDs(), this._iid;
    }
    GetUID() {
      return this._uid;
    }
    SetUID(t2) {
      this._uid = t2;
    }
    GetPUID() {
      return this._puid;
    }
    _SetTagsSetFromJson(t2) {
      t2 ? this.SetTagsSet(new Set(t2)) : this._tagsSet = null;
    }
    SetTagsSet(t2) {
      if (0 === t2.size) this._tagsSet = null;
      else {
        this._tagsSet ? this._tagsSet.clear() : this._tagsSet = /* @__PURE__ */ new Set();
        for (const e of t2) this._tagsSet.add(e);
      }
    }
    GetTagsSet() {
      return this._tagsSet ?? /* @__PURE__ */ new Set();
    }
    GetTagsString() {
      return Array.from(this.GetTagsSet()).join(" ");
    }
    GetTagAt(t2) {
      t2 = Math.floor(t2);
      for (const e of this.GetTagsSet()) {
        if (0 === t2) return e;
        --t2;
      }
      return "";
    }
    GetBehaviorInstances() {
      return this._behaviorInstances;
    }
    GetBehaviorInstanceFromCtor(t2) {
      if (!t2) return null;
      for (const e of this._behaviorInstances) if (e.GetBehavior() instanceof t2) return e;
      return null;
    }
    GetBehaviorSdkInstanceFromCtor(t2) {
      if (!t2) return null;
      const e = this.GetBehaviorInstanceFromCtor(t2);
      return e ? e.GetSdkInstance() : null;
    }
    GetBehaviorIndexBySID(t2) {
      const e = this._behaviorInstances;
      for (let s = 0, n = e.length; s < n; ++s) if (e[s].GetBehaviorType().GetSID() === t2) return s;
      return -1;
    }
    GetAllInstanceVariableValues() {
      return this._instVarValues;
    }
    _GetAllInstanceVariableNames() {
      return this._objectType._GetAllInstanceVariableNames();
    }
    GetInstanceVariableCount() {
      return this._instVarValues.length;
    }
    GetInstanceVariableValue(t2) {
      t2 |= 0;
      const e = this._instVarValues;
      if (t2 < 0 || t2 >= e.length) throw new RangeError("invalid instance variable");
      return e[t2];
    }
    _GetInstanceVariableValueUnchecked(t2) {
      return this._instVarValues[t2];
    }
    _GetInstanceVariableTypedValue(t2) {
      const e = this._instVarValues[t2];
      return 0 === this._objectType.GetInstanceVariableType(t2) ? !!e : e;
    }
    SetInstanceVariableValue(t2, e) {
      t2 |= 0;
      const s = this._instVarValues;
      if (t2 < 0 || t2 >= s.length) throw new RangeError("invalid instance variable");
      switch (this._objectType.GetInstanceVariableType(t2)) {
        case 0:
          s[t2] = e ? 1 : 0;
          break;
        case 1:
          s[t2] = "number" == typeof e ? e : parseFloat(e);
          break;
        case 2:
          s[t2] = "string" == typeof e ? e : e.toString();
          break;
        default:
          throw new Error("unknown instance variable type");
      }
    }
    SetInstanceVariableOffset(t2, e) {
      if (0 === e) return;
      t2 |= 0;
      const s = this._instVarValues;
      if (t2 < 0 || t2 >= s.length) throw new RangeError("invalid instance variable");
      const n = s[t2];
      if ("number" != typeof n) throw "boolean" == typeof n ? new Error("can not set offset of boolean variable") : "string" == typeof n ? new Error("can not set offset of string variable") : new Error("unknown instance variable type");
      s[t2] += "number" == typeof e ? e : parseFloat(e);
    }
    GetSavedDataMap() {
      let t2 = savedDataMaps.get(this);
      return t2 || (t2 = /* @__PURE__ */ new Map(), savedDataMaps.set(this, t2), t2);
    }
    GetUnsavedDataMap() {
      let t2 = unsavedDataMaps.get(this);
      return t2 || (t2 = /* @__PURE__ */ new Map(), unsavedDataMaps.set(this, t2), t2);
    }
    _HasAnyCreateDestroyHandler(t2) {
      const e = this.GetObjectClass();
      if (e.UserScriptDispatcher().HasAnyHandlerFor(t2)) return true;
      for (const s of e.GetFamilies()) if (s.UserScriptDispatcher().HasAnyHandlerFor(t2)) return true;
      return !!this._runtime.UserScriptDispatcher().HasAnyHandlerFor(t2);
    }
    _TriggerOnCreatedOnSelfAndRelated(t2 = void 0) {
      const e = t2 ?? /* @__PURE__ */ new Set();
      if (e.has(this)) return;
      e.add(this);
      const s = this.GetWorldInfo();
      if (s && s.HasChildren()) {
        for (const t3 of this.allChildren()) if (e.add(t3), t3.IsInContainer()) for (const s2 of t3.siblings()) e.add(s2);
      }
      if (this.IsInContainer()) for (const t3 of this.siblings()) t3._TriggerOnCreatedOnSelfAndRelated(e);
      if (!t2) {
        for (const t3 of e.values()) t3._TriggerOnCreated();
        this._OnHierarchyReady();
      }
    }
    _OnCreatedCommon() {
      this._objectType._GetUserScriptInstanceClass() && this.GetInterfaceClass();
      for (const t2 of this._behaviorInstances) t2.PostCreate();
    }
    _OnCreatedForLoadingSavegame() {
      this._OnCreatedCommon();
    }
    _TriggerOnCreated() {
      if (this._OnCreatedCommon(), this._HasAnyCreateDestroyHandler("instancecreate")) {
        const t2 = this.GetObjectClass(), e = new C32.Event("instancecreate");
        e.instance = this.GetInterfaceClass(), t2.DispatchUserScriptEvent(e);
        for (const s of t2.GetFamilies()) s.DispatchUserScriptEvent(e);
        this._runtime.DispatchUserScriptEvent(e);
      }
      this._runtime.Trigger(this.GetPlugin().GetConstructor().Cnds.OnCreated, this, null);
    }
    _OnHierarchyReady() {
      if (this.GetPlugin().SupportsSceneGraph()) {
        if (this.DispatchUserScriptEvent(new C32.Event("hierarchyready")), this._HasAnyCreateDestroyHandler("hierarchyready")) {
          const t2 = this.GetObjectClass(), e = new C32.Event("hierarchyready");
          e.instance = this.GetInterfaceClass(), t2.DispatchUserScriptEvent(e);
          for (const s of t2.GetFamilies()) s.DispatchUserScriptEvent(e);
          this._runtime.DispatchUserScriptEvent(e);
        }
        this._runtime.Trigger(this.GetPlugin().GetConstructor().Cnds.OnHierarchyReady, this, null);
      }
    }
    _TriggerOnDestroyed() {
      this._runtime.Trigger(this.GetPlugin().GetConstructor().Cnds.OnDestroyed, this, null);
    }
    _FireDestroyedScriptEvents(t2) {
      if (this._iScriptInterface) {
        const e2 = new C32.Event("destroy");
        e2.isEndingLayout = t2, this.DispatchUserScriptEvent(e2);
      }
      if (!this._HasAnyCreateDestroyHandler("instancedestroy")) return;
      const e = this.GetObjectClass(), s = new C32.Event("instancedestroy");
      s.instance = this.GetInterfaceClass(), s.isEndingLayout = t2, e.DispatchUserScriptEvent(s);
      for (const t3 of e.GetFamilies()) t3.DispatchUserScriptEvent(s);
      this._runtime.DispatchUserScriptEvent(s);
    }
    _GetDebuggerProperties() {
      return this._sdkInst ? this._sdkInst.GetDebuggerProperties() : this._iScriptInterface._getDebuggerProperties();
    }
    SaveToJson(t2 = "full", e = null) {
      const s = {};
      "full" === t2 ? s["uid"] = this.GetUID() : s["c3"] = true;
      const n = this.GetTagsSet();
      if (n.size > 0 && (s["tags"] = Array.from(n)), "visual-state" !== t2) {
        const e2 = savedDataMaps.get(this);
        if (e2 && e2.size && (s["ex"] = C32.ToSuperJSON(e2)), -1 !== this.GetTimeScale() && (s["mts"] = this.GetTimeScale()), this._objectType.GetInstanceVariablesCount() > 0) {
          const t3 = {}, e3 = this._objectType.GetInstanceVariableSIDs();
          for (let s2 = 0, n2 = this._instVarValues.length; s2 < n2; ++s2) t3[e3[s2].toString()] = this._instVarValues[s2];
          s["ivs"] = t3;
        }
        if (this._behaviorInstances.length) {
          const e3 = {};
          for (const s2 of this._behaviorInstances) {
            const n2 = s2.SaveToJson(t2);
            n2 && (e3[s2.GetBehaviorType().GetSID().toString()] = n2);
          }
          s["behs"] = e3;
        }
      }
      this._worldInfo && (s["w"] = this._worldInfo._SaveToJson(t2, e));
      const i = this._sdkInst ? this._sdkInst.SaveToJson() : this._iScriptInterface._saveToJson();
      return i && (s["data"] = i), s;
    }
    _OnBeforeLoad(t2 = "full", e = null) {
      this._worldInfo && this._worldInfo._OnBeforeLoad(t2);
    }
    _OnAfterLoad(t2, e = "full", s = null) {
      this._worldInfo && this._worldInfo._OnAfterLoad(t2, e, s);
    }
    _OnAfterLoad2(t2, e = "full", s = null) {
      this._worldInfo && this._worldInfo._OnAfterLoad2(t2, e, s);
    }
    _SetupSceneGraphConnectionsOnChangeOfLayout() {
      this.GetPlugin().IsWorldType() && this._worldInfo._SetupSceneGraphConnectionsOnChangeOfLayout();
    }
    LoadFromJson(t2, e = "full", s = null) {
      if ("full" === e) this._uid = t2["uid"];
      else if (!t2["c3"]) return;
      if (this._SetTagsSetFromJson(t2["tags"]), "visual-state" !== e) {
        let e2 = savedDataMaps.get(this);
        e2 && (e2.clear(), savedDataMaps.delete(this));
        const s2 = t2["ex"];
        s2 && (e2 = C32.FromSuperJSON(s2), savedDataMaps.set(this, e2)), this._timeScale = t2.hasOwnProperty("mts") ? t2["mts"] : -1;
        const n2 = t2["ivs"];
        if (n2) for (const [t3, e3] of Object.entries(n2)) {
          const s3 = parseInt(t3, 10), n3 = this._objectType.GetInstanceVariableIndexBySID(s3);
          if (n3 < 0 || n3 >= this._instVarValues.length) continue;
          let i = e3;
          null === i && (i = NaN), this._instVarValues[n3] = i;
        }
      }
      if (this.GetPlugin().IsWorldType()) {
        const n2 = t2["w"];
        if (n2) {
          const t3 = n2["l"];
          if (this._worldInfo.GetLayer().GetSID() !== t3) {
            const s2 = this._worldInfo.GetLayer(), n3 = s2.GetLayout().GetLayerBySID(t3);
            n3 ? (this._worldInfo._SetLayer(n3), s2._RemoveInstance(this, true), n3._AddInstance(this, true), n3.SetZIndicesChanged(this), this._worldInfo.SetBboxChanged()) : "full" === e && this._runtime.DestroyInstance(this);
          }
          this._worldInfo._LoadFromJson(n2, e, s);
        }
      }
      if ("visual-state" !== e) {
        const s2 = t2["behs"];
        if (s2) for (const [t3, n2] of Object.entries(s2)) {
          const s3 = parseInt(t3, 10), i = this.GetBehaviorIndexBySID(s3);
          i < 0 || i >= this._behaviorInstances.length || this._behaviorInstances[i].LoadFromJson(n2, e);
        }
      }
      const n = t2["data"];
      n && (this._sdkInst ? this._sdkInst.LoadFromJson(n, e) : this._iScriptInterface._loadFromJson(n));
    }
    MoveToLayerWithSID(t2) {
      if (this._worldInfo.GetLayer().GetSID() === t2) return;
      const e = this._worldInfo.GetLayer(), s = e.GetLayout().GetLayerBySID(t2);
      s && (this._worldInfo._SetLayer(s), e._RemoveInstance(this, true), s._AddInstance(this, true), s.SetZIndicesChanged(this), this._worldInfo.SetBboxChanged());
    }
    GetInterfaceClass() {
      return this._iScriptInterface || this._InitUserScriptInterface();
    }
    HasScriptInterface() {
      return !!this._iScriptInterface;
    }
    _InitUserScriptInterface(t2, e) {
      const s = this._worldInfo ? t2 ? self.ISDKWorldInstanceBase : self.IWorldInstance : t2 ? self.ISDKInstanceBase : self.IInstance, n = t2 || this._sdkInst.GetScriptInterfaceClass(), i = this._objectType._GetUserScriptInstanceClass(), r2 = i || n || s, a2 = this.GetPlugin().GetSdkVersion();
      if (C32.AddonManager._PushInitObject(this, a2), C32.AddonManager._PushInitProperties(e), this._iScriptInterface = new r2(), C32.AddonManager._PopInitProperties(), C32.AddonManager._PopInitObject(a2), n && !(this._iScriptInterface instanceof s)) throw new TypeError(`script interface class '${n.name}' does not extend the right base class '${s.name}'`);
      if (i) {
        const t3 = n || s;
        if (!(this._iScriptInterface instanceof t3)) throw new TypeError(`setInstanceClass(): class '${i.name}' does not extend the right base class - check it extends the right class, e.g. globalThis.InstanceType.MyObjectName`);
      }
      return this._iScriptInterface;
    }
    _GetInstVarsScriptDescriptor(t2) {
      if (0 === this._instVarValues.length) return;
      const e = {}, s = this._objectType._GetAllInstanceVariableJsPropNames();
      for (let t3 = 0, n2 = s.length; t3 < n2; ++t3) e[s[t3]] = { configurable: false, enumerable: true, get: C32.Instance.prototype._GetInstanceVariableTypedValue.bind(this, t3), set: C32.Instance.prototype.SetInstanceVariableValue.bind(this, t3) };
      const n = Object.create(Object.prototype, e);
      t2.instVars = { value: n, writable: false };
    }
    _GetBehaviorsScriptDescriptor(t2) {
      const e = this._behaviorInstances;
      if (0 === e.length) return;
      const s = {};
      for (const t3 of e) s[t3.GetBehaviorType().GetJsPropName()] = { value: t3.GetScriptInterface(), writable: false };
      const n = Object.create(Object.prototype, s);
      t2.behaviors = { value: n, writable: false };
    }
    DispatchUserScriptEvent(t2) {
      if (!this.HasScriptInterface()) return;
      const e = this.GetInterfaceClass();
      t2.instance = e;
      const s = this._runtime, n = s.IsDebug() && !s.GetEventSheetManager().IsInEventEngine();
      n && C3Debugger.StartMeasuringScriptTime(), e.dispatchEvent(t2), n && C3Debugger.AddScriptTime();
    }
  };
}
{
  const C32 = self.C3, updatedInstances = /* @__PURE__ */ new Map();
  C32.SceneGraphInfo = class extends C32.DefendedBase {
    constructor(t2) {
      super(), this._owner = t2, this._parent = null, this._children = [], this._startWidth = t2.GetWidth(), this._startHeight = t2.GetHeight(), this._startScaleX = 1, this._startScaleY = 1, this._parentStartAngle = 0, this._ownOpacity = 1, this._startOpacity = t2.GetOpacity(), this._tmpSceneGraphChildren = null, this._tmpSceneGraphChildrenIndexes = null, this._indexInParent = NaN, this._originalSizeKnown = false, this._originalWidth = NaN, this._originalHeight = NaN, this._on_instance_create = (e) => {
        if (e.instance !== this._parent.GetInstance()) return;
        t2.GetRuntime().Dispatcher().removeEventListener("instancecreate", this._on_instance_create);
        const n = this._parent.GetInstance().GetSdkInstance();
        this._originalSizeKnown = !!n.IsOriginalSizeKnown(), this._originalWidth = this._originalSizeKnown ? n.GetOriginalWidth() : NaN, this._originalHeight = this._originalSizeKnown ? n.GetOriginalHeight() : NaN;
      };
    }
    Release() {
      this._parent = null, this._tmpSceneGraphChildren = null, this._tmpSceneGraphChildrenIndexes = null, this._indexInParent = NaN, this._originalSizeKnown = false, this._originalWidth = NaN, this._originalHeight = NaN, C32.clearArray(this._children);
    }
    SetParent(t2) {
      if (this._ownOpacity = this._owner.GetOpacity(), this._startOpacity = this._ownOpacity, this._parent = t2, this._parentStartAngle = t2 ? t2.GetAngle() : 0, this._parent) {
        const t3 = this._owner.GetRuntime();
        if (this._parent.GetInstance().GetPlugin().GetSdkVersion() < 2) {
          const e = this._parent.GetInstance().GetSdkInstance();
          e ? (this._originalSizeKnown = !!e.IsOriginalSizeKnown(), this._originalWidth = this._originalSizeKnown ? e.GetOriginalWidth() : NaN, this._originalHeight = this._originalSizeKnown ? e.GetOriginalHeight() : NaN) : this._parent.GetInstance().IsDestroyed() || t3.Dispatcher().addEventListener("instancecreate", this._on_instance_create);
        } else this._originalSizeKnown = false, this._originalWidth = NaN, this._originalHeight = NaN;
      } else this._originalSizeKnown = false, this._originalWidth = NaN, this._originalHeight = NaN;
    }
    GetParent() {
      return this._parent;
    }
    HasChildren() {
      return this._children.length > 0;
    }
    GetChildren() {
      return this._children;
    }
    _MaybeSortChildren() {
      this.HasChildren() && 1 !== this._children.length && (this._tmpSceneGraphChildrenIndexes ? this._children.sort((t2, e) => {
        const n = this._tmpSceneGraphChildrenIndexes.get(t2.GetInstance()), s = this._tmpSceneGraphChildrenIndexes.get(e.GetInstance());
        return C32.IsFiniteNumber(n) && C32.IsFiniteNumber(s) ? n - s : 0;
      }) : this._children.sort((t2, e) => {
        const n = t2._GetSceneGraphInfo()._GetIndexInParent(), s = e._GetSceneGraphInfo()._GetIndexInParent();
        return C32.IsFiniteNumber(n) && C32.IsFiniteNumber(s) ? n - s : 0;
      }));
    }
    _GetIndexInParent() {
      return this._indexInParent;
    }
    GetStartScaleX() {
      return this._startScaleX;
    }
    SetStartScaleX(t2) {
      this._startScaleX = t2;
    }
    GetStartScaleY() {
      return this._startScaleY;
    }
    SetStartScaleY(t2) {
      this._startScaleY = t2;
    }
    GetStartOpacity() {
      return this._startOpacity;
    }
    GetOwnOpacity() {
      return this._ownOpacity;
    }
    SetOwnOpacity(t2) {
      this._ownOpacity = t2;
    }
    _GetStartWidth() {
      return 0 === this._startWidth ? Number.EPSILON : this._startWidth;
    }
    _GetStartHeight() {
      return 0 === this._startHeight ? Number.EPSILON : this._startHeight;
    }
    GetParentScaleX() {
      if (this._owner.GetTransformWithParentWidth()) {
        const t2 = this._parent;
        let e = t2.GetWidth(), n = t2._GetSceneGraphInfo()._GetStartWidth();
        return 0 === e && (e = Number.EPSILON), n === Number.EPSILON && e === Number.EPSILON ? 1 : n === Number.EPSILON && e !== Number.EPSILON && this._originalSizeKnown ? 1 + e / this._originalWidth : e / n;
      }
      return 1;
    }
    GetParentScaleY() {
      if (this._owner.GetTransformWithParentHeight()) {
        const t2 = this._parent;
        let e = t2.GetHeight(), n = t2._GetSceneGraphInfo()._GetStartHeight();
        return 0 === e && (e = Number.EPSILON), n === Number.EPSILON && e === Number.EPSILON ? 1 : n === Number.EPSILON && e !== Number.EPSILON && this._originalSizeKnown ? 1 + e / this._originalHeight : e / n;
      }
      return 1;
    }
    GetParentStartAngle() {
      return 0;
    }
    _SaveToJsonProperties() {
      return { "sw": this._startWidth, "sh": this._startHeight, "sx": this._startScaleX, "sy": this._startScaleY, "psa": this._parentStartAngle, "oo": this._ownOpacity, "so": this._startOpacity, "pi": this._owner.GetInstance().GetIndexInParent() };
    }
    _SaveToJson(t2, e = null) {
      const n = this._SaveToJsonProperties();
      return e && e["selfOnly"] ? Object.assign(n, { "p": null, "c": [] }) : Object.assign(n, { "p": this._GetParentJson(t2), "c": this._GetChildrenJson(t2) });
    }
    _GetFlagsString(t2) {
      let e = "";
      return t2.GetTransformWithParentX() && (e += "x"), t2.GetTransformWithParentY() && (e += "y"), t2.GetTransformWithParentWidth() && (e += "w"), t2.GetTransformWithParentHeight() && (e += "h"), t2.GetTransformWithParentAngle() && (e += "a"), t2.GetTransformWithParentZElevation() && (e += "z"), t2.GetDestroyWithParent() && (e += "d"), t2.GetTransformWithParentOpacity() && (e += "o"), t2.GetTransformWithParentVisibility() && (e += "v"), e;
    }
    _GetParentJson(t2) {
      return this._parent ? !this._parent.GetInstance() || this._parent.GetInstance().IsDestroyed() ? null : this._GetInstanceJson(this._parent, this._owner, t2) : null;
    }
    _GetChildrenJson(t2) {
      return this._children.map((e) => this._GetInstanceJson(e, e, t2)).filter((t3) => t3);
    }
    _GetInstanceJson(t2, e, n) {
      const s = t2.GetInstance();
      if (s && s.IsDestroyed()) return null;
      const i = {};
      return i["uid"] = s.GetUID(), i["f"] = this._GetFlagsString(e), i["offsets"] = e._SaveSceneGraphPropertiesToJson(), i["data"] = C32.SceneGraphInfo.GetSceneGraphInstanceDataFromInstance(s), i["oci"] = s.GetObjectClass().GetIndex(), "state" === n ? (i["inst"] = s.SaveToJson("full", { "selfOnly": true }), i["instIndex"] = NaN) : (i["instIndex"] = s.GetObjectClass().GetInstances().indexOf(s), i["inst"] = null), i;
    }
    _LoadFromJson(t2) {
      this._startWidth = t2["sw"], this._startHeight = t2["sh"], this._startScaleX = t2["sx"], this._startScaleY = t2["sy"], this._parentStartAngle = t2["psa"], this._ownOpacity = t2["oo"], this._startOpacity = t2["so"], this._indexInParent = C32.IsFiniteNumber(t2["pi"]) ? t2["pi"] : NaN;
    }
    _SetTmpSceneGraphChildren(t2, e, n, s) {
      if (!t2 && !e) {
        if (s?.setFromJson) {
          if (this._tmpSceneGraphChildren) for (const t3 of this._tmpSceneGraphChildren) t3.IsDestroyed() || t3.HasParent() || t3.GetRuntime().DestroyInstance(t3);
        } else if (this._tmpSceneGraphChildren) {
          for (const t3 of this._tmpSceneGraphChildren) if (n["c"] && n["c"].length) {
            if (!n["c"].some((e2) => e2["uid"] === t3.GetUID())) continue;
            t3.IsDestroyed() || t3.HasParent() || t3.GetRuntime().DestroyInstance(t3);
          }
        }
      }
      this._tmpSceneGraphChildren = t2, this._tmpSceneGraphChildrenIndexes = e;
    }
    _GetInstanceByUID(t2) {
      const e = this._owner.GetRuntime();
      return updatedInstances.has(t2) ? updatedInstances.get(t2) : e.GetInstanceByUID(t2);
    }
    _OnAfterLoad(t2, e) {
      const n = this._owner, s = n.GetRuntime(), i = e?.processedWorldInfo ?? /* @__PURE__ */ new Set();
      if (t2["p"] && !this._parent) {
        const a3 = t2["p"]["uid"], r3 = this._GetInstanceByUID(a3);
        if (r3) {
          const a4 = r3.GetWorldInfo();
          if (r3.HasChild(n.GetInstance())) this._parent = a4;
          else {
            r3.HasChildWithUID(n.GetInstance().GetUID()) ? (s.DestroyInstance(n.GetInstance()), s._RemoveInstanceFromUIDMap(n.GetInstance().GetUID()), updatedInstances.delete(n.GetInstance().GetUID())) : r3.AddChild(n.GetInstance(), this._GetFlagsObj(t2["p"]["f"])), i.has(n) || (n._LoadSceneGraphPropertiesFromJson(t2["p"]["offsets"]), this._LoadInstancePropertiesFromJson(r3, t2["p"], e), this._UpdateUIDInstanceMap(r3, r3.GetUID(), n.GetRuntime(), e)), i.add(n);
            r3.GetWorldInfo()._GetSceneGraphInfo()._MaybeSortChildren();
          }
        } else if (C32.IsFiniteNumber(t2["p"]["oci"])) {
          const i2 = s.CreateInstance(s.GetObjectClassByIndex(t2["p"]["oci"]), n.GetLayer(), 0, 0, true);
          if (i2) {
            const a4 = this._GetInstanceData(t2["p"], s);
            a4 && i2.LoadFromJson(a4);
            const r4 = i2.GetWorldInfo(), h2 = !!e?.setFromJson;
            r4.GetLayer().SortAndAddInstancesByZIndex(i2, false, h2), i2.AddChild(n.GetInstance(), this._GetFlagsObj(t2["p"]["f"])), updatedInstances.set(i2.GetUID(), i2), this._UpdateUIDInstanceMap(i2, i2.GetUID(), s, e);
            i2.GetWorldInfo()._GetSceneGraphInfo()._MaybeSortChildren();
          }
        }
      }
      const a2 = [];
      for (const e2 of t2["c"]) {
        const t3 = e2["uid"], n2 = this._GetInstanceByUID(t3);
        n2 && a2.push(n2);
      }
      let r2 = 0;
      for (const h2 of t2["c"]) {
        const c2 = h2["uid"], o2 = this._GetInstanceByUID(c2);
        if (o2) {
          if (this._tmpSceneGraphChildren) {
            if (this._tmpSceneGraphChildren.includes(o2)) {
              const s3 = o2;
              if (s3.GetObjectClass() !== o2.GetObjectClass()) {
                r2++;
                continue;
              }
              if (s3.IsDestroyed()) {
                r2++;
                continue;
              }
              const h3 = t2["c"][r2];
              if (!e?.setFromJson && this._HasAllChildrenOfType(s3, a2, n)) {
                if (n.GetInstance().GetChildAt(r2)) {
                  const a3 = s3.GetObjectClass().GetIndex(), c3 = h3["oci"], o3 = n.GetInstance().GetChildAt(r2).GetObjectClass().GetIndex();
                  if (a3 !== c3 || c3 !== o3) {
                    this._RefreshAllChildren(t2["c"], n, i, e);
                    break;
                  }
                  this._UpdateInstance(r2, h3, n, i, e);
                } else this._UpdateInstance(r2, h3, n, i, e);
                r2++;
                continue;
              }
              if (s3.HasParent() && s3.GetParent() !== n.GetInstance()) {
                const t3 = this._CreateNewChildInstance(h3, e);
                this._AddAndSetChildInstance(t3, h3, i, e), r2++;
                continue;
              }
              this._AddAndSetChildInstance(s3.GetWorldInfo(), h3, i, e, true), r2++;
              continue;
            }
            if (this._tmpSceneGraphChildren[r2]) {
              const s3 = this._tmpSceneGraphChildren[r2];
              if (s3.GetObjectClass() !== o2.GetObjectClass()) {
                r2++;
                continue;
              }
              if (s3.IsDestroyed()) {
                r2++;
                continue;
              }
              const h3 = t2["c"][r2];
              if (!e?.setFromJson && this._HasAllChildrenOfType(s3, a2, n)) {
                if (n.GetInstance().GetChildAt(r2)) {
                  const a3 = s3.GetObjectClass().GetIndex(), c3 = h3["oci"], o3 = n.GetInstance().GetChildAt(r2).GetObjectClass().GetIndex();
                  if (a3 !== c3 || c3 !== o3) {
                    this._RefreshAllChildren(t2["c"], n, i, e);
                    break;
                  }
                  this._UpdateInstance(r2, h3, n, i, e);
                } else this._UpdateInstance(r2, h3, n, i, e);
                r2++;
                continue;
              }
              if (s3.HasParent() && s3.GetParent() !== n.GetInstance()) {
                const t3 = this._CreateNewChildInstance(h3, e);
                this._AddAndSetChildInstance(t3, h3, i, e), r2++;
                continue;
              }
              this._AddAndSetChildInstance(s3.GetWorldInfo(), h3, i, e, true), r2++;
              continue;
            }
          }
          const s2 = o2.GetObjectClass();
          if (this._GetInstancesOfObjectClassCount(a2, s2) === n.GetInstance().GetChildrenOfObjectClass(s2).length) {
            for (const t3 of n.GetInstance().GetChildren()) {
              if (t3.GetObjectClass() !== s2) continue;
              const n2 = t3.GetWorldInfo();
              if (n2 && !i.has(n2)) {
                i.add(n2), n2._LoadSceneGraphPropertiesFromJson(h2["offsets"]), this._LoadInstancePropertiesFromJson(t3, h2, e);
                break;
              }
            }
            r2++;
            continue;
          }
          if (o2.HasParent() && o2.GetParent() !== n.GetInstance()) {
            const t3 = this._CreateNewChildInstance(h2, e);
            this._AddAndSetChildInstance(t3, h2, i, e), r2++;
            continue;
          }
          this._AddAndSetChildInstance(o2.GetWorldInfo(), h2, i, e);
        } else if (this._tmpSceneGraphChildren && this._tmpSceneGraphChildren[r2]) {
          const c3 = this._tmpSceneGraphChildren[r2], o3 = s.GetObjectClassByIndex(this._GetObjectClassIndex(h2));
          if (c3.GetObjectClass() !== o3) {
            r2++;
            continue;
          }
          if (c3.IsDestroyed()) {
            r2++;
            continue;
          }
          const d2 = t2["c"][r2];
          if (!e?.setFromJson && this._HasAllChildrenOfType(c3, a2, n)) {
            if (n.GetInstance().GetChildAt(r2)) {
              const s2 = c3.GetObjectClass().GetIndex(), a3 = d2["oci"], h3 = n.GetInstance().GetChildAt(r2).GetObjectClass().GetIndex();
              if (s2 !== a3 || a3 !== h3) {
                this._RefreshAllChildren(t2["c"], n, i, e);
                break;
              }
              this._UpdateInstance(r2, d2, n, i, e);
            } else this._UpdateInstance(r2, d2, n, i, e);
            r2++;
            continue;
          }
          if (c3.HasParent() && c3.GetParent() !== n.GetInstance()) {
            const t3 = this._CreateNewChildInstance(d2, e);
            this._AddAndSetChildInstance(t3, d2, i, e), r2++;
            continue;
          }
          this._AddAndSetChildInstance(c3.GetWorldInfo(), d2, i, e);
        } else {
          const t3 = this._CreateNewChildInstance(h2, e);
          this._AddAndSetChildInstance(t3, h2, i, e);
        }
        r2++;
      }
    }
    _RefreshAllChildren(t2, e, n, s) {
      const i = e.GetRuntime();
      for (const t3 of e.GetInstance().children()) t3 && !t3.IsDestroyed() && (i.DestroyInstance(t3), i._RemoveInstanceFromUIDMap(t3.GetUID()), updatedInstances.delete(t3.GetUID()));
      this._tmpSceneGraphChildren && (this._tmpSceneGraphChildren = []), this._tmpSceneGraphChildrenIndexes && (this._tmpSceneGraphChildrenIndexes = /* @__PURE__ */ new WeakMap());
      Object.assign({}, s, { "assignZIndex": false });
      for (const e2 of t2) {
        const t3 = this._CreateNewChildInstance(e2, s);
        this._AddAndSetChildInstance(t3, e2, n, s), this._tmpSceneGraphChildren.push(t3.GetInstance()), this._tmpSceneGraphChildrenIndexes.set(t3.GetInstance(), this._tmpSceneGraphChildren.length - 1);
      }
      e._GetSceneGraphInfo()._MaybeSortChildren();
    }
    _HasAllChildrenOfType(t2, e, n) {
      const s = t2.GetObjectClass();
      return this._GetInstancesOfObjectClassCount(e, s) === n.GetInstance().GetChildrenOfObjectClass(s).length;
    }
    _UpdateInstance(t2, e, n, s, i) {
      const a2 = n.GetInstance().GetChildAt(t2);
      if (!a2) return;
      const r2 = a2.GetWorldInfo();
      r2 && (s.has(r2) || (r2._LoadSceneGraphPropertiesFromJson(e["offsets"]), this._LoadInstancePropertiesFromJson(a2, e, i)), s.add(r2));
    }
    _GetFlagsObj(t2) {
      const e = {};
      return e.transformX = t2.includes("x"), e.transformY = t2.includes("y"), e.transformWidth = t2.includes("w"), e.transformHeight = t2.includes("h"), e.transformAngle = t2.includes("a"), e.transformZElevation = t2.includes("z"), e.destroyWithParent = t2.includes("d"), e.transformOpacity = t2.includes("o"), e.transformVisibility = t2.includes("v"), e;
    }
    _GetObjectClassIndex(t2) {
      return C32.IsFiniteNumber(t2["oci"]) ? t2["oci"] : t2[1];
    }
    _CreateNewChildInstance(t2, e) {
      if (!C32.IsFiniteNumber(t2["oci"])) return;
      const n = this._owner, s = n.GetRuntime();
      let i;
      const a2 = !e.hasOwnProperty("createHierarchy") || e["createHierarchy"];
      if (i = t2["data"] ? s.CreateInstanceFromData(t2["data"], n.GetLayer(), false, 0, 0, false, a2) : s.CreateInstance(s.GetObjectClassByIndex(t2["oci"]), n.GetLayer(), 0, 0, a2), !i) return;
      const r2 = this._GetInstanceData(t2, s);
      r2 && i.LoadFromJson(r2);
      const h2 = i.GetWorldInfo(), c2 = !!e?.setFromJson;
      return h2.GetLayer().SortAndAddInstancesByZIndex(i, true, c2), h2;
    }
    _UpdateUIDInstanceMap(t2, e, n, s) {
      if (this._GetInstanceByUID(e) && !s?.setFromJson) {
        const s2 = this._GetInstanceByUID(e);
        s2 !== t2 && n.DestroyInstance(s2);
      }
      n._RemoveInstanceFromUIDMap(e), n._MapInstanceByUID(e, t2);
    }
    _AddAndSetChildInstance(t2, e, n, s, i = true) {
      const a2 = this._owner, r2 = a2.AddChild(t2, this._GetFlagsObj(e["f"]));
      r2 && i ? (n.has(t2) || (t2._LoadSceneGraphPropertiesFromJson(e["offsets"]), this._LoadInstancePropertiesFromJson(t2.GetInstance(), e, s)), n.add(t2)) : r2 && (updatedInstances.set(t2.GetInstance().GetUID(), t2.GetInstance()), this._UpdateUIDInstanceMap(t2.GetInstance(), e["uid"], a2.GetRuntime(), s)), this._MaybeSortChildren();
    }
    _LoadInstancePropertiesFromJson(t2, e, n) {
      let s = this._GetInstanceData(e, this._owner.GetRuntime());
      if (!s) return;
      const i = !n.hasOwnProperty("clearChildren") || n["clearChildren"], a2 = !n.hasOwnProperty("assignZIndex") || n["assignZIndex"], r2 = t2.GetRuntime();
      if (updatedInstances.set(t2.GetUID(), t2), s = JSON.parse(JSON.stringify(s)), i && t2.GetUID() !== s["uid"]) {
        for (const e2 of t2.children()) e2 && !e2.IsDestroyed() && (r2.DestroyInstance(e2), r2._RemoveInstanceFromUIDMap(e2.GetUID()), updatedInstances.delete(e2.GetUID()));
        if (s["w"]?.["sgi"] && s["w"]["sgi"]["c"]?.length) for (const e2 of s["w"]["sgi"]["c"]) {
          const s2 = Object.assign({}, n, { "clearChildren": false, "createHierarchy": false }), i2 = this._CreateNewChildInstance(e2, s2);
          updatedInstances.set(i2.GetInstance().GetUID(), i2.GetInstance()), t2.AddChild(i2.GetInstance(), this._GetFlagsObj(e2["f"])), i2._LoadSceneGraphPropertiesFromJson(e2["offsets"]), this._LoadInstancePropertiesFromJson(i2.GetInstance(), e2, s2);
        }
      }
      const h2 = s["w"]?.["zi"], c2 = s["w"]?.["l"];
      s["w"] = null, t2.LoadFromJson(s), n?.setFromJson || (C32.IsFiniteNumber(h2) && a2 && t2.GetWorldInfo()._SetZIndex(h2), C32.IsFiniteNumber(c2) && t2.MoveToLayerWithSID(c2)), this._UpdateUIDInstanceMap(t2, s["uid"], r2, n);
    }
    _GetInstancesOfObjectClassCount(t2, e) {
      return t2.filter((t3) => t3.GetObjectClass().GetName() === e.GetName()).length;
    }
    _GetInstanceData(t2, e) {
      if (C32.IsFiniteNumber(t2["instIndex"])) {
        const n = e.GetObjectClassByIndex(t2["oci"])._GetLoadInstancesJson();
        return n ? n[t2["instIndex"]] : null;
      }
      return C32.IsString(t2["inst"]) ? JSON.parse(t2["inst"]) : t2["inst"] ? t2["inst"] : void 0;
    }
    static GetSceneGraphInstanceDataFromInstance(t2) {
      let e = t2.GetWorldInfo().GetLayer().GetInitialInstanceData(t2.GetUID());
      if (!e) return null;
      e = JSON.parse(JSON.stringify(e));
      const n = [];
      for (const e2 of [...t2.GetChildren()]) {
        const t3 = e2.GetWorldInfo();
        n.push([t3.GetLayout().GetSID(), t3.GetLayer().GetIndex(), e2.GetUID(), C32.SceneGraphInfo._GetFlagsNumber(t3), e2.GetObjectClass().IsInContainer() ? 1 : 0, t3.GetZIndex(), C32.SceneGraphInfo.GetSceneGraphInstanceDataFromInstance(e2)]);
      }
      return C32.IsArray(e[0][14]) ? e[0][14][1] = n : (e[0][14] = [], e[0][14][0] = C32.SceneGraphInfo._GetDefaultFlagsNumber(), e[0][14][1] = n, e[0][14][2] = t2.GetWorldInfo().GetZIndex()), e;
    }
    static _GetFlagsNumber(t2) {
      let e = 0;
      return e |= Number(t2.GetTransformWithParentVisibility()) << 8, e |= Number(t2.GetTransformWithParentOpacity()) << 7, e |= Number(t2.GetTransformWithParentZElevation()) << 6, e |= Number(t2.GetDestroyWithParent()) << 5, e |= Number(t2.GetTransformWithParentAngle()) << 4, e |= Number(t2.GetTransformWithParentHeight()) << 3, e |= Number(t2.GetTransformWithParentWidth()) << 2, e |= Number(t2.GetTransformWithParentY()) << 1, e |= Number(t2.GetTransformWithParentX()) | 0, e;
    }
    static _GetDefaultFlagsNumber(t2) {
      let e = 0;
      return e |= 256, e |= 128, e |= 64, e |= 32, e |= 16, e |= 8, e |= 4, e |= 2, e |= 1, 511;
    }
    static ClearUpdatedInstances() {
      updatedInstances.clear();
    }
  };
}
{
  const C32 = self.C3, glMatrix = self.glMatrix, vec3 = glMatrix.vec3, vec4 = glMatrix.vec4, tempRect = C32.New(C32.Rect), tempQuad = C32.New(C32.Quad), bboxChangeEvent = C32.New(C32.Event, "bboxchange", false), tempColor = C32.New(C32.Color, 0, 0, 0, 0), tempCollisionPoly = C32.New(C32.CollisionPoly), DEFAULT_COLOR = C32.New(C32.Color, 1, 1, 1, 1), DEFAULT_RENDER_CELLS = C32.New(C32.Rect, 0, 0, -1, -1), DEFAULT_COLLISION_CELLS = C32.New(C32.Rect, 0, 0, -1, -1), VALID_SET_MESH_POINT_MODES = /* @__PURE__ */ new Set(["absolute", "relative"]), EMPTY_ARRAY = [];
  let enableUpdateRendererStateGroup = true;
  const FLAG_IS_VISIBLE = 1, FLAG_BBOX_CHANGED = 2, FLAG_ENABLE_BBOX_CHANGED_EVENT = 4, FLAG_COLLISION_ENABLED = 8, FLAG_COLLISION_CELL_CHANGED = 16, FLAG_SOLID_FILTER_INCLUSIVE = 32, FLAG_HAS_ANY_ACTIVE_EFFECT = 64, FLAG_IS_ROTATABLE = 128, FLAG_DESTROYED = 256, FLAG_DESTROY_WITH_PARENT = 512, FLAG_TRANSFORM_WITH_PARENT_X = 1024, FLAG_TRANSFORM_WITH_PARENT_Y = 2048, FLAG_TRANSFORM_WITH_PARENT_W = 4096, FLAG_TRANSFORM_WITH_PARENT_H = 8192, FLAG_TRANSFORM_WITH_PARENT_A = 16384, FLAG_TRANSFORM_WITH_PARENT_Z_ELEVATION = 32768, FLAG_TRANSFORM_WITH_PARENT_OPACITY = 1 << 22, FLAG_TRANSFORM_WITH_PARENT_VISIBILITY = 1 << 23, MASK_ALL_SCENE_GRAPH_FLAGS = 12647936, FLAG_MESH_CHANGED = 65536, FLAG_PHYSICS_BODY_CHANGED = 1 << 17, FLAG_SIN_COS_ANGLE_CHANGED = 1 << 18, FLAG_USE_POINTS_SHADER_PROGRAM = 1 << 19, FLAG_DRAW_BACK_FACE_ONLY = 1 << 20, FLAG_DRAW_NON_BACK_FACES_ONLY = 1 << 21, FLAG_ENABLE_BACK_FACE_CULLING = 1 << 24, FLAG_BLEND_MODE_BIT_OFFSET = 26, FLAG_BLEND_MODE_MASK = 31 << 26, sceneGraphExportDataMap = /* @__PURE__ */ new WeakMap(), sceneGraphZIndexMap = /* @__PURE__ */ new WeakMap();
  C32.WorldInfo = class extends C32.DefendedBase {
    constructor(t2, e) {
      super(), this._inst = t2, this._objectClass = t2.GetObjectClass(), this._runtime = t2.GetRuntime(), this._layer = e, this._objectClass._OnWorldInstanceLayerChanged(this, null, e), this._zIndex = -1, this._htmlZIndex = -1, this._flags = 196635, this._objectClass.GetPlugin().IsRotatable() && (this._flags |= 128), this._x = NaN, this._y = NaN, this._zElevation = NaN, this._w = NaN, this._h = NaN, this._depth = NaN, this._a = NaN, this._sinA = NaN, this._cosA = NaN, this._ox = NaN, this._oy = NaN, this._boundingBox = C32.New(C32.Rect), this._boundingQuad = C32.New(C32.Quad), this._collisionCells = DEFAULT_COLLISION_CELLS, this._renderCells = DEFAULT_RENDER_CELLS, this._sourceCollisionPoly = null, this._transformedPolyInfo = null, this._solidFilterTags = null, this._color = DEFAULT_COLOR, this._colorPremultiplied = DEFAULT_COLOR, this._stateGroup = null, this._instanceEffectList = null, this._inst.GetObjectClass().UsesEffects() && (this._instanceEffectList = C32.New(C32.InstanceEffectList, this._inst, this)), this._sceneGraphInfo = null, this._tmpSceneGraphChildren = null, this._tmpSceneGraphChildrenIndexes = null, this._tmpHierarchyPosition = -1, this._meshInfo = null;
    }
    _MarkDestroyed() {
      this._flags |= 256;
    }
    Release() {
      if (this._objectClass._OnWorldInstanceLayerChanged(this, this._layer, null), this._stateGroup && (this._runtime.GetRenderer().ReleaseStateGroup(this._stateGroup), this._stateGroup = null), this._sourceCollisionPoly = null, this._transformedPolyInfo && (this._transformedPolyInfo.poly.Release(), this._transformedPolyInfo = null), this._solidFilterTags && (this._solidFilterTags.clear(), this._solidFilterTags = null), this.ReleaseMesh(), this._instanceEffectList && this._instanceEffectList.Release(), this.HasParent() && this.GetParent().RemoveChild(this), this.HasChildren()) {
        const t2 = [...this.GetChildren()];
        for (const e of t2) this.RemoveChild(e);
      }
      this._ReleaseSceneGraphInfo(), this._ReleaseTmpSceneGraphInfo(), sceneGraphExportDataMap.delete(this), sceneGraphZIndexMap.delete(this), this._inst = null, this._objectClass = null, this._runtime = null, this._layer = null;
    }
    Init(t2) {
      if (enableUpdateRendererStateGroup = false, this.SetXY(t2[0], t2[1]), this.SetZElevation(t2[2]), this.SetSize(t2[3], t2[4]), this._depth = 0, this.IsRotatable() ? this.SetAngle(t2[6]) : this._a = 0, tempColor.setFromJSON(t2[7]), this._SetColor(tempColor), this.SetOriginX(t2[8]), this.SetOriginY(t2[9]), this.SetBlendMode(t2[10]), this._instanceEffectList && this._instanceEffectList._LoadEffectParameters(t2[12]), t2[14] && sceneGraphExportDataMap.set(this, { childrenData: t2[14][1], zIndexData: t2[14][2] }), t2[15]) {
        const e = t2[15];
        this.CreateMesh(e[0], e[1]);
        const s = this.GetSourceMesh(), i = e[2];
        for (let t3 = 0, e2 = i.length; t3 < e2; ++t3) {
          const e3 = i[t3];
          for (let i2 = 0, n = e3.length; i2 < n; ++i2) {
            const n2 = e3[i2], r2 = s.GetMeshPointAt(i2, t3);
            r2.SetX(n2[0]), r2.SetY(n2[1]), r2.SetZElevation(n2[2]), r2.SetU(n2[3]), r2.SetV(n2[4]);
          }
        }
      }
      if (t2[16]) {
        const e = t2[16][0], s = t2[16][1], i = !!s, n = !i, r2 = this._runtime.GetTemplateManager();
        i && r2 && r2.MapInstanceToTemplateName(this.GetInstance(), s), n && r2 && r2.MapInstanceToTemplateName(this.GetInstance(), e);
      }
      enableUpdateRendererStateGroup = true, this._UpdateRendererStateGroup();
    }
    InitNoData() {
      this._x = 0, this._y = 0, this._zElevation = 0, this._w = 0, this._h = 0, this._depth = 0, this._a = 0, this._sinA = 0, this._cosA = 1, this._ox = 0, this._oy = 0, this._UpdateRendererStateGroup();
    }
    GetRuntime() {
      return this._runtime;
    }
    GetObjectClass() {
      return this._objectClass;
    }
    GetInstance() {
      return this._inst;
    }
    _GetParentOffsetAngle() {
      return this.GetTransformWithParentAngle() ? this._MaybeReflectAngleForMirrorFlip(this.GetParent()._GetAngleNoReflect() - this._sceneGraphInfo.GetParentStartAngle()) : 0;
    }
    SetX(t2) {
      if (t2 = +t2, this.GetTransformWithParentX()) {
        const e = this._sceneGraphInfo, s = t2 - this.GetX(), i = -this._GetParentOffsetAngle();
        0 === i ? this._x += s / e.GetParentScaleX() : (this._x += Math.cos(i) * s / e.GetParentScaleX(), this.GetTransformWithParentY() && (this._y += Math.sin(i) * s / e.GetParentScaleY()));
      } else this._x = t2;
    }
    OffsetX(t2, e = false) {
      t2 = +t2, e ? this._x += t2 : this.GetTransformWithParentX() ? this.SetX(this.GetX() + t2) : this._x += t2;
    }
    GetX() {
      if (this.GetTransformWithParentX()) {
        let t2 = this._x;
        const e = this._sceneGraphInfo, s = this.GetParent(), i = this._GetParentOffsetAngle();
        return 0 === i ? t2 *= e.GetParentScaleX() : (t2 = t2 * e.GetParentScaleX() * Math.cos(i), this.GetTransformWithParentY() && (t2 -= this._y * e.GetParentScaleY() * Math.sin(i))), s.GetX() + t2;
      }
      return this._x;
    }
    SetY(t2) {
      if (t2 = +t2, this.GetTransformWithParentY()) {
        const e = this._sceneGraphInfo, s = t2 - this.GetY(), i = -this._GetParentOffsetAngle();
        0 === i ? this._y += s / e.GetParentScaleY() : (this.GetTransformWithParentX() && (this._x -= Math.sin(i) * s / e.GetParentScaleX()), this._y += Math.cos(i) * s / e.GetParentScaleY());
      } else this._y = t2;
    }
    OffsetY(t2, e = false) {
      t2 = +t2, e ? this._y += t2 : this.GetTransformWithParentY() ? this.SetY(this.GetY() + t2) : this._y += t2;
    }
    GetY() {
      if (this.GetTransformWithParentY()) {
        let t2 = this._y;
        const e = this._sceneGraphInfo, s = this.GetParent(), i = this._GetParentOffsetAngle();
        return 0 === i ? t2 *= e.GetParentScaleY() : (t2 = t2 * e.GetParentScaleY() * Math.cos(i), this.GetTransformWithParentX() && (t2 += this._x * e.GetParentScaleX() * Math.sin(i))), s.GetY() + t2;
      }
      return this._y;
    }
    SetXY(t2, e) {
      if (t2 = +t2, e = +e, this.GetTransformWithParentXOrY()) {
        const s = this.GetTransformWithParentX(), i = this.GetTransformWithParentY(), n = this._sceneGraphInfo, r2 = t2 - this.GetX(), h2 = e - this.GetY(), a2 = -this._GetParentOffsetAngle();
        if (0 === a2) s ? this._x += r2 / n.GetParentScaleX() : this._x = t2, i ? this._y += h2 / n.GetParentScaleY() : this._y = e;
        else {
          const o2 = Math.sin(a2), l = Math.cos(a2);
          s ? this._x += i ? (l * r2 - o2 * h2) / n.GetParentScaleX() : l * r2 / n.GetParentScaleX() : this._x = t2, i ? this._y += s ? (o2 * r2 + l * h2) / n.GetParentScaleY() : l * h2 / n.GetParentScaleY() : this._y = e;
        }
      } else this._x = t2, this._y = e;
    }
    GetXY() {
      return [this.GetX(), this.GetY()];
    }
    OffsetXY(t2, e) {
      t2 = +t2, e = +e, this.GetTransformWithParentXOrY() ? this.SetXY(this.GetX() + t2, this.GetY() + e) : (this._x += t2, this._y += e);
    }
    EqualsXY(t2, e) {
      return this.GetX() === t2 && this.GetY() === e;
    }
    SetZElevation(t2) {
      if (t2 = +t2, this.GetTransformWithParentZElevation() && (t2 -= this.GetParent().GetZElevation()), this._zElevation === t2) return;
      this._zElevation = t2, this._UpdateZElevation();
      const e = this.GetLayer();
      0 !== this._zElevation && e._SetAnyInstanceZElevated(), e.SetZIndicesChanged(this);
    }
    _UpdateZElevation() {
      if (this._UpdateRendererStateGroup(), this.HasChildren()) {
        const t2 = this.GetChildren();
        for (let e = 0, s = t2.length; e < s; e++) {
          const s2 = t2[e];
          s2.GetTransformWithParentZElevation() && s2._UpdateZElevation();
        }
      }
    }
    OffsetZElevation(t2) {
      this.SetZElevation(this.GetZElevation() + t2);
    }
    GetZElevation() {
      return this.GetTransformWithParentZElevation() ? this.GetParent().GetZElevation() + this._zElevation : this._zElevation;
    }
    GetTotalZElevation() {
      return this.GetLayer().GetZElevation() + this.GetZElevation();
    }
    IsOriginalSizeKnown() {
      return this.GetInstance().GetPlugin().GetSdkVersion() < 2 && this.GetInstance().GetSdkInstance().IsOriginalSizeKnown();
    }
    SetWidth(t2) {
      if (t2 = +t2, this.GetTransformWithParentWidth()) {
        const e = this.GetWidth();
        0 === e ? this._w = Number.EPSILON : this._w *= t2 / e;
      } else this._w = t2;
      this._MarkSinCosAngleChanged();
    }
    OffsetWidth(t2, e) {
      t2 = +t2, e ? this._w += t2 : this.GetTransformWithParentWidth() ? this.SetWidth(this.GetWidth() + t2) : this._w += t2, this._MarkSinCosAngleChanged();
    }
    GetWidth() {
      if (this.GetTransformWithParentWidth()) {
        const t2 = this.GetParent(), e = t2.GetWidth();
        return t2._GetSceneGraphInfo()._GetStartWidth() === Number.EPSILON ? (this._GetSceneGraphInfo()._GetStartWidth() + e) * this._w : e * this._w;
      }
      return this._w;
    }
    SetHeight(t2) {
      if (t2 = +t2, this.GetTransformWithParentHeight()) {
        const e = this.GetHeight();
        0 === e ? this._h = Number.EPSILON : this._h *= t2 / e;
      } else this._h = t2;
      this._MarkSinCosAngleChanged();
    }
    OffsetHeight(t2, e) {
      t2 = +t2, e ? this._h += t2 : this.GetTransformWithParentHeight() ? this.SetHeight(this.GetHeight() + t2) : this._h += t2, this._MarkSinCosAngleChanged();
    }
    GetHeight() {
      if (this.GetTransformWithParentHeight()) {
        const t2 = this.GetParent(), e = t2.GetHeight();
        return t2._GetSceneGraphInfo()._GetStartHeight() === Number.EPSILON ? (this._GetSceneGraphInfo()._GetStartHeight() + e) * this._h : e * this._h;
      }
      return this._h;
    }
    SetSize(t2, e) {
      if (t2 = +t2, e = +e, this.GetTransformWithParentWidth()) {
        const e2 = this.GetWidth();
        0 === e2 ? this._w = Number.EPSILON : this._w *= t2 / e2;
      } else this._w = t2;
      if (this.GetTransformWithParentHeight()) {
        const t3 = this.GetHeight();
        0 === t3 ? this._h = Number.EPSILON : this._h *= e / t3;
      } else this._h = e;
      this._MarkSinCosAngleChanged();
    }
    GetSize() {
      return [this.GetWidth(), this.GetHeight()];
    }
    GetDepth() {
      return this._depth;
    }
    SetDepth(t2) {
      if (t2 < 0) throw new RangeError("invalid depth");
      this._depth = t2;
    }
    GetSceneGraphScale() {
      if (this.HasParent()) {
        const t2 = this._sceneGraphInfo;
        return Math.min(t2.GetParentScaleX(), t2.GetParentScaleY());
      }
      return 1;
    }
    IsRotatable() {
      return !!(128 & this._flags);
    }
    SetAngle(t2) {
      t2 = +t2, this.IsRotatable() && (this.GetTransformWithParentAngle() && (t2 -= this.GetParent().GetAngle()), t2 = C32.clampAngle(t2), this._a !== t2 && (this._a = t2, this._MarkSinCosAngleChanged()));
    }
    OffsetAngle(t2) {
      0 !== (t2 = +t2) && this.IsRotatable() && (this._a = C32.clampAngle(this._a + t2), this._MarkSinCosAngleChanged());
    }
    _MarkSinCosAngleChanged() {
      if (this._flags |= 262144, this.HasChildren()) {
        const t2 = this.GetChildren();
        for (let e = 0, s = t2.length; e < s; e++) t2[e]._MarkSinCosAngleChanged();
      }
    }
    GetAngle() {
      return this.GetTransformWithParentAngle() && this.IsRotatable() ? this._MaybeReflectAngleForMirrorFlip(C32.clampAngle(this.GetParent()._GetAngleNoReflect() + this._a)) : this._a;
    }
    _GetAngleNoReflect() {
      return this.GetTransformWithParentAngle() && this.IsRotatable() ? C32.clampAngle(this.GetParent()._GetAngleNoReflect() + this._a) : this._a;
    }
    _MaybeReflectAngleForMirrorFlip(t2) {
      return this.GetTransformWithParentWidth() && this.GetTopParent().GetWidth() < 0 && (t2 = C32.clampAngle(C32.angleReflect(t2, this.GetTopParent().GetAngle() + Math.PI))), this.GetTransformWithParentHeight() && this.GetTopParent().GetHeight() < 0 && (t2 = C32.angleReflect(t2, this.GetTopParent().GetAngle())), t2;
    }
    _NeedsReflectAngleForMirrorOrFlip() {
      const t2 = this.GetParent();
      return !!(this.GetTransformWithParentWidth() && t2.GetWidth() < 0) || !!(this.GetTransformWithParentHeight() && t2.GetHeight() < 0);
    }
    _NeedsReflectAngleForMirrorAndFlip() {
      const t2 = this.GetParent();
      return !!(this.GetTransformWithParentWidth() && t2.GetWidth() < 0 && this.GetTransformWithParentHeight() && t2.GetHeight() < 0);
    }
    _MaybeUpdateSinCosAngle() {
      const t2 = this._flags;
      if (!(262144 & t2)) return;
      const e = this.GetAngle();
      this._sinA = Math.sin(e), this._cosA = Math.cos(e), this._flags = -262145 & t2;
    }
    GetSinAngle() {
      return this._MaybeUpdateSinCosAngle(), this._sinA;
    }
    GetCosAngle() {
      return this._MaybeUpdateSinCosAngle(), this._cosA;
    }
    SetOriginX(t2) {
      this._ox = +t2;
    }
    OffsetOriginX(t2) {
      this._ox += +t2;
    }
    GetOriginX() {
      return this._ox;
    }
    SetOriginY(t2) {
      this._oy = +t2;
    }
    OffsetOriginY(t2) {
      this._oy += +t2;
    }
    GetOriginY() {
      return this._oy;
    }
    _SetColor(t2) {
      this._color.equals(t2) || (this._color === DEFAULT_COLOR ? (this._color = C32.New(C32.Color, t2), this._colorPremultiplied = C32.New(C32.Color, t2), this._colorPremultiplied.premultiply()) : t2.equalsRgba(1, 1, 1, 1) ? (this._color = DEFAULT_COLOR, this._colorPremultiplied = DEFAULT_COLOR) : (this._color.set(t2), this._colorPremultiplied.set(t2), this._colorPremultiplied.premultiply()), this._UpdateRendererStateGroup());
    }
    SetOpacity(t2) {
      if (t2 = C32.clamp(+t2, 0, 1), this.GetTransformWithParentOpacity()) {
        if (this._GetSceneGraphInfo().GetOwnOpacity() === t2) return;
        this._GetSceneGraphInfo().SetOwnOpacity(t2), t2 = this.GetOpacity();
      } else if (this._color.a === t2) return;
      this._SetColorWithOpacity(t2);
    }
    _SetOpacityOfChildren() {
      if (!this.HasChildren()) return;
      const t2 = this.GetChildren();
      for (let e = 0, s = t2.length; e < s; e++) {
        const s2 = t2[e];
        s2._SetColorWithOpacity(s2.GetOpacity());
      }
    }
    _SetColorWithOpacity(t2) {
      tempColor.copyRgb(this._color), tempColor.a = t2, this._SetColor(tempColor), this._SetOpacityOfChildren();
    }
    OffsetOpacity(t2) {
      this.GetTransformWithParentOpacity() ? this.SetOpacity(this._GetSceneGraphInfo().GetOwnOpacity() + t2) : this.SetOpacity(this.GetOpacity() + t2);
    }
    GetOpacity() {
      return this.GetTransformWithParentOpacity() ? this.GetParent().GetOpacity() * this._GetSceneGraphInfo().GetOwnOpacity() : this._color.a;
    }
    SetUnpremultipliedColor(t2) {
      this._color.equalsIgnoringAlpha(t2) || (tempColor.copyRgb(t2), tempColor.a = this.GetOpacity(), this._SetColor(tempColor));
    }
    SetUnpremultipliedColorRGB(t2, e, s) {
      tempColor.setRgb(t2, e, s), this.SetUnpremultipliedColor(tempColor);
    }
    OffsetUnpremultipliedColorRGB(t2, e, s) {
      0 === t2 && 0 === e && 0 === s || (tempColor.copyRgb(this._color), tempColor.r += t2, tempColor.g += e, tempColor.b += s, this.SetUnpremultipliedColor(tempColor));
    }
    GetUnpremultipliedColor() {
      return this._color;
    }
    GetPremultipliedColor() {
      return this._colorPremultiplied;
    }
    GetDestroyWithParent() {
      return !!(512 & this._flags);
    }
    SetDestroyWithParent(t2) {
      this._SetFlag(512, t2);
    }
    GetTransformWithParentX() {
      return !!(1024 & this._flags);
    }
    SetTransformWithParentX(t2) {
      this._SetFlag(1024, t2);
    }
    GetTransformWithParentY() {
      return !!(2048 & this._flags);
    }
    GetTransformWithParentXOrY() {
      return !!(3072 & this._flags);
    }
    SetTransformWithParentY(t2) {
      this._SetFlag(2048, t2);
    }
    GetTransformWithParentWidth() {
      return !!(4096 & this._flags);
    }
    SetTransformWithParentWidth(t2) {
      this._SetFlag(4096, t2);
    }
    GetTransformWithParentHeight() {
      return !!(8192 & this._flags);
    }
    SetTransformWithParentHeight(t2) {
      this._SetFlag(8192, t2);
    }
    GetTransformWithParentAngle() {
      return !!(16384 & this._flags);
    }
    SetTransformWithParentAngle(t2) {
      this._SetFlag(16384, t2);
    }
    GetTransformWithParentZElevation() {
      return !!(32768 & this._flags);
    }
    SetTransformWithParentZElevation(t2) {
      this._SetFlag(32768, t2);
    }
    GetTransformWithParentOpacity() {
      return !!(4194304 & this._flags);
    }
    SetTransformWithParentOpacity(t2) {
      this._SetFlag(4194304, t2);
    }
    GetTransformWithParentVisibility() {
      return !!(8388608 & this._flags);
    }
    SetTransformWithParentVisibility(t2) {
      this._SetFlag(8388608, t2);
    }
    _ClearAllSceneGraphFlags() {
      this._flags &= -12647937;
    }
    AddChild(t2, e) {
      if (t2 === this) return false;
      if (t2.HasParent()) return false;
      if (this._HasChildRecursive(t2)) return false;
      if (this._HasAnyParent(t2)) return false;
      const s = t2.GetX(), i = t2.GetY(), n = t2.GetWidth(), r2 = t2.GetHeight(), h2 = t2.GetAngle(), a2 = t2.GetZElevation(), o2 = t2.GetOpacity();
      t2._SetParent(this), t2.SetTransformWithParentX(e.transformX), t2.SetTransformWithParentY(e.transformY), t2.SetTransformWithParentWidth(e.transformWidth), t2.SetTransformWithParentHeight(e.transformHeight), t2.SetTransformWithParentAngle(e.transformAngle), t2.SetTransformWithParentZElevation(e.transformZElevation), t2.SetTransformWithParentOpacity(e.transformOpacity), t2.SetTransformWithParentVisibility(e.transformVisibility), t2.SetDestroyWithParent(e.destroyWithParent);
      const l = s - this.GetX(), _2 = i - this.GetY(), G = -this.GetAngle(), c2 = Math.cos(G), d2 = Math.sin(G);
      if (e.transformX && (e.transformAngle ? t2._x = l * c2 - _2 * d2 : t2._x = l, e.transformWidth)) {
        const e2 = this.GetWidth() / this._sceneGraphInfo._GetStartWidth();
        0 !== e2 && (t2._x /= e2);
      }
      if (e.transformY && (e.transformAngle ? t2._y = l * d2 + _2 * c2 : t2._y = _2, e.transformHeight)) {
        const e2 = this.GetHeight() / this._sceneGraphInfo._GetStartHeight();
        0 !== e2 && (t2._y /= e2);
      }
      if (e.transformWidth) {
        const e2 = this.GetWidth();
        0 === e2 || e2 === Number.EPSILON ? (t2._w = 1, t2._sceneGraphInfo.SetStartScaleX(1)) : (t2._w = n / this.GetWidth(), t2._sceneGraphInfo.SetStartScaleX(t2._w));
      }
      if (e.transformHeight) {
        const e2 = this.GetHeight();
        0 === e2 || e2 === Number.EPSILON ? (t2._h = 1, t2._sceneGraphInfo.SetStartScaleY(1)) : (t2._h = r2 / this.GetHeight(), t2._sceneGraphInfo.SetStartScaleY(t2._h));
      }
      return e.transformAngle && (t2._a = h2 - this.GetAngle()), e.transformZElevation && (t2._zElevation = a2 - this.GetZElevation()), e.transformOpacity && t2._sceneGraphInfo.SetOwnOpacity(o2), e.transformVisibility && t2.SetVisible(this.IsVisible()), this._AddChildToSceneGraphInfo(t2), this.SetBboxChanged(), this._SetOpacityOfChildren(), true;
    }
    RemoveChild(t2) {
      if (t2.GetParent() !== this) return;
      const e = t2.GetX(), s = t2.GetY(), i = t2.GetWidth(), n = t2.GetHeight(), r2 = t2.GetAngle(), h2 = t2.GetZElevation(), a2 = t2.GetOpacity();
      t2._SetParent(null), t2._ClearAllSceneGraphFlags(), t2.SetXY(e, s), t2.SetSize(i, n), t2.SetAngle(r2), t2.SetZElevation(h2), t2.SetOpacity(a2), this._RemoveChildFromSceneGraphInfo(t2), this.SetBboxChanged();
    }
    GetTmpHierarchyPosition() {
      return this._tmpHierarchyPosition;
    }
    _ResetAllSceneGraphState() {
      this._BuildTmpSceneGraphData();
      const t2 = [...this.children()];
      for (const e2 of t2) this.RemoveChild(e2);
      const e = this.GetParent();
      e && e.RemoveChild(this), this._ClearAllSceneGraphFlags();
    }
    _BuildTmpSceneGraphData() {
      if (this._SetTmpHierarchyPosition(), !this._tmpSceneGraphChildren) {
        const t3 = [...this.children()];
        t3.length && (this._tmpSceneGraphChildren = [], this._tmpSceneGraphChildrenIndexes = /* @__PURE__ */ new WeakMap());
        let e = 0;
        for (const s of t3) {
          const t4 = s.GetInstance();
          this._tmpSceneGraphChildren.push(t4), this._tmpSceneGraphChildrenIndexes.set(t4, e), e++;
        }
      }
      const t2 = this.GetParent();
      t2 && t2._BuildTmpSceneGraphData();
    }
    _SetTmpHierarchyPosition() {
      if (-1 !== this._tmpHierarchyPosition) return;
      const t2 = [...this.parents()];
      this._tmpHierarchyPosition = t2.length;
      for (const e2 of t2) e2._SetTmpHierarchyPosition();
      const e = [...this.children()];
      for (const t3 of e) t3._SetTmpHierarchyPosition();
    }
    _ReleaseTmpSceneGraphInfo() {
      this._tmpSceneGraphChildren && (this._tmpSceneGraphChildren.length = 0), this._tmpSceneGraphChildren = null, this._tmpSceneGraphChildrenIndexes = null;
      const t2 = this.GetParent();
      t2 && t2._ReleaseTmpSceneGraphInfo(), this._tmpHierarchyPosition = -1;
    }
    HasParent() {
      return null !== this.GetParent();
    }
    GetParent() {
      const t2 = this._sceneGraphInfo;
      return null !== t2 ? t2.GetParent() : null;
    }
    GetTopParent() {
      let t2 = this;
      for (; t2.HasParent(); ) t2 = t2.GetParent();
      return t2;
    }
    *parents() {
      let t2 = this.GetParent();
      for (; t2; ) yield t2, t2 = t2.GetParent();
    }
    HasChild(t2) {
      return this.GetChildren().includes(t2);
    }
    HasChildren() {
      const t2 = this._sceneGraphInfo;
      return null !== t2 && t2.HasChildren();
    }
    GetChildren() {
      const t2 = this._sceneGraphInfo;
      return null !== t2 ? t2.GetChildren() : EMPTY_ARRAY;
    }
    children() {
      return this.GetChildren();
    }
    *allChildren() {
      for (const t2 of this.children()) yield t2, yield* t2.allChildren();
    }
    GetChildCount() {
      return this.GetChildren().length;
    }
    GetAllChildCount() {
      return [...this.allChildren()].length;
    }
    GetChildAt(t2) {
      const e = this.GetChildren();
      return (t2 = Math.floor(+t2)) < 0 || t2 >= e.length ? null : e[t2];
    }
    GetChildIndex(t2) {
      if (!t2) return NaN;
      const e = this.GetChildren();
      if (!e) return NaN;
      for (let s = 0; s < e.length; s++) if (t2 === e[s]) return s;
      return NaN;
    }
    _CreateSceneGraphInfo(t2) {
      this._sceneGraphInfo || (this._sceneGraphInfo = C32.New(C32.SceneGraphInfo, this)), t2 && this._sceneGraphInfo.SetParent(t2);
    }
    _GetSceneGraphInfo() {
      return this._sceneGraphInfo;
    }
    _ReleaseSceneGraphInfo() {
      this._sceneGraphInfo && (this._sceneGraphInfo.Release(), this._sceneGraphInfo = null);
    }
    _SetParent(t2) {
      t2 ? (t2._CreateSceneGraphInfo(null), this._CreateSceneGraphInfo(t2)) : (this._sceneGraphInfo && this._sceneGraphInfo.SetParent(null), this.HasChildren() || this._ReleaseSceneGraphInfo());
    }
    _HasAnyParent(t2) {
      if (!this.HasParent()) return false;
      const e = this.GetParent();
      return e === t2 || e._HasAnyParent(t2);
    }
    _HasChildRecursive(t2) {
      if (this.HasChild(t2)) return true;
      for (const e of this.GetChildren()) if (e._HasChildRecursive(t2)) return true;
      return false;
    }
    _AddChildToSceneGraphInfo(t2) {
      this._sceneGraphInfo.GetChildren().push(t2);
    }
    _RemoveChildFromSceneGraphInfo(t2) {
      const e = this._sceneGraphInfo.GetChildren(), s = e.indexOf(t2);
      -1 !== s && e.splice(s, 1), 0 !== e.length || this.HasParent() || this._ReleaseSceneGraphInfo(), t2.HasChildren() || t2._ReleaseSceneGraphInfo();
    }
    GetSceneGraphChildrenExportData() {
      const t2 = sceneGraphExportDataMap.get(this);
      return t2 ? t2.childrenData : null;
    }
    GetSceneGraphZIndexExportData() {
      const t2 = sceneGraphExportDataMap.get(this);
      return t2 ? t2.zIndexData : NaN;
    }
    GetSceneGraphZIndex() {
      const t2 = sceneGraphZIndexMap.get(this);
      return C32.IsFiniteNumber(t2) ? t2 : NaN;
    }
    SetSceneGraphZIndex(t2) {
      sceneGraphZIndexMap.set(this, t2);
    }
    SetUsePointsShaderProgram() {
      this._SetFlag(524288, true), this._UpdateRendererStateGroup();
    }
    _UpdateRendererStateGroup() {
      if (!enableUpdateRendererStateGroup) return;
      const t2 = this._runtime.GetRenderer();
      let e;
      this._stateGroup && t2.ReleaseStateGroup(this._stateGroup), e = 524288 & this._flags ? t2.GetPointsRenderingProgram() || "<point>" : t2.GetTextureFillShaderProgram() || "<default>", this._stateGroup = t2.AcquireStateGroup(e, this.GetBlendMode(), this._colorPremultiplied, this.GetZElevation(), this.IsBackFaceCulling() ? 1 : 0, 0);
    }
    GetRendererStateGroup() {
      return this._stateGroup;
    }
    HasDefaultColor() {
      return this._color === DEFAULT_COLOR;
    }
    SetBlendMode(t2) {
      if ((t2 |= 0) < 0 || t2 > 31) throw new RangeError("invalid blend mode");
      this.GetBlendMode() !== t2 && (this._flags = -2080374785 & this._flags | t2 << 26, this._UpdateRendererStateGroup());
    }
    GetBlendMode() {
      return (2080374784 & this._flags) >> 26;
    }
    _SetLayer(t2, e) {
      const s = e && this._layer !== t2;
      s && this._RemoveFromRenderCells(), this._objectClass._OnWorldInstanceLayerChanged(this, this._layer, t2), this._layer = t2, s && this._UpdateRenderCell(), 0 !== this.GetZElevation() && this._layer._SetAnyInstanceZElevated();
    }
    GetLayer() {
      return this._layer;
    }
    GetLayout() {
      return this.GetLayer().GetLayout();
    }
    _SetZIndex(t2) {
      this._zIndex = 0 | t2;
    }
    GetZIndex() {
      return this._layer._UpdateZIndices(), this._zIndex;
    }
    _SetHTMLZIndex(t2) {
      this._htmlZIndex = 0 | t2;
    }
    GetHTMLZIndex() {
      return this._layer._UpdateHTMLZIndices(), this._htmlZIndex;
    }
    _GetLastCachedZIndex() {
      return this._zIndex;
    }
    _SetFlag(t2, e) {
      e ? this._flags |= t2 : this._flags &= ~t2;
    }
    IsVisible() {
      return !!(1 & this._flags);
    }
    SetVisible(t2) {
      if (this._SetFlag(1, t2), this.HasChildren()) for (const e of this.GetChildren()) e.GetTransformWithParentVisibility() && e.SetVisible(t2);
    }
    IsCollisionEnabled() {
      return !!(8 & this._flags);
    }
    SetCollisionEnabled(t2) {
      t2 = !!t2, this.IsCollisionEnabled() !== t2 && (this._SetFlag(8, t2), t2 ? this.SetBboxChanged() : this._RemoveFromCollisionCells());
    }
    SetSolidCollisionFilter(t2, e) {
      if (this._SetFlag(32, t2), this._solidFilterTags && this._solidFilterTags.clear(), e.trim()) {
        this._solidFilterTags || (this._solidFilterTags = /* @__PURE__ */ new Set());
        for (const t3 of e.split(" ")) t3 && this._solidFilterTags.add(t3.toLowerCase());
      } else this._solidFilterTags = null;
    }
    IsSolidCollisionAllowed(t2) {
      const e = !!(32 & this._flags), s = this._solidFilterTags;
      if (!t2 || !s) return !e;
      for (const i of s) if (t2.has(i)) return e;
      return !e;
    }
    SetBboxChanged() {
      if (this._flags |= 65554, this._objectClass._SetAnyCollisionCellChanged(true), this._runtime.UpdateRender(), this._layer.UsesRenderCells() && (this.CalculateBbox(this._boundingBox, this._boundingQuad, true), this._flags &= -3, this._UpdateRenderCell()), 4 & this._flags && this._inst.Dispatcher().dispatchEvent(bboxChangeEvent), null !== this._sceneGraphInfo) {
        const t2 = this._sceneGraphInfo.GetChildren();
        for (let e = 0, s = t2.length; e < s; ++e) t2[e].SetBboxChanged();
      }
    }
    CalculateBbox(t2, e, s) {
      const i = this.GetX(), n = this.GetY(), r2 = this.GetWidth(), h2 = this.GetHeight(), a2 = this.GetAngle();
      t2.setWH(i - this._ox * r2, n - this._oy * h2, r2, h2), s && this.HasMesh() && this._ExpandBboxForMesh(t2), 0 === a2 ? e.setFromRect(t2) : (t2.offset(-i, -n), e.setFromRotatedRectPrecalc(t2, this.GetSinAngle(), this.GetCosAngle()), e.offset(i, n), e.getBoundingBox(t2)), t2.normalize();
    }
    _UpdateBbox() {
      const t2 = this._flags;
      2 & t2 && (this.CalculateBbox(this._boundingBox, this._boundingQuad, true), this._flags = -3 & t2);
    }
    GetBoundingBox() {
      return this._UpdateBbox(), this._boundingBox;
    }
    GetBoundingQuad() {
      return this._UpdateBbox(), this._boundingQuad;
    }
    PixelRoundQuad(t2) {
      const e = this.GetX(), s = this.GetY(), i = Math.round(e) - e, n = Math.round(s) - s;
      return 0 === i && 0 === n ? t2 : (tempQuad.copy(t2), tempQuad.offset(i, n), tempQuad);
    }
    OverwriteBoundingBox(t2) {
      this._boundingBox.copy(t2), this._boundingQuad.setFromRect(this._boundingBox), this._flags &= -3, this._UpdateCollisionCell(), this._UpdateRenderCell();
    }
    SetBboxChangeEventEnabled(t2) {
      this._SetFlag(4, t2);
    }
    IsBboxChangeEventEnabled() {
      return !!(4 & this._flags);
    }
    IsInViewport(t2, e, s) {
      return e && 0 !== this.GetDepth() ? this.IsInViewport3D(this.GetLayer()._GetViewFrustum()) : 0 === this.GetZElevation() || s ? t2.intersectsRect(this.GetBoundingBox()) : this._IsInViewport_ZElevated();
    }
    _IsInViewport_ZElevated() {
      const t2 = this.GetLayer(), e = this.GetTotalZElevation();
      return !(e >= t2.Get2DCameraZ()) && (t2.GetViewportForZ(e, tempRect), tempRect.intersectsRect(this.GetBoundingBox()));
    }
    IsInViewport3D(t2) {
      const e = this.GetBoundingBox(), s = e.getLeft(), i = e.getRight(), n = e.getTop(), r2 = e.getBottom(), h2 = this.GetTotalZElevation(), a2 = h2 + this.GetDepth();
      return t2.ContainsAABB(s, n, h2, i, r2, a2);
    }
    IsInViewport2() {
      const t2 = this.GetLayer();
      if (t2.Has3DCamera()) return this.IsInViewport3D(t2._GetViewFrustum());
      {
        const e = t2.GetLayout();
        return this.IsInViewport(t2.GetViewport(), e.HasVanishingPointOutsideViewport(), e.IsOrthographicProjection());
      }
    }
    _SetDrawBackFaceOnly(t2) {
      this._SetFlag(1048576, t2);
    }
    _SetDrawNonBackFacesOnly(t2) {
      this._SetFlag(2097152, t2);
    }
    IsDrawBackFaceOnly() {
      return !!(1048576 & this._flags);
    }
    IsDrawNonBackFacesOnly() {
      return !!(2097152 & this._flags);
    }
    SetBackFaceCulling(t2) {
      (t2 = !!t2) !== this.IsBackFaceCulling() && (this._SetFlag(16777216, t2), this._UpdateRendererStateGroup());
    }
    IsBackFaceCulling() {
      return !!(16777216 & this._flags);
    }
    SetSourceCollisionPoly(t2) {
      this._sourceCollisionPoly = t2, this._DiscardTransformedCollisionPoly(), this.HasMesh() && (this._meshInfo.meshPoly = null);
    }
    GetSourceCollisionPoly() {
      return this._sourceCollisionPoly;
    }
    HasOwnCollisionPoly() {
      return null !== this._sourceCollisionPoly || this.HasMesh();
    }
    GetTransformedCollisionPoly() {
      return this._GetCustomTransformedCollisionPolyPrecalc(this.GetWidth(), this.GetHeight(), this.GetAngle(), this.GetSinAngle(), this.GetCosAngle());
    }
    GetCustomTransformedCollisionPoly(t2, e, s) {
      let i = 0, n = 1;
      return 0 !== s && (i = Math.sin(s), n = Math.cos(s)), this._GetCustomTransformedCollisionPolyPrecalc(t2, e, s, i, n);
    }
    _GetCustomTransformedCollisionPolyPrecalc(t2, e, s, i, n) {
      let r2 = this._transformedPolyInfo;
      null === r2 && (r2 = { poly: C32.New(C32.CollisionPoly), width: NaN, height: NaN, angle: NaN }, this._transformedPolyInfo = r2);
      const h2 = r2.poly;
      if (r2.width === t2 && r2.height === e && r2.angle === s) return h2;
      const a2 = this._sourceCollisionPoly;
      if (this.HasMesh()) {
        const s2 = this.GetOriginX(), r3 = this.GetOriginY(), o2 = this.GetSourceMesh();
        let l = this._meshInfo.meshPoly;
        l || (a2 ? (tempCollisionPoly.copy(a2), tempCollisionPoly.offset(s2, r3)) : tempCollisionPoly.setDefaultPoints(), l = o2.InsertPolyMeshVertices(tempCollisionPoly), this._meshInfo.meshPoly = l), o2.TransformCollisionPoly(l, h2), h2.offset(-s2, -r3), h2.transformPrecalc(t2, e, i, n);
      } else a2 ? (h2.copy(a2), h2.transformPrecalc(t2, e, i, n)) : h2.setFromQuad(this.GetBoundingQuad(), -this.GetX(), -this.GetY());
      return r2.width = t2, r2.height = e, r2.angle = s, h2;
    }
    _DiscardTransformedCollisionPoly() {
      this.SetPhysicsBodyChanged(true);
      const t2 = this._transformedPolyInfo;
      null !== t2 && (t2.width = NaN);
    }
    CreateMesh(t2, e) {
      if (t2 = Math.floor(t2), e = Math.floor(e), !this.GetInstance().GetPlugin().SupportsMesh()) throw new Error("object does not support mesh");
      this.ReleaseMesh(), this._meshInfo = { sourceMesh: C32.New(C32.Gfx.Mesh, t2, e), transformedMesh: C32.New(C32.Gfx.Mesh, t2, e), meshPoly: null };
    }
    HasMesh() {
      return null !== this._meshInfo;
    }
    GetSourceMesh() {
      if (!this.HasMesh()) throw new Error("no mesh");
      return this._meshInfo.sourceMesh;
    }
    GetTransformedMesh() {
      if (!this.HasMesh()) throw new Error("no mesh");
      return this._meshInfo.transformedMesh;
    }
    SetMeshChanged(t2) {
      this._SetFlag(65536, t2);
    }
    IsMeshChanged() {
      return !!(65536 & this._flags);
    }
    SetPhysicsBodyChanged(t2) {
      this._SetFlag(131072, t2);
    }
    IsPhysicsBodyChanged() {
      return !!(131072 & this._flags);
    }
    _ExpandBboxForMesh(t2) {
      const e = this._meshInfo.sourceMesh, s = Math.min(e.GetMinX(), 0), i = Math.min(e.GetMinY(), 0), n = Math.max(e.GetMaxX(), 1), r2 = Math.max(e.GetMaxY(), 1), h2 = t2.width(), a2 = t2.height();
      t2.offsetLeft(s * h2), t2.offsetTop(i * a2), t2.offsetRight((n - 1) * h2), t2.offsetBottom((r2 - 1) * a2), this._depth = e.GetMaxZ();
    }
    ReleaseMesh() {
      this._meshInfo && (this._meshInfo.sourceMesh.Release(), this._meshInfo.transformedMesh.Release(), this._meshInfo = null, this._DiscardTransformedCollisionPoly());
    }
    SetMeshPoint(t2, e, s) {
      t2 = Math.floor(t2), e = Math.floor(e);
      const i = s.mode || "absolute";
      if (!VALID_SET_MESH_POINT_MODES.has(i)) throw new Error("invalid mode");
      const n = "relative" === i;
      let r2 = s.x, h2 = s.y;
      const a2 = s.zElevation;
      let o2 = "number" == typeof s.u ? s.u : n ? 0 : -1, l = "number" == typeof s.v ? s.v : n ? 0 : -1;
      if (!this.HasMesh()) return false;
      const _2 = this.GetSourceMesh(), G = _2.GetMeshPointAt(t2, e);
      if (null === G) return false;
      let c2 = false;
      return "number" == typeof a2 && G.GetZElevation() !== a2 && (G.SetZElevation(a2), c2 = true), n && (r2 += t2 / (_2.GetHSize() - 1), h2 += e / (_2.GetVSize() - 1)), -1 !== o2 || n ? (n && (o2 += t2 / (_2.GetHSize() - 1)), o2 = C32.clamp(o2, 0, 1)) : o2 = G.GetU(), -1 !== l || n ? (n && (l += e / (_2.GetVSize() - 1)), l = C32.clamp(l, 0, 1)) : l = G.GetV(), G.GetX() === r2 && G.GetY() === h2 && G.GetU() === o2 && G.GetV() === l ? c2 : (G.SetX(r2), G.SetY(h2), G.SetU(o2), G.SetV(l), this._DiscardTransformedCollisionPoly(), true);
    }
    HasTilemap() {
      return this._inst.HasTilemap();
    }
    ContainsPoint(t2, e) {
      return !!this.GetBoundingBox().containsPoint(t2, e) && (!!this.GetBoundingQuad().containsPoint(t2, e) && (this.HasTilemap() ? this._inst.GetSdkInstance().TestPointOverlapTile(t2, e) : !this.HasOwnCollisionPoly() || this.GetTransformedCollisionPoly().containsPoint(t2 - this.GetX(), e - this.GetY())));
    }
    _IsCollisionCellChanged() {
      return !!(16 & this._flags);
    }
    _UpdateCollisionCell() {
      if (!this._IsCollisionCellChanged() || !this.IsCollisionEnabled() || 256 & this._flags) return;
      const t2 = this.GetBoundingBox(), e = this._objectClass._GetCollisionCellGrid(), s = this._collisionCells;
      if (tempRect.set(e.XToCell(t2.getLeft()), e.YToCell(t2.getTop()), e.XToCell(t2.getRight()), e.YToCell(t2.getBottom())), s.equals(tempRect)) return;
      const i = this._inst;
      s === DEFAULT_COLLISION_CELLS ? (e.Update(i, null, tempRect), this._collisionCells = C32.New(C32.Rect, tempRect)) : (e.Update(i, s, tempRect), s.copy(tempRect)), this._flags &= -17;
    }
    _SetCollisionCellChanged() {
      this._flags |= 16;
    }
    _RemoveFromCollisionCells() {
      const t2 = this._collisionCells;
      t2 !== DEFAULT_COLLISION_CELLS && (this._objectClass._GetCollisionCellGrid().Update(this._inst, t2, null), this._collisionCells = DEFAULT_COLLISION_CELLS);
    }
    _UpdateRenderCell() {
      const t2 = this.GetLayer();
      if (!t2.UsesRenderCells() || 256 & this._flags) return;
      const e = t2.GetRenderGrid(), s = this.GetBoundingBox(), i = this._renderCells;
      if (tempRect.set(e.XToCell(s.getLeft()), e.YToCell(s.getTop()), e.XToCell(s.getRight()), e.YToCell(s.getBottom())), i.equals(tempRect)) return;
      const n = this._inst;
      i === DEFAULT_RENDER_CELLS ? (e.Update(n, null, tempRect), this._renderCells = C32.New(C32.Rect, tempRect)) : (e.Update(n, i, tempRect), i.copy(tempRect)), t2.SetRenderListStale();
    }
    _RemoveFromRenderCells() {
      const t2 = this._renderCells;
      t2 !== DEFAULT_RENDER_CELLS && (this.GetLayer().GetRenderGrid().Update(this._inst, t2, null), this._renderCells = DEFAULT_RENDER_CELLS);
    }
    GetRenderCellRange() {
      return this._renderCells;
    }
    ZOrderMoveToTop() {
      const t2 = this._inst, e = this._layer, s = e._GetInstances();
      s.length && s.at(-1) === t2 || (e._RemoveInstance(t2, false), e._AddInstance(t2, false), this._runtime.UpdateRender());
    }
    ZOrderMoveToBottom() {
      const t2 = this._inst, e = this._layer, s = e._GetInstances();
      s.length && s[0] === t2 || (e._RemoveInstance(t2, false), e._PrependInstance(t2, false), this._runtime.UpdateRender());
    }
    ZOrderMoveToLayer(t2) {
      const e = this._inst, s = this._layer;
      if (s.GetLayout() !== t2.GetLayout()) throw new Error("layer from different layout");
      t2 !== s && (s._RemoveInstance(e, true), this._SetLayer(t2), t2._AddInstance(e, true), this._runtime.UpdateRender());
    }
    ZOrderMoveAdjacentToInstance(t2, e) {
      const s = this._inst;
      let i = false;
      const n = this._layer;
      if (t2.GetUID() === s.GetUID()) return;
      const r2 = t2.GetWorldInfo();
      if (!r2) throw new Error("expected world instance");
      const h2 = r2.GetLayer();
      n.GetIndex() !== h2.GetIndex() && (n._RemoveInstance(s, true), this._SetLayer(h2), h2._AddInstance(s, true), i = true);
      const a2 = h2.MoveInstanceAdjacent(s, t2, !!e);
      (i || a2) && this._runtime.UpdateRender();
    }
    GetInstanceEffectList() {
      return this._instanceEffectList;
    }
    _SetHasAnyActiveEffect(t2) {
      this._SetFlag(64, t2);
    }
    HasAnyActiveEffect() {
      return !!(64 & this._flags);
    }
    _SaveToJson(t2, e = null) {
      const s = { "x": this.GetX(), "y": this.GetY(), "w": this.GetWidth(), "h": this.GetHeight(), "l": this.GetLayer().GetSID(), "zi": this.GetZIndex() };
      0 !== this.GetZElevation() && (s["ze"] = this.GetZElevation()), 0 !== this.GetAngle() && (s["a"] = this._GetAngleNoReflect()), this.HasDefaultColor() || (s["c"] = this._color.toJSON()), 0.5 !== this.GetOriginX() && (s["oX"] = this.GetOriginX()), 0.5 !== this.GetOriginY() && (s["oY"] = this.GetOriginY()), 0 !== this.GetBlendMode() && (s["bm"] = this.GetBlendMode()), this.IsVisible() || (s["v"] = this.IsVisible()), this.IsCollisionEnabled() || (s["ce"] = this.IsCollisionEnabled()), this.IsBboxChangeEventEnabled() && (s["be"] = this.IsBboxChangeEventEnabled()), this._instanceEffectList && (s["fx"] = this._instanceEffectList._SaveToJson());
      const i = !!(32 & this._flags);
      return i && (s["sfi"] = i), this._solidFilterTags && (s["sft"] = [...this._solidFilterTags].join(" ")), this._sceneGraphInfo && "visual-state" !== t2 && (s["sgi"] = this._sceneGraphInfo._SaveToJson(t2, e), sceneGraphExportDataMap.has(this) && (s["sgcd"] = sceneGraphExportDataMap.get(this).childrenData, s["sgzid"] = sceneGraphExportDataMap.get(this).zIndexData)), this.HasMesh() && (s["mesh"] = this.GetSourceMesh().SaveToJson()), s;
    }
    _SaveSceneGraphPropertiesToJson() {
      return { "x": this._x, "y": this._y, "z": this._zElevation, "w": this._w, "h": this._h, "a": this._a, "sgi": this._GetSceneGraphInfo() ? this._GetSceneGraphInfo()._SaveToJsonProperties() : null };
    }
    _LoadSceneGraphPropertiesFromJson(t2) {
      t2 && (this._x = t2["x"], this._y = t2["y"], this._zElevation = t2["z"], this._w = t2["w"], this._h = t2["h"], this._a = t2["a"], t2["sgi"] && this._GetSceneGraphInfo() && this._GetSceneGraphInfo()._LoadFromJson(t2["sgi"]), this._MarkSinCosAngleChanged(), this.SetBboxChanged());
    }
    _SetupSceneGraphConnectionsOnChangeOfLayout() {
      this._ReleaseTmpSceneGraphInfo(), this._ResetAllSceneGraphState(), this._CreateSceneGraphInfo(null), this._sceneGraphInfo && this._sceneGraphInfo._SetTmpSceneGraphChildren(this._tmpSceneGraphChildren, this._tmpSceneGraphChildrenIndexes);
    }
    _OnBeforeLoad(t2) {
      "visual-state" !== t2 && this._ResetAllSceneGraphState();
    }
    _OnAfterLoad(t2, e = "full", s = null) {
      if (t2.hasOwnProperty("sgi") && "visual-state" !== e) {
        if (256 & this._flags) return;
        this._sceneGraphInfo._OnAfterLoad(t2["sgi"], s);
      }
    }
    _OnAfterLoad2(t2, e = "full", s = null) {
      if ("visual-state" !== e) if (256 & this._flags) this._ReleaseTmpSceneGraphInfo();
      else {
        if (t2.hasOwnProperty("sgi")) this._sceneGraphInfo._SetTmpSceneGraphChildren(null, null, t2["sgi"], s);
        else if (s?.setFromJson && this._tmpSceneGraphChildren) for (const t3 of this._tmpSceneGraphChildren) t3.IsDestroyed() || this._runtime.DestroyInstance(t3);
        this._ReleaseTmpSceneGraphInfo(), this.SetBboxChanged();
      }
    }
    _LoadFromJson(t2, e, s = null) {
      if (enableUpdateRendererStateGroup = false, this.SetX(t2["x"]), this.SetY(t2["y"]), this.SetWidth(t2["w"]), this.SetHeight(t2["h"]), this._SetZIndex(t2["zi"]), this.SetZElevation(t2.hasOwnProperty("ze") ? t2["ze"] : 0), this.SetAngle(t2.hasOwnProperty("a") ? t2["a"] : 0), t2.hasOwnProperty("c") ? tempColor.setFromJSON(t2["c"]) : t2.hasOwnProperty("o") ? (tempColor.copyRgb(this._color), tempColor.a = t2["o"]) : tempColor.setRgba(1, 1, 1, 1), this._SetColor(tempColor), this.SetOriginX(t2.hasOwnProperty("oX") ? t2["oX"] : 0.5), this.SetOriginY(t2.hasOwnProperty("oY") ? t2["oY"] : 0.5), this.SetBlendMode(t2.hasOwnProperty("bm") ? t2["bm"] : 0), this.SetVisible(!t2.hasOwnProperty("v") || t2["v"]), this.SetCollisionEnabled(!t2.hasOwnProperty("ce") || t2["ce"]), this.SetBboxChangeEventEnabled(!!t2.hasOwnProperty("be") && t2["be"]), this.SetSolidCollisionFilter(!!t2.hasOwnProperty("sfi") && t2["sfi"], t2.hasOwnProperty("sft") ? t2["sft"] : ""), this._instanceEffectList && t2.hasOwnProperty("fx") && this._instanceEffectList._LoadFromJson(t2["fx"]), t2.hasOwnProperty("sgi") && "visual-state" !== e) {
        this._CreateSceneGraphInfo(null);
        const e2 = this._sceneGraphInfo, s2 = t2["sgi"];
        e2._LoadFromJson(s2), e2._SetTmpSceneGraphChildren(this._tmpSceneGraphChildren, this._tmpSceneGraphChildrenIndexes), this._SetSceneGraphExportData(t2["sgcd"], t2["sgzid"]);
      }
      if (t2.hasOwnProperty("mesh")) {
        const e2 = t2["mesh"];
        this.CreateMesh(e2["cols"], e2["rows"]), this.GetSourceMesh().LoadFromJson(e2);
      } else this.ReleaseMesh();
      this.SetBboxChanged(), enableUpdateRendererStateGroup = true, this._UpdateRendererStateGroup(), "visual-state" !== e && this._runtime.AddInstanceNeedingAfterLoad(this.GetInstance(), t2);
    }
    _SetSceneGraphExportData(t2, e) {
      t2 && C32.IsFiniteNumber(e) && sceneGraphExportDataMap.set(this, { childrenData: t2, zIndexData: e });
    }
  };
}
{
  const C32 = self.C3;
  C32.BehaviorType = class extends C32.DefendedBase {
    constructor(e, t2) {
      super();
      const s = e.GetRuntime(), i = s.GetObjectReference(t2[1]);
      s.GetAddonManager()._DelayCreateBehavior(i), this._runtime = s, this._objectClass = e, this._behavior = C32.AddonManager.GetBehaviorByConstructorFunction(i), this._sdkType = null, this._iBehaviorType = null, this._instSdkCtor = i.Instance, this._sid = t2[2], this._name = t2[0], this._jsPropName = this._runtime.GetJsPropName(t2[3]);
      const r2 = this._behavior.GetSdkVersion();
      if (r2 < 2 && (this._sdkType = C32.New(i.Type, this), !(this._sdkType instanceof C32.SDKBehaviorTypeBase))) throw new Error("v1 sdk type must derive from SDKBehaviorBase");
      if (C32.AddonManager._PushInitObject(this, r2), r2 >= 2) {
        const e2 = i.Type ?? globalThis.ISDKBehaviorTypeBase;
        if (this._iBehaviorType = new e2(), !(this._iBehaviorType instanceof globalThis.ISDKBehaviorTypeBase)) throw new Error("script interface class must derive from ISDKBehaviorTypeBase");
      } else this._iBehaviorType = new globalThis.IBehaviorType();
      C32.AddonManager._PopInitObject(r2), this.OnCreate();
    }
    static Create(e, t2) {
      return C32.New(C32.BehaviorType, e, t2);
    }
    Release() {
      this._runtime = null, this._behavior = null, this._sdkType && (this._sdkType.Release(), this._sdkType = null), this._instSdkCtor = null;
    }
    GetSdkType() {
      return this._sdkType;
    }
    OnCreate() {
      this._sdkType ? this._sdkType.OnCreate() : this._iBehaviorType && this._iBehaviorType._onCreate();
    }
    GetRuntime() {
      return this._runtime;
    }
    GetObjectClass() {
      return this._objectClass;
    }
    GetBehavior() {
      return this._behavior;
    }
    GetInstanceSdkCtor() {
      return this._instSdkCtor;
    }
    GetName() {
      return this._name;
    }
    GetSID() {
      return this._sid;
    }
    GetIBehaviorType() {
      return this._iBehaviorType;
    }
    GetJsPropName() {
      return this._jsPropName;
    }
  };
}
{
  const C32 = self.C3, IBehaviorInstance = self.IBehaviorInstance;
  C32.BehaviorInstance = class extends C32.DefendedBase {
    constructor(t2) {
      super(), this._runtime = t2.runtime, this._behaviorType = t2.behaviorType, this._behavior = this._behaviorType.GetBehavior(), this._inst = t2.instance, this._index = t2.index, this._sdkInst = null, this._iScriptInterface = null, this._behavior._AddInstance(this._inst);
    }
    Release() {
      this._iScriptInterface && (this._iScriptInterface._release(), this._iScriptInterface = null), this._behavior._RemoveInstance(this._inst), this._sdkInst && (this._sdkInst.Release(), this._sdkInst = null), this._runtime = null, this._behaviorType = null, this._behavior = null, this._inst = null;
    }
    _CreateSdkInstance(t2) {
      if (this._sdkInst) throw new Error("already got sdk instance");
      if (this.GetBehavior().GetSdkVersion() < 2) {
        if (this._sdkInst = C32.New(this._behaviorType.GetInstanceSdkCtor(), this, t2), !(this._sdkInst instanceof C32.SDKBehaviorInstanceBase)) throw new Error("v1 sdk type must derive from SDKBehaviorInstanceBase");
      } else {
        const e = this.GetBehavior().GetScriptInterfaceClass();
        this._InitScriptInterface(e.Instance, t2);
      }
    }
    GetSdkInstance() {
      return this._sdkInst ?? this._iScriptInterface;
    }
    GetObjectInstance() {
      return this._inst;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetBehaviorType() {
      return this._behaviorType;
    }
    GetBehavior() {
      return this._behavior;
    }
    _GetIndex() {
      return this._index;
    }
    PostCreate() {
      this._sdkInst ? this._sdkInst.PostCreate() : this._iScriptInterface._postCreate();
    }
    OnSpriteFrameChanged(t2, e) {
      this._sdkInst && this._sdkInst.OnSpriteFrameChanged(t2, e);
    }
    _GetDebuggerProperties() {
      return this._sdkInst ? this._sdkInst.GetDebuggerProperties() : this._iScriptInterface._getDebuggerProperties();
    }
    SaveToJson(t2 = "full") {
      return this._sdkInst ? this._sdkInst.SaveToJson(t2) : this._iScriptInterface._saveToJson(t2);
    }
    LoadFromJson(t2, e = "full") {
      if (this._sdkInst) return this._sdkInst.LoadFromJson(t2, e);
      this._iScriptInterface._loadFromJson(t2, e);
    }
    static SortByTickSequence(t2, e, s) {
      const n = globalThis.ISDKBehaviorInstanceBase;
      let i, r2;
      i = e instanceof n ? t2._UnwrapScriptInterface(e) : e.GetBehaviorInstance(), r2 = s instanceof n ? t2._UnwrapScriptInterface(s) : s.GetBehaviorInstance();
      const a2 = i.GetObjectInstance(), h2 = r2.GetObjectInstance(), c2 = a2.GetObjectClass().GetIndex(), o2 = h2.GetObjectClass().GetIndex();
      if (c2 !== o2) return c2 - o2;
      const I2 = a2.GetPUID(), _2 = h2.GetPUID();
      return I2 !== _2 ? I2 - _2 : i._GetIndex() - r2._GetIndex();
    }
    _InitScriptInterface(t2, e) {
      const s = IBehaviorInstance, n = t2 ?? this._sdkInst.GetScriptInterfaceClass(), i = n || s, r2 = this.GetBehavior().GetSdkVersion();
      if (C32.AddonManager._PushInitObject(this, r2), C32.AddonManager._PushInitProperties(e), this._iScriptInterface = new i(), C32.AddonManager._PopInitProperties(), C32.AddonManager._PopInitObject(r2), n && !(this._iScriptInterface instanceof s)) throw new TypeError(`script interface class '${n.name}' does not extend the right base class '${s.name}'`);
      return this._iScriptInterface;
    }
    GetScriptInterface() {
      return this._iScriptInterface || this._InitScriptInterface();
    }
    HasScriptInterface() {
      return !!this._iScriptInterface;
    }
  };
}
{
  const C32 = self.C3;
  C32.EffectList = class extends C32.DefendedBase {
    constructor(e, t2) {
      super(), this._owner = e, this._allEffectTypes = [], this._activeEffectTypes = [], this._effectTypesByName = /* @__PURE__ */ new Map(), this._effectParams = [], this._effectParamBuffers = [], this._allInstanceEffectLists = /* @__PURE__ */ new Set(), this._preservesOpaqueness = true;
      for (const e2 of t2) {
        const t3 = C32.New(C32.EffectType, this, e2, this._allEffectTypes.length);
        this._allEffectTypes.push(t3), this._effectTypesByName.set(t3.GetName().toLowerCase(), t3), e2.length >= 3 && this._effectParams.push(this._LoadSingleEffectParameters(t3, e2[2]));
      }
      this.GetRuntime()._AddEffectList(this);
    }
    Release() {
      this.GetRuntime()._RemoveEffectList(this);
      for (const e of this._effectParamBuffers) e.Release();
      C32.clearArray(this._effectParamBuffers), C32.clearArray(this._allEffectTypes), C32.clearArray(this._activeEffectTypes), this._effectTypesByName.clear(), C32.clearArray(this._effectParams), this._owner = null;
    }
    _AddInstanceEffectList(e) {
      this._allInstanceEffectLists.add(e);
    }
    _RemoveInstanceEffectList(e) {
      this._allInstanceEffectLists.delete(e);
    }
    _InitRenderer(e) {
      e.IsWebGPU() && (this._effectParamBuffers = this._allEffectTypes.map((e2) => {
        const t2 = e2.GetShaderProgram();
        return t2.GetCustomParametersByteSize() > 0 ? C32.New(C32.Gfx.WebGPUEffectCustomParamsBuffer, t2) : null;
      }), this._UpdateAllEffectParamBuffers());
      for (const t2 of this._allInstanceEffectLists) t2._InitRenderer(e);
    }
    PrependEffectTypes(e) {
      if (e.length) {
        this._allEffectTypes = e.concat(this._allEffectTypes);
        for (const t2 of e) this._effectTypesByName.set(t2.GetName().toLowerCase(), t2);
        for (let e2 = 0, t2 = this._allEffectTypes.length; e2 < t2; ++e2) this._allEffectTypes[e2]._SetIndex(e2);
      }
    }
    _LoadSingleEffectParameters(e, t2) {
      e.SetActive(t2[0]);
      const s = t2.slice(1);
      for (let e2 = 0, t3 = s.length; e2 < t3; ++e2) {
        const t4 = s[e2];
        if (Array.isArray(t4)) {
          const f2 = C32.New(C32.Color);
          f2.setFromJSON(t4), s[e2] = f2;
        }
      }
      return s;
    }
    GetOwner() {
      return this._owner;
    }
    GetRuntime() {
      return this._owner.GetRuntime();
    }
    UpdateActiveEffects() {
      C32.clearArray(this._activeEffectTypes);
      let e = true;
      for (const t2 of this._allEffectTypes) t2.IsActive() && (this._activeEffectTypes.push(t2), t2.GetShaderProgram().PreservesOpaqueness() || (e = false));
      this._preservesOpaqueness = e;
    }
    GetAllEffectTypes() {
      return this._allEffectTypes;
    }
    HasAnyEffectType() {
      return this._allEffectTypes.length > 0;
    }
    GetEffectTypeByName(e) {
      return this._effectTypesByName.get(e.toLowerCase()) || null;
    }
    GetEffectTypeByIndex(e) {
      if ((e = Math.floor(+e)) < 0 || e >= this._allEffectTypes.length) throw new RangeError("invalid effect type index");
      return this._allEffectTypes[e];
    }
    IsEffectIndexActive(e) {
      return this.GetEffectTypeByIndex(e).IsActive();
    }
    SetEffectIndexActive(e, t2) {
      this.GetEffectTypeByIndex(e).SetActive(t2);
    }
    GetActiveEffectTypes() {
      return this._activeEffectTypes;
    }
    HasAnyActiveEffect() {
      return this._activeEffectTypes.length > 0;
    }
    PreservesOpaqueness() {
      return this._preservesOpaqueness;
    }
    GetEffectParametersForIndex(e) {
      return this._effectParams[e];
    }
    _GetEffectChainShaderParametersForIndex(e) {
      return e < this._effectParamBuffers.length ? this._effectParamBuffers[e] : this._effectParams[e];
    }
    GetEffectParameter(e, t2) {
      if (e < 0 || e >= this._effectParams.length) return null;
      const s = this._effectParams[e];
      return t2 < 0 || t2 >= s.length ? null : s[t2];
    }
    SetEffectParameter(e, t2, s) {
      if (e < 0 || e >= this._effectParams.length) return false;
      const f2 = this._effectParams[e];
      if (t2 < 0 || t2 >= f2.length) return false;
      const r2 = f2[t2];
      if (r2 instanceof C32.Color) {
        if (r2.equalsIgnoringAlpha(s)) return false;
        r2.copyRgb(s);
      } else {
        if (r2 === s) return false;
        f2[t2] = s;
      }
      return e < this._effectParamBuffers.length && this._effectParamBuffers[e].SetParameterValue(t2, s), true;
    }
    _UpdateAllEffectParamBuffers() {
      const e = this._effectParams, t2 = this._effectParamBuffers;
      for (let s = 0, f2 = Math.min(e.length, t2.length); s < f2; ++s) {
        const f3 = t2[s], r2 = e[s];
        for (let e2 = 0, t3 = r2.length; e2 < t3; ++e2) f3.SetParameterValue(e2, r2[e2]);
      }
    }
    static SaveFxParamToJson(e) {
      return e && e instanceof C32.Color ? { "t": "color", "v": e.toJSON() } : e;
    }
    static LoadFxParamFromJson(e) {
      if (null === e) return NaN;
      if ("object" == typeof e) {
        if ("color" === e["t"]) {
          const t2 = C32.New(C32.Color);
          return t2.setFromJSON(e["v"]), t2;
        }
        throw new Error("invalid effect parameter type");
      }
      return e;
    }
    static SaveFxParamsToJson(e) {
      return e.map(C32.EffectList.SaveFxParamToJson);
    }
    static LoadFxParamsFromJson(e) {
      return e.map(C32.EffectList.LoadFxParamFromJson);
    }
    SaveToJson() {
      return this._allEffectTypes.map((e) => ({ "name": e.GetName(), "active": e.IsActive(), "params": C32.EffectList.SaveFxParamsToJson(this._effectParams[e.GetIndex()]) }));
    }
    LoadFromJson(e) {
      for (const t2 of e) {
        const e2 = this.GetEffectTypeByName(t2["name"]);
        e2 && (e2.SetActive(t2["active"]), this._effectParams[e2.GetIndex()] = C32.EffectList.LoadFxParamsFromJson(t2["params"]));
      }
      this.UpdateActiveEffects(), this._UpdateAllEffectParamBuffers();
    }
  };
}
{
  const C32 = self.C3;
  C32.EffectType = class extends C32.DefendedBase {
    constructor(e, t2, r2) {
      super(), this._effectList = e, this._id = t2[0], this._name = t2[1], this._index = r2, this._shaderProgram = null, this._isActive = true;
    }
    Release() {
      this._effectList = null, this._shaderProgram = null;
    }
    Clone(e) {
      const t2 = C32.New(C32.EffectType, e, [this._id, this._name], -1);
      return t2._shaderProgram = this._shaderProgram, t2._isActive = this._isActive, t2;
    }
    _InitRenderer(e) {
      const t2 = e.GetShaderProgramByName(this._id);
      if (!t2) throw new Error("failed to find shader program '" + this._id + "'");
      this._shaderProgram = t2;
    }
    GetEffectList() {
      return this._effectList;
    }
    GetName() {
      return this._name;
    }
    _SetIndex(e) {
      this._index = e;
    }
    GetIndex() {
      return this._index;
    }
    GetOwner() {
      return this._effectList.GetOwner();
    }
    GetRuntime() {
      return this._effectList.GetRuntime();
    }
    SetActive(e) {
      this._isActive = !!e;
    }
    IsActive() {
      return this._isActive;
    }
    GetShaderProgram() {
      return this._shaderProgram;
    }
    GetDefaultParameterValues() {
      const e = [];
      for (let t2 = 0, r2 = this._shaderProgram.GetParameterCount(); t2 < r2; ++t2) {
        const r3 = this._shaderProgram.GetParameterType(t2);
        if ("float" === r3 || "percent" === r3) e.push(0);
        else {
          if ("color" !== r3) throw new TypeError("unknown effect parameter type");
          e.push(C32.New(C32.Color, 1, 1, 1, 1));
        }
      }
      return e;
    }
  };
}
{
  const C32 = self.C3;
  C32.InstanceEffectList = class extends C32.DefendedBase {
    constructor(e, t2) {
      super(), this._inst = e, this._wi = t2, this._effectList = e.GetObjectClass().GetEffectList(), this._needsRebuildSteps = true, this._wasDefaultColor = true, this._was3D = false, this._wasRotatedOrNegativeSize = false, this._wasTexRotated = false, this._wasMustPreDraw = false, this._effectChain = C32.New(C32.Gfx.EffectChain, e.GetRuntime().GetCanvasManager().GetEffectChainManager(), { drawContent: (e2, t3) => {
        const s = t3.GetContentObject(), f2 = s.GetWorldInfo();
        e2.SetColor(f2.GetPremultipliedColor()), e2.SetCurrentZ(f2.GetTotalZElevation()), s.Draw(e2), e2.SetCurrentZ(0);
      }, getSourceTextureInfo: (e2) => {
        const t3 = e2.GetCurrentTexRect(), [s, f2] = e2.GetCurrentSurfaceSize();
        return { srcTexRect: t3, srcWidth: s, srcHeight: f2 };
      }, getShaderParameters: (e2) => this._GetEffectChainShaderParametersForIndex(e2) }), this._activeEffectFlags = [], this._activeEffectTypes = [], this._preservesOpaqueness = true, this._effectParams = [], this._effectParamBuffers = [], this._InitRenderer(e.GetRuntime().GetRenderer());
      for (let e2 = 0, t3 = this._effectList.GetAllEffectTypes().length; e2 < t3; ++e2) this._activeEffectFlags.push(true);
      this.UpdateActiveEffects(), this._effectList._AddInstanceEffectList(this);
    }
    Release() {
      this._effectList._RemoveInstanceEffectList(this);
      for (const e of this._effectParamBuffers) e && e.Release();
      C32.clearArray(this._effectParamBuffers), this._effectChain.Release(), this._effectChain = null, C32.clearArray(this._activeEffectFlags), C32.clearArray(this._activeEffectTypes), C32.clearArray(this._effectParams), this._inst = null, this._effectList = null;
    }
    _InitRenderer(e) {
      e.IsWebGPU() && (this._effectParamBuffers = this._effectList.GetAllEffectTypes().map((e2) => {
        const t2 = e2.GetShaderProgram();
        return t2.GetCustomParametersByteSize() > 0 ? C32.New(C32.Gfx.WebGPUEffectCustomParamsBuffer, t2) : null;
      }));
    }
    _LoadEffectParameters(e) {
      let t2 = 0;
      for (const s of e) this._effectParams.push(this._LoadSingleEffectParameters(t2, s)), ++t2;
      this._UpdateAllEffectParamBuffers(), this.UpdateActiveEffects();
    }
    _LoadSingleEffectParameters(e, t2) {
      this._activeEffectFlags[e] = t2[0];
      const s = t2.slice(1);
      for (let e2 = 0, t3 = s.length; e2 < t3; ++e2) {
        const t4 = s[e2];
        if (Array.isArray(t4)) {
          const f2 = C32.New(C32.Color);
          f2.setFromJSON(t4), s[e2] = f2;
        }
      }
      return s;
    }
    LoadDefaultEffectParameters() {
      for (const e of this._effectList.GetAllEffectTypes()) this._effectParams.push(e.GetDefaultParameterValues());
      this._UpdateAllEffectParamBuffers();
    }
    GetOwner() {
      return this._owner;
    }
    GetEffectList() {
      return this._effectList;
    }
    GetEffectChain() {
      return this._MaybeRebuildEffectChainSteps(), this._effectChain;
    }
    GetRuntime() {
      return this._inst.GetRuntime();
    }
    UpdateActiveEffects() {
      C32.clearArray(this._activeEffectTypes);
      const e = this._wi, t2 = this._effectList.GetAllEffectTypes(), s = this._activeEffectTypes, f2 = this._activeEffectFlags;
      let a2 = true;
      for (let e2 = 0, r2 = t2.length; e2 < r2; ++e2) if (f2[e2]) {
        const f3 = t2[e2];
        s.push(f3), f3.GetShaderProgram().PreservesOpaqueness() || (a2 = false);
      }
      this._preservesOpaqueness = a2, e._SetHasAnyActiveEffect(!!s.length), this._needsRebuildSteps = true;
    }
    _MaybeRebuildEffectChainSteps() {
      const e = this._inst, t2 = this._wi, s = t2.HasDefaultColor(), f2 = e.GetPlugin().Is3D(), a2 = 0 !== t2.GetAngle() || 0 !== t2.GetLayer().GetAngle() || t2.GetWidth() < 0 || t2.GetHeight() < 0, r2 = e.IsCurrentTexRotated(), i = e.MustPreDraw();
      (this._needsRebuildSteps || s !== this._wasDefaultColor || f2 !== this._was3D || a2 !== this._wasRotatedOrNegativeSize || r2 !== this._wasTexRotated || i !== this._wasMustPreDraw || this._effectChain.NeedsRebuild()) && (this._effectChain.BuildSteps(this._activeEffectTypes.map((e2) => e2.GetShaderProgram()), { indexMap: this._activeEffectTypes.map((e2) => e2.GetIndex()), forcePreDraw: !s || i, is3D: f2, isSourceTextureRotated: r2, isRotatedOrNegativeSizeInstance: a2 }), this._needsRebuildSteps = false, this._wasDefaultColor = s, this._was3D = f2, this._wasRotatedOrNegativeSize = a2, this._wasTexRotated = r2, this._wasMustPreDraw = i);
    }
    GetActiveEffectTypes() {
      return this._activeEffectTypes;
    }
    GetEffectParametersForIndex(e) {
      return this._effectParams[e];
    }
    _GetEffectChainShaderParametersForIndex(e) {
      return e < this._effectParamBuffers.length ? this._effectParamBuffers[e] : this._effectParams[e];
    }
    GetEffectParameter(e, t2) {
      if (e < 0 || e >= this._effectParams.length) return null;
      const s = this._effectParams[e];
      return t2 < 0 || t2 >= s.length ? null : s[t2];
    }
    SetEffectParameter(e, t2, s) {
      if (e < 0 || e >= this._effectParams.length) return false;
      const f2 = this._effectParams[e];
      if (t2 < 0 || t2 >= f2.length) return false;
      const a2 = f2[t2];
      if (a2 instanceof C32.Color) {
        if (a2.equalsIgnoringAlpha(s)) return false;
        a2.copyRgb(s);
      } else {
        if (a2 === s) return false;
        f2[t2] = s;
      }
      return e < this._effectParamBuffers.length && this._effectParamBuffers[e].SetParameterValue(t2, s), true;
    }
    _UpdateAllEffectParamBuffers() {
      const e = this._effectParams, t2 = this._effectParamBuffers;
      for (let s = 0, f2 = t2.length; s < f2; ++s) {
        const f3 = t2[s], a2 = e[s];
        for (let e2 = 0, t3 = a2.length; e2 < t3; ++e2) f3.SetParameterValue(e2, a2[e2]);
      }
    }
    PreservesOpaqueness() {
      return this._preservesOpaqueness;
    }
    HasAnyActiveBackgroundBlendingEffect() {
      return this._activeEffectTypes.some((e) => e.GetShaderProgram().BlendsBackground());
    }
    IsEffectIndexActive(e) {
      return this._activeEffectFlags[e];
    }
    SetEffectIndexActive(e, t2) {
      this._activeEffectFlags[e] = !!t2;
    }
    GetAllEffectTypes() {
      return this._effectList.GetAllEffectTypes();
    }
    _SaveToJson() {
      return this._effectList.GetAllEffectTypes().map((e) => ({ "name": e.GetName(), "active": this._activeEffectFlags[e.GetIndex()], "params": C32.EffectList.SaveFxParamsToJson(this._effectParams[e.GetIndex()]) }));
    }
    _LoadFromJson(e) {
      for (const t2 of e) {
        const e2 = this._effectList.GetEffectTypeByName(t2["name"]);
        e2 && (this._activeEffectFlags[e2.GetIndex()] = t2["active"], this._effectParams[e2.GetIndex()] = C32.EffectList.LoadFxParamsFromJson(t2["params"]));
      }
      this.UpdateActiveEffects(), this._UpdateAllEffectParamBuffers();
    }
  };
}
{
  const C32 = self.C3, tempCandidates = [], tileCollRectCandidates = [], tempJumpthruRet = [], tempPolyA = C32.New(C32.CollisionPoly), tempPolyB = C32.New(C32.CollisionPoly), tempQuad = C32.New(C32.Quad), tempRect = C32.New(C32.Rect), tempRect2 = C32.New(C32.Rect);
  let tempPolyC = null, tempRect3 = null, tempQuadB = null;
  C32.CollisionEngine = class extends C32.DefendedBase {
    constructor(e) {
      super(), this._runtime = e, this._collisionCellWidth = 0, this._collisionCellHeight = 0, this._registeredCollisions = [], this._collisionCheckCount = 0, this._collisionCheckSec = 0, this._polyCheckCount = 0, this._polyCheckSec = 0, this._iCollisionEngine = new self.ICollisionEngine(this);
    }
    Release() {
      this._runtime = null;
    }
    GetRuntime() {
      return this._runtime;
    }
    GetICollisionEngine() {
      return this._iCollisionEngine;
    }
    _Update1sStats() {
      this._collisionCheckSec = this._collisionCheckCount, this._collisionCheckCount = 0, this._polyCheckSec = this._polyCheckCount, this._polyCheckCount = 0;
    }
    Get1secCollisionChecks() {
      return this._collisionCheckSec;
    }
    Get1secPolyChecks() {
      return this._polyCheckSec;
    }
    RegisterCollision(e, t2) {
      const s = e.GetWorldInfo(), n = t2.GetWorldInfo();
      s && n && s.IsCollisionEnabled() && n.IsCollisionEnabled() && this._registeredCollisions.push([e, t2]);
    }
    AddRegisteredCollisionCandidates(e, t2, s) {
      for (const [n, l] of this._registeredCollisions) {
        let o2 = null;
        if (e === n) o2 = l;
        else {
          if (e !== l) continue;
          o2 = n;
        }
        o2.BelongsToObjectClass(t2) && (s.includes(o2) || s.push(o2));
      }
    }
    CheckRegisteredCollision(e, t2) {
      if (!this._registeredCollisions.length) return false;
      for (const [s, n] of this._registeredCollisions) if (e === s && t2 === n || e === n && t2 === s) return true;
      return false;
    }
    ClearRegisteredCollisions() {
      C32.clearArray(this._registeredCollisions);
    }
    TestOverlap(e, t2) {
      if (!e || !t2 || e === t2) return false;
      const s = e.GetWorldInfo(), n = t2.GetWorldInfo();
      if (!s.IsCollisionEnabled() || !n.IsCollisionEnabled()) return false;
      this._collisionCheckCount++;
      const l = s.GetLayer(), o2 = n.GetLayer();
      return l.IsTransformCompatibleWith(o2) ? this._TestOverlap_SameLayers(s, n) : this._TestOverlap_DifferentLayers(s, n);
    }
    _TestOverlap_SameLayers(e, t2) {
      if (!e.GetBoundingBox().intersectsRect(t2.GetBoundingBox())) return false;
      if (this._polyCheckCount++, !e.GetBoundingQuad().intersectsQuad(t2.GetBoundingQuad())) return false;
      if (e.HasTilemap() && t2.HasTilemap()) return false;
      if (e.HasTilemap()) return this.TestTilemapOverlap(e, t2);
      if (t2.HasTilemap()) return this.TestTilemapOverlap(t2, e);
      if (!e.HasOwnCollisionPoly() && !t2.HasOwnCollisionPoly()) return true;
      const s = e.GetTransformedCollisionPoly(), n = t2.GetTransformedCollisionPoly();
      return s.intersectsPoly(n, t2.GetX() - e.GetX(), t2.GetY() - e.GetY());
    }
    _TestOverlap_DifferentLayers(e, t2) {
      const s = e.HasTilemap(), n = t2.HasTilemap();
      if (s && !n) return this.TestTilemapOverlapDifferentLayers(e, t2);
      if (n && !s) return this.TestTilemapOverlapDifferentLayers(t2, e);
      if (n || s) return false;
      {
        const s2 = e.GetLayer(), n2 = t2.GetLayer();
        tempPolyA.copy(e.GetTransformedCollisionPoly()), tempPolyB.copy(t2.GetTransformedCollisionPoly());
        const l = tempPolyA.pointsArr();
        for (let t3 = 0, n3 = l.length; t3 < n3; t3 += 2) {
          const n4 = t3 + 1, o3 = l[t3], i = l[n4], [r2, a2] = s2.LayerToCanvasCss(o3 + e.GetX(), i + e.GetY());
          l[t3] = r2, l[n4] = a2;
        }
        const o2 = tempPolyB.pointsArr();
        for (let e2 = 0, s3 = o2.length; e2 < s3; e2 += 2) {
          const s4 = e2 + 1, l2 = o2[e2], i = o2[s4], [r2, a2] = n2.LayerToCanvasCss(l2 + t2.GetX(), i + t2.GetY());
          o2[e2] = r2, o2[s4] = a2;
        }
        return tempPolyA.setBboxChanged(), tempPolyB.setBboxChanged(), this._polyCheckCount++, tempPolyA.intersectsPoly(tempPolyB, 0, 0);
      }
    }
    TestTilemapOverlapDifferentLayers(e, t2) {
      const s = e.GetLayer(), n = t2.GetLayer();
      tempPolyC || (tempPolyC = C32.New(C32.CollisionPoly)), tempRect3 || (tempRect3 = C32.New(C32.Rect)), tempQuadB || (tempQuadB = C32.New(C32.Quad));
      const l = t2.GetX(), o2 = t2.GetY(), [i, r2] = n.LayerToCanvasCss(l, o2), [a2, c2] = s.CanvasCssToLayer(i, r2), C2 = a2 - l, d2 = c2 - o2;
      if (tempRect3.copy(t2.GetBoundingBox()), tempRect3.offset(C2, d2), !e.GetBoundingBox().intersectsRect(tempRect3)) return false;
      if (tempQuadB.copy(t2.GetBoundingQuad()), tempQuadB.offset(C2, d2), this._polyCheckCount++, !e.GetBoundingQuad().intersectsQuad(tempQuadB)) return false;
      tempPolyC.copy(t2.GetTransformedCollisionPoly());
      const u2 = tempPolyC.pointsArr();
      for (let e2 = 0, t3 = u2.length; e2 < t3; e2 += 2) {
        const t4 = e2 + 1;
        u2[e2] += C2, u2[t4] += d2;
      }
      return tempPolyC.setBboxChanged(), this.TestTilemapOverlap(e, t2, a2, c2, tempPolyC, tempRect3, tempQuadB);
    }
    TestTilemapOverlap(e, t2, s, n, l, o2, i) {
      const r2 = void 0 !== o2 ? o2 : t2.GetBoundingBox(), a2 = e.GetX(), c2 = e.GetY(), C2 = e.GetInstance().GetSdkInstance(), d2 = void 0 !== s ? s : t2.GetX(), u2 = void 0 !== n ? n : t2.GetY(), h2 = t2.HasOwnCollisionPoly(), p2 = void 0 !== i ? i : t2.GetBoundingQuad(), f2 = tileCollRectCandidates;
      C2.GetCollisionRectCandidates(r2, f2);
      for (let e2 = 0, s2 = f2.length; e2 < s2; ++e2) {
        const s3 = f2[e2], n2 = s3.GetRect();
        if (this._collisionCheckCount++, r2.intersectsRectOffset(n2, a2, c2) && (tempQuad.setFromRect(n2), tempQuad.offset(a2, c2), tempQuad.intersectsQuad(p2))) if (h2) {
          const e3 = void 0 !== l ? l : t2.GetTransformedCollisionPoly();
          let o3 = d2, i2 = u2;
          void 0 !== l && (o3 = t2.GetX(), i2 = t2.GetY());
          const r3 = s3.GetPoly();
          if (r3) {
            if (this._polyCheckCount++, r3.intersectsPoly(e3, o3 - (a2 + n2.getLeft()), i2 - (c2 + n2.getTop()))) return C32.clearArray(f2), true;
          } else if (tempPolyA.setFromQuad(tempQuad, 0, 0), tempPolyA.intersectsPoly(e3, o3, i2)) return C32.clearArray(f2), true;
        } else {
          const e3 = s3.GetPoly();
          if (!e3) return C32.clearArray(f2), true;
          if (tempPolyA.setFromQuad(p2, 0, 0), e3.intersectsPoly(tempPolyA, -(a2 + n2.getLeft()), -(c2 + n2.getTop()))) return C32.clearArray(f2), true;
        }
      }
      return C32.clearArray(f2), false;
    }
    TestAndSelectCanvasPointOverlap(e, t2, s) {
      const n = e.GetCurrentSol(), l = this._runtime.GetCurrentEvent();
      if (!l) throw new Error("cannot call outside event");
      const o2 = l.IsOrBlock(), i = new C32.LayerStateCache();
      if (n.IsSelectAll()) {
        s || (n._SetSelectAll(false), C32.clearArray(n._GetOwnInstances())), o2 && C32.clearArray(n._GetOwnElseInstances());
        for (const l2 of e.GetInstances()) {
          const e2 = l2.GetWorldInfo(), r2 = e2.GetLayer();
          let a2 = false;
          if (i.IsInteractive(r2) && e2.IsInViewport2() && (a2 = t2.some(([t3, s2]) => {
            const [n2, l3] = i.CanvasCssToLayer(r2, t3, s2, e2.GetTotalZElevation());
            return e2.ContainsPoint(n2, l3);
          })), a2) {
            if (s) return false;
            n._PushInstance(l2);
          } else o2 && n._PushElseInstance(l2);
        }
      } else {
        let e2, r2 = false;
        o2 && !l.IsFirstConditionOfType(this._runtime.GetCurrentCondition()) ? this._runtime.IsCurrentConditionFirst() && !n._GetOwnElseInstances().length && n._GetOwnInstances().length ? e2 = n._GetOwnInstances() : (e2 = n._GetOwnElseInstances(), r2 = true) : e2 = n._GetOwnInstances();
        let a2 = 0;
        for (let l2 = 0, c2 = e2.length; l2 < c2; ++l2) {
          const c3 = e2[l2], C2 = c3.GetWorldInfo(), d2 = C2.GetLayer();
          let u2 = false;
          if (i.IsInteractive(d2) && C2.IsInViewport2() && (u2 = t2.some(([e3, t3]) => {
            const [s2, n2] = i.CanvasCssToLayer(d2, e3, t3, C2.GetTotalZElevation());
            return C2.ContainsPoint(s2, n2);
          })), u2) {
            if (s) return false;
            r2 ? n._PushInstance(c3) : e2[a2++] = c3;
          } else r2 ? e2[a2++] = c3 : o2 && n._PushElseInstance(c3);
        }
        s || (e2.length = a2);
      }
      return e.ApplySolToContainer(), i.Release(), !!s || n.HasAnyInstances();
    }
    _ObjectClassCanUseCollisionCells(e, t2) {
      if (!e) return true;
      for (const s of t2.layersHasInstancesOn()) if (!e.IsTransformCompatibleWith(s)) return false;
      return true;
    }
    GetCollisionCandidates(e, t2, s, n) {
      if (t2.IsFamily()) for (const l of t2.GetFamilyMembers()) this._ObjectClassCanUseCollisionCells(e, l) ? (l._UpdateAllCollisionCells(), l._GetCollisionCellGrid().QueryRange(s, n)) : C32.appendArray(n, l.GetInstances());
      else this._ObjectClassCanUseCollisionCells(e, t2) ? (t2._UpdateAllCollisionCells(), t2._GetCollisionCellGrid().QueryRange(s, n)) : C32.appendArray(n, t2.GetInstances());
    }
    GetObjectClassesCollisionCandidates(e, t2, s, n) {
      for (const l of t2) this.GetCollisionCandidates(e, l, s, n);
    }
    GetSolidCollisionCandidates(e, t2, s) {
      const n = this._runtime.GetSolidBehavior();
      n && this.GetObjectClassesCollisionCandidates(e, n.GetObjectClasses(), t2, s);
    }
    GetJumpthruCollisionCandidates(e, t2, s) {
      const n = this._runtime.GetJumpthruBehavior();
      n && this.GetObjectClassesCollisionCandidates(e, n.GetObjectClasses(), t2, s);
    }
    IsSolidCollisionAllowed(e, t2) {
      return e._IsSolidEnabled() && (!t2 || t2.GetWorldInfo().IsSolidCollisionAllowed(e.GetSavedDataMap().get("solidTags")));
    }
    TestOverlapSolid(e) {
      const t2 = e.GetWorldInfo();
      this.GetSolidCollisionCandidates(t2.GetLayer(), t2.GetBoundingBox(), tempCandidates);
      for (const t3 of tempCandidates) if (this.IsSolidCollisionAllowed(t3, e) && this.TestOverlap(e, t3)) return C32.clearArray(tempCandidates), t3;
      return C32.clearArray(tempCandidates), null;
    }
    TestRectOverlapSolid(e, t2) {
      this.GetSolidCollisionCandidates(null, e, tempCandidates);
      for (const s of tempCandidates) if (this.IsSolidCollisionAllowed(s, t2) && this.TestRectOverlap(e, s)) return C32.clearArray(tempCandidates), s;
      return C32.clearArray(tempCandidates), null;
    }
    TestOverlapJumpthru(e, t2) {
      let s = null;
      t2 && (s = tempJumpthruRet, C32.clearArray(s));
      const n = e.GetWorldInfo();
      this.GetJumpthruCollisionCandidates(n.GetLayer(), n.GetBoundingBox(), tempCandidates);
      for (const n2 of tempCandidates) if (n2._IsJumpthruEnabled() && this.TestOverlap(e, n2)) {
        if (!t2) return C32.clearArray(tempCandidates), n2;
        s.push(n2);
      }
      return C32.clearArray(tempCandidates), s;
    }
    PushOut(e, t2, s, n, l) {
      n = n || 50;
      const o2 = e.GetWorldInfo(), i = o2.GetX(), r2 = o2.GetY();
      for (let a2 = 0; a2 < n; ++a2) if (o2.SetXY(i + t2 * a2, r2 + s * a2), o2.SetBboxChanged(), !this.TestOverlap(e, l)) return true;
      return o2.SetXY(i, r2), o2.SetBboxChanged(), false;
    }
    PushOutSolid(e, t2, s, n, l, o2) {
      n = n || 50;
      const i = e.GetWorldInfo(), r2 = i.GetX(), a2 = i.GetY();
      let c2 = null, C2 = null;
      for (let d2 = 0; d2 < n; ++d2) if (i.SetXY(r2 + t2 * d2, a2 + s * d2), i.SetBboxChanged(), !this.TestOverlap(e, c2)) {
        if (c2 = this.TestOverlapSolid(e), c2) C2 = c2;
        else if (l && (c2 = o2 ? this.TestOverlap(e, o2) ? o2 : null : this.TestOverlapJumpthru(e), c2 && (C2 = c2)), !c2) return C2 && this.PushInFractional(e, t2, s, C2, 16, true), true;
      }
      return i.SetXY(r2, a2), i.SetBboxChanged(), false;
    }
    PushOutSolidAxis(e, t2, s, n) {
      n = n || 50;
      const l = e.GetWorldInfo(), o2 = l.GetX(), i = l.GetY();
      let r2 = null, a2 = null;
      for (let c2 = 0; c2 < n; ++c2) for (let n2 = 0; n2 < 2; ++n2) {
        const C2 = 2 * n2 - 1;
        if (l.SetXY(o2 + t2 * c2 * C2, i + s * c2 * C2), l.SetBboxChanged(), !this.TestOverlap(e, r2)) {
          if (r2 = this.TestOverlapSolid(e), !r2) return a2 && this.PushInFractional(e, t2 * C2, s * C2, a2, 16, true), true;
          a2 = r2;
        }
      }
      return l.SetXY(o2, i), l.SetBboxChanged(), false;
    }
    PushInFractional(e, t2, s, n, l, o2) {
      let i = 2, r2 = false, a2 = false;
      const c2 = e.GetWorldInfo();
      let C2 = c2.GetX(), d2 = c2.GetY();
      for (; i <= l; ) {
        const l2 = 1 / i;
        i *= 2, c2.OffsetXY(t2 * l2 * (r2 ? 1 : -1), s * l2 * (r2 ? 1 : -1)), c2.SetBboxChanged(), this.TestOverlap(e, n) || o2 && this.TestOverlapSolid(e) ? (r2 = true, a2 = true) : (r2 = false, a2 = false, C2 = c2.GetX(), d2 = c2.GetY());
      }
      a2 && (c2.SetXY(C2, d2), c2.SetBboxChanged());
    }
    PushOutSolidNearest(e, t2 = 100) {
      let s = 0;
      const n = e.GetWorldInfo(), l = n.GetX(), o2 = n.GetY();
      let i = 0, r2 = this.TestOverlapSolid(e);
      if (!r2) return true;
      for (; s <= t2; ) {
        let t3 = 0, a2 = 0;
        switch (i) {
          case 0:
            t3 = 0, a2 = -1, s++;
            break;
          case 1:
            t3 = 1, a2 = -1;
            break;
          case 2:
            t3 = 1, a2 = 0;
            break;
          case 3:
            t3 = 1, a2 = 1;
            break;
          case 4:
            t3 = 0, a2 = 1;
            break;
          case 5:
            t3 = -1, a2 = 1;
            break;
          case 6:
            t3 = -1, a2 = 0;
            break;
          case 7:
            t3 = -1, a2 = -1;
        }
        if (i = (i + 1) % 8, n.SetXY(Math.floor(l + t3 * s), Math.floor(o2 + a2 * s)), n.SetBboxChanged(), !this.TestOverlap(e, r2) && (r2 = this.TestOverlapSolid(e), !r2)) return true;
      }
      return n.SetXY(l, o2), n.SetBboxChanged(), false;
    }
    CalculateBounceAngle(e, t2, s, n) {
      const l = e.GetWorldInfo(), o2 = l.GetX(), i = l.GetY(), r2 = Math.max(10, C32.distanceTo(t2, s, o2, i)), a2 = C32.angleTo(t2, s, o2, i), c2 = n || this.TestOverlapSolid(e);
      if (!c2) return C32.clampAngle(a2 + Math.PI);
      let C2 = c2, d2 = 0, u2 = 0;
      const h2 = C32.toRadians(5);
      let p2;
      for (p2 = 1; p2 < 36; ++p2) {
        const o3 = a2 - p2 * h2;
        if (l.SetXY(t2 + Math.cos(o3) * r2, s + Math.sin(o3) * r2), l.SetBboxChanged(), !this.TestOverlap(e, C2) && (C2 = n ? null : this.TestOverlapSolid(e), !C2)) {
          d2 = o3;
          break;
        }
      }
      for (36 === p2 && (d2 = C32.clampAngle(a2 + Math.PI)), C2 = c2, p2 = 1; p2 < 36; ++p2) {
        const o3 = a2 + p2 * h2;
        if (l.SetXY(t2 + Math.cos(o3) * r2, s + Math.sin(o3) * r2), l.SetBboxChanged(), !this.TestOverlap(e, C2) && (C2 = n ? null : this.TestOverlapSolid(e), !C2)) {
          u2 = o3;
          break;
        }
      }
      if (36 === p2 && (u2 = C32.clampAngle(a2 + Math.PI)), l.SetXY(o2, i), l.SetBboxChanged(), u2 === d2) return u2;
      const f2 = C32.angleDiff(u2, d2) / 2;
      let G;
      G = C32.angleClockwise(u2, d2) ? C32.clampAngle(d2 + f2 + Math.PI) : C32.clampAngle(u2 + f2);
      const m2 = Math.cos(a2), y2 = Math.sin(a2), g2 = Math.cos(G), T2 = Math.sin(G), _2 = m2 * g2 + y2 * T2, I2 = m2 - 2 * _2 * g2, S2 = y2 - 2 * _2 * T2;
      return C32.angleTo(0, 0, I2, S2);
    }
    TestSegmentOverlap(e, t2, s, n, l) {
      if (!l) return false;
      const o2 = l.GetWorldInfo();
      if (!o2.IsCollisionEnabled()) return false;
      if (this._collisionCheckCount++, tempRect.set(Math.min(e, s), Math.min(t2, n), Math.max(e, s), Math.max(t2, n)), !o2.GetBoundingBox().intersectsRect(tempRect)) return false;
      if (l.HasTilemap()) return this._TestSegmentOverlapTilemap(e, t2, s, n, l, o2);
      if (this._polyCheckCount++, !o2.GetBoundingQuad().intersectsSegment(e, t2, s, n)) return false;
      if (!o2.HasOwnCollisionPoly()) return true;
      return o2.GetTransformedCollisionPoly().intersectsSegment(o2.GetX(), o2.GetY(), e, t2, s, n);
    }
    _TestSegmentOverlapTilemap(e, t2, s, n, l, o2) {
      const i = o2.GetX(), r2 = o2.GetY(), a2 = l.GetSdkInstance(), c2 = tileCollRectCandidates;
      tempRect2.set(e, t2, s, n), tempRect2.normalize(), a2.GetCollisionRectCandidates(tempRect2, c2);
      for (let l2 = 0, o3 = c2.length; l2 < o3; ++l2) {
        const o4 = c2[l2], a3 = o4.GetRect();
        if (this._collisionCheckCount++, tempRect.intersectsRectOffset(a3, i, r2) && (tempQuad.setFromRect(a3), tempQuad.offset(i, r2), tempQuad.intersectsSegment(e, t2, s, n))) {
          const l3 = o4.GetPoly();
          if (!l3) return C32.clearArray(c2), true;
          if (this._polyCheckCount++, l3.intersectsSegment(i + a3.getLeft(), r2 + a3.getTop(), e, t2, s, n)) return C32.clearArray(c2), true;
        }
      }
      return C32.clearArray(c2), false;
    }
    TestRectOverlap(e, t2) {
      if (!t2) return false;
      const s = t2.GetWorldInfo();
      if (!s.IsCollisionEnabled()) return false;
      if (this._collisionCheckCount++, !s.GetBoundingBox().intersectsRect(e)) return false;
      if (t2.HasTilemap()) return this._TestRectOverlapTilemap(e, t2, s);
      if (this._polyCheckCount++, tempQuad.setFromRect(e), !s.GetBoundingQuad().intersectsQuad(tempQuad)) return false;
      if (!s.HasOwnCollisionPoly()) return true;
      const n = tempPolyA;
      n.setFromRect(e, s.GetX(), s.GetY());
      const l = s.GetTransformedCollisionPoly();
      return n.intersectsPoly(l, 0, 0);
    }
    _TestRectOverlapTilemap(e, t2, s) {
      const n = s.GetX(), l = s.GetY(), o2 = t2.GetSdkInstance(), i = tileCollRectCandidates;
      o2.GetCollisionRectCandidates(e, i);
      for (let t3 = 0, s2 = i.length; t3 < s2; ++t3) {
        const s3 = i[t3], o3 = s3.GetRect();
        if (this._collisionCheckCount++, e.intersectsRectOffset(o3, n, l)) {
          const t4 = s3.GetPoly();
          if (!t4) return C32.clearArray(i), true;
          if (this._polyCheckCount++, tempPolyA.setFromRect(e, 0, 0), t4.intersectsPoly(tempPolyA, -(n + o3.getLeft()), -(l + o3.getTop()))) return C32.clearArray(i), true;
        }
      }
      return C32.clearArray(i), false;
    }
    TestRayIntersectsInstance(e, t2) {
      if (!e) return;
      const s = e.GetWorldInfo();
      s.IsCollisionEnabled() && (this._collisionCheckCount++, s.GetBoundingBox().intersectsRect(t2.rect) && (e.HasTilemap() ? this._TestRayIntersectsTilemap(e, s, t2) : (this._polyCheckCount++, s.HasOwnCollisionPoly() ? t2.TestInstancePoly(e, s.GetX(), s.GetY(), s.GetTransformedCollisionPoly()) : t2.TestInstanceQuad(e, s.GetBoundingQuad()))));
    }
    _TestRayIntersectsTilemap(e, t2, s) {
      const n = t2.GetX(), l = t2.GetY(), o2 = tileCollRectCandidates;
      e.GetSdkInstance().GetCollisionRectCandidates(s.rect, o2);
      for (let i = 0, r2 = o2.length; i < r2; i++) {
        const r3 = o2[i], a2 = r3.GetRect();
        if (this._collisionCheckCount++, s.rect.intersectsRectOffset(a2, n, l)) {
          const o3 = r3.GetPoly();
          this._polyCheckCount++, o3 ? s.TestInstancePoly(e, n + a2.getLeft(), l + a2.getTop(), o3) : s.TestInstanceRect(e, t2.GetX(), t2.GetY(), a2);
        }
      }
      C32.clearArray(o2);
    }
    SetCollisionCellSize(e, t2) {
      if (e === this._collisionCellWidth && t2 === this._collisionCellHeight) return;
      this._collisionCellWidth = e, this._collisionCellHeight = t2;
      const s = this._runtime.GetAllObjectClasses();
      for (const n of s) if (n.IsWorldType()) {
        for (const e2 of n.instancesIncludingPendingCreate()) e2.GetWorldInfo()._RemoveFromCollisionCells();
        n._GetCollisionCellGrid().SetCellSize(e, t2), n._SetAnyCollisionCellChanged();
        for (const e2 of n.instancesIncludingPendingCreate()) {
          const t3 = e2.GetWorldInfo();
          t3._SetCollisionCellChanged(), t3._UpdateCollisionCell();
        }
      }
    }
    GetCollisionCellSize() {
      return [this._collisionCellWidth, this._collisionCellHeight];
    }
    _InitCollisionCellSize(e, t2) {
      this._collisionCellWidth = e, this._collisionCellHeight = t2;
    }
  };
}
{
  const C32 = self.C3;
  C32.SparseGrid = class extends C32.DefendedBase {
    constructor(t2, e) {
      super(), this._cellWidth = t2, this._cellHeight = e, this._cells = C32.New(C32.PairMap);
    }
    Release() {
      this._cells.Release(), this._cells = null;
    }
    SetCellSize(t2, e) {
      if (!this._cells.IsEmpty()) throw new Error("grid not empty");
      this._cellWidth = t2, this._cellHeight = e;
    }
    GetCell(t2, e, l) {
      let i = this._cells.Get(t2, e);
      return i || (l ? (i = C32.New(C32.GridCell, this, t2, e), this._cells.Set(t2, e, i), i) : null);
    }
    XToCell(t2) {
      const e = Math.floor(t2 / this._cellWidth);
      return isFinite(e) ? e : 0;
    }
    YToCell(t2) {
      const e = Math.floor(t2 / this._cellHeight);
      return isFinite(e) ? e : 0;
    }
    Update(t2, e, l) {
      if (e) for (let i = e.getLeft(), s = e.getRight(); i <= s; ++i) for (let s2 = e.getTop(), o2 = e.getBottom(); s2 <= o2; ++s2) {
        if (l && l.containsPoint(i, s2)) continue;
        const e2 = this.GetCell(i, s2, false);
        e2 && (e2.Remove(t2), e2.IsEmpty() && this._cells.Delete(i, s2));
      }
      if (l) for (let i = l.getLeft(), s = l.getRight(); i <= s; ++i) for (let s2 = l.getTop(), o2 = l.getBottom(); s2 <= o2; ++s2) e && e.containsPoint(i, s2) || this.GetCell(i, s2, true).Insert(t2);
    }
    QueryRange(t2, e) {
      let l = this.XToCell(t2.getLeft());
      const i = this.YToCell(t2.getTop()), s = this.XToCell(t2.getRight()), o2 = this.YToCell(t2.getBottom());
      if (isFinite(s) && isFinite(o2)) for (; l <= s; ++l) for (let t3 = i; t3 <= o2; ++t3) {
        const i2 = this.GetCell(l, t3, false);
        i2 && i2.Dump(e);
      }
    }
  };
}
{
  const C32 = self.C3;
  C32.GridCell = class extends C32.DefendedBase {
    constructor(s, e, t2) {
      super(), this._grid = s, this._x = e, this._y = t2, this._instances = C32.New(C32.ArraySet);
    }
    Release() {
      this._instances.Release(), this._instances = null, this._grid = null;
    }
    IsEmpty() {
      return this._instances.IsEmpty();
    }
    Insert(s) {
      this._instances.Add(s);
    }
    Remove(s) {
      this._instances.Delete(s);
    }
    Dump(s) {
      C32.appendArray(s, this._instances.GetArray());
    }
  };
}
{
  const C32 = self.C3, PADDING = 1e-6, NO_HIT = 2;
  C32.Ray = class {
    constructor() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.dx = 0, this.dy = 0, this.rect = new C32.Rect(), this.hitFraction = 2, this.hitUid = null, this.hitNormal = 0, this.hitNormalDx = 0, this.hitNormalDy = 0, this.hitX = 0, this.hitY = 0, this.distance = 0, this.normalX = 1, this.normalY = 0, this.reflectionX = 1, this.reflectionY = 0;
    }
    DidCollide() {
      return this.hitFraction < 1.000001;
    }
    Reset() {
      this.hitFraction = 2;
    }
    Set(t2, i, s, h2) {
      return this.x1 = t2, this.y1 = i, this.x2 = s, this.y2 = h2, this.dx = s - t2, this.dy = h2 - i, this.rect.set(t2, i, s, h2), this.rect.normalize(), this.hitFraction = 2, this.hitUid = null, this.hitNormal = 0, this.hitNormalDx = 0, this.hitNormalDy = 0, this.hitX = 0, this.hitY = 0, this.distance = 0, this.normalX = 1, this.normalY = 0, this.reflectionX = 1, this.reflectionY = 0, this;
    }
    Complete() {
      if (false === this.DidCollide()) return;
      const t2 = this.dx * this.hitFraction, i = this.dy * this.hitFraction, s = C32.hypot2DFast(t2, i), h2 = t2 / s, e = i / s;
      this.distance = s - PADDING, this.hitX = this.x1 + h2 * this.distance, this.hitY = this.y1 + e * this.distance, this.hitNormal = Math.atan2(this.hitNormalDy, this.hitNormalDx) + Math.PI / 2, this.normalX = Math.cos(this.hitNormal), this.normalY = Math.sin(this.hitNormal);
      const n = h2 * this.normalX + e * this.normalY;
      if (this.reflectionX = h2 - 2 * this.normalX * n, this.reflectionY = e - 2 * this.normalY * n, n > 0) {
        const t3 = Math.PI;
        this.hitNormal = C32.clampAngle(this.hitNormal + t3), this.normalX = -this.normalX, this.normalY = -this.normalY;
      }
    }
    TestInstanceSegment(t2, i, s, h2, e) {
      const n = C32.rayIntersect(this.x1, this.y1, this.x2, this.y2, i, s, h2, e);
      n >= 0 && n < this.hitFraction && (this.hitFraction = n, this.hitUid = t2.GetUID(), this.hitNormalDx = i - h2, this.hitNormalDy = s - e);
    }
    TestInstanceRect(t2, i, s, h2) {
      const e = i + h2.getLeft(), n = i + h2.getRight(), a2 = s + h2.getTop(), o2 = s + h2.getBottom();
      this.TestInstanceSegment(t2, e, a2, n, a2), this.TestInstanceSegment(t2, n, a2, n, o2), this.TestInstanceSegment(t2, n, o2, e, o2), this.TestInstanceSegment(t2, e, o2, e, a2);
    }
    TestInstanceQuad(t2, i) {
      const s = i.getTlx(), h2 = i.getTly(), e = i.getTrx(), n = i.getTry(), a2 = i.getBrx(), o2 = i.getBry(), r2 = i.getBlx(), l = i.getBly();
      this.TestInstanceSegment(t2, s, h2, e, n), this.TestInstanceSegment(t2, e, n, a2, o2), this.TestInstanceSegment(t2, a2, o2, r2, l), this.TestInstanceSegment(t2, r2, l, s, h2);
    }
    TestInstancePoly(t2, i, s, h2) {
      const e = h2.pointsArr();
      for (let h3 = 0, n = e.length; h3 < n; h3 += 2) {
        const a2 = (h3 + 2) % n, o2 = e[h3] + i, r2 = e[h3 + 1] + s, l = e[a2] + i, c2 = e[a2 + 1] + s;
        this.TestInstanceSegment(t2, o2, r2, l, c2);
      }
    }
  };
}
{
  const C32 = self.C3;
  C32.LayerStateCache = class {
    constructor() {
      this._layerCache = /* @__PURE__ */ new Map();
    }
    Release() {
      for (const e of this._layerCache.values()) e.layerPts.Clear();
      this._layerCache.clear();
    }
    _GetLayerCache(e) {
      let a2 = this._layerCache.get(e);
      return void 0 === a2 && (a2 = { isInteractive: null, layerPts: new C32.PairMap() }, this._layerCache.set(e, a2)), a2;
    }
    IsInteractive(e) {
      const a2 = this._GetLayerCache(e);
      return null === a2.isInteractive && (a2.isInteractive = e.IsSelfAndParentsInteractive()), a2.isInteractive;
    }
    CanvasCssToLayer(e, a2, t2, s) {
      if (0 !== s) return e.CanvasCssToLayer(a2, t2, s);
      const r2 = this._GetLayerCache(e);
      let n = r2.layerPts.Get(a2, t2);
      return void 0 === n && (n = e.CanvasCssToLayer(a2, t2, s), r2.layerPts.Set(a2, t2, n)), n;
    }
  };
}
{
  const C32 = self.C3, VALID_FULLSCREEN_MODES = /* @__PURE__ */ new Set(["off", "crop", "scale-inner", "scale-outer", "letterbox-scale", "letterbox-integer-scale"]), VALID_FULLSCREEN_SCALING_QUALITIES = /* @__PURE__ */ new Set(["high", "low"]), glMatrix = self.glMatrix, mat4 = glMatrix.mat4, vec3 = glMatrix.vec3, tempProjection = mat4.create(), PERCENTTEXT_WIDTH = 300, PERCENTTEXT_HEIGHT = 200, PROGRESSBAR_WIDTH = 120, PROGRESSBAR_HEIGHT = 8, tempQuad = C32.New(C32.Quad), tempRect = C32.New(C32.Rect), SPLASH_MIN_DISPLAY_TIME = 3e3, SPLASH_AFTER_FADEOUT_WAIT_TIME = 200, SPLASH_FADE_DURATION = 300;
  C32.CanvasManager = class extends C32.DefendedBase {
    constructor(e) {
      super(), this._runtime = e, this._canvasLayers = [], this._isWebGPUEnabled = false, this._webglRenderer = null, this._webgpuRenderer = null, this._iRenderer = null, this._gpuPreference = "high-performance", this._isLimitedToWebGL1 = false, this._multitexturingMode = "auto", this._windowInnerWidth = 0, this._windowInnerHeight = 0, this._cssDisplayMode = "", this._canvasCssWidth = 0, this._canvasCssHeight = 0, this._canvasDeviceWidth = 0, this._canvasDeviceHeight = 0, this._canvasCssOffsetX = 0, this._canvasCssOffsetY = 0, this._zAxisScale = "normalized", this._initFieldOfView = 0, this._zNear = 1, this._zFar = 1e4, this._enableMipmaps = true, this._textureAnisotropy = 0, this._drawWidth = 0, this._drawHeight = 0, this._fullscreenMode = "letterbox-scale", this._documentFullscreenMode = "letterbox-scale", this._deviceTransformOffX = 0, this._deviceTransformOffY = 0, this._defaultProjectionMatrix = mat4.create(), this._wantFullscreenScalingQuality = "high", this._fullscreenScalingQuality = this._wantFullscreenScalingQuality, this._isDocumentFullscreen = false, this._availableAdditionalRenderTargets = [], this._usedAdditionalRenderTargets = /* @__PURE__ */ new Set(), this._shaderData = self["C3_Shaders"], this._effectChainManager = C32.New(C32.Gfx.EffectChainManager, { getDrawSize: () => [this.GetDrawWidth(), this.GetDrawHeight()], getRenderTarget: () => this.GetEffectCompositorRenderTarget(), releaseRenderTarget: (e2) => this.ReleaseEffectCompositorRenderTarget(e2), getTime: () => this.GetRuntime().GetGameTime(), redraw: () => this.GetRuntime().UpdateRender() }), this._gpuTimeStartFrame = 0, this._gpuTimeEndFrame = 0, this._gpuLastUtilisation = NaN, this._gpuFrameTimingsBuffer = null, this._layersGpuProfile = /* @__PURE__ */ new Map(), this._gpuCurUtilisation = NaN, this._webgpuFrameTimings = /* @__PURE__ */ new Map(), this._snapshotFormat = "", this._snapshotQuality = 1, this._snapshotArea = C32.New(C32.Rect), this._snapshotUrl = "", this._snapshotPromise = null, this._snapshotResolve = null, this._isPastingToDrawingCanvas = 0, this._loaderStartTime = 0, this._rafId = -1, this._loadingProgress = 0, this._loadingprogress_handler = (e2) => this._loadingProgress = e2.progress, this._percentText = null, this._splashTextures = { logo: null, powered: null, website: null }, this._splashFrameNumber = 0, this._splashFadeInFinishTime = 0, this._splashFadeOutStartTime = 0, this._splashState = "fade-in", this._splashDoneResolve = null, this._splashDonePromise = new Promise((e2) => this._splashDoneResolve = e2);
    }
    _SetGPUPowerPreference(e) {
      this._gpuPreference = e;
    }
    _SetWebGPUEnabled(e) {
      this._isWebGPUEnabled = !!e;
    }
    _SetZAxisScale(e) {
      this._zAxisScale = e;
    }
    GetZAxisScale() {
      return this._zAxisScale;
    }
    _SetInitFieldOfView(e) {
      this._initFieldOfView = e;
    }
    _SetZDistances(e, t2) {
      this._zNear = e, this._zFar = t2;
    }
    _SetLimitedToWebGL1(e) {
      this._isLimitedToWebGL1 = !!e;
    }
    _SetMultitexturingMode(e) {
      this._multitexturingMode = e;
    }
    async CreateCanvas(e) {
      let t2 = e["canvas"];
      this._canvasLayers.push({ canvas: t2, ctx: null }), this._runtime.AddDOMComponentMessageHandler("runtime", "window-resize", (e2) => this._OnWindowResize(e2)), this._runtime.AddDOMComponentMessageHandler("runtime", "fullscreenchange", (e2) => this._OnFullscreenChange(e2)), this._runtime.AddDOMComponentMessageHandler("runtime", "fullscreenerror", (e2) => this._OnFullscreenError(e2)), t2.addEventListener("webglcontextlost", (e2) => this._OnWebGLContextLost(e2)), t2.addEventListener("webglcontextrestored", (e2) => this._OnWebGLContextRestored(e2)), this._isDocumentFullscreen = !!e["isFullscreen"], this._cssDisplayMode = e["cssDisplayMode"];
      const s = navigator["gpu"] && this._isWebGPUEnabled;
      let i = false;
      if (s) try {
        await this._InitWebGPUContext(true);
      } catch (e2) {
        this._MaybeLogRendererError("WebGPU", e2), this._webgpuRenderer = null;
      }
      if (!this.GetRenderer()) try {
        await this._InitWebGLContext(true);
      } catch (e2) {
        this._MaybeLogRendererError("WebGL", e2), this._webglRenderer = null;
      }
      if (this.GetRenderer() || (i = true), !this.GetRenderer() && s) try {
        await this._InitWebGPUContext(false);
      } catch (e2) {
        this._MaybeLogRendererError("WebGPU", e2), this._webgpuRenderer = null;
      }
      if (!this.GetRenderer()) try {
        await this._InitWebGLContext(false);
      } catch (e2) {
        this._MaybeLogRendererError("WebGL", e2), this._webglRenderer = null;
      }
      const r2 = this.GetRenderer();
      if (!r2) throw new Error("failed to acquire a renderer - check WebGL or WebGPU is supported");
      r2.SetHasMajorPerformanceCaveat(i), this._webgpuRenderer && (this._webgpuRenderer.ondevicelost = () => this._OnWebGPUDeviceLost(), this._webgpuRenderer.ondevicerestored = () => this._OnWebGPUDeviceRestored()), "normalized" === this._zAxisScale ? r2.SetZAxisScaleNormalized() : (r2.SetZAxisScaleRegular(), r2.SetFovY(this._initFieldOfView)), this.SetSize(e["windowInnerWidth"], e["windowInnerHeight"], true), await this._InitRenderer();
    }
    _MaybeLogRendererError(e, t2) {
      t2 && "string" == typeof t2.message && t2.message.startsWith("renderer-unavailable") || console.error(`Error creating ${e} renderer: `, t2);
    }
    async _InitWebGPUContext(e) {
      const t2 = { nearZ: this._zNear, farZ: this._zFar };
      let s = true;
      "no" === this._multitexturingMode ? s = false : "auto" === this._multitexturingMode && (s = C32.Platform.IsDesktop);
      let i = "nearest";
      this._runtime.UsesAnyCrossSampling() && "nearest" !== this._runtime.GetSampling() && (i = "bilinear");
      const r2 = { powerPreference: this._gpuPreference, depth: this._runtime.Uses3DFeatures(), failIfMajorPerformanceCaveat: e, usesBackgroundBlending: this._runtime.UsesAnyBackgroundBlending(), canSampleBackbuffer: this._runtime.UsesAnyCrossSampling(), backTextureSampling: i, canSampleDepth: this._runtime.UsesAnyDepthSampling(), isMultiTexturingAllowed: s };
      this._webgpuRenderer = C32.New(C32.Gfx.WebGPURenderer, t2), await this._webgpuRenderer.Create(this._canvasLayers[0].canvas, r2);
    }
    async _InitWebGLContext(e) {
      const t2 = { alpha: true, powerPreference: this._gpuPreference, enableGpuProfiling: "xbox-uwp-webview2" !== this._runtime.GetExportType(), depth: this._runtime.Uses3DFeatures(), canSampleDepth: this._runtime.UsesAnyDepthSampling(), failIfMajorPerformanceCaveat: e, nearZ: this._zNear, farZ: this._zFar };
      this._isLimitedToWebGL1 && (t2.maxWebGLVersion = 1), this._webglRenderer = C32.New(C32.Gfx.WebGLRenderer, this._canvasLayers[0].canvas, t2), await this._webglRenderer.InitState();
    }
    async _InitWebGPU() {
      if (this._shaderData) {
        const e = [];
        for (const [t2, s] of Object.entries(this._shaderData)) {
          s.src = s.wgsl;
          const i = C32.Gfx.WebGPUShaderProgram.GetDefaultVertexShaderSource(this._webgpuRenderer.IsColorDataF16());
          e.push(this._webgpuRenderer.CreateShaderProgram(Object.assign({ vertexSrc: i, name: t2 }, s)));
        }
        await Promise.all(e);
      }
    }
    async _InitWebGL() {
      if (this._shaderData) {
        const e = [];
        for (const [t2, s] of Object.entries(this._shaderData)) {
          let i;
          if (s.glslWebGL2 && this._webglRenderer.GetWebGLVersionNumber() >= 2) s.src = s.glslWebGL2, i = C32.Gfx.WebGLShaderProgram.GetDefaultVertexShaderSource_WebGL2();
          else {
            if (!s.glsl) throw new Error(`shader '${t2}' does not support WebGL 1`);
            s.src = s.glsl, i = C32.Gfx.WebGLShaderProgram.GetDefaultVertexShaderSource();
          }
          e.push(this._webglRenderer.CreateShaderProgram(Object.assign({ vertexSrc: i, name: t2 }, s)));
        }
        await Promise.all(e), this._webglRenderer.ResetLastProgram(), this._webglRenderer.SetTextureFillMode();
      }
      this._webglRenderer.SupportsGPUProfiling() && (this._gpuFrameTimingsBuffer = C32.New(C32.Gfx.WebGLQueryResultBuffer, this._webglRenderer));
    }
    async _InitRenderer() {
      this._webgpuRenderer ? await this._InitWebGPU() : this._webglRenderer && await this._InitWebGL();
      const e = this.GetRenderer();
      e.SetMipmapsEnabled(this._enableMipmaps), e.SupportsGPUProfiling() && (this._gpuLastUtilisation = 0);
      for (const t2 of this._runtime._GetAllEffectLists()) {
        for (const s of t2.GetAllEffectTypes()) s._InitRenderer(e);
        t2._InitRenderer(e), t2.UpdateActiveEffects();
      }
      this._iRenderer = new self.IRenderer(this._runtime, e);
    }
    Release() {
      this._runtime = null, this._webglRenderer = null, this._canvasLayers.length = 0;
    }
    IsInWorker() {
      return this._runtime.IsInWorker();
    }
    _OnWindowResize(e) {
      const t2 = this._runtime;
      if (t2.IsExportToVideo()) return;
      const s = e["devicePixelRatio"];
      this.IsInWorker() && (self.devicePixelRatio = s), t2._SetDevicePixelRatio(s), this._isDocumentFullscreen = !!e["isFullscreen"], this._cssDisplayMode = e["cssDisplayMode"], this.SetSize(e["innerWidth"], e["innerHeight"]), t2.UpdateRender();
      const i = new C32.Event("window-resize");
      i.data = e, t2.Dispatcher().dispatchEventAndWaitAsyncSequential(i);
      const r2 = new C32.Event("resize");
      r2.cssWidth = this.GetCssWidth(), r2.cssHeight = this.GetCssHeight(), r2.deviceWidth = this.GetDeviceWidth(), r2.deviceHeight = this.GetDeviceHeight(), t2.DispatchUserScriptEvent(r2), this._runtime.GetCurrentLayout()?.BoundScrolling(), t2.IsDebug() && (t2.HitBreakpoint() || self.C3Debugger.IsDebuggerPaused()) && t2.Render();
    }
    _OnFullscreenChange(e) {
      this._isDocumentFullscreen = !!e["isFullscreen"], this.SetSize(e["innerWidth"], e["innerHeight"], true), this._runtime.UpdateRender();
    }
    _OnFullscreenError(e) {
      this._isDocumentFullscreen = !!e["isFullscreen"], this.SetSize(e["innerWidth"], e["innerHeight"], true), this._runtime.UpdateRender();
    }
    SetSize(e, t2, s = false) {
      if (e = Math.floor(e), t2 = Math.floor(t2), e <= 0 || t2 <= 0) throw new Error("invalid size");
      if (this._windowInnerWidth === e && this._windowInnerHeight === t2 && !s) return;
      this._windowInnerWidth = e, this._windowInnerHeight = t2;
      const i = this.GetCurrentFullscreenMode();
      "letterbox-scale" === i ? this._CalculateLetterboxScale(e, t2) : "letterbox-integer-scale" === i ? this._CalculateLetterboxIntegerScale(e, t2) : "off" === i ? this._CalculateFixedSizeCanvas(e, t2) : this._CalculateFullsizeCanvas(e, t2), this._UpdateFullscreenScalingQuality(i);
      for (const { canvas: e2 } of this._canvasLayers) e2.width = this._canvasDeviceWidth, e2.height = this._canvasDeviceHeight;
      this._runtime.PostComponentMessageToDOM("canvas", "update-size", { "marginLeft": this._canvasCssOffsetX, "marginTop": this._canvasCssOffsetY, "styleWidth": this._canvasCssWidth, "styleHeight": this._canvasCssHeight, "displayScale": this.GetDisplayScale() });
      const r2 = this.GetRenderer();
      r2.SetSize(this._canvasDeviceWidth, this._canvasDeviceHeight, true);
      for (const e2 of this._availableAdditionalRenderTargets) r2.DeleteRenderTarget(e2);
      C32.clearArray(this._availableAdditionalRenderTargets), this.UpdateDefaultProjectionMatrix();
      const a2 = this._runtime.GetLayoutManager();
      a2.SetAllLayerProjectionChanged(), a2.SetAllLayerMVChanged();
    }
    UpdateDefaultProjectionMatrix() {
      this.GetRenderer().CalculatePerspectiveMatrix(this._defaultProjectionMatrix, this.GetDrawWidth() / this.GetDrawHeight());
    }
    GetDefaultProjectionMatrix() {
      return this._defaultProjectionMatrix;
    }
    _CalculateLetterboxScale(e, t2) {
      const s = this._runtime.GetDevicePixelRatio(), i = this._runtime.GetOriginalViewportWidth(), r2 = this._runtime.GetOriginalViewportHeight(), a2 = i / r2;
      if (e / t2 > a2) {
        const s2 = t2 * a2;
        this._canvasCssWidth = Math.round(s2), this._canvasCssHeight = t2, this._canvasCssOffsetX = Math.floor((e - this._canvasCssWidth) / 2), this._canvasCssOffsetY = 0;
      } else {
        const s2 = e / a2;
        this._canvasCssWidth = e, this._canvasCssHeight = Math.round(s2), this._canvasCssOffsetX = 0, this._canvasCssOffsetY = Math.floor((t2 - this._canvasCssHeight) / 2);
      }
      this._canvasDeviceWidth = Math.round(this._canvasCssWidth * s), this._canvasDeviceHeight = Math.round(this._canvasCssHeight * s), this._runtime.SetViewportSize(i, r2);
    }
    _CalculateLetterboxIntegerScale(e, t2) {
      const s = this._runtime.GetDevicePixelRatio();
      1 !== s && (e += 1, t2 += 1);
      const i = this._runtime.GetOriginalViewportWidth(), r2 = this._runtime.GetOriginalViewportHeight(), a2 = i / r2;
      let n;
      if (e / t2 > a2) {
        n = t2 * a2 * s / i;
      } else {
        n = e / a2 * s / r2;
      }
      n > 1 ? n = Math.floor(n) : n < 1 && (n = 1 / Math.ceil(1 / n)), this._canvasDeviceWidth = Math.round(i * n), this._canvasDeviceHeight = Math.round(r2 * n), this._canvasCssWidth = this._canvasDeviceWidth / s, this._canvasCssHeight = this._canvasDeviceHeight / s, this._canvasCssOffsetX = Math.max(Math.floor((e - this._canvasCssWidth) / 2), 0), this._canvasCssOffsetY = Math.max(Math.floor((t2 - this._canvasCssHeight) / 2), 0), this._runtime.SetViewportSize(i, r2);
    }
    _CalculateFullsizeCanvas(e, t2) {
      const s = this._runtime.GetDevicePixelRatio();
      this._canvasCssWidth = e, this._canvasCssHeight = t2, this._canvasDeviceWidth = Math.round(this._canvasCssWidth * s), this._canvasDeviceHeight = Math.round(this._canvasCssHeight * s), this._canvasCssOffsetX = 0, this._canvasCssOffsetY = 0;
      const i = this.GetDisplayScale();
      this._runtime.SetViewportSize(this._canvasCssWidth / i, this._canvasCssHeight / i);
    }
    _CalculateFixedSizeCanvas(e, t2) {
      const s = this._runtime.GetDevicePixelRatio();
      this._canvasCssWidth = this._runtime.GetViewportWidth(), this._canvasCssHeight = this._runtime.GetViewportHeight(), this._canvasDeviceWidth = Math.round(this._canvasCssWidth * s), this._canvasDeviceHeight = Math.round(this._canvasCssHeight * s), this.IsDocumentFullscreen() ? (this._canvasCssOffsetX = Math.floor((e - this._canvasCssWidth) / 2), this._canvasCssOffsetY = Math.floor((t2 - this._canvasCssHeight) / 2)) : (this._canvasCssOffsetX = 0, this._canvasCssOffsetY = 0), this._runtime.SetViewportSize(this._runtime.GetViewportWidth(), this._runtime.GetViewportHeight());
    }
    _UpdateFullscreenScalingQuality(e) {
      if ("high" === this._wantFullscreenScalingQuality) this._drawWidth = this._canvasDeviceWidth, this._drawHeight = this._canvasDeviceHeight, this._fullscreenScalingQuality = "high";
      else {
        let t2, s;
        if ("off" === this.GetCurrentFullscreenMode() ? (t2 = this._runtime.GetViewportWidth(), s = this._runtime.GetViewportHeight()) : (t2 = this._runtime.GetOriginalViewportWidth(), s = this._runtime.GetOriginalViewportHeight()), this._canvasDeviceWidth < t2 || this._canvasDeviceHeight < s) this._drawWidth = this._canvasDeviceWidth, this._drawHeight = this._canvasDeviceHeight, this._fullscreenScalingQuality = "high";
        else if (this._drawWidth = t2, this._drawHeight = s, this._fullscreenScalingQuality = "low", "scale-inner" === e) {
          const e2 = t2 / s, i = this._windowInnerWidth / this._windowInnerHeight;
          i < e2 ? this._drawWidth = this._drawHeight * i : i > e2 && (this._drawHeight = this._drawWidth / i);
        } else if ("scale-outer" === e) {
          const e2 = t2 / s, i = this._windowInnerWidth / this._windowInnerHeight;
          i > e2 ? this._drawWidth = this._drawHeight * i : i < e2 && (this._drawHeight = this._drawWidth / i);
        }
      }
    }
    GetRuntime() {
      return this._runtime;
    }
    GetMainCanvas() {
      return this._canvasLayers[0].canvas;
    }
    GetEffectChainManager() {
      return this._effectChainManager;
    }
    IsDocumentFullscreen() {
      return this._isDocumentFullscreen;
    }
    GetCssDisplayMode() {
      return this._cssDisplayMode;
    }
    SetFullscreenMode(e) {
      if (!VALID_FULLSCREEN_MODES.has(e)) throw new Error("invalid fullscreen mode");
      this._fullscreenMode = e;
      const t2 = this._runtime.GetLayoutManager();
      t2.SetAllLayerProjectionChanged(), t2.SetAllLayerMVChanged();
    }
    GetFullscreenMode() {
      return this._fullscreenMode;
    }
    SetDocumentFullscreenMode(e) {
      if (!VALID_FULLSCREEN_MODES.has(e)) throw new Error("invalid fullscreen mode");
      this._documentFullscreenMode = e;
      const t2 = this._runtime.GetLayoutManager();
      t2.SetAllLayerProjectionChanged(), t2.SetAllLayerMVChanged();
    }
    GetDocumentFullscreenMode() {
      return this._documentFullscreenMode;
    }
    GetCurrentFullscreenMode() {
      return this.IsDocumentFullscreen() ? this.GetDocumentFullscreenMode() : this.GetFullscreenMode();
    }
    SetFullscreenScalingQuality(e) {
      if (!VALID_FULLSCREEN_SCALING_QUALITIES.has(e)) throw new Error("invalid fullscreen scaling quality");
      this._wantFullscreenScalingQuality = e, this._runtime.GetLayoutManager().SetAllLayerProjectionChanged();
    }
    GetSetFullscreenScalingQuality() {
      return this._wantFullscreenScalingQuality;
    }
    GetCurrentFullscreenScalingQuality() {
      return this._fullscreenScalingQuality;
    }
    static _FullscreenModeNumberToString(e) {
      switch (e) {
        case 0:
          return "off";
        case 1:
          return "crop";
        case 2:
          return "scale-inner";
        case 3:
          return "scale-outer";
        case 4:
          return "letterbox-scale";
        case 5:
          return "letterbox-integer-scale";
        default:
          throw new Error("invalid fullscreen mode");
      }
    }
    GetLastWidth() {
      return this._windowInnerWidth;
    }
    GetLastHeight() {
      return this._windowInnerHeight;
    }
    GetDrawWidth() {
      return this._drawWidth;
    }
    GetDrawHeight() {
      return this._drawHeight;
    }
    SetMipmapsEnabled(e) {
      this._enableMipmaps = !!e;
    }
    GetMipmapsEnabled() {
      return this._enableMipmaps;
    }
    _SetTextureAnisotropy(e) {
      this._textureAnisotropy = e;
    }
    GetTextureAnisotropy() {
      return this._textureAnisotropy;
    }
    IsRendererContextLost() {
      return this.GetRenderer().IsContextLost();
    }
    _OnWebGLContextLost(e) {
      console.log("[Construct] WebGL context lost"), e.preventDefault(), this._availableAdditionalRenderTargets = [], this._usedAdditionalRenderTargets.clear(), this._effectChainManager.OnContextLost(), this._webglRenderer.OnContextLost(), this._runtime._OnRendererContextLost();
    }
    _OnWebGPUDeviceLost() {
      console.log("[Construct] WebGPU device lost"), this._availableAdditionalRenderTargets = [], this._usedAdditionalRenderTargets.clear(), this._effectChainManager.OnContextLost(), this._runtime._OnRendererContextLost();
    }
    async _OnWebGLContextRestored(e) {
      await this._webglRenderer.OnContextRestored(), await this._InitRenderer(), await this._runtime._OnRendererContextRestored(), console.log("[Construct] WebGL context restored");
    }
    async _OnWebGPUDeviceRestored() {
      await this._InitRenderer(), await this._runtime._OnRendererContextRestored(), console.log("[Construct] WebGPU device restored");
    }
    GetWebGLRenderer() {
      return this._webglRenderer;
    }
    GetWebGPURenderer() {
      return this._webgpuRenderer;
    }
    GetRenderer() {
      return this._webgpuRenderer || this._webglRenderer;
    }
    GetIRenderer() {
      return this._iRenderer;
    }
    GetRendererString() {
      let e = "";
      return e = this._runtime.GetWebGPURenderer() ? "webgpu" : "webgl" + this._runtime.GetWebGLRenderer().GetWebGLVersionNumber(), this._runtime.GetRenderer().HasMajorPerformanceCaveat() && (e += "-software"), e;
    }
    GetRendererDetailString() {
      return this._runtime.GetWebGPURenderer() ? this._runtime.GetWebGPURenderer().GetAdapterInfoString() : this._runtime.GetWebGLRenderer().GetUnmaskedRenderer();
    }
    GetRenderScale() {
      return "low" === this._fullscreenScalingQuality ? 1 / this._runtime.GetDevicePixelRatio() : this.GetDisplayScale();
    }
    GetDisplayScale() {
      const e = this.GetCurrentFullscreenMode();
      if ("off" === e || "crop" === e) return 1;
      const t2 = this._runtime.GetOriginalViewportWidth(), s = this._runtime.GetOriginalViewportHeight(), i = t2 / s, r2 = this._canvasDeviceWidth / this._canvasDeviceHeight;
      return "scale-inner" !== e && r2 > i || "scale-inner" === e && r2 < i ? this._canvasCssHeight / s : this._canvasCssWidth / t2;
    }
    GetEffectLayerScaleParam() {
      return "low" === this.GetCurrentFullscreenScalingQuality() ? 1 : this.GetDisplayScale();
    }
    GetEffectDevicePixelRatioParam() {
      return "low" === this.GetCurrentFullscreenScalingQuality() ? 1 : this._runtime.GetDevicePixelRatio();
    }
    SetDeviceTransformOffset(e, t2) {
      this._deviceTransformOffX = e, this._deviceTransformOffY = t2;
    }
    SetDeviceTransform(e, t2, s, i = true) {
      t2 = t2 || this._drawWidth, s = s || this._drawHeight;
      const r2 = t2 / 2 + this._deviceTransformOffX, a2 = s / 2 + this._deviceTransformOffY;
      if (i) {
        let i2 = this.GetDefaultProjectionMatrix();
        t2 === this._drawWidth && s === this._drawHeight || (e.CalculatePerspectiveMatrix(tempProjection, t2 / s), i2 = tempProjection), e.SetProjectionMatrix(i2);
      }
      const n = e.CalculateLookAtModelView2(r2, a2, e.GetDefaultCameraZ(s), r2, a2, 0, s);
      e.SetModelViewMatrix(n);
    }
    SetCssTransform(e, t2 = true) {
      const s = this.GetCssWidth(), i = this.GetCssHeight(), r2 = s / 2, a2 = i / 2;
      t2 && e.SetProjectionMatrix(this.GetDefaultProjectionMatrix());
      const n = e.CalculateLookAtModelView2(r2, a2, e.GetDefaultCameraZ(i), r2, a2, 0, i);
      e.SetModelViewMatrix(n);
    }
    GetDeviceWidth() {
      return this._canvasDeviceWidth;
    }
    GetDeviceHeight() {
      return this._canvasDeviceHeight;
    }
    GetCssWidth() {
      return this._canvasCssWidth;
    }
    GetCssHeight() {
      return this._canvasCssHeight;
    }
    GetCanvasClientX() {
      return this._canvasCssOffsetX;
    }
    GetCanvasClientY() {
      return this._canvasCssOffsetY;
    }
    GetHTMLLayerCount() {
      return this._canvasLayers.length;
    }
    _CanUseImageBitmapRenderingContext() {
      return "undefined" != typeof OffscreenCanvas && this.GetMainCanvas() instanceof OffscreenCanvas && ("Chromium" !== C32.Platform.BrowserEngine || C32.Platform.BrowserVersionNumber >= 124);
    }
    async SetHTMLLayerCount(e, t2 = false) {
      if (e < 1) throw new Error("invalid HTML layer count");
      if (this._canvasLayers.length === e) return;
      const s = { "count": e, "layersDomState": this._runtime.GetLayoutManager().GetMainRunningLayout()._GetRootLayers().filter((e2) => e2.IsHTMLElementsLayer()).map((e2) => e2._GetHTMLLayerDOMState()), "immediate": t2, "marginLeft": this._canvasCssOffsetX, "marginTop": this._canvasCssOffsetY, "styleWidth": this._canvasCssWidth, "styleHeight": this._canvasCssHeight };
      let i;
      if (i = this.IsInWorker() ? await this._runtime.PostComponentMessageToDOMAsync("canvas", "set-html-layer-count", s) : self["c3_runtimeInterface"]["_OnSetHTMLLayerCount"](s), e < this._canvasLayers.length) this._canvasLayers.length = e;
      else for (const e2 of i["addedCanvases"]) {
        e2.width = this._canvasDeviceWidth, e2.height = this._canvasDeviceHeight;
        const t3 = this._CanUseImageBitmapRenderingContext() ? "bitmaprenderer" : "2d", s2 = e2.getContext(t3);
        if (!s2) throw new Error(`failed to acquire '${t3}' canvas context`);
        this._canvasLayers.push({ canvas: e2, ctx: s2 });
      }
      this._runtime.UpdateRender();
    }
    BlitMainCanvasToHTMLLayerCanvas(e) {
      if (e >= this._canvasLayers.length) return;
      const t2 = this.GetMainCanvas(), s = this._canvasLayers[e].ctx;
      this._CanUseImageBitmapRenderingContext() ? s["transferFromImageBitmap"](t2["transferToImageBitmap"]()) : (s.globalCompositeOperation = "copy", s.drawImage(t2, 0, 0));
    }
    GetAdditionalRenderTarget(e) {
      e.depth = this._runtime.Uses3DFeatures();
      const t2 = this._availableAdditionalRenderTargets, s = t2.findIndex((t3) => t3.IsCompatibleWithOptions(e));
      let i;
      return -1 !== s ? (i = t2[s], t2.splice(s, 1)) : i = this.GetRenderer().CreateRenderTarget(e), this._usedAdditionalRenderTargets.add(i), i;
    }
    ReleaseAdditionalRenderTarget(e) {
      if (!this._usedAdditionalRenderTargets.has(e)) throw new Error("render target not in use");
      this._usedAdditionalRenderTargets.delete(e), this._availableAdditionalRenderTargets.push(e);
    }
    GetEffectCompositorRenderTarget() {
      const e = { sampling: this._runtime.GetSampling() };
      return "low" === this.GetCurrentFullscreenScalingQuality() && (e.width = this.GetDrawWidth(), e.height = this.GetDrawHeight()), this.GetAdditionalRenderTarget(e);
    }
    ReleaseEffectCompositorRenderTarget(e) {
      this.ReleaseAdditionalRenderTarget(e);
    }
    *activeLayersGpuProfiles() {
      for (const e of this._runtime.GetLayoutManager().runningLayouts()) for (const t2 of e.GetLayers()) {
        const e2 = this._layersGpuProfile.get(t2);
        e2 && (yield e2);
      }
    }
    GetLayerTimingsBuffer(e) {
      if (!this.GetRenderer().SupportsGPUProfiling()) return null;
      let t2 = this._layersGpuProfile.get(e);
      return t2 || (t2 = { layer: e, name: e.GetName(), timingsBuffer: C32.New(C32.Gfx.WebGLQueryResultBuffer, this._webglRenderer), curUtilisation: 0, lastTotalUtilisation: 0, lastSelfUtilisation: 0 }, this._layersGpuProfile.set(e, t2)), t2.timingsBuffer;
    }
    _Update1sFrameRange() {
      const e = this.GetRenderer();
      if (e.SupportsGPUProfiling() && 0 === this._gpuTimeEndFrame) {
        this._gpuTimeEndFrame = e.GetFrameNumber(), this._gpuCurUtilisation = NaN;
        for (const e2 of this.activeLayersGpuProfiles()) e2.curUtilisation = NaN;
      }
    }
    _UpdateTick() {
      this._webglRenderer && this._webglRenderer.SupportsGPUProfiling() && this._UpdateTick_WebGL(), this._webgpuRenderer && this._webgpuRenderer.SupportsGPUProfiling() && this._UpdateTick_WebGPU();
    }
    _UpdateTick_WebGL() {
      if (isNaN(this._gpuCurUtilisation) && (this._gpuCurUtilisation = this._gpuFrameTimingsBuffer.GetFrameRangeResultSum(this._gpuTimeStartFrame, this._gpuTimeEndFrame), !isNaN(this._gpuCurUtilisation))) {
        if (this._runtime.IsDebug()) {
          for (const e of this.activeLayersGpuProfiles()) if (e.curUtilisation = e.timingsBuffer.GetFrameRangeResultSum(this._gpuTimeStartFrame, this._gpuTimeEndFrame), isNaN(e.curUtilisation)) return;
        }
        if (this._gpuFrameTimingsBuffer.DeleteAllBeforeFrameNumber(this._gpuTimeEndFrame), this._gpuLastUtilisation = Math.min(this._gpuCurUtilisation, 1), this._runtime.IsDebug()) {
          const e = /* @__PURE__ */ new Map();
          for (const t3 of this.activeLayersGpuProfiles()) t3.timingsBuffer.DeleteAllBeforeFrameNumber(this._gpuTimeEndFrame), t3.lastTotalUtilisation = Math.min(t3.curUtilisation, 1), e.set(t3.layer, t3.lastTotalUtilisation);
          for (const t3 of this.activeLayersGpuProfiles()) {
            const s2 = t3.layer, i = (e.get(s2) || 0) - s2.GetSubLayers().reduce((t4, s3) => t4 + (e.get(s3) || 0), 0);
            t3.lastSelfUtilisation = C32.clamp(i, 0, 1);
          }
          const t2 = this._runtime.GetMainRunningLayout(), s = this._gpuLastUtilisation - t2._GetRootLayers().reduce((t3, s2) => t3 + (e.get(s2) || 0), 0);
          self.C3Debugger.UpdateGPUProfile(C32.clamp(s, 0, 1), this._gpuLastUtilisation, [...this.activeLayersGpuProfiles()]);
        }
        this._gpuTimeStartFrame = this._gpuTimeEndFrame, this._gpuTimeEndFrame = 0;
      }
    }
    GetGPUFrameTimingsBuffer() {
      return this._gpuFrameTimingsBuffer;
    }
    _UpdateTick_WebGPU() {
      if (0 === this._gpuTimeEndFrame) return;
      for (let e2 = this._gpuTimeStartFrame; e2 < this._gpuTimeEndFrame; ++e2) {
        const t3 = this._webgpuFrameTimings.get(e2);
        if (t3 && !t3.HasResult()) return;
      }
      const e = this._runtime.GetMainRunningLayout(), t2 = C32.MakeFilledArray(e.GetLayerCount() + 1, 0);
      let s = 0;
      for (let e2 = this._gpuTimeStartFrame; e2 < this._gpuTimeEndFrame; ++e2) {
        const i = this._webgpuFrameTimings.get(e2);
        if (!i) continue;
        const r2 = i.GetResult();
        let a2 = BigInt(0), n = BigInt(0);
        const h2 = BigInt(0);
        for (let e3 = 0, s2 = Math.min(t2.length, r2.length / 2); e3 < s2; ++e3) {
          const s3 = r2[2 * e3], i2 = r2[2 * e3 + 1];
          s3 !== h2 && (a2 === h2 || s3 < a2) && (a2 = s3), i2 > n && (n = i2);
          const o2 = Number(i2 - s3) / 1e9;
          t2[e3] += o2;
        }
        s += Number(n - a2) / 1e9;
      }
      if (this._gpuLastUtilisation = C32.clamp(s, 0, 1), this._runtime.IsDebug()) {
        const s2 = e.GetLayers(), i = /* @__PURE__ */ new Map();
        for (let e2 = 0, r3 = Math.min(s2.length, t2.length - 1); e2 < r3; ++e2) {
          const r4 = t2[e2 + 1];
          i.set(s2[e2], r4);
        }
        const r2 = [], a2 = /* @__PURE__ */ new Map();
        for (const [e2, t3] of i) {
          const s3 = [...e2.selfAndAllSubLayers()].reduce((e3, t4) => e3 + (i.get(t4) || 0), 0);
          a2.set(e2, s3), r2.push({ name: e2.GetName(), lastSelfUtilisation: C32.clamp(t3, 0, 1), lastTotalUtilisation: C32.clamp(s3, 0, 1) });
        }
        const n = this._gpuLastUtilisation - e._GetRootLayers().reduce((e2, t3) => e2 + (a2.get(t3) || 0), 0);
        self.C3Debugger.UpdateGPUProfile(C32.clamp(n, 0, 1), this._gpuLastUtilisation, r2);
      }
      for (let e2 = this._gpuTimeStartFrame; e2 < this._gpuTimeEndFrame; ++e2) this._webgpuFrameTimings.delete(e2);
      this._gpuTimeStartFrame = this._gpuTimeEndFrame, this._gpuTimeEndFrame = 0;
    }
    _AddWebGPUFrameTiming(e) {
      this._webgpuFrameTimings.set(this._webgpuRenderer.GetFrameNumber(), e);
    }
    GetGPUUtilisation() {
      return this._gpuLastUtilisation;
    }
    SnapshotCanvas(e, t2, s, i, r2, a2) {
      return this._snapshotFormat = e, this._snapshotQuality = t2, this._snapshotArea.setWH(s, i, r2, a2), this._snapshotPromise || (this._snapshotPromise = new Promise((e2) => {
        this._snapshotResolve = e2;
      })), this._snapshotPromise;
    }
    _MaybeTakeSnapshot() {
      if (!this._snapshotFormat) return;
      let e = this.GetMainCanvas();
      const t2 = this._snapshotArea, s = C32.clamp(Math.floor(t2.getLeft()), 0, e.width), i = C32.clamp(Math.floor(t2.getTop()), 0, e.height);
      let r2 = t2.width();
      r2 = 0 === r2 ? e.width - s : C32.clamp(Math.floor(r2), 0, e.width - s);
      let a2 = t2.height();
      if (a2 = 0 === a2 ? e.height - i : C32.clamp(Math.floor(a2), 0, e.height - i), (0 !== s || 0 !== i || r2 !== e.width || a2 !== e.height) && r2 > 0 && a2 > 0) {
        const t3 = C32.CreateCanvas(r2, a2);
        t3.getContext("2d").drawImage(e, s, i, r2, a2, 0, 0, r2, a2), e = t3;
      }
      C32.CanvasToBlob(e, this._snapshotFormat, this._snapshotQuality).then((e2) => {
        this._snapshotUrl && URL.revokeObjectURL(this._snapshotUrl), this._snapshotUrl = URL.createObjectURL(e2), this._snapshotPromise = null, this._snapshotResolve(e2);
      }), this._snapshotFormat = "", this._snapshotQuality = 1;
    }
    GetCanvasSnapshotUrl() {
      return this._snapshotUrl;
    }
    SetIsPastingToDrawingCanvas(e) {
      e ? this._isPastingToDrawingCanvas++ : this._isPastingToDrawingCanvas--;
    }
    IsPastingToDrawingCanvas() {
      return this._isPastingToDrawingCanvas > 0;
    }
    InitLoadingScreen(e) {
      const t2 = this.GetRenderer();
      if (2 === e) this._percentText = C32.New(C32.Gfx.RendererText, this.GetRenderer()), this._percentText.SetFontName("Arial"), this._percentText.SetFontSize(16), this._percentText.SetHorizontalAlignment("center"), this._percentText.SetVerticalAlignment("center"), this._percentText.SetSize(300, 200);
      else if (0 === e) {
        const e2 = this._runtime.GetLoadingLogoAsset();
        e2 && e2.LoadStaticTexture(t2).catch((e3) => console.warn("[C3 runtime] Failed to create texture for loading logo: ", e3));
      } else 4 === e && (this._LoadSvgSplashImage("splash-images/splash-logo.svg").then((e2) => {
        "done" === this._splashState ? t2.DeleteTexture(e2) : this._splashTextures.logo = e2;
      }).catch((e2) => console.warn("Failed to load splash image: ", e2)), this._LoadBitmapSplashImage("splash-images/splash-poweredby-512.png").then((e2) => {
        "done" === this._splashState ? t2.DeleteTexture(e2) : this._splashTextures.powered = e2;
      }).catch((e2) => console.warn("Failed to load splash image: ", e2)), this._LoadBitmapSplashImage("splash-images/splash-website-512.png").then((e2) => {
        "done" === this._splashState ? t2.DeleteTexture(e2) : this._splashTextures.website = e2;
      }).catch((e2) => console.warn("Failed to load splash image: ", e2)));
    }
    async _LoadSvgSplashImage(e) {
      e = new URL(e, this._runtime.GetRuntimeBaseURL()).toString();
      const t2 = await C32.FetchBlob(e), s = await this._runtime.RasterSvgImage(t2, 2048, 2048);
      return await this.GetRenderer().CreateStaticTextureAsync(s, { mipMapQuality: "high" });
    }
    async _LoadBitmapSplashImage(e) {
      e = new URL(e, this._runtime.GetRuntimeBaseURL()).toString();
      const t2 = await C32.FetchBlob(e);
      return await this.GetRenderer().CreateStaticTextureAsync(t2, { mipMapQuality: "high" });
    }
    HideCordovaSplashScreen() {
      this._runtime.PostComponentMessageToDOM("runtime", "hide-cordova-splash");
    }
    StartLoadingScreen() {
      this._loaderStartTime = Date.now(), this._runtime.Dispatcher().addEventListener("loadingprogress", this._loadingprogress_handler), this._rafId = requestAnimationFrame(() => this._DrawLoadingScreen());
      3 !== this._runtime.GetLoaderStyle() && this.HideCordovaSplashScreen();
    }
    async EndLoadingScreen() {
      const e = this.GetRenderer();
      this._loadingProgress = 1;
      const t2 = this._runtime.GetLoaderStyle();
      4 === t2 && await this._splashDonePromise, this._splashDoneResolve = null, this._splashDonePromise = null, -1 !== this._rafId && (cancelAnimationFrame(this._rafId), this._rafId = -1), this._runtime.Dispatcher().removeEventListener("loadingprogress", this._loadingprogress_handler), this._loadingprogress_handler = null, this._percentText && (this._percentText.Release(), this._percentText = null), this._runtime.ReleaseLoadingLogoAsset(), e.Start(), this._splashTextures.logo && (e.DeleteTexture(this._splashTextures.logo), this._splashTextures.logo = null), this._splashTextures.powered && (e.DeleteTexture(this._splashTextures.powered), this._splashTextures.powered = null), this._splashTextures.website && (e.DeleteTexture(this._splashTextures.website), this._splashTextures.website = null), e.ClearRgba(0, 0, 0, 0), e.Finish(), this._splashState = "done", this._gpuTimeStartFrame = e.GetFrameNumber(), 3 === t2 && this.HideCordovaSplashScreen();
    }
    _DrawLoadingScreen() {
      if (-1 === this._rafId) return;
      const e = this.GetRenderer();
      e.Start(), this._rafId = -1;
      const t2 = this._runtime.GetAssetManager().HasHadErrorLoading(), s = this._runtime.GetLoaderStyle();
      if (3 !== s && (this.SetCssTransform(e), e.ClearRgba(0, 0, 0, 0), e.ResetColor(), e.SetTextureFillMode(), e.SetTexture(null)), 0 === s) this._DrawProgressBarAndLogoLoadingScreen(t2);
      else if (1 === s) this._DrawProgressBarLoadingScreen(t2, 120, 0);
      else if (2 === s) this._DrawPercentTextLoadingScreen(t2);
      else if (3 === s) C32.noop();
      else {
        if (4 !== s) throw new Error("invalid loader style");
        this._DrawSplashLoadingScreen(t2);
      }
      e.Finish(), this._rafId = requestAnimationFrame(() => this._DrawLoadingScreen());
    }
    _DrawPercentTextLoadingScreen(e) {
      e ? this._percentText.SetColorRgb(1, 0, 0) : this._percentText.SetColorRgb(0.6, 0.6, 0.6), this._percentText.SetText(Math.round(100 * this._loadingProgress) + "%");
      const t2 = this._canvasCssWidth / 2, s = this._canvasCssHeight / 2;
      tempQuad.setRect(t2 - 150, s - 100, t2 + 150, s + 100);
      const i = this.GetRenderer();
      i.SetTexture(this._percentText.GetTexture()), i.Quad3(tempQuad, this._percentText.GetTexRect());
    }
    _DrawProgressBarLoadingScreen(e, t2, s) {
      const i = this.GetRenderer();
      i.SetColorFillMode(), e ? i.SetColorRgba(1, 0, 0, 1) : i.SetColorRgba(0.118, 0.565, 1, 1);
      const r2 = this._canvasCssWidth / 2, a2 = this._canvasCssHeight / 2, n = t2 / 2;
      tempRect.setWH(r2 - n, a2 - 4 + s, Math.floor(t2 * this._loadingProgress), 8), i.Rect(tempRect), tempRect.setWH(r2 - n, a2 - 4 + s, t2, 8), tempRect.offset(-0.5, -0.5), tempRect.inflate(0.5, 0.5), i.SetColorRgba(0, 0, 0, 1), i.LineRect2(tempRect), tempRect.inflate(1, 1), i.SetColorRgba(1, 1, 1, 1), i.LineRect2(tempRect);
    }
    _DrawProgressBarAndLogoLoadingScreen(e) {
      const t2 = this.GetRenderer(), s = this._runtime.GetLoadingLogoAsset();
      if (!s) return void this._DrawProgressBarLoadingScreen(e, 120, 0);
      const i = s.GetTexture();
      if (!i) return void this._DrawProgressBarLoadingScreen(e, 120, 0);
      const r2 = i.GetWidth(), a2 = i.GetHeight(), n = this._canvasCssWidth / 2, h2 = this._canvasCssHeight / 2, o2 = r2 / 2, l = a2 / 2;
      tempQuad.setRect(n - o2, h2 - l, n + o2, h2 + l), t2.SetTexture(i), t2.Quad(tempQuad), this._DrawProgressBarLoadingScreen(e, r2, l + 16);
    }
    _DrawSplashLoadingScreen(e) {
      const t2 = this.GetRenderer(), s = this._splashTextures.logo, i = this._splashTextures.powered, r2 = this._splashTextures.website, a2 = Date.now();
      0 === this._splashFrameNumber && (this._loaderStartTime = a2);
      const n = this._runtime.IsPreview() || this._runtime.IsFBInstantAvailable() && !this._runtime.IsCordova(), h2 = n ? 0 : 200, o2 = n ? 0 : 3e3;
      let l = 1;
      "fade-in" === this._splashState ? l = Math.min((a2 - this._loaderStartTime) / 300, 1) : "fade-out" === this._splashState && (l = Math.max(1 - (a2 - this._splashFadeOutStartTime) / 300, 0)), t2.SetColorFillMode(), t2.SetColorRgba(0.231 * l, 0.251 * l, 0.271 * l, l), tempRect.set(0, 0, this._canvasCssWidth, this._canvasCssHeight), t2.Rect(tempRect);
      const c2 = Math.ceil(this._canvasCssWidth), _2 = Math.ceil(this._canvasCssHeight);
      let d2, u2;
      this._canvasCssHeight > 256 ? (t2.SetColorRgba(0.302 * l, 0.334 * l, 0.365 * l, l), d2 = c2, u2 = Math.max(5e-3 * _2, 2), tempRect.setWH(0, 0.8 * _2 - u2 / 2, d2, u2), t2.Rect(tempRect), e ? t2.SetColorRgba(l, 0, 0, l) : t2.SetColorRgba(0.161 * l, 0.953 * l, 0.816 * l, l), d2 = c2 * this._loadingProgress, tempRect.setWH(0.5 * c2 - d2 / 2, 0.8 * _2 - u2 / 2, d2, u2), t2.Rect(tempRect), t2.SetColorRgba(l, l, l, l), t2.SetTextureFillMode(), i && (d2 = 1.5 * C32.clamp(0.22 * _2, 105, 0.6 * c2), u2 = d2 / 8, tempRect.setWH(0.5 * c2 - d2 / 2, 0.2 * _2 - u2 / 2, d2, u2), t2.SetTexture(i), t2.Rect(tempRect)), s && (d2 = Math.min(0.395 * _2, 0.95 * c2), u2 = d2, tempRect.setWH(0.5 * c2 - d2 / 2, 0.485 * _2 - u2 / 2, d2, u2), t2.SetTexture(s), t2.Rect(tempRect)), r2 && (d2 = 1.5 * C32.clamp(0.22 * _2, 105, 0.6 * c2), u2 = d2 / 8, tempRect.setWH(0.5 * c2 - d2 / 2, 0.868 * _2 - u2 / 2, d2, u2), t2.SetTexture(r2), t2.Rect(tempRect))) : (t2.SetColorRgba(0.302 * l, 0.334 * l, 0.365 * l, l), d2 = c2, u2 = Math.max(5e-3 * _2, 2), tempRect.setWH(0, 0.85 * _2 - u2 / 2, d2, u2), t2.Rect(tempRect), e ? t2.SetColorRgba(l, 0, 0, l) : t2.SetColorRgba(0.161 * l, 0.953 * l, 0.816 * l, l), d2 = c2 * this._loadingProgress, tempRect.setWH(0.5 * c2 - d2 / 2, 0.85 * _2 - u2 / 2, d2, u2), t2.Rect(tempRect), t2.SetColorRgba(l, l, l, l), t2.SetTextureFillMode(), s && (d2 = 0.55 * _2, u2 = d2, tempRect.setWH(0.5 * c2 - d2 / 2, 0.45 * _2 - u2 / 2, d2, u2), t2.SetTexture(s), t2.Rect(tempRect))), this._splashFrameNumber++, "fade-in" === this._splashState && a2 - this._loaderStartTime >= 300 && this._splashFrameNumber >= 2 && (this._splashState = "wait", this._splashFadeInFinishTime = a2), "wait" === this._splashState && a2 - this._splashFadeInFinishTime >= o2 && this._loadingProgress >= 1 && (this._splashState = "fade-out", this._splashFadeOutStartTime = a2), ("fade-out" === this._splashState && a2 - this._splashFadeOutStartTime >= 300 + h2 || n && this._loadingProgress >= 1 && a2 - this._loaderStartTime < 500) && this._splashDoneResolve();
    }
  };
}
{
  const C32 = self.C3, C3Debugger = self.C3Debugger, assert = self.assert, ISDKBehaviorInstanceBase = self.ISDKBehaviorInstanceBase, DEFAULT_RUNTIME_OPTS = { "messagePort": null, "runtimeBaseUrl": "", "headless": false, "hasDom": true, "isInWorker": false, "useAudio": true, "exportType": "" };
  let ife = true;
  C32.Runtime = class extends C32.DefendedBase {
    constructor(e) {
      e = Object.assign({}, DEFAULT_RUNTIME_OPTS, e), super(), this._messagePort = e["messagePort"], this._runtimeBaseUrl = e["runtimeBaseUrl"], this._previewUrl = e["previewUrl"], this._isHeadless = !!e["headless"], this._hasDom = !!e["hasDom"], this._isInWorker = !!e["isInWorker"], ife = e["ife"], this._useAudio = !!e["useAudio"], this._exportType = e["exportType"], this._isiOSCordova = !!e["isiOSCordova"], this._isiOSWebView = !!e["isiOSWebView"], this._isWindowsWebView2 = !!e["isWindowsWebView2"], this._isAnyWebView2Wrapper = !!e["isAnyWebView2Wrapper"], this._isFBInstantAvailable = !!e["isFBInstantAvailable"], this._isDebug = !("preview" !== this._exportType || !e["isDebug"]), this._breakpointsEnabled = this._isDebug, this._isDebugging = this._isDebug, this._debuggingDisabled = 0, this._additionalLoadPromises = [], this._additionalCreatePromises = [], this._isUsingCreatePromises = false, this._projectName = "", this._projectVersion = "", this._projectUniqueId = "", this._appId = "", this._exportTimestamp = 0, this._originalViewportWidth = 0, this._originalViewportHeight = 0, this._devicePixelRatio = self.devicePixelRatio, this._parallaxXorigin = 0, this._parallaxYorigin = 0, this._viewportWidth = 0, this._viewportHeight = 0, this._loaderStyle = 0, this._usesLoaderLayout = false, this._isLoading = true, this._usesAnyBackgroundBlending = false, this._usesAnyCrossSampling = false, this._usesAnyDepthSampling = false, this._loadingLogoAsset = null, this._assetManager = C32.New(C32.AssetManager, this, e), this._layoutManager = C32.New(C32.LayoutManager, this), this._eventSheetManager = C32.New(C32.EventSheetManager, this), this._addonManager = C32.New(C32.AddonManager, this, e["wrapperComponentIds"]), this._collisionEngine = C32.New(C32.CollisionEngine, this), this._timelineManager = C32.New(C32.TimelineManager, this), this._transitionManager = C32.New(C32.TransitionManager, this), this._templateManager = C32.New(C32.TemplateManager, this), this._flowchartManager = C32.New(C32.FlowchartManager, this), this._textIconManager = C32.New(C32.TextIconManager, { getIconSetMeta: (e2) => this._GetTextIconSetMeta(e2), getIconSetContent: (e2) => this._GetTextIconSetContent(e2) }), this._iconChangeHandlers = /* @__PURE__ */ new Map(), this._allObjectClasses = [], this._objectClassesByName = /* @__PURE__ */ new Map(), this._objectClassesBySid = /* @__PURE__ */ new Map(), this._familyCount = 0, this._allContainers = [], this._allEffectLists = /* @__PURE__ */ new Set(), this._currentLayoutStack = [], this._instancesPendingCreate = [], this._instancesPendingDestroy = /* @__PURE__ */ new Map(), this._hasPendingInstances = false, this._isFlushingPendingInstances = false, this._objectCount = 0, this._nextUid = 0, this._instancesByUid = /* @__PURE__ */ new Map(), this._instancesPendingRelease = /* @__PURE__ */ new Set(), this._instancesPendingReleaseAffectedObjectClasses = /* @__PURE__ */ new Set(), this._objectReferenceTable = [], this._jsPropNameTable = [], this._canvasManager = null, this._uses3dFeatures = false, this._framerateMode = "vsync", this._sampling = "trilinear", this._isPixelRoundingEnabled = false, this._needRender = true, this._pauseOnBlur = false, this._isPausedOnBlur = false, this._exportToVideo = null, this._tickCallbacks = { normal: (e2) => {
        this._rafId = -1, this._ruafId = -1, this.Tick(e2);
      }, tickOnly: (e2) => {
        this._ruafId = -1, this.Tick(e2, false, "skip-render");
      }, renderOnly: () => {
        this._rafId = -1, this.Render();
      } }, this._rafId = -1, this._ruafId = -1, this._tickCount = 0, this._tickCountNoSave = 0, this._hasStarted = false, this._isInTick = false, this._hasStartedTicking = false, this._isLayoutFirstTick = true, this._isAutoSuspendEnabled = true, this._isPageVisibilitySuspended = false, this._suspendCount = 0, this._scheduleTriggersThrottle = new C32.PromiseThrottle(1), this._randomNumberCallback = () => Math.random(), this._startTime = 0, this._lastTickTime = 0, this._dtRaw = 0, this._dt1 = 0, this._dt = 0, this._timeScale = 1, this._maxDt = 1 / 30, this._minDt = 0, this._gameTime = C32.New(C32.KahanSum), this._gameTimeRaw = C32.New(C32.KahanSum), this._wallTime = C32.New(C32.KahanSum), this._instanceTimes = /* @__PURE__ */ new Map(), this._fpsFrameCount = -1, this._fpsLastTime = 0, this._fps = 0, this._tpsTickCount = -1, this._tps = 0, this._mainThreadTimeCounter = 0, this._mainThreadTime = 0, this._isLoadingState = false, this._saveToSlotName = "", this._saveToJsonString = false, this._loadFromSlotName = "", this._loadFromJson = null, this._lastSaveJson = "", this._projectStorage = null, this._savegamesStorage = null, this._dispatcher = C32.New(C32.Event.Dispatcher), this._domEventHandlers = /* @__PURE__ */ new Map(), this._pendingResponsePromises = /* @__PURE__ */ new Map(), this._nextDomResponseId = 0, this._didRequestDeviceOrientationEvent = false, this._didRequestDeviceMotionEvent = false, this._isReadyToHandleEvents = false, this._waitingToHandleEvents = [], this._eventObjects = { "pretick": C32.New(C32.Event, "pretick", false), "tick": C32.New(C32.Event, "tick", false), "tick2": C32.New(C32.Event, "tick2", false), "instancecreate": C32.New(C32.Event, "instancecreate", false), "instancedestroy": C32.New(C32.Event, "instancedestroy", false), "beforelayoutchange": C32.New(C32.Event, "beforelayoutchange", false), "layoutchange": C32.New(C32.Event, "layoutchange", false), "beforerender": C32.New(C32.Event, "beforerender", false), "afterrender": C32.New(C32.Event, "afterrender", false) }, this._eventObjects["instancecreate"].instance = null, this._eventObjects["instancedestroy"].instance = null, this._userScriptDispatcher = C32.New(C32.Event.Dispatcher), this._userScriptEventObjects = null;
      const t2 = (e2, t3) => C32.BehaviorInstance.SortByTickSequence(this, e2, t3);
      this._behInstsToTick = C32.New(C32.RedBlackSet, t2), this._behInstsToPostTick = C32.New(C32.RedBlackSet, t2), this._behInstsToTick2 = C32.New(C32.RedBlackSet, t2), this._jobScheduler = C32.New(C32.JobSchedulerRuntime, this, e["jobScheduler"]), e["canvas"] && (this._canvasManager = C32.New(C32.CanvasManager, this)), this._messagePort.onmessage = (e2) => this["_OnMessageFromDOM"](e2.data), this.AddDOMComponentMessageHandler("runtime", "visibilitychange", (e2) => this._OnVisibilityChange(e2)), this.AddDOMComponentMessageHandler("runtime", "wrapper-extension-message", (e2) => this._OnWrapperExtensionMessage(e2)), this.AddDOMComponentMessageHandler("runtime", "get-remote-preview-status-info", () => this._GetRemotePreviewStatusInfo()), this.AddDOMComponentMessageHandler("runtime", "js-invoke-function", (e2) => this._InvokeFunctionFromJS(e2)), this.AddDOMComponentMessageHandler("runtime", "go-to-last-error-script", self["goToLastErrorScript"]), this.AddDOMComponentMessageHandler("runtime", "offline-audio-render-completed", (e2) => this._OnOfflineAudioRenderCompleted(e2)), this._dispatcher.addEventListener("window-blur", (e2) => this._OnWindowBlur(e2)), this._dispatcher.addEventListener("window-focus", () => this._OnWindowFocus()), this._timelineManager.AddRuntimeListeners(), this._templateManager.AddRuntimeListeners(), this._iRuntime = null, this._constructVersionCode = 0, this._interfaceMap = /* @__PURE__ */ new WeakMap(), this._commonScriptInterfaces = { keyboard: null, mouse: null, touch: null, timelineController: null }, this._instancesNeedingAfterLoadMap = /* @__PURE__ */ new WeakMap(), this._instancesNeedingAfterLoadArray = [];
    }
    static Create(e) {
      return C32.New(C32.Runtime, e);
    }
    Release() {
      C32.clearArray(this._allObjectClasses), this._objectClassesByName.clear(), this._objectClassesBySid.clear(), this._layoutManager.Release(), this._layoutManager = null, this._eventSheetManager.Release(), this._eventSheetManager = null, this._addonManager.Release(), this._addonManager = null, this._assetManager.Release(), this._assetManager = null, this._collisionEngine.Release(), this._collisionEngine = null, this._timelineManager.Release(), this._timelineManager = null, this._transitionManager.Release(), this._transitionManager = null, this._templateManager.Release(), this._templateManager = null, this._flowchartManager.Release(), this._flowchartManager = null, this._textIconManager.Release(), this._textIconManager = null, this._canvasManager && (this._canvasManager.Release(), this._canvasManager = null), this._dispatcher.Release(), this._dispatcher = null, this._tickEvent = null;
    }
    "_OnMessageFromDOM"(e) {
      const t2 = e["type"];
      if ("event" === t2) this._OnEventFromDOM(e);
      else {
        if ("result" !== t2) throw new Error(`unknown message '${t2}'`);
        this._OnResultFromDOM(e);
      }
    }
    _OnEventFromDOM(e) {
      if (!this._isReadyToHandleEvents) return void this._waitingToHandleEvents.push(e);
      const t2 = e["component"], s = e["handler"], i = e["data"], n = e["dispatchOpts"], a2 = !(!n || !n["dispatchRuntimeEvent"]), r2 = !(!n || !n["dispatchUserScriptEvent"]), o2 = e["responseId"];
      if ("runtime" === t2) {
        if (a2) {
          const e2 = new C32.Event(s);
          e2.data = i, this._dispatcher.dispatchEventAndWaitAsyncSequential(e2);
        }
        if (r2) {
          const e2 = new C32.Event(s, true);
          if (i) for (const [t3, s2] of Object.entries(i)) e2[t3] = s2;
          this.DispatchUserScriptEvent(e2);
        }
      }
      const h2 = this._domEventHandlers.get(t2);
      if (!h2) return void (a2 || r2 || console.warn(`[Runtime] No DOM event handlers for component '${t2}'`));
      const l = h2.get(s);
      if (!l) return void (a2 || r2 || console.warn(`[Runtime] No DOM handler '${s}' for component '${t2}'`));
      let c2 = null;
      try {
        c2 = l(i);
      } catch (e2) {
        return console.error(`Exception in '${t2}' handler '${s}':`, e2), void (null !== o2 && this._PostResultToDOM(o2, false, "" + e2));
      }
      null !== o2 && (c2 && c2.then ? c2.then((e2) => this._PostResultToDOM(o2, true, e2)).catch((e2) => {
        console.error(`Rejection from '${t2}' handler '${s}':`, e2), this._PostResultToDOM(o2, false, "" + e2);
      }) : this._PostResultToDOM(o2, true, c2));
    }
    _PostResultToDOM(e, t2, s) {
      this._messagePort.postMessage({ "type": "result", "responseId": e, "isOk": t2, "result": s });
    }
    _OnResultFromDOM(e) {
      const t2 = e["responseId"], s = e["isOk"], i = e["result"], n = this._pendingResponsePromises.get(t2);
      s ? n.resolve(i) : n.reject(i), this._pendingResponsePromises.delete(t2);
    }
    AddDOMComponentMessageHandler(e, t2, s) {
      let i = this._domEventHandlers.get(e);
      if (i || (i = /* @__PURE__ */ new Map(), this._domEventHandlers.set(e, i)), i.has(t2)) throw new Error(`[Runtime] Component '${e}' already has handler '${t2}'`);
      i.set(t2, s);
    }
    PostComponentMessageToDOM(e, t2, s, i) {
      this._messagePort.postMessage({ "type": "event", "component": e, "handler": t2, "data": s, "responseId": null }, i);
    }
    PostComponentMessageToDOMAsync(e, t2, s, i) {
      const n = this._nextDomResponseId++, a2 = new Promise((e2, t3) => {
        this._pendingResponsePromises.set(n, { resolve: e2, reject: t3 });
      });
      return this._messagePort.postMessage({ "type": "event", "component": e, "handler": t2, "data": s, "responseId": n }, i), a2;
    }
    SendWrapperExtensionMessage(e, t2, s, i = -1) {
      this.PostComponentMessageToDOM("runtime", "send-wrapper-extension-message", { "componentId": e, "messageId": t2, "params": s, "asyncId": i });
    }
    SendRawWrapperExtensionMessage(e) {
      this.PostComponentMessageToDOM("runtime", "send-raw-wrapper-extension-message", e);
    }
    SendWrapperExtensionMessageAsync(e, t2, s) {
      const i = this._nextDomResponseId++, n = new Promise((e2, t3) => {
        this._pendingResponsePromises.set(i, { resolve: e2, reject: t3 });
      });
      return this.SendWrapperExtensionMessage(e, t2, s, i), n;
    }
    _OnWrapperExtensionMessage(e) {
      if (-1 !== e["asyncId"]) {
        const t2 = e["asyncId"];
        this._pendingResponsePromises.get(t2).resolve(e["params"]), this._pendingResponsePromises.delete(t2);
      } else this._OnEventFromDOM({ "component": "wrapper-extension:" + e["componentId"], "handler": e["messageId"], "data": e["params"], "responseId": null });
    }
    AddWrapperExtensionMessageHandler(e, t2, s) {
      this.AddDOMComponentMessageHandler("wrapper-extension:" + e, t2, s);
    }
    HasWrapperComponentId(e) {
      return this._addonManager.HasWrapperComponentId(e);
    }
    PostToDebugger(e) {
      if (!this.IsDebug()) throw new Error("not in debug mode");
      this.PostComponentMessageToDOM("runtime", "post-to-debugger", e);
    }
    async Init(e) {
      C32.CommonACES_SetRuntime(this), this.IsDebug() ? await C3Debugger.Init(this) : self.C3Debugger && self.C3Debugger.InitPreview(this);
      const t2 = await this._assetManager.FetchJson("data.json");
      if (await this._LoadDataJson(t2), await this._InitialiseCanvas(e), this.IsPreview() || console.info("%cMade with Construct, the game and animation creation tool. Visit: https://www.construct.net", "font-weight: bold"), this.GetWebGLRenderer()) {
        const e2 = this.GetWebGLRenderer();
        console.info(`[C3 runtime] Hosted in ${this.IsInWorker() ? "worker" : "DOM"}, rendering with WebGL ${e2.GetWebGLVersionNumber()} [${e2.GetUnmaskedRenderer()}]`);
      } else this.GetWebGPURenderer() && console.info(`[C3 runtime] Hosted in ${this.IsInWorker() ? "worker" : "DOM"}, rendering with WebGPU [${this.GetWebGPURenderer().GetAdapterInfoString()}]`);
      this.GetRenderer().HasMajorPerformanceCaveat() && console.warn("[C3 runtime] The renderer indicates a major performance caveat. Software rendering may be in use. This can result in significantly degraded performance."), this._isReadyToHandleEvents = true;
      for (const e2 of this._waitingToHandleEvents) this._OnEventFromDOM(e2);
      C32.clearArray(this._waitingToHandleEvents), this._canvasManager && this._canvasManager.StartLoadingScreen();
      for (const t3 of e["runOnStartupFunctions"]) this._additionalLoadPromises.push(this._RunOnStartupFunction(t3));
      if (await Promise.all([this._assetManager.WaitForAllToLoad(false), ...this._additionalLoadPromises]), C32.clearArray(this._additionalLoadPromises), !this._assetManager.HasHadErrorLoading()) return this._canvasManager && await this._canvasManager.EndLoadingScreen(), await this._dispatcher.dispatchEventAndWaitAsync(new C32.Event("beforeruntimestart")), await this.Start(), this._messagePort.postMessage({ "type": "runtime-ready" }), this;
      this._canvasManager && this._canvasManager.HideCordovaSplashScreen();
    }
    async _RunOnStartupFunction(e) {
      try {
        await e(this._iRuntime);
      } catch (e2) {
        console.error("[C3 runtime] Error in runOnStartup function: ", e2);
      }
    }
    async _LoadDataJson(e) {
      const t2 = e["project"];
      this._projectName = t2[0], this._projectVersion = t2[16], this._projectUniqueId = t2[31], this._appId = t2[38], this._exportTimestamp = t2[36];
      const s = t2[39] || "loading-logo.png";
      this._isPixelRoundingEnabled = !!t2[9], this._originalViewportWidth = this._viewportWidth = t2[10], this._originalViewportHeight = this._viewportHeight = t2[11], this._collisionEngine._InitCollisionCellSize(this._originalViewportWidth, this._originalViewportHeight), this._parallaxXorigin = this._originalViewportWidth / 2, this._parallaxYorigin = this._originalViewportHeight / 2, this._framerateMode = t2[37], this._uses3dFeatures = !!t2[40], this._sampling = t2[14], this._usesAnyBackgroundBlending = t2[15], this._usesAnyCrossSampling = t2[42], this._usesAnyDepthSampling = t2[17], this._usesLoaderLayout = !!t2[18], this._loaderStyle = t2[19], this._nextUid = t2[21], this._pauseOnBlur = t2[22], this._constructVersionCode = t2[51];
      const i = this._assetManager;
      i._SetAudioFiles(t2[7], t2[25]), i._SetMediaSubfolder(t2[8]), i._SetFontsSubfolder(t2[32]), i._SetIconsSubfolder(t2[28]), i._SetWebFonts(t2[29]), i._SetExportedFileList(t2[45]), 0 === this._loaderStyle && s && (this._loadingLogoAsset = i.LoadImage({ url: s })), this._canvasManager && (this._canvasManager.SetFullscreenMode(C32.CanvasManager._FullscreenModeNumberToString(t2[12])), this._canvasManager.SetFullscreenScalingQuality(t2[23] ? "high" : "low"), this._canvasManager.SetMipmapsEnabled(0 !== t2[24]), this._canvasManager._SetGPUPowerPreference(t2[34]), this._canvasManager._SetTextureAnisotropy(t2[41]), this._canvasManager._SetWebGPUEnabled(t2[13]), this._canvasManager._SetZAxisScale(t2[30]), this._canvasManager._SetZDistances(t2[46], t2[47]), this._canvasManager._SetInitFieldOfView(t2[26]), this._canvasManager._SetLimitedToWebGL1(t2[48]), this._canvasManager._SetMultitexturingMode(t2[50]));
      const n = t2[43];
      n && await this._LoadExportToVideoData(n), this._InitScriptInterfaces(), this._addonManager.CreateSystemPlugin(), this._objectReferenceTable = self.C3_GetObjectRefTable();
      const a2 = t2[2];
      for (const e2 of a2[1]) this._addonManager.CreateBehavior(e2);
      for (const e2 of a2[0]) this._addonManager.CreatePlugin(e2);
      this._objectReferenceTable = self.C3_GetObjectRefTable(), this._LoadJsPropNameTable(), this._addonManager._InitAddonScriptInterfaces();
      for (const e2 of t2[3]) {
        const t3 = C32.ObjectClass.Create(this, this._allObjectClasses.length, e2);
        this._allObjectClasses.push(t3), this._objectClassesByName.set(t3.GetName().toLowerCase(), t3), this._objectClassesBySid.set(t3.GetSID(), t3);
      }
      for (const e2 of t2[4]) {
        this._allObjectClasses[e2[0]]._LoadFamily(e2);
      }
      for (const e2 of t2[27]) {
        const t3 = e2.map((e3) => this._allObjectClasses[e3]);
        this._allContainers.push(C32.New(C32.Container, this, t3));
      }
      this._InitObjectsScriptInterface();
      for (const e2 of this._allObjectClasses) e2._OnAfterCreate();
      for (const e2 of t2[5]) this._layoutManager.Create(e2);
      const r2 = t2[1];
      if (r2) {
        const e2 = this._layoutManager.GetLayoutByName(r2);
        e2 && this._layoutManager.SetFirstLayout(e2);
      }
      for (const e2 of t2[35]) this._transitionManager.Create(e2);
      for (const e2 of t2[33]) this._timelineManager.Create(e2);
      for (const e2 of t2[44]) this._templateManager.Create(e2);
      this._templateManager.HasTemplates() || (this._templateManager.Release(), this._templateManager = null);
      for (const e2 of t2[49]) this._flowchartManager.Create(e2);
      this._flowchartManager.HasFlowcharts() || (this._flowchartManager.Release(), this._flowchartManager = null);
      for (const e2 of t2[6]) this._eventSheetManager.Create(e2);
      this._eventSheetManager._PostInit(), this._InitGlobalVariableScriptInterface(), C32.clearArray(this._objectReferenceTable), this.FlushPendingInstances();
      let o2 = "any";
      const h2 = t2[20];
      1 === h2 ? o2 = "portrait" : 2 === h2 && (o2 = "landscape"), this.PostComponentMessageToDOM("runtime", "set-target-orientation", { "targetOrientation": o2 });
    }
    async _LoadExportToVideoData(e) {
      const t2 = e["format"];
      "image-sequence" === t2 ? this._exportToVideo = new self.C3ExportToImageSequence(this, e) : "image-sequence-gif" === t2 ? this._exportToVideo = new self.C3ExportToGIF(this, e) : "webm" === t2 ? this._exportToVideo = new self.C3ExportToWebMVideo(this, e) : "mp4" === t2 && (this._exportToVideo = new self.C3ExportToMP4Video(this, e)), this._framerateMode = "unlimited-frame", this._canvasManager.SetFullscreenMode("off"), this._devicePixelRatio = 1, self.devicePixelRatio = 1, await this.PostComponentMessageToDOMAsync("runtime", "set-exporting-to-video", { "message": this._exportToVideo.GetExportingMessageForPercent(0), "duration": this._exportToVideo.GetDuration() });
    }
    GetLoaderStyle() {
      return this._loaderStyle;
    }
    IsExportToVideo() {
      return null !== this._exportToVideo;
    }
    GetExportVideoDuration() {
      return this._exportToVideo.GetDuration();
    }
    GetExportVideoFramerate() {
      return this._exportToVideo.GetFramerate();
    }
    _InitExportToVideo() {
      return this._exportToVideo.Init({ width: this._canvasManager.GetDeviceWidth(), height: this._canvasManager.GetDeviceHeight() });
    }
    _ExportToVideoAddFrame() {
      const e = this._tickCount / this.GetExportVideoFramerate();
      return this._exportToVideo.AddFrame(this._canvasManager.GetMainCanvas(), e);
    }
    _ExportToVideoAddKeyframe() {
      this._exportToVideo && this._exportToVideo.AddKeyframe();
    }
    _OnOfflineAudioRenderCompleted(e) {
      this._exportToVideo.OnOfflineAudioRenderCompleted(e);
    }
    _ExportToVideoFinish() {
      return this._exportToVideo.Finish();
    }
    IsFBInstantAvailable() {
      return this._isFBInstantAvailable;
    }
    IsLoading() {
      return this._isLoading;
    }
    AddLoadPromise(e) {
      this._additionalLoadPromises.push(e);
    }
    SetUsingCreatePromises(e) {
      this._isUsingCreatePromises = !!e;
    }
    AddCreatePromise(e) {
      this._isUsingCreatePromises && this._additionalCreatePromises.push(e);
    }
    GetCreatePromises() {
      return this._additionalCreatePromises;
    }
    _GetNextFamilyIndex() {
      return this._familyCount++;
    }
    GetFamilyCount() {
      return this._familyCount;
    }
    _AddEffectList(e) {
      this._allEffectLists.add(e);
    }
    _RemoveEffectList(e) {
      this._allEffectLists.delete(e);
    }
    _GetAllEffectLists() {
      return this._allEffectLists;
    }
    async _InitialiseCanvas(e) {
      this._canvasManager && (await this._canvasManager.CreateCanvas(e), this._canvasManager.InitLoadingScreen(this._loaderStyle));
    }
    async Start() {
      this._hasStarted = true, this._startTime = Date.now();
      let e = null;
      const t2 = new Promise((t3) => e = t3);
      if (this._usesLoaderLayout) {
        for (const e2 of this._allObjectClasses) e2.IsFamily() || e2.IsOnLoaderLayout() || !e2.IsWorldType() || e2.OnCreate();
        (async () => {
          await this._assetManager.WaitForAllToLoad(true), await t2, this._isLoading = false, this._OnLoadFinished();
        })();
      } else this._isLoading = false;
      this._assetManager.SetInitialLoadFinished(), this.IsDebug() && C3Debugger.RuntimeInit(ife);
      for (const e2 of this._layoutManager.GetAllLayouts()) e2._CreateGlobalNonWorlds();
      this.IsExportToVideo() && await this._InitExportToVideo();
      const s = this._layoutManager.GetFirstLayout();
      await s._Load(null, this.GetRenderer()), await s._StartRunning(true), this._fpsLastTime = performance.now(), e(), this._usesLoaderLayout || this._OnLoadFinished();
      (await this.PostComponentMessageToDOMAsync("runtime", "before-start-ticking"))["isSuspended"] && !this.IsExportToVideo() ? (this._suspendCount++, this._isPageVisibilitySuspended = true) : this.Tick();
    }
    _OnLoadFinished() {
      this.Trigger(C32.Plugins.System.Cnds.OnLoadFinished, null, null), this.PostComponentMessageToDOM("runtime", "register-sw");
    }
    GetObjectReference(e) {
      e = Math.floor(e);
      const t2 = this._objectReferenceTable;
      if (e < 0 || e >= t2.length) throw new Error("invalid object reference");
      return t2[e];
    }
    _LoadJsPropNameTable() {
      for (const e of self.C3_JsPropNameTable) {
        const t2 = C32.first(Object.keys(e));
        this._jsPropNameTable.push(t2);
      }
    }
    GetJsPropName(e) {
      e = Math.floor(e);
      const t2 = this._jsPropNameTable;
      if (e < 0 || e >= t2.length) throw new Error("invalid prop reference");
      return t2[e];
    }
    HasDOM() {
      return this._hasDom;
    }
    IsHeadless() {
      return this._isHeadless;
    }
    IsInWorker() {
      return this._isInWorker;
    }
    GetRuntimeBaseURL() {
      return this._runtimeBaseUrl;
    }
    GetPreviewURL() {
      return this._previewUrl;
    }
    GetEventSheetManager() {
      return this._eventSheetManager;
    }
    GetEventStack() {
      return this._eventSheetManager.GetEventStack();
    }
    GetCurrentEventStackFrame() {
      return this._eventSheetManager.GetCurrentEventStackFrame();
    }
    GetCurrentEvent() {
      return this._eventSheetManager.GetCurrentEvent();
    }
    GetCurrentCondition() {
      return this._eventSheetManager.GetCurrentCondition();
    }
    IsCurrentConditionFirst() {
      return 0 === this.GetCurrentEventStackFrame().GetConditionIndex();
    }
    GetCurrentAction() {
      return this._eventSheetManager.GetCurrentAction();
    }
    GetAddonManager() {
      return this._addonManager;
    }
    GetSystemPlugin() {
      return this._addonManager.GetSystemPlugin();
    }
    GetObjectClassByIndex(e) {
      if ((e = Math.floor(e)) < 0 || e >= this._allObjectClasses.length) throw new RangeError("invalid index");
      return this._allObjectClasses[e];
    }
    GetObjectClassByName(e) {
      return this._objectClassesByName.get(e.toLowerCase()) || null;
    }
    GetObjectClassBySID(e) {
      return this._objectClassesBySid.get(e) || null;
    }
    GetSingleGlobalObjectClassByCtor(e) {
      const t2 = C32.AddonManager.GetPluginByConstructorFunction(e);
      return t2 ? t2.GetSingleGlobalObjectClass() : null;
    }
    GetAllObjectClasses() {
      return this._allObjectClasses;
    }
    *allInstances() {
      for (const e of this._allObjectClasses) e.IsFamily() || (yield* e.instances());
    }
    Dispatcher() {
      return this._dispatcher;
    }
    UserScriptDispatcher() {
      return this._userScriptDispatcher;
    }
    DispatchUserScriptEvent(e) {
      e.runtime = this.GetIRuntime();
      const t2 = this.IsDebug() && !this._eventSheetManager.IsInEventEngine();
      t2 && C3Debugger.StartMeasuringScriptTime(), this._userScriptDispatcher.dispatchEvent(e), t2 && C3Debugger.AddScriptTime();
    }
    DispatchUserScriptEventAsyncWait(e) {
      return e.runtime = this.GetIRuntime(), this._userScriptDispatcher.dispatchEventAndWaitAsync(e);
    }
    GetOriginalViewportWidth() {
      return this._originalViewportWidth;
    }
    GetOriginalViewportHeight() {
      return this._originalViewportHeight;
    }
    SetOriginalViewportSize(e, t2) {
      if (this._originalViewportWidth === e && this._originalViewportHeight === t2) return;
      this._originalViewportWidth = e, this._originalViewportHeight = t2;
      const s = this.GetLayoutManager();
      s.SetAllLayerProjectionChanged(), s.SetAllLayerMVChanged();
    }
    GetViewportWidth() {
      return this._viewportWidth;
    }
    GetViewportHeight() {
      return this._viewportHeight;
    }
    SetViewportSize(e, t2) {
      if (this._viewportWidth === e && this._viewportHeight === t2) return;
      this._viewportWidth = e, this._viewportHeight = t2;
      const s = this.GetLayoutManager();
      s.SetAllLayerProjectionChanged(), s.SetAllLayerMVChanged();
    }
    _SetDevicePixelRatio(e) {
      this.IsExportToVideo() || (this._devicePixelRatio = e);
    }
    GetDevicePixelRatio() {
      return this._devicePixelRatio;
    }
    GetParallaxXOrigin() {
      return this._parallaxXorigin;
    }
    GetParallaxYOrigin() {
      return this._parallaxYorigin;
    }
    GetCanvasManager() {
      return this._canvasManager;
    }
    GetDrawWidth() {
      return this._canvasManager ? this._canvasManager.GetDrawWidth() : this._viewportWidth;
    }
    GetDrawHeight() {
      return this._canvasManager ? this._canvasManager.GetDrawHeight() : this._viewportHeight;
    }
    GetRenderScale() {
      return this._canvasManager ? this._canvasManager.GetRenderScale() : 1;
    }
    GetDisplayScale() {
      return this._canvasManager ? this._canvasManager.GetDisplayScale() : 1;
    }
    GetEffectLayerScaleParam() {
      return this._canvasManager ? this._canvasManager.GetEffectLayerScaleParam() : 1;
    }
    GetEffectDevicePixelRatioParam() {
      return this._canvasManager ? this._canvasManager.GetEffectDevicePixelRatioParam() : 1;
    }
    GetCanvasClientX() {
      return this._canvasManager ? this._canvasManager.GetCanvasClientX() : 0;
    }
    GetCanvasClientY() {
      return this._canvasManager ? this._canvasManager.GetCanvasClientY() : 0;
    }
    GetCanvasCssWidth() {
      return this._canvasManager ? this._canvasManager.GetCssWidth() : 0;
    }
    GetCanvasCssHeight() {
      return this._canvasManager ? this._canvasManager.GetCssHeight() : 0;
    }
    GetFullscreenMode() {
      return this._canvasManager ? this._canvasManager.GetFullscreenMode() : "off";
    }
    GetAdditionalRenderTarget(e) {
      return this._canvasManager ? this._canvasManager.GetAdditionalRenderTarget(e) : null;
    }
    ReleaseAdditionalRenderTarget(e) {
      this._canvasManager && this._canvasManager.ReleaseAdditionalRenderTarget(e);
    }
    UsesAnyBackgroundBlending() {
      return this._usesAnyBackgroundBlending;
    }
    UsesAnyCrossSampling() {
      return this._usesAnyCrossSampling;
    }
    UsesAnyDepthSampling() {
      return this._usesAnyDepthSampling;
    }
    GetGPUUtilisation() {
      return this._canvasManager ? this._canvasManager.GetGPUUtilisation() : NaN;
    }
    IsLinearSampling() {
      return "nearest" !== this.GetSampling();
    }
    GetFramerateMode() {
      return this._framerateMode;
    }
    _SetFramerateMode(e) {
      this._framerateMode !== e && (this._framerateMode = e, -1 === this._rafId && -1 === this._ruafId || (this._CancelAnimationFrame(), this._RequestAnimationFrame()));
    }
    GetSampling() {
      return this._sampling;
    }
    UsesLoaderLayout() {
      return this._usesLoaderLayout;
    }
    GetLoadingLogoAsset() {
      return this._loadingLogoAsset;
    }
    ReleaseLoadingLogoAsset() {
      this._loadingLogoAsset && (this._loadingLogoAsset.ReleaseTexture(), this._loadingLogoAsset.Release(), this._loadingLogoAsset = null);
    }
    GetLayoutManager() {
      return this._layoutManager;
    }
    GetMainRunningLayout() {
      return this._layoutManager.GetMainRunningLayout();
    }
    GetTimelineManager() {
      return this._timelineManager;
    }
    GetTransitionManager() {
      return this._transitionManager;
    }
    GetTemplateManager() {
      return this._templateManager;
    }
    GetFlowchartManager() {
      return this._flowchartManager;
    }
    GetAssetManager() {
      return this._assetManager;
    }
    LoadImage(e) {
      return this._assetManager.LoadImage(e);
    }
    CreateInstance(e, t2, s, i, n, a2) {
      if (a2 && this._templateManager) {
        if (e instanceof C32.ObjectClass && e.IsFamily()) {
          const r3 = e.GetFamilyMembers(), o2 = Math.floor(this.Random() * r3.length);
          return this.CreateInstance(r3[o2], t2, s, i, n, a2);
        }
        const r2 = this._templateManager.GetTemplateData(e, a2);
        if (r2) {
          const e2 = this.CreateInstanceFromData(r2, t2, false, s, i, false, n, void 0, n);
          return this._templateManager.MapInstanceToTemplateName(e2, a2), e2;
        }
      }
      return this.CreateInstanceFromData(e, t2, false, s, i, false, n, void 0, n);
    }
    CreateInstanceFromData(e, t2, s, i, n, a2, r2, o2, h2) {
      let l = null, c2 = null;
      if (e instanceof C32.ObjectClass) {
        if (c2 = e, c2.IsFamily()) {
          const e2 = c2.GetFamilyMembers();
          c2 = e2[Math.floor(this.Random() * e2.length)];
        }
        l = c2.GetDefaultInstanceData();
      } else l = e, c2 = this.GetObjectClassByIndex(l[1]);
      const d2 = c2.GetPlugin().IsWorldType();
      if (this._isLoading && d2 && !c2.IsOnLoaderLayout()) return null;
      const _2 = t2;
      let u2;
      d2 || (t2 = null), u2 = s && !a2 && l && !this._instancesByUid.has(l[2]) ? l[2] : this._nextUid++;
      const g2 = l ? l[0] : null, m2 = C32.New(C32.Instance, { runtime: this, objectType: c2, layer: t2, worldData: g2, instVarData: l ? l[3] : null, uid: u2, tags: l ? l[6] : null });
      this._instancesByUid.set(u2, m2);
      let p2 = null;
      if (d2 && (p2 = m2.GetWorldInfo(), void 0 !== i && void 0 !== n && (p2.SetX(i), p2.SetY(n)), c2._SetAnyCollisionCellChanged(true)), t2 && (h2 || t2._AddInstance(m2, true), t2.GetLayout().MaybeLoadTexturesFor(c2)), this._objectCount++, c2.IsInContainer() && !s && !a2) {
        const e2 = /* @__PURE__ */ new Set();
        for (const t3 of c2.GetContainer().objectTypes()) {
          if (t3 === c2) continue;
          const s2 = this._MaybeGetChildInstanceForObjectTypeData(t3, p2, e2);
          if (s2) {
            const e3 = this.CreateInstanceFromData(s2, _2, false, p2 ? p2.GetX() : i, p2 ? p2.GetY() : n, true, false, void 0, h2);
            m2._AddSibling(e3);
          } else {
            const e3 = this.CreateInstanceFromData(t3, _2, false, p2 ? p2.GetX() : i, p2 ? p2.GetY() : n, true, false, void 0, h2);
            m2._AddSibling(e3);
          }
        }
        for (const e3 of m2.siblings()) {
          e3._AddSibling(m2);
          for (const t3 of m2.siblings()) e3 !== t3 && e3._AddSibling(t3);
        }
      }
      if (d2 && !s && r2 && this._CreateChildInstancesFromData(m2, g2, p2, t2, i, n, h2), c2.IsInContainer() && !s && !a2 && r2) for (const e2 of m2.siblings()) {
        const s2 = e2.GetWorldInfo();
        if (!s2) continue;
        const i2 = e2.GetPlugin(), n2 = e2.GetObjectClass().GetDefaultInstanceData()[0];
        i2.IsWorldType() ? this._CreateChildInstancesFromData(e2, n2, s2, t2, s2.GetX(), s2.GetY(), h2) : this._CreateChildInstancesFromData(e2, n2, s2, t2, void 0, void 0, h2);
      }
      if (!a2 && r2) {
        void 0 === i && (i = g2[0]), void 0 === n && (n = g2[1]);
        const e2 = p2.GetTopParent(), t3 = i - p2.GetX() + e2.GetX(), s2 = n - p2.GetY() + e2.GetY();
        e2.SetXY(t3, s2);
      }
      c2._SetIIDsStale();
      const f2 = l ? C32.cloneArray(l[5]) : null, C2 = l ? l[4].map((e2) => C32.cloneArray(e2)) : null, S2 = d2 && g2 && g2[13];
      if (S2 && m2._SetHasTilemap(), m2._CreateSdkInstance(f2, C2), S2) {
        const e2 = g2[13];
        m2.GetSdkInstance().LoadTilemapData(e2[2], e2[0], e2[1]);
      }
      this._instancesPendingCreate.push(m2), this._hasPendingInstances = true, this.IsDebug() && C3Debugger.InstanceCreated(m2);
      const I2 = this._eventObjects["instancecreate"];
      return I2.instance = m2, this._dispatcher.dispatchEvent(I2), m2;
    }
    _GetInstanceData(e) {
      const t2 = e[0], s = e[1], i = e[2], n = e[6];
      if (n) return n;
      return this._layoutManager.GetLayoutBySID(t2).GetLayer(s).GetInitialInstanceData(i);
    }
    _MaybeGetChildInstanceForObjectTypeData(e, t2, s) {
      const i = t2?.GetSceneGraphChildrenExportData() ?? [];
      for (const t3 of i) {
        const i2 = this._GetInstanceData(t3), n = !!t3[4], a2 = this.GetObjectClassByIndex(i2[1]);
        if (!s.has(i2) && (e === a2 && n)) return s.add(i2), i2;
      }
    }
    _CreateChildInstancesFromData(e, t2, s, i, n, a2, r2) {
      const o2 = s.GetSceneGraphZIndexExportData(), h2 = s.GetSceneGraphChildrenExportData();
      if (e.GetWorldInfo().SetSceneGraphZIndex(o2), !h2) return;
      void 0 === n && (n = t2[0]), void 0 === a2 && (a2 = t2[1]);
      const l = /* @__PURE__ */ new Set(), c2 = t2[0], d2 = t2[1];
      for (const t3 of h2) {
        const s2 = t3[0], o3 = t3[1], h3 = t3[2], _2 = t3[3], u2 = !!t3[4], g2 = t3[5], m2 = t3[6];
        let p2;
        if (m2) p2 = m2;
        else {
          p2 = this._layoutManager.GetLayoutBySID(s2).GetLayer(o3).GetInitialInstanceData(h3);
        }
        const f2 = this.GetObjectClassByIndex(p2[1]), C2 = e.HasSibling(f2), S2 = l.has(f2);
        if (C2 && !S2 && u2) {
          const t4 = e.GetSibling(f2);
          t4.GetWorldInfo().Init(p2[0]);
          const s3 = n + p2[0][0] - c2, i2 = a2 + p2[0][1] - d2;
          t4.GetWorldInfo().SetXY(s3, i2), t4.GetWorldInfo().SetSceneGraphZIndex(g2), e.AddChild(t4, { transformX: !!(1 & _2), transformY: !!(_2 >> 1 & 1), transformWidth: !!(_2 >> 2 & 1), transformHeight: !!(_2 >> 3 & 1), transformAngle: !!(_2 >> 4 & 1), destroyWithParent: !!(_2 >> 5 & 1), transformZElevation: !!(_2 >> 6 & 1), transformOpacity: !!(_2 >> 7 & 1), transformVisibility: !!(_2 >> 8 & 1) }), l.add(f2);
        } else {
          const t4 = n + p2[0][0] - c2, s3 = a2 + p2[0][1] - d2, o4 = this.CreateInstanceFromData(p2, i, false, t4, s3, false, true, e, r2);
          o4.GetWorldInfo().SetSceneGraphZIndex(g2), e.AddChild(o4, { transformX: !!(1 & _2), transformY: !!(_2 >> 1 & 1), transformWidth: !!(_2 >> 2 & 1), transformHeight: !!(_2 >> 3 & 1), transformAngle: !!(_2 >> 4 & 1), destroyWithParent: !!(_2 >> 5 & 1), transformZElevation: !!(_2 >> 6 & 1), transformOpacity: !!(_2 >> 7 & 1), transformVisibility: !!(_2 >> 8 & 1) });
        }
      }
    }
    DestroyInstance(e) {
      if (this._instancesPendingRelease.has(e)) return;
      const t2 = e.GetObjectClass();
      let s = this._instancesPendingDestroy.get(t2);
      if (s) {
        if (s.has(e)) return;
        s.add(e);
      } else s = /* @__PURE__ */ new Set(), s.add(e), this._instancesPendingDestroy.set(t2, s);
      if (this.IsDebug() && C3Debugger.InstanceDestroyed(e), e._MarkDestroyed(), this._hasPendingInstances = true, e.IsInContainer()) for (const t3 of e.siblings()) this.DestroyInstance(t3);
      for (const t3 of e.children()) t3.GetDestroyWithParent() && this.DestroyInstance(t3);
      if (!this._layoutManager.IsEndingLayout() && !this._isLoadingState) {
        const t3 = this.GetEventSheetManager();
        t3.BlockFlushingInstances(true), e._TriggerOnDestroyed(), t3.BlockFlushingInstances(false);
      }
      e._FireDestroyedScriptEvents(this._layoutManager.IsEndingLayout());
    }
    FlushPendingInstances() {
      this._hasPendingInstances && (this._isFlushingPendingInstances = true, this._FlushInstancesPendingCreate(), this._FlushInstancesPendingDestroy(), this._isFlushingPendingInstances = false, this._hasPendingInstances = false, this.UpdateRender());
    }
    _FlushInstancesPendingCreate() {
      for (const e of this._instancesPendingCreate) {
        const t2 = e.GetObjectClass();
        t2._AddInstance(e);
        for (const s of t2.GetFamilies()) s._AddInstance(e), s._SetIIDsStale();
      }
      C32.clearArray(this._instancesPendingCreate);
    }
    _FlushInstancesPendingDestroy() {
      this._dispatcher.SetDelayRemoveEventsEnabled(true);
      for (const [e, t2] of this._instancesPendingDestroy.entries()) this._FlushInstancesPendingDestroyForObjectClass(e, t2), t2.clear();
      this._instancesPendingDestroy.clear(), this._dispatcher.SetDelayRemoveEventsEnabled(false);
    }
    _FlushInstancesPendingDestroyForObjectClass(e, t2) {
      for (const e2 of t2) {
        const t3 = this._eventObjects["instancedestroy"];
        t3.instance = e2, this._dispatcher.dispatchEvent(t3), this._instancesByUid.delete(e2.GetUID()), this._instanceTimes.delete(e2);
        const s = e2.GetWorldInfo();
        s && (s._RemoveFromCollisionCells(), s._RemoveFromRenderCells(), s._MarkDestroyed()), this._instancesPendingRelease.add(e2), this._objectCount--;
      }
      C32.arrayRemoveAllInSet(e.GetInstances(), t2), e._SetIIDsStale(), this._instancesPendingReleaseAffectedObjectClasses.add(e);
      for (const s of e.GetFamilies()) C32.arrayRemoveAllInSet(s.GetInstances(), t2), s._SetIIDsStale(), this._instancesPendingReleaseAffectedObjectClasses.add(s);
      if (e.GetPlugin().IsWorldType()) {
        const e2 = new Set([...t2].map((e3) => e3.GetWorldInfo().GetLayer()));
        for (const s of e2) s._RemoveAllInstancesInSet(t2);
      }
    }
    _GetInstancesPendingCreate() {
      return this._instancesPendingCreate;
    }
    *instancesPendingCreateForObjectClass(e) {
      for (const t2 of this._GetInstancesPendingCreate()) e.IsFamily() ? t2.GetObjectClass().BelongsToFamily(e) && (yield t2) : t2.GetObjectClass() === e && (yield t2);
    }
    _GetNewUID() {
      return this._nextUid++;
    }
    _MapInstanceByUID(e, t2) {
      this._instancesByUid.set(e, t2);
    }
    _SetAutoSuspendEnabled(e) {
      e = !!e, this._isAutoSuspendEnabled !== e && (this._isAutoSuspendEnabled = !!e, this._isAutoSuspendEnabled && this._isPageVisibilitySuspended && (this.SetSuspended(false), this._isPageVisibilitySuspended = false));
    }
    _IsAutoSuspendEnabled() {
      return this._isAutoSuspendEnabled;
    }
    _OnRendererContextLost() {
      this._dispatcher.dispatchEvent(C32.New(C32.Event, "renderercontextlost")), this.SetSuspended(true);
      for (const e2 of this._allObjectClasses) !e2.IsFamily() && e2.HasLoadedTextures() && e2.ReleaseTextures();
      const e = this.GetMainRunningLayout();
      e && e._OnRendererContextLost(), C32.ImageInfo.OnRendererContextLost(), C32.ImageAsset.OnRendererContextLost();
    }
    async _OnRendererContextRestored() {
      await this.GetMainRunningLayout()._Load(null, this.GetRenderer()), this._dispatcher.dispatchEvent(C32.New(C32.Event, "renderercontextrestored")), this.SetSuspended(false), this.UpdateRender();
    }
    _OnVisibilityChange(e) {
      if (!this._isAutoSuspendEnabled) return;
      const t2 = e["hidden"];
      this.SetSuspended(t2), this._isPageVisibilitySuspended = t2, t2 || this.UpdateRender();
    }
    _OnWindowBlur(e) {
      this.IsPreview() && this._pauseOnBlur && !C32.Platform.IsMobile && (e.data["parentHasFocus"] || (this.SetSuspended(true), this._isPausedOnBlur = true));
    }
    _OnWindowFocus() {
      this._isPausedOnBlur && (this.SetSuspended(false), this._isPausedOnBlur = false);
    }
    _RequestAnimationFrame() {
      const e = this._tickCallbacks;
      "vsync" === this._framerateMode ? -1 === this._rafId && (this._rafId = self.requestAnimationFrame(e.normal)) : "unlimited-tick" === this._framerateMode ? (-1 === this._ruafId && (this._ruafId = C32.RequestUnlimitedAnimationFrame(e.tickOnly)), -1 === this._rafId && (this._rafId = self.requestAnimationFrame(e.renderOnly))) : -1 === this._ruafId && (this._ruafId = C32.RequestUnlimitedAnimationFrame(e.normal));
    }
    _CancelAnimationFrame() {
      -1 !== this._rafId && (self.cancelAnimationFrame(this._rafId), this._rafId = -1), -1 !== this._ruafId && (C32.CancelUnlimitedAnimationFrame(this._ruafId), this._ruafId = -1);
    }
    IsSuspended() {
      return this._suspendCount > 0;
    }
    SetSuspended(e) {
      if (this.IsExportToVideo()) return;
      const t2 = this.IsSuspended();
      this._suspendCount += e ? 1 : -1, this._suspendCount < 0 && (this._suspendCount = 0);
      const s = this.IsSuspended();
      if (!t2 && s) console.log("[Construct] Suspending"), this._CancelAnimationFrame(), this._dispatcher.dispatchEvent(C32.New(C32.Event, "suspend")), this.DispatchUserScriptEvent(C32.New(C32.Event, "suspend")), this.Trigger(C32.Plugins.System.Cnds.OnSuspend, null, null);
      else if (t2 && !s) {
        console.log("[Construct] Resuming");
        const e2 = performance.now();
        this._lastTickTime = e2, this._fpsLastTime = e2, this._fpsFrameCount = 0, this._fps = 0, this._tpsTickCount = 0, this._tps = 0, this._mainThreadTime = 0, this._mainThreadTimeCounter = 0, this._dispatcher.dispatchEvent(C32.New(C32.Event, "resume")), this.DispatchUserScriptEvent(C32.New(C32.Event, "resume")), this.Trigger(C32.Plugins.System.Cnds.OnResume, null, null), this.HitBreakpoint() || this.Tick(e2);
      }
    }
    _AddBehInstToTick(e) {
      this._behInstsToTick.Add(e);
    }
    _AddBehInstToPostTick(e) {
      this._behInstsToPostTick.Add(e);
    }
    _AddBehInstToTick2(e) {
      this._behInstsToTick2.Add(e);
    }
    _RemoveBehInstToTick(e) {
      this._behInstsToTick.Remove(e);
    }
    _RemoveBehInstToPostTick(e) {
      this._behInstsToPostTick.Remove(e);
    }
    _RemoveBehInstToTick2(e) {
      this._behInstsToTick2.Remove(e);
    }
    _CallBehaviorTickMethod(e, t2) {
      const s = t2 ? performance.now() : 0;
      let i;
      return e instanceof ISDKBehaviorInstanceBase ? (i = e._tick(), t2 && C3Debugger.AddIndividualBehaviorTickTime(e.behavior, performance.now() - s)) : (i = e.Tick(), t2 && C3Debugger.AddIndividualBehaviorTickTime(e.GetBehavior(), performance.now() - s)), i;
    }
    _BehaviorTick() {
      const e = this.IsDebug();
      this._behInstsToTick.SetQueueingEnabled(true);
      for (const t2 of this._behInstsToTick) this._CallBehaviorTickMethod(t2, e);
      this._behInstsToTick.SetQueueingEnabled(false);
    }
    _CallBehaviorPostTickMethod(e, t2) {
      const s = t2 ? performance.now() : 0;
      let i;
      return e instanceof ISDKBehaviorInstanceBase ? (i = e._postTick(), t2 && C3Debugger.AddIndividualBehaviorTickTime(e.behavior, performance.now() - s)) : (i = e.PostTick(), t2 && C3Debugger.AddIndividualBehaviorTickTime(e.GetBehavior(), performance.now() - s)), i;
    }
    _BehaviorPostTick() {
      const e = this.IsDebug();
      this._behInstsToPostTick.SetQueueingEnabled(true);
      for (const t2 of this._behInstsToPostTick) this._CallBehaviorPostTickMethod(t2, e);
      this._behInstsToPostTick.SetQueueingEnabled(false);
    }
    _CallBehaviorTick2Method(e, t2) {
      const s = t2 ? performance.now() : 0;
      let i;
      return e instanceof ISDKBehaviorInstanceBase ? (i = e._tick2(), t2 && C3Debugger.AddIndividualBehaviorTickTime(e.behavior, performance.now() - s)) : (i = e.Tick2(), t2 && C3Debugger.AddIndividualBehaviorTickTime(e.GetBehavior(), performance.now() - s)), i;
    }
    _BehaviorTick2() {
      const e = this.IsDebug();
      this._behInstsToTick2.SetQueueingEnabled(true);
      for (const t2 of this._behInstsToTick2) this._CallBehaviorTick2Method(t2, e);
      this._behInstsToTick2.SetQueueingEnabled(false);
    }
    *_DebugBehaviorTick() {
      const e = this.IsDebug();
      this._behInstsToTick.SetQueueingEnabled(true);
      for (const t2 of this._behInstsToTick) {
        const s = this._CallBehaviorTickMethod(t2, e);
        C32.IsIterator(s) && (yield* s);
      }
      this._behInstsToTick.SetQueueingEnabled(false);
    }
    *_DebugBehaviorPostTick() {
      const e = this.IsDebug();
      this._behInstsToPostTick.SetQueueingEnabled(true);
      for (const t2 of this._behInstsToPostTick) {
        const s = this._CallBehaviorPostTickMethod(t2, e);
        C32.IsIterator(s) && (yield* s);
      }
      this._behInstsToPostTick.SetQueueingEnabled(false);
    }
    *_DebugBehaviorTick2() {
      const e = this.IsDebug();
      this._behInstsToTick2.SetQueueingEnabled(true);
      for (const t2 of this._behInstsToTick2) {
        const s = this._CallBehaviorTick2Method(t2, e);
        C32.IsIterator(s) && (yield* s);
      }
      this._behInstsToTick2.SetQueueingEnabled(false);
    }
    async Tick(e, t2, s) {
      this._hasStartedTicking = true;
      const i = "background-wake" === s, n = "background-wake" !== s && "skip-render" !== s, a2 = this.GetLayoutManager(), r2 = this.GetCanvasManager();
      if (!this._hasStarted || this.IsSuspended() && !t2 && !i) return;
      const o2 = performance.now();
      this._isInTick = true, this._MeasureDt(e || 0), this._tpsTickCount++, this._ReleasePendingInstances();
      const h2 = this.Step_BeforePreTick();
      this.IsDebugging() && await h2;
      const l = this._dispatcher.dispatchEventAndWait_AsyncOptional(this._eventObjects["pretick"]);
      l instanceof Promise && await l, this.DispatchUserScriptEvent(this._userScriptEventObjects["pretick"]);
      const c2 = this.Step_AfterPreTick();
      this.IsDebugging() && await c2, this._NeedsHandleSaveOrLoad() && await this._HandleSaveOrLoad(), a2.IsPendingChangeMainLayout() && await this._MaybeChangeLayout();
      const d2 = this.Step_RunEventsEtc();
      this.IsDebugging() && await d2;
      const _2 = a2.GetMainRunningLayout(), u2 = _2._GetPendingSetHTMLLayerCount();
      let g2 = false;
      if (-1 !== u2 && (_2._ResetPendingHTMLLayerCount(), r2.GetHTMLLayerCount() !== u2)) {
        const e2 = this.GetCanvasManager().SetHTMLLayerCount(u2);
        this.IsInWorker() && (g2 = true, await e2);
      }
      this.PostComponentMessageToDOM("canvas", "update-html-layer-dom-state", { "layersDomState": _2._GetRootLayers().filter((e2) => e2.IsHTMLElementsLayer()).map((e2) => e2._GetHTMLLayerDOMState()) }), n && this.Render(), g2 && this.PostComponentMessageToDOM("canvas", "cleanup-html-layers"), this.IsExportToVideo() && (await this._ExportToVideoAddFrame(), this.GetGameTime() >= this.GetExportVideoDuration()) ? this._ExportToVideoFinish() : (this.IsSuspended() || i || this._RequestAnimationFrame(), this._tickCount++, this._tickCountNoSave++, this._isInTick = false, this._mainThreadTimeCounter += performance.now() - o2);
    }
    async Step_BeforePreTick() {
      const e = this._eventSheetManager, t2 = this.IsDebug();
      this.FlushPendingInstances(), e.BlockFlushingInstances(true), this.PushCurrentLayout(this.GetMainRunningLayout()), t2 && C3Debugger.StartMeasuringTime(), this.IsDebugging() ? await e.DebugRunScheduledWaits() : e.RunScheduledWaits(), t2 && C3Debugger.AddEventsTime(), this.PopCurrentLayout(), e.BlockFlushingInstances(false), this.FlushPendingInstances(), e.BlockFlushingInstances(true);
    }
    async Step_AfterPreTick() {
      const e = this._eventSheetManager, t2 = this.IsDebug(), s = this.IsDebugging(), i = this._dispatcher, n = this._eventObjects, a2 = this._userScriptEventObjects;
      t2 && C3Debugger.StartMeasuringTime(), s ? await this.DebugIterateAndBreak(this._DebugBehaviorTick()) : this._BehaviorTick(), s ? await this.DebugIterateAndBreak(this._DebugBehaviorPostTick()) : this._BehaviorPostTick(), t2 && C3Debugger.AddBehaviorTotalTickTime(), t2 && C3Debugger.StartMeasuringTime(), s ? await this.DebugFireGeneratorEventAndBreak(n["tick"]) : i.dispatchEvent(n["tick"]), t2 && C3Debugger.AddPluginTotalTickTime(), e.BlockFlushingInstances(false), this.DispatchUserScriptEvent(a2["tick"]);
    }
    async Step_RunEventsEtc() {
      const e = this._eventSheetManager, t2 = this._dispatcher, s = this._eventObjects, i = this._userScriptEventObjects, n = this.IsDebug(), a2 = this.IsDebugging();
      n && C3Debugger.StartMeasuringTime(), a2 ? await e.DebugRunEvents(this._layoutManager) : e.RunEvents(this._layoutManager), n && C3Debugger.AddEventsTime(), this._collisionEngine.ClearRegisteredCollisions(), this._ReleasePendingInstances(), this._isLayoutFirstTick = false, e.BlockFlushingInstances(true), n && C3Debugger.StartMeasuringTime(), a2 ? await this.DebugIterateAndBreak(this._DebugBehaviorTick2()) : this._BehaviorTick2(), n && C3Debugger.AddBehaviorTotalTickTime(), n && C3Debugger.StartMeasuringTime(), a2 ? await this.DebugFireGeneratorEventAndBreak(s["tick2"]) : t2.dispatchEvent(s["tick2"]), n && C3Debugger.AddPluginTotalTickTime(), e.BlockFlushingInstances(false), this.DispatchUserScriptEvent(i["tick2"]), a2 && await e.RunQueuedDebugTriggersAsync(), this.FlushPendingInstances(), this._ReleasePendingInstances();
    }
    _ReleasePendingInstances() {
      if (0 === this._instancesPendingRelease.size) return;
      const e = this._dispatcher;
      e.SetDelayRemoveEventsEnabled(true);
      for (const e2 of this._instancesPendingReleaseAffectedObjectClasses) e2.GetSolStack().RemoveInstances(this._instancesPendingRelease);
      this._instancesPendingReleaseAffectedObjectClasses.clear(), this._eventSheetManager._OnInstancesReleased(this._instancesPendingRelease);
      for (const e2 of this._instancesPendingRelease) e2.Release();
      this._instancesPendingRelease.clear(), e.SetDelayRemoveEventsEnabled(false);
    }
    async _MaybeChangeLayout() {
      const e = this.GetLayoutManager();
      let t2 = 0;
      for (; e.IsPendingChangeMainLayout() && t2++ < 10; ) await this._DoChangeLayout(e.GetPendingChangeMainLayout());
    }
    _MeasureDt(e) {
      let t2 = 0;
      if (this.IsExportToVideo()) t2 = 1 / this.GetExportVideoFramerate(), this._dtRaw = t2, this._dt1 = t2;
      else if (0 !== this._lastTickTime) {
        t2 = Math.max(e - this._lastTickTime, 0) / 1e3, t2 > 0.5 && (t2 = 0), this._dtRaw = t2, this._dt1 = C32.clamp(t2, this._minDt, this._maxDt);
      }
      this._lastTickTime = e, this._dt = this._dt1 * this._timeScale, this._gameTime.Add(this._dt), this._gameTimeRaw.Add(t2 * this._timeScale), this._wallTime.Add(this._dt1);
      for (const [e2, t3] of this._instanceTimes) t3.Add(this._dt1 * e2.GetTimeScale());
      this._canvasManager && this._canvasManager._UpdateTick(), e - this._fpsLastTime >= 1e3 && (this._fpsLastTime += 1e3, e - this._fpsLastTime >= 1e3 && (this._fpsLastTime = e), this._fps = this._fpsFrameCount, this._fpsFrameCount = 0, this._tps = this._tpsTickCount, this._tpsTickCount = 0, this._mainThreadTime = Math.min(this._mainThreadTimeCounter / 1e3, 1), this._mainThreadTimeCounter = 0, this._canvasManager && this._canvasManager._Update1sFrameRange(), this._collisionEngine._Update1sStats(), this.IsDebug() && C3Debugger.Update1sPerfStats());
    }
    _SetTrackingInstanceTime(e, t2) {
      if (t2) {
        if (!this._instanceTimes.has(e)) {
          const t3 = C32.New(C32.KahanSum);
          t3.Copy(this._gameTime), this._instanceTimes.set(e, t3);
        }
      } else this._instanceTimes.delete(e);
    }
    _GetInstanceGameTime(e) {
      const t2 = this._instanceTimes.get(e);
      return t2 ? t2.Get() : this.GetGameTime();
    }
    async _DoChangeLayout(e) {
      const t2 = this._dispatcher, s = this.GetLayoutManager().GetMainRunningLayout();
      await s._StopRunning(), s._Unload(e, this.GetRenderer()), s === e && this._eventSheetManager.ClearAllScheduledWaits(), this._collisionEngine.ClearRegisteredCollisions(), this._ReleasePendingInstances(), t2.dispatchEvent(this._eventObjects["beforelayoutchange"]), C32.Asyncify.SetHighThroughputMode(true), await e._Load(s, this.GetRenderer()), C32.Asyncify.SetHighThroughputMode(false), await e._StartRunning(false), t2.dispatchEvent(this._eventObjects["layoutchange"]), this.UpdateRender(), this._isLayoutFirstTick = true, this.FlushPendingInstances(), this._ExportToVideoAddKeyframe();
    }
    UpdateRender() {
      this._needRender = true;
    }
    GetWebGLRenderer() {
      return this._canvasManager ? this._canvasManager.GetWebGLRenderer() : null;
    }
    GetWebGPURenderer() {
      return this._canvasManager ? this._canvasManager.GetWebGPURenderer() : null;
    }
    GetRenderer() {
      return this._canvasManager ? this._canvasManager.GetRenderer() : null;
    }
    Render() {
      const e = this._canvasManager;
      if (!e || e.IsRendererContextLost()) return;
      const t2 = this.GetRenderer(), s = t2.SupportsGPUProfiling(), i = s && t2.IsWebGL(), n = s && t2.IsWebGPU();
      if (i && t2.CheckForQueryResults(), !this._needRender && !this.IsExportToVideo()) return void t2.IncrementFrameNumber();
      const a2 = this._layoutManager.GetMainRunningLayout();
      this._fpsFrameCount++, t2.Start();
      const r2 = this.IsDebug();
      r2 && C3Debugger.StartMeasuringTime(), this._needRender = false;
      let o2 = null;
      i && (o2 = e.GetGPUFrameTimingsBuffer().AddTimeElapsedQuery(), t2.StartQuery(o2));
      let h2 = null;
      n && (h2 = t2.StartFrameTiming(2 * (1 + a2.GetLayerCount())), t2.StartMeasuringRenderPassTime(0, 1)), this.Uses3DFeatures() && "low" === e.GetCurrentFullscreenScalingQuality() ? t2.SetFixedSizeDepthBuffer(e.GetDrawWidth(), e.GetDrawHeight()) : t2.SetAutoSizeDepthBuffer(), this._Render(this.GetRenderer(), a2), o2 && t2.EndQuery(o2), n && (t2.StopMeasuringRenderPassTime(), this._canvasManager._AddWebGPUFrameTiming(h2)), t2.Finish(), r2 && (C3Debugger.AddDrawCallsTime(), C3Debugger.UpdateInspectHighlight()), e && e._MaybeTakeSnapshot();
    }
    _NeedsHTMLLayerCompositing(e) {
      return "low" === this.GetCanvasManager().GetCurrentFullscreenScalingQuality() || e.IsWebGL() && (this.UsesAnyBackgroundBlending() || this.Uses3DFeatures());
    }
    _Render(e, t2) {
      e.SetTextureFillMode(), e.SetAlphaBlend(), e.ResetCullState(), e.SetColorRgba(1, 1, 1, 1), e.SetRenderTarget(null), e.SetTexture(null), e.SetDepthEnabled(this.Uses3DFeatures()), this.Dispatcher().dispatchEvent(this._eventObjects["beforerender"]), this._NeedsHTMLLayerCompositing(e) && t2._MaybeStartDrawToOwnTexture(e);
      const s = t2.GetHTMLLayerCount();
      for (let i = 1; i < s; ++i) t2.DrawForHTMLLayerIndex(e, i), e.IsWebGPU() && e.Restart();
      this._NeedsHTMLLayerCompositing(e) || t2._MaybeStartDrawToOwnTexture(e), t2.DrawMain(e), this.Dispatcher().dispatchEvent(this._eventObjects["afterrender"]);
    }
    Trigger(e, t2, s) {
      if (!this._hasStarted) return false;
      const i = !this._isInTick && !this._eventSheetManager.IsInTrigger();
      let n = 0;
      i && (n = performance.now());
      const a2 = this.IsDebug();
      a2 && this.SetDebuggingEnabled(false);
      const r2 = this._eventSheetManager._Trigger(this._layoutManager, e, t2, s);
      if (i) {
        const e2 = performance.now() - n;
        this._mainThreadTimeCounter += e2, a2 && C3Debugger.AddTriggersTime(e2);
      }
      return a2 && this.SetDebuggingEnabled(true), r2;
    }
    DebugTrigger(e, t2, s) {
      if (!this.IsDebugging()) return this.Trigger(e, t2, s);
      if (this.HitBreakpoint()) throw new Error("called DebugTrigger() while stopped on breakpoint");
      if (!this._isInTick && !this._eventSheetManager.IsInTrigger()) throw new Error("called DebugTrigger() outside of event code - use TriggerAsync() instead");
      return this._eventSheetManager._DebugTrigger(this._layoutManager, e, t2, s);
    }
    async TriggerAsync(e, t2, s) {
      if (!this.IsDebugging()) return this.Trigger(e, t2, s);
      if (!this._hasStarted) return false;
      if (this.HitBreakpoint()) return this._eventSheetManager.QueueDebugTrigger(e, t2, s);
      if (!this.GetMainRunningLayout()) return this._eventSheetManager.QueueTrigger(e, t2, s);
      const i = performance.now(), n = this._eventSheetManager._DebugTrigger(this._layoutManager, e, t2, s);
      let a2 = n.next();
      for (; !a2.done; ) await this.DebugBreak(a2.value), a2 = n.next();
      return this.IsSuspended() || this._eventSheetManager.IsInTrigger() || (await this._eventSheetManager.RunQueuedDebugTriggersAsync(), this._hasStartedTicking && !this._isInTick && this._RequestAnimationFrame()), this._mainThreadTimeCounter += performance.now() - i, a2.value;
    }
    FastTrigger(e, t2, s) {
      const i = this.IsDebug();
      i && this.SetDebuggingEnabled(false);
      const n = this._eventSheetManager._FastTrigger(this._layoutManager, e, t2, s);
      return i && this.SetDebuggingEnabled(true), n;
    }
    DebugFastTrigger(e, t2, s) {
      return this._eventSheetManager._DebugFastTrigger(this._layoutManager, e, t2, s);
    }
    ScheduleTriggers(e) {
      return this._scheduleTriggersThrottle.Add(e);
    }
    PushCurrentLayout(e) {
      this._currentLayoutStack.push(e);
    }
    PopCurrentLayout() {
      if (!this._currentLayoutStack.length) throw new Error("layout stack empty");
      this._currentLayoutStack.pop();
    }
    GetCurrentLayout() {
      return this._currentLayoutStack.length ? this._currentLayoutStack.at(-1) : this.GetMainRunningLayout();
    }
    GetDt(e) {
      return e && -1 !== e.GetTimeScale() ? this._dt1 * e.GetTimeScale() : this._dt;
    }
    _GetDtFast() {
      return this._dt;
    }
    GetDt1() {
      return this._dt1;
    }
    GetDtRaw() {
      return this._dtRaw;
    }
    GetTimeScale() {
      return this._timeScale;
    }
    SetTimeScale(e) {
      (isNaN(e) || e < 0) && (e = 0), this._timeScale = e;
    }
    SetMinDt(e) {
      this._minDt = Math.max(e, 0);
    }
    GetMinDt() {
      return this._minDt;
    }
    SetMaxDt(e) {
      this._maxDt = Math.max(e, 0);
    }
    GetMaxDt() {
      return this._maxDt;
    }
    GetFramesPerSecond() {
      return this._fps;
    }
    GetTicksPerSecond() {
      return this._tps;
    }
    GetMainThreadTime() {
      return this._mainThreadTime;
    }
    GetStartTime() {
      return this._startTime;
    }
    GetGameTime() {
      return this._gameTime.Get();
    }
    GetGameTimeRaw() {
      return this._gameTimeRaw.Get();
    }
    GetWallTime() {
      return this._wallTime.Get();
    }
    GetTickCount() {
      return this._tickCount;
    }
    GetTickCountNoSave() {
      return this._tickCountNoSave;
    }
    GetObjectCount() {
      return this._objectCount;
    }
    GetProjectName() {
      return this._projectName;
    }
    GetProjectVersion() {
      return this._projectVersion;
    }
    GetProjectUniqueId() {
      return this._projectUniqueId;
    }
    GetAppId() {
      return this._appId;
    }
    GetExportTimestamp() {
      return this._exportTimestamp;
    }
    GetInstanceByUID(e) {
      if (this._isLoadingState) throw new Error("cannot call while loading state - wait until afterload event");
      return this._instancesByUid.get(e) || null;
    }
    _RemoveInstanceFromUIDMap(e) {
      if (this._isLoadingState) throw new Error("cannot call while loading state - wait until afterload event");
      this._instancesByUid.delete(e);
    }
    _RefreshUidMap() {
      this._instancesByUid.clear();
      for (const e of this._allObjectClasses) if (!e.IsFamily()) for (const t2 of e.GetInstances()) this._instancesByUid.set(t2.GetUID(), t2);
    }
    IsPreview() {
      return "preview" === this._exportType;
    }
    IsDebug() {
      return this._isDebug;
    }
    GetExportType() {
      return this._exportType;
    }
    IsCordova() {
      return "cordova" === this._exportType;
    }
    IsAndroidWebView() {
      return "Android" === C32.Platform.OS && ("cordova" === this._exportType || "playable-ad-single-file" === this._exportType || "playable-ad-zip" === this._exportType || "instant-games" === this._exportType);
    }
    IsiOSCordova() {
      return this._isiOSCordova;
    }
    IsiOSWebView() {
      return this._isiOSWebView;
    }
    IsWindowsWebView2() {
      return this._isWindowsWebView2;
    }
    IsAnyWebView2Wrapper() {
      return this._isAnyWebView2Wrapper;
    }
    GetCollisionEngine() {
      return this._collisionEngine;
    }
    GetSolidBehavior() {
      return this._addonManager.GetSolidBehavior();
    }
    GetJumpthruBehavior() {
      return this._addonManager.GetJumpthruBehavior();
    }
    Uses3DFeatures() {
      return this._uses3dFeatures;
    }
    GetZScaleFactor() {
      return this.GetRenderer().GetZAxisScaleFactor(this.GetViewportHeight());
    }
    GetDefaultCameraZ(e) {
      return this.GetRenderer().GetDefaultCameraZ(e || this.GetViewportHeight());
    }
    IsLayoutFirstTick() {
      return this._isLayoutFirstTick;
    }
    SetPixelRoundingEnabled(e) {
      e = !!e, this._isPixelRoundingEnabled !== e && (this._isPixelRoundingEnabled = e, this.GetLayoutManager().SetAllLayerMVChanged(), this.UpdateRender());
    }
    IsPixelRoundingEnabled() {
      return this._isPixelRoundingEnabled;
    }
    GetTextIconSet(e) {
      if (!this._iconChangeHandlers.has(e)) {
        const t3 = () => this.DeleteTextIconSet(e);
        this._iconChangeHandlers.set(e, t3), e.Dispatcher().addEventListener("animationframeimagechange", t3);
      }
      const t2 = this._textIconManager.GetIconSet(e);
      return t2.HasLoaded() || t2.LoadContent().then(() => this.UpdateRender()), t2;
    }
    DeleteTextIconSet(e) {
      this._textIconManager.DeleteIconSet(e);
    }
    _GetTextIconSetMeta(e) {
      const t2 = [];
      for (const s of e.GetAnimations()) for (const e2 of s.GetFrames()) {
        const s2 = e2.GetImageInfo();
        t2.push({ source: e2, width: s2.GetWidth(), height: s2.GetHeight(), tag: e2.GetTag() });
      }
      return { icons: t2 };
    }
    async _GetTextIconSetContent(e) {
      const t2 = C32.New(C32.PromiseThrottle), s = [], i = /* @__PURE__ */ new Map();
      for (const n2 of e.GetAnimations()) for (const e2 of n2.GetFrames()) {
        const n3 = e2.GetImageInfo().GetImageAsset();
        i.has(n3) || (i.set(n3, null), s.push(t2.Add(async () => {
          const e3 = await n3.LoadToDrawable();
          i.set(n3, e3);
        })));
      }
      await Promise.all(s);
      const n = [];
      for (const s2 of e.GetAnimations()) for (const e2 of s2.GetFrames()) n.push(t2.Add(async () => {
        const t3 = e2.GetImageInfo(), s3 = i.get(t3.GetImageAsset()), n2 = await t3.ExtractImageToCanvas(s3);
        return { drawable: await createImageBitmap(n2) };
      }));
      const a2 = await Promise.all(n);
      for (const e2 of i.values()) e2 instanceof ImageBitmap && e2["close"] && e2["close"]();
      return { icons: a2 };
    }
    SaveToSlot(e) {
      this._saveToSlotName = e, this._saveToJsonString = false;
    }
    SaveToJsonString() {
      this._saveToSlotName = "", this._saveToJsonString = true;
    }
    LoadFromSlot(e) {
      this._loadFromSlotName = e;
    }
    LoadFromJsonString(e) {
      this._loadFromJson = e;
    }
    GetLastSaveJsonString() {
      return this._lastSaveJson;
    }
    _NeedsHandleSaveOrLoad() {
      return !!(this._saveToSlotName || this._saveToJsonString || this._loadFromSlotName || null !== this._loadFromJson);
    }
    async _HandleSaveOrLoad() {
      if (this._saveToSlotName && (this.FlushPendingInstances(), await this._DoSaveToSlot(this._saveToSlotName), this._ClearSaveOrLoad()), this._loadFromSlotName && (await this._DoLoadFromSlot(this._loadFromSlotName), this._ClearSaveOrLoad(), this.IsDebug() && C3Debugger.StepIfPausedInDebugger()), this._saveToJsonString) {
        const e = await this._SaveToJsonString();
        this._lastSaveJson = e, await this.TriggerAsync(C32.Plugins.System.Cnds.OnSaveComplete, null), this._lastSaveJson = "", this._ClearSaveOrLoad();
      }
      if (null !== this._loadFromJson) {
        this.FlushPendingInstances();
        try {
          await this._DoLoadFromJsonString(this._loadFromJson), this._lastSaveJson = this._loadFromJson, await this.TriggerAsync(C32.Plugins.System.Cnds.OnLoadComplete, null), this._lastSaveJson = "";
        } catch (e) {
          console.error("[Construct] Failed to load state from JSON string: ", e), await this.TriggerAsync(C32.Plugins.System.Cnds.OnLoadFailed, null);
        }
        this._ClearSaveOrLoad();
      }
    }
    _ClearSaveOrLoad() {
      this._saveToSlotName = "", this._saveToJsonString = false, this._loadFromSlotName = "", this._loadFromJson = null;
    }
    _GetProjectStorage() {
      return this._projectStorage || (this._projectStorage = localforage.createInstance({ name: "c3-localstorage-" + this.GetProjectUniqueId(), description: this.GetProjectName() })), this._projectStorage;
    }
    _GetSavegamesStorage() {
      return this._savegamesStorage || (this._savegamesStorage = localforage.createInstance({ name: "c3-savegames-" + this.GetProjectUniqueId(), description: this.GetProjectName() })), this._savegamesStorage;
    }
    async _DoSaveToSlot(e) {
      const t2 = await this._SaveToJsonString();
      try {
        await this._GetSavegamesStorage().setItem(e, t2), console.log("[Construct] Saved state to storage (" + t2.length + " chars)"), this._lastSaveJson = t2, await this.TriggerAsync(C32.Plugins.System.Cnds.OnSaveComplete, null), this._lastSaveJson = "";
      } catch (e2) {
        console.error("[Construct] Failed to save state to storage: ", e2), await this.TriggerAsync(C32.Plugins.System.Cnds.OnSaveFailed, null);
      }
    }
    async _DoLoadFromSlot(e) {
      try {
        const t2 = await this._GetSavegamesStorage().getItem(e);
        if (!t2) throw new Error("empty slot");
        console.log("[Construct] Loaded state from storage (" + t2.length + " chars)"), await this._DoLoadFromJsonString(t2), this._lastSaveJson = t2, await this.TriggerAsync(C32.Plugins.System.Cnds.OnLoadComplete, null), this._lastSaveJson = "";
      } catch (e2) {
        console.error("[Construct] Failed to load state from storage: ", e2), await this.TriggerAsync(C32.Plugins.System.Cnds.OnLoadFailed, null);
      }
    }
    async _SaveToJsonString() {
      const e = { "c3save": true, "version": 1, "rt": { "time": this.GetGameTime(), "timeRaw": this.GetGameTimeRaw(), "walltime": this.GetWallTime(), "timescale": this.GetTimeScale(), "tickcount": this.GetTickCount(), "next_uid": this._nextUid, "running_layout": this.GetMainRunningLayout().GetSID(), "start_time_offset": Date.now() - this._startTime }, "types": {}, "layouts": {}, "events": this._eventSheetManager._SaveToJson(), "timelines": this._timelineManager._SaveToJson(), "user_script_data": null };
      for (const t3 of this._allObjectClasses) t3.IsFamily() || t3.HasNoSaveBehavior() || (e["types"][t3.GetSID().toString()] = t3._SaveToJson());
      for (const t3 of this._layoutManager.GetAllLayouts()) e["layouts"][t3.GetSID().toString()] = t3._SaveToJson();
      const t2 = this._CreateUserScriptEvent("save");
      return t2.saveData = null, await this.DispatchUserScriptEventAsyncWait(t2), e["user_script_data"] = t2.saveData, JSON.stringify(e);
    }
    IsLoadingState() {
      return this._isLoadingState;
    }
    async _DoLoadFromJsonString(e) {
      const t2 = this.GetLayoutManager(), s = JSON.parse(e);
      if (s["c2save"]) throw new Error("C2 saves are incompatible with C3 runtime");
      if (!s["c3save"]) throw new Error("not valid C3 save data");
      if (s["version"] > 1) throw new Error("C3 save data from future version");
      this.ClearIntancesNeedingAfterLoad(), this._dispatcher.dispatchEvent(C32.New(C32.Event, "beforeload"));
      for (const e2 of this.allInstances()) {
        e2.GetObjectClass().HasNoSaveBehavior() || e2._OnBeforeLoad();
      }
      const i = s["rt"];
      this._gameTime.Set(i["time"]), i.hasOwnProperty("timeRaw") && this._gameTimeRaw.Set(i["timeRaw"]), this._wallTime.Set(i["walltime"]), this._timeScale = i["timescale"], this._tickCount = i["tickcount"], this._startTime = Date.now() - i["start_time_offset"];
      const n = i["running_layout"];
      this._isLoadingState = true;
      let a2 = false;
      if (n !== this.GetMainRunningLayout().GetSID()) {
        const e2 = t2.GetLayoutBySID(n);
        if (!e2) return;
        await this._DoChangeLayout(e2), a2 = true;
      }
      for (const [e2, i2] of Object.entries(s["layouts"])) {
        const s2 = parseInt(e2, 10), n2 = t2.GetLayoutBySID(s2);
        n2 && n2._LoadFromJson(i2);
      }
      const r2 = /* @__PURE__ */ new Set();
      for (const [e2, t3] of Object.entries(s["types"])) {
        const s2 = parseInt(e2, 10), i2 = this.GetObjectClassBySID(s2);
        !i2 || i2.IsFamily() || i2.HasNoSaveBehavior() || i2._LoadFromJson(t3, r2);
      }
      for (const e2 of this._layoutManager.GetAllLayouts()) for (const t3 of e2.allLayers()) t3._LoadFromJsonAfterInstances();
      if (this.FlushPendingInstances(), this._RefreshUidMap(), this._isLoadingState = false, a2) {
        for (const e2 of this.allInstances()) e2.SetupInitialSceneGraphConnections();
        for (const [e2, t3] of Object.entries(s["types"])) {
          const s2 = parseInt(e2, 10), i2 = this.GetObjectClassBySID(s2);
          !i2 || i2.IsFamily() || i2.HasNoSaveBehavior() || i2._SetupSceneGraphConnectionsOnChangeOfLayout(t3);
        }
      }
      this._nextUid = i["next_uid"], this._eventSheetManager._LoadFromJson(s["events"]);
      for (const e2 of this._allObjectClasses) if (!e2.IsFamily() && e2.IsInContainer()) for (const t3 of e2.GetInstances()) {
        const s2 = t3.GetIID();
        t3._ClearSiblings();
        for (const i2 of e2.GetContainer().objectTypes()) {
          if (i2 === e2) continue;
          const n2 = i2.GetInstances();
          if (s2 < 0 || s2 >= n2.length) throw new Error("missing sibling instance");
          t3._AddSibling(n2[s2]);
        }
      }
      this._timelineManager._LoadFromJson(s["timelines"]), t2.SetAllLayerProjectionChanged(), t2.SetAllLayerMVChanged();
      for (const e2 of r2) e2._OnCreatedForLoadingSavegame();
      this.DoAfterLoad(), this._dispatcher.dispatchEvent(C32.New(C32.Event, "afterload")), this.DispatchUserScriptEvent(this._CreateUserScriptEvent("afterload"));
      for (const [e2, t3] of Object.entries(s["types"])) {
        const t4 = parseInt(e2, 10), s2 = this.GetObjectClassBySID(t4);
        s2 && s2._ClearLoadInstancesJson();
      }
      const o2 = this._CreateUserScriptEvent("load");
      o2.saveData = s["user_script_data"], await this.DispatchUserScriptEventAsyncWait(o2), this.UpdateRender();
    }
    SortOnTmpHierarchyPosition(e, t2) {
      return t2.GetWorldInfo().GetTmpHierarchyPosition() - e.GetWorldInfo().GetTmpHierarchyPosition();
    }
    AddInstanceNeedingAfterLoad(e, t2) {
      e.GetWorldInfo() && (this._instancesNeedingAfterLoadMap.has(e) || (this._instancesNeedingAfterLoadMap.set(e, t2), this._instancesNeedingAfterLoadArray.push(e)));
    }
    ClearIntancesNeedingAfterLoad() {
      this._instancesNeedingAfterLoadMap = /* @__PURE__ */ new WeakMap(), C32.clearArray(this._instancesNeedingAfterLoadArray), C32.SceneGraphInfo.ClearUpdatedInstances();
    }
    DoAfterLoad(e = "full", t2 = null) {
      this._instancesNeedingAfterLoadArray.sort(this.SortOnTmpHierarchyPosition), t2 || (t2 = {}), t2.processedWorldInfo = /* @__PURE__ */ new Set();
      const s = this._instancesNeedingAfterLoadArray.length;
      for (const s2 of this._instancesNeedingAfterLoadArray) s2._OnAfterLoad(this._instancesNeedingAfterLoadMap.get(s2), e, t2);
      for (const s2 of this._instancesNeedingAfterLoadArray) s2._OnAfterLoad2(this._instancesNeedingAfterLoadMap.get(s2), e, t2);
      if (this.ClearIntancesNeedingAfterLoad(), s) {
        this.FlushPendingInstances(), this._RefreshUidMap();
        for (const e2 of this._layoutManager.GetAllLayouts()) for (const t3 of e2.allLayers()) t3._SortInstancesByLastCachedZIndex(), t3.SetZIndicesChanged();
      }
    }
    async AddJobWorkerScripts(e) {
      const t2 = e.map((e2) => new URL(e2, location.href).toString());
      this._jobScheduler.ImportScriptsToJobWorkers(t2);
    }
    AddJobWorkerBlob(e, t2) {
      this._jobScheduler.SendBlobToJobWorkers(e, t2);
    }
    AddJobWorkerBuffer(e, t2) {
      this._jobScheduler.SendBufferToJobWorkers(e, t2);
    }
    AddJob(e, t2, s, i) {
      return this._jobScheduler.AddJob(e, t2, s, null, null, i);
    }
    BroadcastJob(e, t2, s, i) {
      return this._jobScheduler.BroadcastJob(e, t2, s, i);
    }
    GetMaxNumJobWorkers() {
      return this._jobScheduler.GetMaxNumWorkers();
    }
    InvokeDownload(e, t2) {
      this.PostComponentMessageToDOM("runtime", "invoke-download", { "url": e, "filename": t2 });
    }
    async RasterSvgImage(e, t2, s, i, n, a2) {
      if (i = i || t2, n = n || s, this.IsInWorker()) {
        return (await this.PostComponentMessageToDOMAsync("runtime", "raster-svg-image", { "blob": e, "imageWidth": t2, "imageHeight": s, "surfaceWidth": i, "surfaceHeight": n, "imageBitmapOpts": a2 }))["imageBitmap"];
      }
      {
        const r2 = await self["C3_RasterSvgImageBlob"](e, t2, s, i, n);
        return a2 ? await self.createImageBitmap(r2, a2) : r2;
      }
    }
    async GetSvgImageSize(e) {
      return this.IsInWorker() ? await this.PostComponentMessageToDOMAsync("runtime", "get-svg-image-size", { "blob": e }) : await self["C3_GetSvgImageSize"](e);
    }
    RequestDeviceOrientationEvent() {
      this._didRequestDeviceOrientationEvent || (this._didRequestDeviceOrientationEvent = true, this.PostComponentMessageToDOM("runtime", "enable-device-orientation"));
    }
    RequestDeviceMotionEvent() {
      this._didRequestDeviceMotionEvent || (this._didRequestDeviceMotionEvent = true, this.PostComponentMessageToDOM("runtime", "enable-device-motion"));
    }
    Random() {
      return this._randomNumberCallback();
    }
    SetRandomNumberGeneratorCallback(e) {
      this._randomNumberCallback = e;
    }
    _GetRemotePreviewStatusInfo() {
      const e = this.GetRenderer();
      return { "fps": this.GetFramesPerSecond(), "tps": this.GetTicksPerSecond(), "cpu": this.GetMainThreadTime(), "gpu": this.GetGPUUtilisation(), "layout": this.GetMainRunningLayout() ? this.GetMainRunningLayout().GetName() : "", "renderer": e.IsWebGL() ? e.GetUnmaskedRenderer() : e.GetAdapterInfoString() };
    }
    HitBreakpoint() {
      return !!this.IsDebug() && C3Debugger.HitBreakpoint();
    }
    DebugBreak(e) {
      return this.IsDebugging() ? C3Debugger.DebugBreak(e) : Promise.resolve();
    }
    DebugBreakNext() {
      return !!this.IsDebugging() && C3Debugger.BreakNext();
    }
    SetDebugBreakpointsEnabled(e) {
      this._breakpointsEnabled = !!e, this._UpdateDebuggingFlag();
    }
    AreDebugBreakpointsEnabled() {
      return this._breakpointsEnabled;
    }
    IsDebugging() {
      return this._isDebugging;
    }
    SetDebuggingEnabled(e) {
      e ? this._debuggingDisabled-- : this._debuggingDisabled++, this._UpdateDebuggingFlag();
    }
    _UpdateDebuggingFlag() {
      this._isDebugging = this.IsDebug() && this._breakpointsEnabled && 0 === this._debuggingDisabled;
    }
    IsCPUProfiling() {
      return this.IsDebug() && C3Debugger.IsCPUProfiling();
    }
    IsGPUProfiling() {
      return this.IsDebug() && this.GetRenderer().SupportsGPUProfiling() && C3Debugger.IsGPUProfiling();
    }
    async DebugIterateAndBreak(e) {
      if (e) for (const t2 of e) await this.DebugBreak(t2);
    }
    DebugFireGeneratorEventAndBreak(e) {
      return this.DebugIterateAndBreak(this._dispatcher.dispatchGeneratorEvent(e));
    }
    _InvokeFunctionFromJS(e) {
      return this._eventSheetManager._InvokeFunctionFromJS(e["name"], e["params"]);
    }
    _GetHTMLLayerWrapElement(e) {
      if (this.IsInWorker()) throw new Error("not supported in worker mode");
      return self["c3_runtimeInterface"]["_GetHTMLWrapElement"](e);
    }
    GetIRuntime() {
      return this._iRuntime;
    }
    GetConstructVersionCode() {
      return this._constructVersionCode;
    }
    _CreateUserScriptEvent(e) {
      const t2 = C32.New(C32.Event, e, false);
      return t2.runtime = this._iRuntime, t2;
    }
    _InitScriptInterfaces() {
      this._iRuntime = new self.IRuntime(this), this._userScriptEventObjects = { "pretick": this._CreateUserScriptEvent("pretick"), "tick": this._CreateUserScriptEvent("tick"), "tick2": this._CreateUserScriptEvent("tick2") };
    }
    _InitObjectsScriptInterface() {
      const e = {};
      for (const t2 of this._allObjectClasses) e[t2.GetJsPropName()] = { value: t2.GetIObjectClass(), enumerable: true, writable: false };
      this._iRuntime._InitObjects(e);
    }
    _InitGlobalVariableScriptInterface() {
      const e = {};
      for (const t2 of this.GetEventSheetManager().GetAllGlobalVariables()) e[t2.GetJsPropName()] = t2._GetScriptInterfaceDescriptor();
      this._iRuntime._InitGlobalVars(e);
    }
    _GetCommonScriptInterfaces() {
      return this._commonScriptInterfaces;
    }
    _MapScriptInterface(e, t2) {
      this._interfaceMap.set(e, t2);
    }
    _UnwrapScriptInterface(e) {
      return this._interfaceMap.get(e);
    }
    _UnwrapIObjectClass(e) {
      if (!(e instanceof self.IObjectClass)) throw new TypeError("expected IObjectClass");
      const t2 = this._UnwrapScriptInterface(e);
      if (!(t2 && t2 instanceof C32.ObjectClass)) throw new Error("invalid IObjectClass");
      return t2;
    }
    _UnwrapIInstance(e) {
      if (!(e instanceof self.IInstance)) throw new TypeError("expected IInstance");
      const t2 = this._UnwrapScriptInterface(e);
      if (!(t2 && t2 instanceof C32.Instance)) throw new Error("invalid IInstance");
      return t2;
    }
    _UnwrapIWorldInstance(e) {
      if (!(e instanceof self.IWorldInstance)) throw new TypeError("expected IWorldInstance");
      const t2 = this._UnwrapScriptInterface(e);
      if (!(t2 && t2 instanceof C32.Instance)) throw new Error("invalid IInstance");
      return t2;
    }
  }, self["C3_CreateRuntime"] = C32.Runtime.Create, self["C3_InitRuntime"] = (e, t2) => e.Init(t2);
}
{
  const C32 = self.C3;
  C32.JobSchedulerRuntime = class extends C32.DefendedBase {
    constructor(r2, e) {
      super(), this._runtime = r2, this._jobPromises = /* @__PURE__ */ new Map(), this._nextJobId = 0, this._inputPort = e["inputPort"], e["outputPort"].onmessage = (r3) => this._OnJobWorkerMessage(r3), this._maxNumWorkers = e["maxNumWorkers"], this._jobWorkerCount = 1, this._isCreatingWorker = false, this._hadErrorCreatingWorker = false;
    }
    GetMaxNumWorkers() {
      return this._maxNumWorkers;
    }
    ImportScriptsToJobWorkers(r2) {
      this._inputPort.postMessage({ "type": "_import_scripts", "scripts": r2 });
    }
    SendBlobToJobWorkers(r2, e) {
      this._inputPort.postMessage({ "type": "_send_blob", "blob": r2, "id": e });
    }
    SendBufferToJobWorkers(r2, e) {
      this._inputPort.postMessage({ "type": "_send_buffer", "buffer": r2, "id": e }, [r2]);
    }
    AddJob(r2, e, o2, s, t2, i) {
      if (o2 || (o2 = []), "number" == typeof i && (i = Math.floor(i)) <= 0) throw new Error("invalid maxWorkerNum");
      const n = this._nextJobId++, a2 = { "type": r2, "isBroadcast": false, "maxWorkerNum": i, "jobId": n, "params": e, "transferables": o2 }, _2 = new Promise((r3, e2) => {
        this._jobPromises.set(n, { resolve: r3, progress: s, reject: e2, cancelled: false, maxWorkerNum: i });
      });
      return t2 && t2.SetAction(() => this._CancelJob(n)), this._inputPort.postMessage(a2, o2), this._MaybeCreateExtraWorker(), _2;
    }
    BroadcastJob(r2, e, o2, s) {
      if (o2 || (o2 = []), "number" == typeof s && (s = Math.floor(s)) <= 0) throw new Error("invalid maxWorkerNum");
      const t2 = { "type": r2, "isBroadcast": true, "maxWorkerNum": s, "jobId": this._nextJobId++, "params": e, "transferables": o2 };
      this._inputPort.postMessage(t2, o2);
    }
    _CancelJob(r2) {
      const e = this._jobPromises.get(r2);
      e && (e.cancelled = true, e.resolve = null, e.progress = null, e.reject = null, this._inputPort.postMessage({ "type": "_cancel", "jobId": r2 }));
    }
    _OnJobWorkerMessage(r2) {
      const e = r2.data, o2 = e["type"], s = e["jobId"];
      switch (o2) {
        case "result":
          this._OnJobResult(s, e["result"]);
          break;
        case "progress":
          this._OnJobProgress(s, e["progress"]);
          break;
        case "error":
          this._OnJobError(s, e["error"]);
          break;
        case "ready":
          this._OnJobWorkerReady();
          break;
        default:
          throw new Error(`unknown message from worker '${o2}'`);
      }
    }
    _OnJobResult(r2, e) {
      const o2 = this._jobPromises.get(r2);
      if (!o2) throw new Error("invalid job ID");
      o2.cancelled || o2.resolve(e), this._jobPromises.delete(r2);
    }
    _OnJobProgress(r2, e) {
      const o2 = this._jobPromises.get(r2);
      if (!o2) throw new Error("invalid job ID");
      !o2.cancelled && o2.progress && o2.progress(e);
    }
    _OnJobError(r2, e) {
      const o2 = this._jobPromises.get(r2);
      if (!o2) throw new Error("invalid job ID");
      o2.cancelled || o2.reject(e), this._jobPromises.delete(r2);
    }
    _OnJobWorkerReady() {
      this._isCreatingWorker && (this._isCreatingWorker = false, this._jobWorkerCount++, this._jobWorkerCount < this._maxNumWorkers ? this._MaybeCreateExtraWorker() : this._inputPort.postMessage({ "type": "_no_more_workers" }));
    }
    _GetWorkerCountNeededForPendingJobs() {
      let r2 = 0;
      const e = [...this._jobPromises.values()].sort((r3, e2) => (r3.maxWorkerNum || 1 / 0) - (e2.maxWorkerNum || 1 / 0));
      for (const o2 of e) {
        r2 < (o2.maxWorkerNum || 1 / 0) && r2++;
      }
      return r2;
    }
    async _MaybeCreateExtraWorker() {
      if (!(this._jobWorkerCount >= this._maxNumWorkers || this._isCreatingWorker || this._hadErrorCreatingWorker || this._GetWorkerCountNeededForPendingJobs() <= this._jobWorkerCount)) try {
        this._isCreatingWorker = true;
        (await this._runtime.PostComponentMessageToDOMAsync("runtime", "create-job-worker"))["outputPort"].onmessage = (r2) => this._OnJobWorkerMessage(r2);
      } catch (r2) {
        this._hadErrorCreatingWorker = true, this._isCreatingWorker = false, console.error(`[Construct] Failed to create job worker; stopping creating any more (created ${this._jobWorkerCount} so far)`, r2);
      }
    }
  };
}
{
  self["C3_Shaders"] = {};
  self["C3_Shaders"]["sharpen"] = {
    glsl: "varying mediump vec2 vTex;\nuniform lowp sampler2D samplerFront;\nuniform mediump vec2 pixelSize;\nuniform lowp float intensity;\nvoid main(void)\n{\nmediump float centerMultiplier = 1.0 + 4.0 * intensity;\nmediump vec4 front = texture2D(samplerFront, vTex);\nmediump vec3 textureColor = front.rgb;\nmediump vec3 leftTextureColor = texture2D(samplerFront, vTex - vec2(pixelSize.x, 0.0)).rgb;\nmediump vec3 rightTextureColor = texture2D(samplerFront, vTex + vec2(pixelSize.x, 0.0)).rgb;\nmediump vec3 topTextureColor = texture2D(samplerFront, vTex - vec2(0.0, pixelSize.y)).rgb;\nmediump vec3 bottomTextureColor = texture2D(samplerFront, vTex + vec2(0.0, pixelSize.y)).rgb;\ngl_FragColor = vec4((textureColor * centerMultiplier - (leftTextureColor * intensity + rightTextureColor * intensity + topTextureColor * intensity + bottomTextureColor * intensity)), front.a);\n}",
    glslWebGL2: "",
    wgsl: "%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\nstruct ShaderParams {\nintensity : f32\n};\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\n%%C3_UTILITY_FUNCTIONS%%\n%%FRAGMENTINPUT_STRUCT%%\n%%FRAGMENTOUTPUT_STRUCT%%\n@fragment\nfn main(input : FragmentInput) -> FragmentOutput\n{\nvar pixelSize : vec2<f32> = c3_getPixelSize(textureFront);\nvar centerMultiplier : f32 = 1.0 + 4.0 * shaderParams.intensity;\nvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\nvar textureColor : vec3<f32> = front.rgb;\nvar leftTextureColor : vec3<f32> = textureSample(textureFront, samplerFront, input.fragUV - vec2<f32>(pixelSize.x, 0.0)).rgb;\nvar rightTextureColor : vec3<f32> = textureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(pixelSize.x, 0.0)).rgb;\nvar topTextureColor : vec3<f32> = textureSample(textureFront, samplerFront, input.fragUV - vec2<f32>(0.0, pixelSize.y)).rgb;\nvar bottomTextureColor : vec3<f32> = textureSample(textureFront, samplerFront, input.fragUV + vec2<f32>(0.0, pixelSize.y)).rgb;\nvar output : FragmentOutput;\noutput.color = vec4<f32>((textureColor * centerMultiplier - (leftTextureColor * shaderParams.intensity + rightTextureColor * shaderParams.intensity + topTextureColor * shaderParams.intensity + bottomTextureColor * shaderParams.intensity)), front.a);\nreturn output;\n}",
    blendsBackground: false,
    usesDepth: false,
    extendBoxHorizontal: 0,
    extendBoxVertical: 0,
    crossSampling: false,
    mustPreDraw: false,
    preservesOpaqueness: true,
    supports3dDirectRendering: false,
    animated: false,
    parameters: [["intensity", 0, "percent"]]
  };
  self["C3_Shaders"]["setcolor"] = {
    glsl: "varying mediump vec2 vTex;\nuniform lowp sampler2D samplerFront;\nuniform lowp vec3 setColor;\nvoid main(void)\n{\nlowp float a = texture2D(samplerFront, vTex).a;\ngl_FragColor = vec4(setColor.r * a, setColor.g * a, setColor.b * a, a);\n}",
    glslWebGL2: "",
    wgsl: "%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\nstruct ShaderParams {\nsetColor : vec3<f32>\n};\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\n%%FRAGMENTINPUT_STRUCT%%\n%%FRAGMENTOUTPUT_STRUCT%%\n@fragment\nfn main(input : FragmentInput) -> FragmentOutput\n{\nvar a : f32 = textureSample(textureFront, samplerFront, input.fragUV).a;\nvar output : FragmentOutput;\noutput.color = vec4<f32>(shaderParams.setColor * a, a);\nreturn output;\n}",
    blendsBackground: false,
    usesDepth: false,
    extendBoxHorizontal: 0,
    extendBoxVertical: 0,
    crossSampling: false,
    mustPreDraw: false,
    preservesOpaqueness: true,
    supports3dDirectRendering: false,
    animated: false,
    parameters: [["setColor", 0, "color"]]
  };
  self["C3_Shaders"]["pulse"] = {
    glsl: "#ifdef GL_FRAGMENT_PRECISION_HIGH\n#define highmedp highp\n#else\n#define highmedp mediump\n#endif\nvarying mediump vec2 vTex;\nuniform lowp sampler2D samplerFront;\nuniform mediump vec2 srcStart;\nuniform mediump vec2 srcEnd;\nuniform lowp float intensity;\nuniform lowp float lighting;\nuniform mediump float frequency;\nuniform mediump float speed;\nuniform mediump float centerX;\nuniform mediump float centerY;\nuniform mediump vec2 pixelSize;\nuniform mediump float devicePixelRatio;\nuniform mediump float layerScale;\nuniform highmedp float seconds;\nvoid main(void)\n{\nmediump vec2 srcSize = srcEnd - srcStart;\nmediump vec2 tex = (vTex - srcStart) / srcSize;\nmediump vec2 res = 1.0 / pixelSize;\nmediump vec2 halfres = res / 2.0;\nmediump vec2 cPos = (tex - vec2(centerX, 1.0 - centerY)) * res;\nmediump float cLength = length(cPos);\nmediump vec2 uv = tex+(cPos/cLength)*sin(cLength/frequency/(devicePixelRatio*layerScale)-seconds*speed)/25.0;\ntex = mix(tex, uv, intensity);\ntex = clamp(tex, 0.0, 1.0);\ntex = tex * srcSize + srcStart;\nlowp vec4 front = texture2D(samplerFront, tex);\nlowp vec3 col = mix(front.rgb, front.rgb*50.0/cLength, lighting * intensity);\ngl_FragColor = vec4(col,front.a);\n}",
    glslWebGL2: "",
    wgsl: "%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\nstruct ShaderParams {\nintensity : f32,\nlighting : f32,\nspeed : f32,\nfrequency : f32,\ncenterX : f32,\ncenterY : f32\n};\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\n%%C3PARAMS_STRUCT%%\n%%C3_UTILITY_FUNCTIONS%%\n%%FRAGMENTINPUT_STRUCT%%\n%%FRAGMENTOUTPUT_STRUCT%%\n@fragment\nfn main(input : FragmentInput) -> FragmentOutput\n{\nvar tex : vec2<f32> = c3_srcToNorm(input.fragUV);\nvar res : vec2<f32> = vec2<f32>(textureDimensions(textureFront));\nvar halfres : vec2<f32> = res / 2.0;\nvar cPos : vec2<f32> = (tex - vec2<f32>(shaderParams.centerX, 1.0 - shaderParams.centerY)) * res;\nvar cLength : f32 = length(cPos);\nvar uv : vec2<f32> = tex + (cPos / cLength) * sin(cLength / shaderParams.frequency / (c3Params.devicePixelRatio * c3Params.layerScale) - c3Params.seconds * shaderParams.speed) / 25.0;\ntex = mix(tex, uv, shaderParams.intensity);\ntex = c3_clamp2(tex, 0.0, 1.0);\ntex = c3_normToSrc(tex);\nvar front : vec4<f32> = textureSample(textureFront, samplerFront, tex);\nvar col : vec3<f32> = mix(front.rgb, front.rgb * 50.0 / cLength, shaderParams.lighting * shaderParams.intensity);\nvar output : FragmentOutput;\noutput.color = vec4<f32>(col, front.a);\nreturn output;\n}",
    blendsBackground: false,
    usesDepth: false,
    extendBoxHorizontal: 50,
    extendBoxVertical: 50,
    crossSampling: false,
    mustPreDraw: false,
    preservesOpaqueness: false,
    supports3dDirectRendering: false,
    animated: true,
    parameters: [["intensity", 0, "percent"], ["lighting", 0, "percent"], ["speed", 0, "float"], ["frequency", 0, "float"], ["centerX", 0, "percent"], ["centerY", 0, "percent"]]
  };
  self["C3_Shaders"]["tint"] = {
    glsl: "varying mediump vec2 vTex;\nuniform lowp sampler2D samplerFront;\nuniform lowp vec3 tintColor;\nvoid main(void)\n{\nlowp vec4 front = texture2D(samplerFront, vTex);\ngl_FragColor = front * vec4(tintColor.r, tintColor.g, tintColor.b, 1.0);\n}",
    glslWebGL2: "",
    wgsl: "%%SAMPLERFRONT_BINDING%% var samplerFront : sampler;\n%%TEXTUREFRONT_BINDING%% var textureFront : texture_2d<f32>;\nstruct ShaderParams {\ntintColor : vec3<f32>\n};\n%%SHADERPARAMS_BINDING%% var<uniform> shaderParams : ShaderParams;\n%%FRAGMENTINPUT_STRUCT%%\n%%FRAGMENTOUTPUT_STRUCT%%\n@fragment\nfn main(input : FragmentInput) -> FragmentOutput {\nvar front : vec4<f32> = textureSample(textureFront, samplerFront, input.fragUV);\nvar output : FragmentOutput;\noutput.color = front * vec4<f32>(shaderParams.tintColor, 1.0);\nreturn output;\n}",
    blendsBackground: false,
    usesDepth: false,
    extendBoxHorizontal: 0,
    extendBoxVertical: 0,
    crossSampling: false,
    mustPreDraw: false,
    preservesOpaqueness: true,
    supports3dDirectRendering: false,
    animated: false,
    parameters: [["tintColor", 0, "color"]]
  };
}
{
  {
    let ForEachOrdered_SortInstances = function(e2, t3) {
      const n2 = e2[1], r3 = t3[1];
      if ("number" == typeof n2 && "number" == typeof r3) return n2 - r3;
      {
        const e3 = "" + n2, t4 = "" + r3;
        return e3 < t4 ? -1 : e3 > t4 ? 1 : 0;
      }
    };
    ForEachOrdered_SortInstances2 = ForEachOrdered_SortInstances;
    const e = self.C3;
    let t2 = null, n = "", r2 = "", a2 = [], i = "", s = "", o2 = "";
    const u2 = e.New(e.ArrayStack);
    e.Plugins.System = class extends e.SDKPluginBase {
      constructor(e2) {
        super(e2), this._loopStack = this._runtime.GetEventSheetManager().GetLoopStack(), this._eventStack = this._runtime.GetEventSheetManager().GetEventStack(), this._imagesLoadingTotal = 0, this._imagesLoadingComplete = 0, this._functionMaps = /* @__PURE__ */ new Map();
      }
      Release() {
        super.Release();
      }
      UpdateRender() {
        this._runtime.UpdateRender();
      }
      Trigger(e2) {
        this._runtime.Trigger(e2, null, null);
      }
      GetRegex(e2, a3) {
        return t2 && e2 === n && a3 === r2 || (t2 = new RegExp(e2, a3), n = e2, r2 = a3), t2.lastIndex = 0, t2;
      }
      GetRegexMatches(e2, t3, n2) {
        if (e2 === i && t3 === s && n2 === o2) return a2;
        const r3 = this.GetRegex(t3, n2);
        return a2 = e2.match(r3), i = e2, s = t3, o2 = n2, a2;
      }
      async _LoadTexturesForObjectClasses(t3, n2) {
        if (!n2.length) return;
        this._imagesLoadingTotal += n2.length;
        const r3 = [];
        for (const e2 of n2) r3.push(t3.MaybeLoadTexturesFor(e2));
        await e.PromiseAllWithProgress(r3, () => {
          this._imagesLoadingComplete++;
        }), this._imagesLoadingComplete++, this._imagesLoadingComplete === this._imagesLoadingTotal && (this._imagesLoadingComplete = 0, this._imagesLoadingTotal = 0, this._runtime.Trigger(e.Plugins.System.Cnds.OnImageLoadingComplete, null, null));
      }
      GetImageLoadingProgress() {
        return 0 === this._imagesLoadingTotal ? 1 : this._imagesLoadingComplete / this._imagesLoadingTotal;
      }
      _UnloadTexturesForObjectClasses(e2, t3) {
        for (const n2 of t3) 0 === n2.GetInstanceCount() && e2.MaybeUnloadTexturesFor(n2);
      }
      _GetForEachStack() {
        return u2;
      }
      _Repeat(e2) {
        const t3 = this._runtime.GetEventSheetManager(), n2 = t3.GetEventStack(), r3 = n2.GetCurrentStackFrame(), a3 = r3.GetCurrentEvent(), i2 = a3.GetSolModifiers(), s2 = r3.IsSolModifierAfterCnds(), o3 = n2.Push(a3), u3 = t3.GetLoopStack(), l = u3.Push();
        if (l.SetEnd(e2), s2) for (let n3 = 0; n3 < e2 && !l.IsStopped(); ++n3) t3.PushCopySol(i2), l.SetIndex(n3), a3.Retrigger(r3, o3), t3.PopSol(i2);
        else for (let t4 = 0; t4 < e2 && !l.IsStopped(); ++t4) l.SetIndex(t4), a3.Retrigger(r3, o3);
        return n2.Pop(), u3.Pop(), false;
      }
      *_DebugRepeat(e2) {
        const t3 = this._runtime.GetEventSheetManager(), n2 = t3.GetEventStack(), r3 = n2.GetCurrentStackFrame(), a3 = r3.GetCurrentEvent(), i2 = a3.GetSolModifiers(), s2 = r3.IsSolModifierAfterCnds(), o3 = n2.Push(a3), u3 = t3.GetLoopStack(), l = u3.Push();
        if (l.SetEnd(e2), s2) for (let n3 = 0; n3 < e2 && !l.IsStopped(); ++n3) t3.PushCopySol(i2), l.SetIndex(n3), yield* a3.DebugRetrigger(r3, o3), t3.PopSol(i2);
        else for (let t4 = 0; t4 < e2 && !l.IsStopped(); ++t4) l.SetIndex(t4), yield* a3.DebugRetrigger(r3, o3);
        return n2.Pop(), u3.Pop(), false;
      }
      _While() {
        const e2 = this._runtime.GetEventSheetManager(), t3 = e2.GetEventStack(), n2 = t3.GetCurrentStackFrame(), r3 = n2.GetCurrentEvent(), a3 = r3.GetSolModifiers(), i2 = n2.IsSolModifierAfterCnds(), s2 = t3.Push(r3), o3 = e2.GetLoopStack(), u3 = o3.Push();
        if (i2) for (let t4 = 0; !u3.IsStopped(); ++t4) e2.PushCopySol(a3), u3.SetIndex(t4), r3.Retrigger(n2, s2) || u3.Stop(), e2.PopSol(a3);
        else for (let e3 = 0; !u3.IsStopped(); ++e3) u3.SetIndex(e3), r3.Retrigger(n2, s2) || u3.Stop();
        return t3.Pop(), o3.Pop(), false;
      }
      *_DebugWhile() {
        const e2 = this._runtime.GetEventSheetManager(), t3 = e2.GetEventStack(), n2 = t3.GetCurrentStackFrame(), r3 = n2.GetCurrentEvent(), a3 = r3.GetSolModifiers(), i2 = n2.IsSolModifierAfterCnds(), s2 = t3.Push(r3), o3 = e2.GetLoopStack(), u3 = o3.Push();
        if (i2) for (let t4 = 0; !u3.IsStopped(); ++t4) {
          e2.PushCopySol(a3), u3.SetIndex(t4);
          (yield* r3.DebugRetrigger(n2, s2)) || u3.Stop(), e2.PopSol(a3);
        }
        else for (let e3 = 0; !u3.IsStopped(); ++e3) {
          u3.SetIndex(e3);
          (yield* r3.DebugRetrigger(n2, s2)) || u3.Stop();
        }
        return t3.Pop(), o3.Pop(), false;
      }
      _For(e2, t3, n2) {
        const r3 = this._runtime.GetEventSheetManager(), a3 = r3.GetEventStack(), i2 = a3.GetCurrentStackFrame(), s2 = i2.GetCurrentEvent(), o3 = s2.GetSolModifiers(), u3 = i2.IsSolModifierAfterCnds(), l = a3.Push(s2), c2 = r3.GetLoopStack(), h2 = c2.Push();
        if (h2.SetName(e2), h2.SetEnd(n2), n2 < t3) if (u3) for (let e3 = t3; e3 >= n2 && !h2.IsStopped(); --e3) r3.PushCopySol(o3), h2.SetIndex(e3), s2.Retrigger(i2, l), r3.PopSol(o3);
        else for (let e3 = t3; e3 >= n2 && !h2.IsStopped(); --e3) h2.SetIndex(e3), s2.Retrigger(i2, l);
        else if (u3) for (let e3 = t3; e3 <= n2 && !h2.IsStopped(); ++e3) r3.PushCopySol(o3), h2.SetIndex(e3), s2.Retrigger(i2, l), r3.PopSol(o3);
        else for (let e3 = t3; e3 <= n2 && !h2.IsStopped(); ++e3) h2.SetIndex(e3), s2.Retrigger(i2, l);
        return a3.Pop(), c2.Pop(), false;
      }
      *_DebugFor(e2, t3, n2) {
        const r3 = this._runtime.GetEventSheetManager(), a3 = r3.GetEventStack(), i2 = a3.GetCurrentStackFrame(), s2 = i2.GetCurrentEvent(), o3 = s2.GetSolModifiers(), u3 = i2.IsSolModifierAfterCnds(), l = a3.Push(s2), c2 = r3.GetLoopStack(), h2 = c2.Push();
        if (h2.SetName(e2), h2.SetEnd(n2), n2 < t3) if (u3) for (let e3 = t3; e3 >= n2 && !h2.IsStopped(); --e3) r3.PushCopySol(o3), h2.SetIndex(e3), yield* s2.DebugRetrigger(i2, l), r3.PopSol(o3);
        else for (let e3 = t3; e3 >= n2 && !h2.IsStopped(); --e3) h2.SetIndex(e3), yield* s2.DebugRetrigger(i2, l);
        else if (u3) for (let e3 = t3; e3 <= n2 && !h2.IsStopped(); ++e3) r3.PushCopySol(o3), h2.SetIndex(e3), yield* s2.DebugRetrigger(i2, l), r3.PopSol(o3);
        else for (let e3 = t3; e3 <= n2 && !h2.IsStopped(); ++e3) h2.SetIndex(e3), yield* s2.DebugRetrigger(i2, l);
        return a3.Pop(), c2.Pop(), false;
      }
      _ForEach(t3) {
        const n2 = t3.GetCurrentSol(), r3 = n2.GetInstances();
        if (0 === r3.length) return false;
        const a3 = this._runtime.GetEventSheetManager(), i2 = a3.GetEventStack(), s2 = i2.GetCurrentStackFrame(), o3 = s2.GetCurrentEvent(), l = o3.GetSolModifiers(), c2 = s2.IsSolModifierAfterCnds(), h2 = i2.Push(o3), g2 = a3.GetLoopStack(), d2 = g2.Push(), S2 = t3.IsInContainer(), p2 = u2.Push();
        if (e.shallowAssignArray(p2, r3), d2.SetEnd(p2.length), c2) for (let e2 = 0, n3 = p2.length; e2 < n3 && !d2.IsStopped(); ++e2) {
          a3.PushCopySol(l);
          const n4 = p2[e2];
          t3.GetCurrentSol().SetSinglePicked(n4), S2 && n4.SetSiblingsSinglePicked(), d2.SetIndex(e2), o3.Retrigger(s2, h2), a3.PopSol(l);
        }
        else {
          n2._SetSelectAll(false);
          const t4 = n2._GetOwnInstances();
          e.clearArray(t4), t4.push(null);
          for (let e2 = 0, n3 = p2.length; e2 < n3 && !d2.IsStopped(); ++e2) {
            const n4 = p2[e2];
            t4[0] = n4, S2 && n4.SetSiblingsSinglePicked(), d2.SetIndex(e2), o3.Retrigger(s2, h2);
          }
        }
        return i2.Pop(), g2.Pop(), e.clearArray(p2), u2.Pop(), false;
      }
      *_DebugForEach(t3) {
        const n2 = t3.GetCurrentSol(), r3 = n2.GetInstances();
        if (0 === r3.length) return false;
        const a3 = this._runtime.GetEventSheetManager(), i2 = a3.GetEventStack(), s2 = i2.GetCurrentStackFrame(), o3 = s2.GetCurrentEvent(), l = o3.GetSolModifiers(), c2 = s2.IsSolModifierAfterCnds(), h2 = i2.Push(o3), g2 = a3.GetLoopStack(), d2 = g2.Push(), S2 = t3.IsInContainer(), p2 = u2.Push();
        if (e.shallowAssignArray(p2, r3), d2.SetEnd(p2.length), c2) for (let e2 = 0, n3 = p2.length; e2 < n3 && !d2.IsStopped(); ++e2) {
          a3.PushCopySol(l);
          const n4 = p2[e2];
          t3.GetCurrentSol().SetSinglePicked(n4), S2 && n4.SetSiblingsSinglePicked(), d2.SetIndex(e2), yield* o3.DebugRetrigger(s2, h2), a3.PopSol(l);
        }
        else {
          n2._SetSelectAll(false);
          const t4 = n2._GetOwnInstances();
          e.clearArray(t4), t4.push(null);
          for (let e2 = 0, n3 = p2.length; e2 < n3 && !d2.IsStopped(); ++e2) {
            const n4 = p2[e2];
            t4[0] = n4, S2 && n4.SetSiblingsSinglePicked(), d2.SetIndex(e2), yield* o3.DebugRetrigger(s2, h2);
          }
        }
        return i2.Pop(), g2.Pop(), e.clearArray(p2), u2.Pop(), false;
      }
      _ForEachOrdered(t3, n2) {
        const r3 = t3.GetCurrentSol(), a3 = r3.GetInstances();
        if (0 === a3.length) return false;
        const i2 = this._runtime.GetEventSheetManager(), s2 = i2.GetEventStack(), o3 = i2.GetCurrentCondition(), l = s2.GetCurrentStackFrame(), c2 = l.GetCurrentEvent(), h2 = c2.GetSolModifiers(), g2 = l.IsSolModifierAfterCnds(), d2 = s2.Push(c2), S2 = i2.GetLoopStack(), p2 = S2.Push(), m2 = t3.IsInContainer(), G = u2.Push();
        e.clearArray(G), p2.SetEnd(a3.length);
        for (let e2 = 0, t4 = a3.length; e2 < t4; ++e2) G.push([a3[e2], o3.ReevaluateParameter(1, e2)]);
        if (G.sort(ForEachOrdered_SortInstances), 1 === n2 && G.reverse(), g2) for (let e2 = 0, n3 = G.length; e2 < n3 && !p2.IsStopped(); ++e2) {
          i2.PushCopySol(h2);
          const n4 = G[e2][0];
          t3.GetCurrentSol().SetSinglePicked(n4), m2 && n4.SetSiblingsSinglePicked(), p2.SetIndex(e2), c2.Retrigger(l, d2), i2.PopSol(h2);
        }
        else {
          r3._SetSelectAll(false);
          const t4 = r3._GetOwnInstances();
          e.clearArray(t4), t4.push(null);
          for (let e2 = 0, n3 = G.length; e2 < n3 && !p2.IsStopped(); ++e2) {
            const n4 = G[e2][0];
            t4[0] = n4, m2 && n4.SetSiblingsSinglePicked(), p2.SetIndex(e2), c2.Retrigger(l, d2);
          }
        }
        return s2.Pop(), S2.Pop(), e.clearArray(G), u2.Pop(), false;
      }
      *_DebugForEachOrdered(t3, n2) {
        const r3 = t3.GetCurrentSol(), a3 = r3.GetInstances();
        if (0 === a3.length) return false;
        const i2 = this._runtime.GetEventSheetManager(), s2 = i2.GetEventStack(), o3 = i2.GetCurrentCondition(), l = s2.GetCurrentStackFrame(), c2 = l.GetCurrentEvent(), h2 = c2.GetSolModifiers(), g2 = l.IsSolModifierAfterCnds(), d2 = s2.Push(c2), S2 = i2.GetLoopStack(), p2 = S2.Push(), m2 = t3.IsInContainer(), G = u2.Push();
        e.clearArray(G), p2.SetEnd(a3.length);
        for (let e2 = 0, t4 = a3.length; e2 < t4; ++e2) G.push([a3[e2], o3.ReevaluateParameter(1, e2)]);
        if (G.sort(ForEachOrdered_SortInstances), 1 === n2 && G.reverse(), g2) for (let e2 = 0, n3 = G.length; e2 < n3 && !p2.IsStopped(); ++e2) {
          i2.PushCopySol(h2);
          const n4 = G[e2][0];
          t3.GetCurrentSol().SetSinglePicked(n4), m2 && n4.SetSiblingsSinglePicked(), p2.SetIndex(e2), yield* c2.DebugRetrigger(l, d2), i2.PopSol(h2);
        }
        else {
          r3._SetSelectAll(false);
          const t4 = r3._GetOwnInstances();
          e.clearArray(t4), t4.push(null);
          for (let e2 = 0, n3 = G.length; e2 < n3 && !p2.IsStopped(); ++e2) {
            const n4 = G[e2][0];
            t4[0] = n4, m2 && n4.SetSiblingsSinglePicked(), p2.SetIndex(e2), yield* c2.DebugRetrigger(l, d2);
          }
        }
        return s2.Pop(), S2.Pop(), e.clearArray(G), u2.Pop(), false;
      }
      _GetFunctionMap(e2, t3) {
        let n2 = this._functionMaps.get(e2);
        return n2 || (t3 ? (n2 = { defaultFunc: null, strMap: /* @__PURE__ */ new Map() }, this._functionMaps.set(e2, n2), n2) : null);
      }
      _DoCallMappedFunction(e2, t3, n2, r3, a3) {
        t3.GetEventBlock().RunAsMappedFunctionCall(n2, t3.IsCopyPicked()), r3 && e2.PopSol(a3);
      }
      *_DebugDoCallMappedFunction(e2, t3, n2, r3, a3) {
        yield* t3.GetEventBlock().DebugRunAsMappedFunctionCall(n2, t3.IsCopyPicked()), r3 && e2.PopSol(a3);
      }
    };
  }
  {
    const l = self.C3;
    l.Plugins.System.Type = class extends l.DefendedBase {
      constructor(e) {
        super(), this._objectClass = e, this._runtime = e.GetRuntime(), this._plugin = e.GetPlugin();
      }
      OnCreate() {
      }
      Release() {
        this._objectClass = null, this._runtime = null, this._plugin = null;
      }
    };
  }
  {
    const c2 = self.C3;
    c2.Plugins.System.Instance = class extends c2.DefendedBase {
      constructor(e, t2) {
        super(), this._inst = e, this._objectClass = this._inst.GetObjectClass(), this._sdkType = this._objectClass.GetSdkType(), this._runtime = this._inst.GetRuntime();
      }
      Release() {
        this._inst = null, this._objectClass = null, this._sdkType = null, this._runtime = null;
      }
    };
  }
  {
    const h2 = self.C3, g2 = [];
    h2.Plugins.System.Cnds = { EveryTick: () => true, OnLayoutStart: () => true, OnLayoutEnd: () => true, OnSuspend: () => true, OnResume: () => true, IsSuspended() {
      return this._runtime.IsSuspended();
    }, Else() {
      const e = this._runtime.GetCurrentEventStackFrame();
      return !e.GetElseBranchRan() && !e.GetLastEventTrue();
    }, TriggerOnce() {
      const e = this._runtime.GetCurrentCondition().GetSavedDataMap();
      let t2 = e.get("TriggerOnce_lastTick");
      void 0 === t2 && (t2 = -1, e.set("TriggerOnce_lastTick", -1));
      const n = this._runtime.GetTickCount();
      return e.set("TriggerOnce_lastTick", n), this._runtime.IsLayoutFirstTick() || t2 !== n - 1;
    }, Every(e) {
      const t2 = this._runtime.GetCurrentCondition().GetSavedDataMap(), n = t2.get("Every_lastTime") || 0, r2 = this._runtime.GetGameTime();
      t2.has("Every_seconds") || t2.set("Every_seconds", e);
      const a2 = t2.get("Every_seconds");
      return r2 >= n + a2 ? (t2.set("Every_lastTime", n + a2), r2 >= t2.get("Every_lastTime") + 0.04 && t2.set("Every_lastTime", r2), t2.set("Every_seconds", e), true) : (r2 < n - 0.1 && t2.set("Every_lastTime", r2), false);
    }, IsGroupActive(e) {
      const t2 = this._runtime.GetEventSheetManager().GetEventGroupByName(e);
      return t2 && t2.IsGroupActive();
    }, IsPreview() {
      return this._runtime.IsPreview();
    }, IsMobile: () => h2.Platform.IsMobile, OnLoadFinished: () => true, OnCanvasSnapshot: () => true, EffectsSupported: () => true, OnSaveComplete: () => true, OnSaveFailed: () => true, OnLoadComplete: () => true, OnLoadFailed: () => true, ObjectUIDExists(e) {
      return !!this._runtime.GetInstanceByUID(e);
    }, IsOnPlatform(e) {
      switch (e) {
        case 0:
          return "browser" === h2.Platform.Context;
        case 1:
          return "iOS" === h2.Platform.OS;
        case 2:
          return "Android" === h2.Platform.OS;
        case 8:
          return "cordova" === h2.Platform.Context;
        case 9:
          return "scirra-arcade" === this._runtime.GetExportType();
        case 13:
          return "windows-uwp" === this._runtime.GetExportType();
        default:
          return false;
      }
    }, RegexTest(e, t2, n) {
      return this.GetRegex(t2, n).test(e);
    }, Compare: (e, t2, n) => h2.compare(e, t2, n), CompareBetween: (e, t2, n) => e >= t2 && e <= n, CompareVar: (e, t2, n) => h2.compare(e.GetValue(), t2, n), CompareBoolVar: (e) => !!e.GetValue(), CompareTime(e, t2) {
      const n = this._runtime.GetGameTime();
      if (0 === e) {
        const e2 = this._runtime.GetCurrentCondition().GetSavedDataMap();
        return !e2.get("CompareTime_executed") && n >= t2 && (e2.set("CompareTime_executed", true), true);
      }
      return h2.compare(n, e, t2);
    }, IsNaN: (e) => isNaN(e), AngleWithin: (e, t2, n) => h2.angleDiff(h2.toRadians(e), h2.toRadians(n)) <= h2.toRadians(t2), IsClockwiseFrom: (e, t2) => h2.angleClockwise(h2.toRadians(e), h2.toRadians(t2)), IsBetweenAngles(e, t2, n) {
      let r2 = h2.toRadians(e), a2 = h2.toRadians(t2), i = h2.toRadians(n);
      return !h2.angleClockwise(i, a2) ? !(!h2.angleClockwise(r2, a2) && h2.angleClockwise(r2, i)) : h2.angleClockwise(r2, a2) && !h2.angleClockwise(r2, i);
    }, IsValueType: (e, t2) => "number" == typeof e ? 0 === t2 : 1 === t2, EvaluateExpression: (e) => !!e, OnSignal(e) {
      return e.toLowerCase() === this._runtime.GetEventSheetManager().GetCurrentSignalTag();
    }, PickByComparison(e, t2, n, r2) {
      if (!e) return false;
      const a2 = this._GetForEachStack(), i = a2.Push(), s = e.GetCurrentSol();
      h2.shallowAssignArray(i, s.GetInstances()), s.IsSelectAll() && h2.clearArray(s._GetOwnElseInstances());
      const o2 = this._runtime.GetCurrentCondition();
      let u2 = 0;
      for (let e2 = 0, a3 = i.length; e2 < a3; ++e2) {
        const a4 = i[e2];
        i[u2] = a4, t2 = o2.ReevaluateParameter(1, e2), r2 = o2.ReevaluateParameter(3, e2), h2.compare(t2, n, r2) ? ++u2 : s._PushElseInstance(a4);
      }
      h2.truncateArray(i, u2), s.SetArrayPicked(i);
      const l = !!i.length;
      return h2.clearArray(i), a2.Pop(), e.ApplySolToContainer(), l;
    }, PickByEvaluate(e, t2) {
      if (!e) return false;
      const n = this._GetForEachStack(), r2 = n.Push(), a2 = e.GetCurrentSol();
      h2.shallowAssignArray(r2, a2.GetInstances()), a2.IsSelectAll() && h2.clearArray(a2._GetOwnElseInstances());
      const i = this._runtime.GetCurrentCondition();
      let s = 0;
      for (let e2 = 0, t3 = r2.length; e2 < t3; ++e2) {
        const t4 = r2[e2];
        r2[s] = t4, i.ReevaluateParameter(1, e2) ? ++s : a2._PushElseInstance(t4);
      }
      h2.truncateArray(r2, s), a2.SetArrayPicked(r2);
      const o2 = !!r2.length;
      return h2.clearArray(r2), n.Pop(), e.ApplySolToContainer(), o2;
    }, PickByHighestLowestValue(e, t2, n) {
      if (!e) return false;
      const r2 = e.GetCurrentSol(), a2 = r2.GetInstances();
      if (0 === a2.length) return false;
      const i = this._runtime.GetCurrentCondition();
      let s = null, o2 = 0;
      for (let e2 = 0, r3 = a2.length; e2 < r3; ++e2) {
        const r4 = a2[e2];
        n = i.ReevaluateParameter(2, e2), (null === s || 0 === t2 && n < o2 || 1 === t2 && n > o2) && (o2 = n, s = r4);
      }
      return r2.PickOne(s), e.ApplySolToContainer(), true;
    }, PickNth(e, t2) {
      if (!e) return false;
      const n = e.GetCurrentSol(), r2 = n.GetInstances();
      if ((t2 = Math.floor(t2)) >= r2.length) return false;
      const a2 = r2[t2];
      return n.PickOne(a2), e.ApplySolToContainer(), true;
    }, PickRandom(e) {
      if (!e) return false;
      const t2 = e.GetCurrentSol(), n = t2.GetInstances(), r2 = Math.floor(this._runtime.Random() * n.length);
      if (r2 >= n.length) return false;
      const a2 = n[r2];
      return t2.PickOne(a2), e.ApplySolToContainer(), true;
    }, PickAll(e) {
      if (!e) return false;
      if (!e.GetInstanceCount()) return false;
      return e.GetCurrentSol()._SetSelectAll(true), e.ApplySolToContainer(), true;
    }, PickOverlappingPoint(e, t2, n) {
      if (!e) return false;
      const r2 = e.GetCurrentSol(), a2 = r2.GetInstances(), i = this._runtime.GetCurrentEvent().IsOrBlock(), s = this._runtime.GetCurrentCondition().IsInverted();
      r2.IsSelectAll() ? (h2.shallowAssignArray(g2, a2), r2.ClearArrays(), r2._SetSelectAll(false)) : i ? (h2.shallowAssignArray(g2, r2._GetOwnElseInstances()), h2.clearArray(r2._GetOwnElseInstances())) : (h2.shallowAssignArray(g2, r2._GetOwnInstances()), h2.clearArray(r2._GetOwnInstances()));
      for (let e2 = 0, a3 = g2.length; e2 < a3; ++e2) {
        const a4 = g2[e2];
        h2.xor(a4.GetWorldInfo().ContainsPoint(t2, n), s) ? r2._PushInstance(a4) : r2._PushElseInstance(a4);
      }
      return e.ApplySolToContainer(), h2.xor(!!r2._GetOwnInstances().length, s);
    }, PickLastCreated(e) {
      if (!e) return false;
      const t2 = e.IsFamily();
      let n = null;
      const r2 = this._runtime._GetInstancesPendingCreate();
      for (let a2 = r2.length - 1; a2 >= 0; --a2) {
        const i = r2[a2];
        if (t2) {
          if (i.GetObjectClass().BelongsToFamily(e)) {
            n = i;
            break;
          }
        } else if (i.GetObjectClass() === e) {
          n = i;
          break;
        }
      }
      if (!n) {
        const t3 = e.GetInstances();
        t3.length && (n = t3.at(-1));
      }
      if (!n) return false;
      return e.GetCurrentSol().PickOne(n), e.ApplySolToContainer(), true;
    }, Repeat(e) {
      return this._runtime.IsDebugging() ? this._DebugRepeat(e) : this._Repeat(e);
    }, While() {
      return this._runtime.IsDebugging() ? this._DebugWhile() : this._While();
    }, For(e, t2, n) {
      return this._runtime.IsDebugging() ? this._DebugFor(e, t2, n) : this._For(e, t2, n);
    }, ForEach(e) {
      return this._runtime.IsDebugging() ? this._DebugForEach(e) : this._ForEach(e);
    }, ForEachOrdered(e, t2, n) {
      return this._runtime.IsDebugging() ? this._DebugForEachOrdered(e, n) : this._ForEachOrdered(e, n);
    }, LayerVisible: (e) => !!e && e.IsVisible(), LayerInteractive: (e) => !!e && e.IsSelfAndParentsInteractive(), LayerIsHTML: (e) => !!e && e.IsHTMLElementsLayer(), LayerEmpty: (e) => !!e && !e.GetInstanceCount(), LayerCmpOpacity: (e, t2, n) => !!e && h2.compare(100 * e.GetOpacity(), t2, n), LayerNameExists(e) {
      const t2 = this._runtime.GetMainRunningLayout();
      return !!t2 && t2.HasLayerByName(e);
    }, OnImageLoadingComplete: () => true, IsLoadingImages() {
      return this._imagesLoadingTotal > 0;
    }, TemplateExists(e, t2) {
      const n = this._runtime.GetTemplateManager();
      return !!n && (!!t2 && !!n.GetTemplateData(e, t2));
    } };
  }
  {
    let SortZOrderList = function(e, t2) {
      const n = e[0] - t2[0];
      if (0 !== n) return n;
      return e[1] - t2[1];
    }, SortInstancesByValue = function(e, t2) {
      return e[1] - t2[1];
    };
    SortZOrderList2 = SortZOrderList, SortInstancesByValue2 = SortInstancesByValue;
    const d2 = self.C3;
    const S2 = [], p2 = [], m2 = d2.New(d2.Rect), G = d2.New(d2.Color), y2 = [];
    d2.Plugins.System.Acts = { SetVar(e, t2) {
      e.SetValue(t2);
    }, AddVar(e, t2) {
      e.IsNumber() && "number" != typeof t2 && (t2 = parseFloat(t2)), e.SetValue(e.GetValue() + t2);
    }, SubVar(e, t2) {
      e.IsNumber() && e.SetValue(e.GetValue() - t2);
    }, SetBoolVar(e, t2) {
      e.SetValue(!!t2);
    }, ToggleBoolVar(e) {
      e.SetValue(!e.GetValue());
    }, ResetEventVar(e) {
      e.SetValue(e.GetInitialValue());
    }, ResetGlobals(e) {
      this._runtime.GetEventSheetManager().ResetAllGlobalsToInitialValue(e);
    }, CreateObject(e, t2, n, r2, a2, i) {
      if (!e || !t2) return;
      const s = this._runtime.CreateInstance(e, t2, n, r2, a2, i);
      if (!s) return;
      a2 && t2.SortAndAddInstancesByZIndex(s);
      const o2 = this._runtime.GetEventSheetManager();
      o2.BlockFlushingInstances(true), s._TriggerOnCreatedOnSelfAndRelated(), o2.BlockFlushingInstances(false);
      const u2 = /* @__PURE__ */ new Map();
      s.CollectInstancesToPick(u2, e, a2);
      for (const [e2, t3] of u2) e2.GetCurrentSol().SetSetPicked(t3);
    }, CreateObjectByName(e, t2, n, r2, a2, i) {
      if (!e || !t2) return;
      const s = this._runtime.GetObjectClassByName(e);
      s && d2.Plugins.System.Acts.CreateObject.call(this, s, t2, n, r2, a2, i);
    }, RecreateInitialObjects(e, t2, n, r2, a2, i, s, o2, u2, l, c2) {
      if (!e) return;
      const h2 = this._runtime.GetCurrentLayout();
      let g2 = h2;
      if (i) {
        const e2 = this._runtime.GetLayoutManager().GetLayoutByName(i);
        if (!e2) return;
        g2 = e2;
      }
      let d3 = null;
      if (("number" != typeof s || s >= 0) && (d3 = g2.GetLayer(s), !d3)) return;
      let S3 = null;
      if (("number" != typeof o2 || o2 >= 0) && (S3 = h2.GetLayer(o2), !S3)) return;
      m2.set(t2, n, r2, a2);
      const p3 = g2.RecreateInitialObjects(e, m2, d3, S3, u2, l, c2);
      e.GetCurrentSol().SetArrayPicked(p3), e.ApplySolToContainer();
    }, StopLoop() {
      const e = this._loopStack;
      e.IsInLoop() && e.GetCurrent().Stop();
    }, SetGroupActive(e, t2) {
      const n = this._runtime.GetEventSheetManager().GetEventGroupByName(e);
      n && (0 === t2 ? n.SetGroupActive(false) : 1 === t2 ? n.SetGroupActive(true) : n.SetGroupActive(!n.IsGroupActive()));
    }, SetTimescale(e) {
      this._runtime.SetTimeScale(e);
    }, SetObjectTimescale(e, t2) {
      if (t2 < 0 && (t2 = 0), !e) return;
      const n = e.GetCurrentSol().GetInstances();
      for (const e2 of n) e2.SetTimeScale(t2);
    }, RestoreObjectTimescale(e) {
      if (!e) return;
      const t2 = e.GetCurrentSol().GetInstances();
      for (const e2 of t2) e2.RestoreTimeScale();
    }, Wait(e, t2) {
      if (e < 0) return;
      const n = this._runtime.GetEventSheetManager().AddScheduledWait();
      return t2 ? n.InitTimer(e) : n.InitWallTimer(e), true;
    }, WaitForSignal(e) {
      return this._runtime.GetEventSheetManager().AddScheduledWait().InitSignal(e), true;
    }, WaitForPreviousActions() {
      const e = this._runtime.GetEventSheetManager();
      return e.AddScheduledWait().InitPromise(e.GetPromiseForAllAsyncActions()), true;
    }, Signal(e) {
      this._runtime.GetEventSheetManager().Signal(e);
    }, async SnapshotCanvas(e, t2, n, r2, a2, i) {
      const s = this._runtime.GetCanvasManager();
      s && (this.UpdateRender(), await s.SnapshotCanvas(0 === e ? "image/png" : "image/jpeg", t2 / 100, n, r2, a2, i), await this._runtime.TriggerAsync(d2.Plugins.System.Cnds.OnCanvasSnapshot, null));
    }, SetCanvasSize(e, t2) {
      if (e <= 0 || t2 <= 0) return;
      this._runtime.SetViewportSize(e, t2), this._runtime.GetCurrentLayout().BoundScrolling();
      const n = this._runtime.GetCanvasManager();
      n && ("off" === n.GetCurrentFullscreenMode() || this._runtime.SetOriginalViewportSize(e, t2), n.SetSize(n.GetLastWidth(), n.GetLastHeight(), true), this._runtime.UpdateRender());
    }, SetFullscreenQuality(e) {
      const t2 = this._runtime.GetCanvasManager();
      t2 && "off" !== t2.GetCurrentFullscreenMode() && (t2.SetFullscreenScalingQuality(0 !== e ? "high" : "low"), t2.SetSize(t2.GetLastWidth(), t2.GetLastHeight(), true));
    }, SaveState(e) {
      this._runtime.SaveToSlot(e);
    }, SaveStateJSON() {
      this._runtime.SaveToJsonString();
    }, LoadState(e) {
      this._runtime.LoadFromSlot(e);
    }, LoadStateJSON(e) {
      this._runtime.LoadFromJsonString(e);
    }, SetHalfFramerateMode(e) {
    }, ResetPersisted() {
      for (const e of this._runtime.GetLayoutManager().GetAllLayouts()) e.ResetPersistData();
    }, SetPixelRounding(e) {
      this._runtime.SetPixelRoundingEnabled(0 !== e);
    }, SetFramerateMinMax(e, t2) {
      this._runtime.SetMaxDt(1 / e), this._runtime.SetMinDt(1 / t2);
    }, SetDeltaTimeMinMax(e, t2) {
      this._runtime.SetMinDt(e), this._runtime.SetMaxDt(t2);
    }, SetFramerateMode(e) {
      this._runtime._SetFramerateMode(["vsync", "unlimited-tick", "unlimited-frame"][e]);
    }, SortZOrderByInstVar(e, t2) {
      if (!e) return;
      const n = e.GetCurrentSol().GetInstances(), r2 = S2, a2 = p2, i = this._runtime.GetCurrentLayout(), s = e.IsFamily(), o2 = e.GetFamilyIndex();
      for (let e2 = 0, i2 = n.length; e2 < i2; ++e2) {
        const i3 = n[e2], u3 = i3.GetWorldInfo();
        if (!u3) continue;
        let l;
        l = s ? i3.GetInstanceVariableValue(t2 + i3.GetObjectClass().GetFamilyInstanceVariableOffset(o2)) : i3.GetInstanceVariableValue(t2), r2.push([u3.GetLayer().GetIndex(), u3.GetZIndex()]), a2.push([i3, l]);
      }
      if (!r2.length) return;
      r2.sort(SortZOrderList), a2.sort(SortInstancesByValue);
      let u2 = false;
      for (let e2 = 0, t3 = r2.length; e2 < t3; ++e2) {
        const t4 = a2[e2][0], n2 = i.GetLayerByIndex(r2[e2][0]), s2 = r2[e2][1], o3 = n2._GetInstances();
        o3[s2] !== t4 && (o3[s2] = t4, t4.GetWorldInfo()._SetLayer(n2, true), n2.SetZIndicesChanged(t4), u2 = true);
      }
      u2 && this._runtime.UpdateRender(), d2.clearArray(S2), d2.clearArray(p2);
    }, SetCollisionCellSize(e, t2) {
      e = Math.floor(e), t2 = Math.floor(t2), e <= 0 || t2 <= 0 || !Number.isFinite(e) || !Number.isFinite(t2) || this._runtime.GetCollisionEngine().SetCollisionCellSize(e, t2);
    }, GoToLayout(e) {
      if (this._runtime.IsLoading()) return;
      const t2 = this._runtime.GetLayoutManager();
      t2.IsPendingChangeMainLayout() || t2.ChangeMainLayout(e);
    }, GoToLayoutByName(e) {
      if (this._runtime.IsLoading()) return;
      const t2 = this._runtime.GetLayoutManager();
      if (t2.IsPendingChangeMainLayout()) return;
      const n = t2.GetLayoutByName(e);
      n && t2.ChangeMainLayout(n);
    }, NextPrevLayout(e) {
      if (this._runtime.IsLoading()) return;
      const t2 = this._runtime.GetLayoutManager();
      if (t2.IsPendingChangeMainLayout()) return;
      const n = t2.GetAllLayouts(), r2 = n.indexOf(t2.GetMainRunningLayout());
      if (e && 0 === r2) return;
      if (!e && r2 === n.length - 1) return;
      const a2 = n[r2 + (e ? -1 : 1)];
      t2.ChangeMainLayout(a2);
    }, RestartLayout() {
      if (this._runtime.IsLoading()) return;
      const e = this._runtime.GetLayoutManager();
      e.IsPendingChangeMainLayout() || (e.ChangeMainLayout(e.GetMainRunningLayout()), this._runtime.GetEventSheetManager().ResetAllGroupsInitialActivation());
    }, SetLayerVisible(e, t2) {
      e && e.SetVisible(t2);
    }, SetLayerInteractive(e, t2) {
      e && e.SetInteractive(t2);
    }, SetLayerHTML(e, t2) {
      e && e.SetIsHTMLElementsLayer(t2);
    }, SetLayerOpacity(e, t2) {
      e && e.SetOpacity(t2 / 100);
    }, SetLayerScale(e, t2) {
      e && e.SetOwnScale(t2);
    }, SetLayerScaleRate(e, t2) {
      e && e.SetScaleRate(t2);
    }, SetLayerAngle(e, t2) {
      e && e.SetAngle(d2.toRadians(+t2));
    }, SetLayerScroll(e, t2, n) {
      e && (e.SetOwnScrollPositionEnabled(true), e.SetScrollX(t2), e.SetScrollY(n));
    }, RestoreLayerScroll(e) {
      e && e.SetOwnScrollPositionEnabled(false);
    }, SetLayerParallax(e, t2, n) {
      e && e.SetParallax(t2 / 100, n / 100);
    }, SetLayerZElevation(e, t2) {
      e && e.SetZElevation(+t2);
    }, SetLayerRenderingMode(e, t2) {
      e && e.SetRenderAs3D(1 === t2);
    }, SetLayerBackground(e, t2) {
      if (!e) return;
      G.setFromRgbValue(t2), G.clamp();
      const n = e.GetBackgroundColor();
      n.equalsIgnoringAlpha(G) || (n.copyRgb(G), this.UpdateRender());
    }, SetLayerTransparent(e, t2) {
      e && e.SetTransparent(t2);
    }, SetLayerBlendMode(e, t2) {
      e && e.SetBlendMode(t2);
    }, SetLayerEffectEnabled(e, t2, n) {
      if (!e) return;
      const r2 = e.GetEffectList().GetEffectTypeByName(n);
      if (!r2) return;
      const a2 = 1 === t2;
      r2.IsActive() !== a2 && (r2.SetActive(a2), e.UpdateActiveEffects(), this._runtime.UpdateRender());
    }, SetLayerEffectParam(e, t2, n, r2) {
      if (!e) return;
      const a2 = e.GetEffectList(), i = a2.GetEffectTypeByName(t2);
      if (!i) return;
      n = Math.floor(n);
      const s = i.GetShaderProgram().GetParameterType(n);
      if (!s) return;
      "color" === s ? (G.setFromRgbValue(r2), r2 = G) : "percent" === s && (r2 /= 100);
      a2.SetEffectParameter(i.GetIndex(), n, r2) && i.IsActive() && this._runtime.UpdateRender();
    }, SetLayerForceOwnTexture(e, t2) {
      e && e.SetForceOwnTexture(t2);
    }, SetLayoutScale(e) {
      this._runtime.GetCurrentLayout().SetScale(+e);
    }, SetLayoutAngle(e) {
      this._runtime.GetCurrentLayout().SetAngle(d2.toRadians(+e));
    }, SetLayoutEffectEnabled(e, t2) {
      const n = this._runtime.GetCurrentLayout(), r2 = n.GetEffectList().GetEffectTypeByName(t2);
      if (!r2) return;
      const a2 = 1 === e;
      r2.IsActive() !== a2 && (r2.SetActive(a2), n.UpdateActiveEffects(), this._runtime.UpdateRender());
    }, SetLayoutEffectParam(e, t2, n) {
      const r2 = this._runtime.GetCurrentLayout().GetEffectList(), a2 = r2.GetEffectTypeByName(e);
      if (!a2) return;
      t2 = Math.floor(t2);
      const i = a2.GetShaderProgram().GetParameterType(t2);
      if (!i) return;
      "color" === i ? (G.setFromRgbValue(n), n = G) : "percent" === i && (n /= 100);
      r2.SetEffectParameter(a2.GetIndex(), t2, n) && a2.IsActive() && this._runtime.UpdateRender();
    }, SetLayoutVanishingPoint(e, t2) {
      this._runtime.GetCurrentLayout().SetVanishingPointXY(e / 100, t2 / 100);
    }, SetLayoutProjection(e) {
      const t2 = this._runtime.GetCurrentLayout();
      0 === e ? t2.SetPerspectiveProjection() : t2.SetOrthographicProjection();
    }, ScrollX(e) {
      this._runtime.GetCurrentLayout().SetScrollX(e);
    }, ScrollY(e) {
      this._runtime.GetCurrentLayout().SetScrollY(e);
    }, Scroll(e, t2) {
      const n = this._runtime.GetCurrentLayout();
      n.SetScrollX(e), n.SetScrollY(t2);
    }, ScrollToObject(e) {
      if (!e) return;
      const t2 = e.GetFirstPicked();
      if (!t2) return;
      const n = t2.GetWorldInfo();
      if (!n) return;
      const r2 = this._runtime.GetCurrentLayout();
      r2.SetScrollX(n.GetX()), r2.SetScrollY(n.GetY());
    }, AddLayer(e, t2, n) {
      const r2 = this._runtime.GetCurrentLayout();
      try {
        r2.AddLayer(e, t2, n);
      } catch (e2) {
        console.warn("[Construct] Cannot add layer: ", e2);
      }
    }, MoveLayer(e, t2, n) {
      if (!e) return;
      const r2 = this._runtime.GetCurrentLayout();
      try {
        r2.MoveLayer(e, t2, n);
      } catch (e2) {
        console.warn("[Construct] Cannot move layer: ", e2);
      }
    }, RemoveLayer(e) {
      if (!e) return;
      this._runtime.GetCurrentLayout().RemoveLayer(e);
    }, RemoveAllDynamicLayers() {
      this._runtime.GetCurrentLayout().RemoveAllDynamicLayers();
    }, async LoadObjectTextures(e) {
      const t2 = this._runtime.GetMainRunningLayout();
      if (!t2 || !e || this._runtime.IsLoading()) return;
      const n = e.IsFamily() ? e.GetFamilyMembers() : [e];
      await this._LoadTexturesForObjectClasses(t2, n);
    }, async LoadObjectTexturesByName(e) {
      await d2.Plugins.System.Acts.LoadObjectTextures.call(this, this._runtime.GetObjectClassByName(e));
    }, UnloadObjectTextures(e) {
      const t2 = this._runtime.GetMainRunningLayout();
      if (!t2 || !e) return;
      const n = e.IsFamily() ? e.GetFamilyMembers() : [e];
      this._UnloadTexturesForObjectClasses(t2, n);
    }, UnloadObjectTexturesByName(e) {
      d2.Plugins.System.Acts.UnloadObjectTextures.call(this, this._runtime.GetObjectClassByName(e));
    }, UnloadUnusedTextures() {
      const e = this._runtime.GetMainRunningLayout();
      if (!e) return;
      const t2 = e._GetTextureLoadedObjectTypes();
      this._UnloadTexturesForObjectClasses(e, t2);
    }, async LoadLayoutTextures(e) {
      const t2 = this._runtime.GetMainRunningLayout();
      e && t2 && !this._runtime.IsLoading() && await this._LoadTexturesForObjectClasses(t2, e._GetInitialObjectClasses());
    }, async LoadLayoutTexturesByName(e) {
      const t2 = this._runtime.GetMainRunningLayout(), n = this._runtime.GetLayoutManager().GetLayoutByName(e);
      n && t2 && !this._runtime.IsLoading() && await this._LoadTexturesForObjectClasses(t2, n._GetInitialObjectClasses());
    }, SetFunctionReturnValue(e) {
      const t2 = this._eventStack.GetCurrentExpFuncStackFrame();
      if (t2) switch (t2.GetFunctionReturnType()) {
        case 1:
          "number" == typeof e && t2.SetFunctionReturnValue(e);
          break;
        case 2:
          "string" == typeof e && t2.SetFunctionReturnValue(e);
          break;
        case 3:
          t2.SetFunctionReturnValue(e);
      }
    }, MapFunction(e, t2, n) {
      const r2 = this._GetFunctionMap(e.toLowerCase(), true), a2 = r2.strMap, i = t2.toLowerCase();
      a2.has(i) && console.warn(`[Construct] Function map '${e}' string '${t2}' already in map; overwriting entry`);
      const s = d2.first(a2.values()) || r2.defaultFunc;
      if (s) {
        if (0 !== s.GetReturnType() !== (0 !== n.GetReturnType())) return void console.error(`[Construct] Function map '${e}' string '${t2}' function return type not compatible with other functions in the map; entry ignored`);
      }
      a2.set(i, n);
    }, MapFunctionDefault(e, t2) {
      const n = this._GetFunctionMap(e.toLowerCase(), true);
      n.defaultFunc && console.warn(`[Construct] Function map '${e}' already has a default; overwriting entry`);
      const r2 = d2.first(n.strMap.values()) || n.defaultFunc;
      if (r2) {
        if (0 !== r2.GetReturnType() !== (0 !== t2.GetReturnType())) return void console.error(`[Construct] Function map '${e}' default: function return type not compatible with other functions in the map; entry ignored`);
      }
      n.defaultFunc = t2;
    }, CallMappedFunction(e, t2, n) {
      const r2 = this._runtime, a2 = r2.IsDebugging() ? y2 : null;
      n = Math.floor(n);
      const i = this._GetFunctionMap(e.toLowerCase(), false);
      if (!i) return console.warn(`[Construct] Call mapped function: map name '${e}' not found; call ignored`), a2;
      let s = i.strMap.get(t2.toLowerCase());
      if (!s) {
        if (!i.defaultFunc) return console.warn(`[Construct] Call mapped function: no function associated with map '${e}' string '${t2}'; call ignored (consider setting a default)`), a2;
        s = i.defaultFunc, n = 0;
      }
      if (!s.IsEnabled()) return a2;
      if (0 !== s.GetReturnType()) return console.warn(`[Construct] Call mapped function: map '${e}' string '${t2}' has a return type so cannot be called`), a2;
      const o2 = r2.GetEventSheetManager(), u2 = o2.GetCurrentEvent(), l = u2.GetSolModifiersIncludingParents(), c2 = l.length > 0;
      c2 && (s.IsCopyPicked() ? o2.PushCopySol(l) : o2.PushCleanSol(l));
      const h2 = [], g2 = o2.FindFirstFunctionBlockParent(u2);
      if (g2) {
        const e2 = g2.GetFunctionParameters();
        for (let t3 = n, r3 = e2.length; t3 < r3; ++t3) h2.push(e2[t3].GetValue());
      }
      const d3 = s.GetFunctionParameters();
      for (let e2 = h2.length, t3 = d3.length; e2 < t3; ++e2) h2.push(d3[e2].GetInitialValue());
      return r2.IsDebugging() ? this._DebugDoCallMappedFunction(o2, s, h2, c2, l) : this._DoCallMappedFunction(o2, s, h2, c2, l);
    } };
  }
  {
    const f2 = self.C3;
    f2.Plugins.System.Exps = { int: function(e) {
      return "string" == typeof e && (e = parseInt(e, 10), isNaN(e) && (e = 0)), Math.floor(e);
    }, float: function(e) {
      return "string" == typeof e && (e = parseFloat(e), isNaN(e) && (e = 0)), e;
    }, str: (e) => e.toString(), len: (e) => "string" == typeof e ? e.length : 0, random(e, t2) {
      return void 0 === t2 ? this._runtime.Random() * e : this._runtime.Random() * (t2 - e) + e;
    }, choose(...e) {
      return e[Math.floor(this._runtime.Random() * e.length)];
    }, chooseindex: (e, ...t2) => ("number" != typeof e && (e = 0), t2[e = f2.clamp(Math.floor(e), 0, t2.length - 1)]), pi: () => Math.PI, infinity: () => 1 / 0, sqrt: (e) => Math.sqrt(e), abs: (e) => Math.abs(e), round: (e) => Math.round(e), roundtodp(e, t2) {
      t2 = Math.max(Math.floor(t2), 0);
      const n = Math.pow(10, t2);
      return Math.round((e + Number.EPSILON) * n) / n;
    }, floor: (e) => Math.floor(e), ceil: (e) => Math.ceil(e), sign: (e) => Math.sign(e), sin: (e) => Math.sin(f2.toRadians(e)), cos: (e) => Math.cos(f2.toRadians(e)), tan: (e) => Math.tan(f2.toRadians(e)), asin: (e) => f2.toDegrees(Math.asin(e)), acos: (e) => f2.toDegrees(Math.acos(e)), atan: (e) => f2.toDegrees(Math.atan(e)), exp: (e) => Math.exp(e), ln: (e) => Math.log(e), log10: (e) => Math.log10(e), max(...e) {
      let t2 = e[0];
      "number" != typeof t2 && (t2 = 0);
      for (let n = 1, r2 = e.length; n < r2; ++n) {
        let r3 = e[n];
        "number" == typeof r3 && (t2 < r3 && (t2 = r3));
      }
      return t2;
    }, min(...e) {
      let t2 = e[0];
      "number" != typeof t2 && (t2 = 0);
      for (let n = 1, r2 = e.length; n < r2; ++n) {
        let r3 = e[n];
        "number" == typeof r3 && (t2 > r3 && (t2 = r3));
      }
      return t2;
    }, clamp: (e, t2, n) => f2.clamp(e, t2, n), distance: (e, t2, n, r2) => f2.distanceTo(e, t2, n, r2), angle: (e, t2, n, r2) => f2.toDegrees(f2.angleTo(e, t2, n, r2)), lerp: (e, t2, n) => f2.lerp(e, t2, n), unlerp: (e, t2, n) => f2.unlerp(e, t2, n), qarp: (e, t2, n, r2) => f2.qarp(e, t2, n, r2), cubic: (e, t2, n, r2, a2) => f2.cubic(e, t2, n, r2, a2), cosp: (e, t2, n) => f2.cosp(e, t2, n), anglediff: (e, t2) => f2.toDegrees(f2.angleDiff(f2.toRadians(e), f2.toRadians(t2))), anglelerp: (e, t2, n) => f2.toDegrees(f2.angleLerp(f2.toRadians(e), f2.toRadians(t2), n)), anglerotate: (e, t2, n) => f2.toDegrees(f2.angleRotate(f2.toRadians(e), f2.toRadians(t2), f2.toRadians(n))), setbit: (e, t2, n) => (e |= 0) & ~(1 << (t2 |= 0)) | (n = 0 !== n ? 1 : 0) << t2, togglebit: (e, t2) => (e |= 0) ^ 1 << (t2 |= 0), getbit: (e, t2) => (e |= 0) & 1 << (t2 |= 0) ? 1 : 0, newline: () => "\n", uppercase: (e) => "string" == typeof e ? e.toUpperCase() : "", lowercase: (e) => "string" == typeof e ? e.toLowerCase() : "", left: (e, t2) => "string" == typeof e ? e.substr(0, t2) : "", mid: (e, t2, n) => "string" != typeof e ? "" : n < 0 ? e.substr(t2) : e.substr(t2, n), right: (e, t2) => "string" == typeof e ? e.substr(Math.max(e.length - t2, 0)) : "", trim: (e) => "string" == typeof e ? e.trim() : "", tokenat(e, t2, n) {
      if ("string" != typeof e || "string" != typeof n) return "";
      let r2 = e.split(n);
      return (t2 = Math.floor(t2)) < 0 || t2 >= r2.length ? "" : r2[t2];
    }, tokencount: (e, t2) => "string" == typeof e && "string" == typeof t2 && e.length ? e.split(t2).length : 0, find: (e, t2) => "string" == typeof e && "string" == typeof t2 ? e.search(new RegExp(f2.EscapeRegex(t2), "i")) : -1, findcase: (e, t2) => "string" == typeof e && "string" == typeof t2 ? e.search(new RegExp(f2.EscapeRegex(t2), "")) : -1, replace: (e, t2, n) => "string" == typeof e && "string" == typeof t2 && "string" == typeof n ? e.replace(new RegExp(f2.EscapeRegex(t2), "gi"), n) : "string" == typeof e ? e : "", stringsub(e, ...t2) {
      let n = e;
      for (let e2 = 0, r2 = t2.length; e2 < r2; ++e2) n = n.replaceAll(`{${e2}}`, t2[e2].toString());
      return n;
    }, regexsearch(e, t2, n) {
      const r2 = this.GetRegex(t2, n);
      return e ? e.search(r2) : -1;
    }, regexreplace(e, t2, n, r2) {
      const a2 = this.GetRegex(t2, n);
      return e ? e.replace(a2, r2) : "";
    }, regexmatchcount(e, t2, n) {
      const r2 = this.GetRegexMatches(e.toString(), t2, n);
      return r2 ? r2.length : 0;
    }, regexmatchat(e, t2, n, r2) {
      r2 = Math.floor(r2);
      const a2 = this.GetRegexMatches(e.toString(), t2, n);
      return !a2 || r2 < 0 || r2 >= a2.length ? "" : a2[r2];
    }, zeropad(e, t2) {
      let n = e < 0 ? "-" : "";
      e < 0 && (e = -e);
      const r2 = t2 - e.toString().length;
      return n += "0".repeat(Math.max(r2, 0)), n + e.toString();
    }, urlencode: (e) => encodeURIComponent(e), urldecode: (e) => decodeURIComponent(e), dt() {
      return this._runtime._GetDtFast();
    }, wallclockdt() {
      return this._runtime.GetDt1();
    }, timescale() {
      return this._runtime.GetTimeScale();
    }, wallclocktime() {
      return (Date.now() - this._runtime.GetStartTime()) / 1e3;
    }, unixtime: () => Date.now(), time() {
      return this._runtime.GetGameTime();
    }, tickcount() {
      return this._runtime.GetTickCount();
    }, objectcount() {
      return this._runtime.GetObjectCount();
    }, fps() {
      return this._runtime.GetFramesPerSecond();
    }, cpuutilisation() {
      return this._runtime.GetMainThreadTime();
    }, gpuutilisation() {
      return this._runtime.GetGPUUtilisation();
    }, windowwidth() {
      return this._runtime.GetCanvasManager().GetDeviceWidth();
    }, windowheight() {
      return this._runtime.GetCanvasManager().GetDeviceHeight();
    }, originalwindowwidth() {
      return this._runtime.GetOriginalViewportWidth();
    }, originalwindowheight() {
      return this._runtime.GetOriginalViewportHeight();
    }, originalviewportwidth() {
      return this._runtime.GetOriginalViewportWidth();
    }, originalviewportheight() {
      return this._runtime.GetOriginalViewportHeight();
    }, scrollx() {
      return this._runtime.GetCurrentLayout().GetScrollX();
    }, scrolly() {
      return this._runtime.GetCurrentLayout().GetScrollY();
    }, layoutname() {
      return this._runtime.GetCurrentLayout().GetName();
    }, layoutscale() {
      return this._runtime.GetCurrentLayout().GetScale();
    }, layoutangle() {
      return f2.toDegrees(this._runtime.GetCurrentLayout().GetAngle());
    }, layoutwidth() {
      return this._runtime.GetCurrentLayout().GetWidth();
    }, layoutheight() {
      return this._runtime.GetCurrentLayout().GetHeight();
    }, vanishingpointx() {
      return 100 * this._runtime.GetCurrentLayout().GetVanishingPointX();
    }, vanishingpointy() {
      return 100 * this._runtime.GetCurrentLayout().GetVanishingPointY();
    }, viewportleft(e) {
      const t2 = this._runtime.GetCurrentLayout().GetLayer(e);
      return t2 ? t2.GetViewport3D().getLeft() : 0;
    }, viewporttop(e) {
      const t2 = this._runtime.GetCurrentLayout().GetLayer(e);
      return t2 ? t2.GetViewport3D().getTop() : 0;
    }, viewportright(e) {
      const t2 = this._runtime.GetCurrentLayout().GetLayer(e);
      return t2 ? t2.GetViewport3D().getRight() : 0;
    }, viewportbottom(e) {
      const t2 = this._runtime.GetCurrentLayout().GetLayer(e);
      return t2 ? t2.GetViewport3D().getBottom() : 0;
    }, viewportwidth(e) {
      const t2 = this._runtime.GetCurrentLayout().GetLayer(e);
      return t2 ? t2.GetViewport3D().width() : 0;
    }, viewportheight(e) {
      const t2 = this._runtime.GetCurrentLayout().GetLayer(e);
      return t2 ? t2.GetViewport3D().height() : 0;
    }, viewportmidx(e) {
      const t2 = this._runtime.GetCurrentLayout().GetLayer(e);
      if (t2) {
        const e2 = t2.GetViewport3D();
        return (e2.getLeft() + e2.getRight()) / 2;
      }
      return 0;
    }, viewportmidy(e) {
      const t2 = this._runtime.GetCurrentLayout().GetLayer(e);
      if (t2) {
        const e2 = t2.GetViewport3D();
        return (e2.getTop() + e2.getBottom()) / 2;
      }
      return 0;
    }, canvastolayerx(e, t2, n) {
      const r2 = this._runtime.GetCurrentLayout().GetLayer(e);
      return r2 ? r2.CanvasCssToLayer(t2, n)[0] : 0;
    }, canvastolayery(e, t2, n) {
      const r2 = this._runtime.GetCurrentLayout().GetLayer(e);
      return r2 ? r2.CanvasCssToLayer(t2, n)[1] : 0;
    }, layertocanvasx(e, t2, n) {
      const r2 = this._runtime.GetCurrentLayout().GetLayer(e);
      return r2 ? r2.LayerToCanvasCss(t2, n)[0] : 0;
    }, layertocanvasy(e, t2, n) {
      const r2 = this._runtime.GetCurrentLayout().GetLayer(e);
      return r2 ? r2.LayerToCanvasCss(t2, n)[1] : 0;
    }, layertolayerx(e, t2, n, r2) {
      const a2 = this._runtime.GetCurrentLayout(), i = a2.GetLayer(e), s = a2.GetLayer(t2);
      if (!i || !s || i === s) return n;
      const [o2, u2] = i.LayerToCanvasCss(n, r2);
      return s.CanvasCssToLayer(o2, u2)[0];
    }, layertolayery(e, t2, n, r2) {
      const a2 = this._runtime.GetCurrentLayout(), i = a2.GetLayer(e), s = a2.GetLayer(t2);
      if (!i || !s || i === s) return r2;
      const [o2, u2] = i.LayerToCanvasCss(n, r2);
      return s.CanvasCssToLayer(o2, u2)[1];
    }, layerscale(e) {
      const t2 = this._runtime.GetCurrentLayout().GetLayer(e);
      return t2 ? t2.GetOwnScale() : 0;
    }, layerangle(e) {
      const t2 = this._runtime.GetCurrentLayout().GetLayer(e);
      return t2 ? f2.toDegrees(t2.GetOwnAngle()) : 0;
    }, layeropacity(e) {
      const t2 = this._runtime.GetCurrentLayout().GetLayer(e);
      return t2 ? 100 * t2.GetOpacity() : 0;
    }, layerscalerate(e) {
      const t2 = this._runtime.GetCurrentLayout().GetLayer(e);
      return t2 ? t2.GetScaleRate() : 0;
    }, layerscrollx(e) {
      const t2 = this._runtime.GetCurrentLayout().GetLayer(e);
      return t2 ? t2.GetScrollX() : 0;
    }, layerscrolly(e) {
      const t2 = this._runtime.GetCurrentLayout().GetLayer(e);
      return t2 ? t2.GetScrollY() : 0;
    }, layerparallaxx(e) {
      const t2 = this._runtime.GetCurrentLayout().GetLayer(e);
      return t2 ? 100 * t2.GetParallaxX() : 0;
    }, layerparallaxy(e) {
      const t2 = this._runtime.GetCurrentLayout().GetLayer(e);
      return t2 ? 100 * t2.GetParallaxY() : 0;
    }, layerzelevation(e) {
      const t2 = this._runtime.GetCurrentLayout().GetLayer(e);
      return t2 ? t2.GetZElevation() : 0;
    }, layerindex(e) {
      const t2 = this._runtime.GetCurrentLayout().GetLayer(e);
      return t2 ? t2.GetIndex() : -1;
    }, canvassnapshot() {
      const e = this._runtime.GetCanvasManager();
      return e ? e.GetCanvasSnapshotUrl() : "";
    }, loopindex(e) {
      const t2 = this._loopStack;
      if (!t2.IsInLoop()) return 0;
      if (e) {
        const n = t2.FindByName(e);
        return n ? n.GetIndex() : 0;
      }
      return t2.GetCurrent().GetIndex();
    }, savestatejson() {
      return this._runtime.GetLastSaveJsonString();
    }, callmapped(e, t2, ...n) {
      const r2 = this._GetFunctionMap(e.toLowerCase(), false);
      if (!r2) return console.warn(`[Construct] Call mapped function: map name '${e}' not found; returning 0`), 0;
      let a2 = r2.strMap.get(t2.toLowerCase());
      if (!a2) {
        if (!r2.defaultFunc) return console.warn(`[Construct] Call mapped function: no function associated with map '${e}' string '${t2}'; returning 0 (consider setting a default)`), 0;
        a2 = r2.defaultFunc;
      }
      const i = a2.GetReturnType(), s = a2.GetDefaultReturnValue();
      if (0 === i) return console.warn(`[Construct] Call mapped function: map '${e}' string '${t2}' has no return type so cannot be called from an expression; returning 0`), 0;
      if (!a2.IsEnabled()) return s;
      const o2 = this._runtime.GetEventSheetManager(), u2 = o2.GetCurrentEvent().GetSolModifiersIncludingParents(), l = u2.length > 0;
      l && (a2.IsCopyPicked() ? o2.PushCopySol(u2) : o2.PushCleanSol(u2));
      const c2 = a2.GetFunctionParameters();
      for (let e2 = n.length, t3 = c2.length; e2 < t3; ++e2) n.push(c2[e2].GetInitialValue());
      const h2 = a2.GetEventBlock(), g2 = h2.RunAsExpressionFunctionCall(h2.GetSolModifiersIncludingParents(), a2.IsCopyPicked(), i, s, ...n);
      return l && o2.PopSol(u2), g2;
    }, loadingprogress() {
      return this._runtime.GetAssetManager().GetLoadProgress();
    }, imageloadingprogress() {
      return this.GetImageLoadingProgress();
    }, renderer() {
      return this._runtime.GetWebGPURenderer() ? "webgpu" : "webgl";
    }, rendererdetail() {
      return this._runtime.GetWebGPURenderer() ? this._runtime.GetWebGPURenderer().GetAdapterInfoString() : this._runtime.GetWebGLRenderer().GetUnmaskedRenderer();
    }, imagememoryusage() {
      let e = this._runtime.GetRenderer().GetEstimatedTextureMemoryUsage();
      return Math.round(100 * e / 1048576) / 100;
    }, rgb: (e, t2, n) => f2.PackRGB(e, t2, n), rgbex: (e, t2, n) => f2.PackRGBEx(e / 100, t2 / 100, n / 100), rgba: (e, t2, n, r2) => f2.PackRGBAEx(e / 100, t2 / 100, n / 100, r2 / 100), rgbex255: (e, t2, n) => f2.PackRGBEx(e / 255, t2 / 255, n / 255), rgba255: (e, t2, n, r2) => f2.PackRGBAEx(e / 255, t2 / 255, n / 255, r2 / 255), projectname() {
      return this._runtime.GetProjectName();
    }, projectversion() {
      return this._runtime.GetProjectVersion();
    }, projectid() {
      return this._runtime.GetAppId();
    }, projectuniqueid() {
      return this._runtime.GetProjectUniqueId();
    }, currenteventsheetname() {
      return this._runtime.GetCurrentEvent().GetEventSheet().GetName();
    }, currenteventnumber() {
      return this._runtime.GetCurrentEvent().GetDisplayNumber();
    }, projectfilecount() {
      return this._runtime.GetAssetManager().GetExportedFileList().length;
    }, projectfilenameat(e) {
      e = Math.floor(e);
      const t2 = this._runtime.GetAssetManager().GetExportedFileList();
      return e < 0 || e >= t2.length ? "" : t2[e].name;
    } };
  }
}
var ForEachOrdered_SortInstances2;
var SortZOrderList2;
var SortInstancesByValue2;
{
  {
    const e = self.C3;
    e.Plugins.Text = class extends e.SDKPluginBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
    };
  }
  {
    const e = self.C3;
    e.Plugins.Text.Type = class extends e.SDKTypeBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
      OnCreate() {
      }
      LoadTextures(e2) {
      }
      ReleaseTextures() {
      }
    };
  }
  {
    const e = self.C3, t2 = self.C3X, i = [0, 0, 0], r2 = 0, s = 1, n = 2, a2 = 3, o2 = 4, h2 = 5, _2 = 6, l = 7, c2 = 8, d2 = 9, g2 = 10, u2 = 11, T2 = 12, S2 = 13, p2 = 15, x2 = ["left", "center", "right"], G = ["top", "center", "bottom"], m2 = ["ltr", "rtl"], f2 = ["word", "cjk", "character"], w2 = new e.Rect(), I2 = new e.Quad(), R = new e.Color(), y2 = e.New(e.Vector2), b2 = /* @__PURE__ */ new Map([["b", "strong"], ["i", "em"], ["s", "s"], ["u", "u"], ["iconoffsety", null]]);
    e.Plugins.Text.Instance = class extends e.SDKWorldInstanceBase {
      constructor(t3, i2) {
        if (super(t3), this._text = "", this._enableBBcode = true, this._faceName = "Arial", this._ptSize = 12, this._lineHeightOffset = 0, this._isBold = false, this._isItalic = false, this._color = e.New(e.Color), this._horizontalAlign = 0, this._verticalAlign = 0, this._wrapMode = "word", this._textDirection = 0, this._resolutionMode = "auto", this._fixedScaleFactor = 1, this._iconObjectClass = null, this._htmlString = "", this._isHtmlStringUpToDate = false, this._readAloud = false, this._screenReaderText = null, this._typewriterStartTime = -1, this._typewriterEndTime = -1, this._typewriterLength = 0, this._rendererText = e.New(e.Gfx.RendererText, this._runtime.GetRenderer(), { timeout: 5 }), this._rendererText.ontextureupdate = () => this._runtime.UpdateRender(), this._animationframeimagechange_handler = () => this._OnIconObjectClassImageChanged(), this._pendingUpdateIconSet = false, this._beforerender_handler = () => this._OnBeforeRender(), i2) {
          this._text = i2[r2], this._enableBBcode = !!i2[s], this._faceName = i2[n], this._ptSize = i2[a2], this._lineHeightOffset = i2[o2], this._isBold = !!i2[h2], this._isItalic = !!i2[_2], this._horizontalAlign = i2[c2], this._verticalAlign = i2[d2], this._wrapMode = f2[i2[g2]], this._textDirection = i2[u2], this._SetIconObjectClass(this._runtime.GetObjectClassBySID(i2[T2]));
          const e2 = i2[l];
          this._color.setRgb(e2[0], e2[1], e2[2]), this.GetWorldInfo().SetVisible(i2[S2]), this._readAloud = !!i2[p2];
        }
        this._UpdateTextSettings(), this._UpdateScreenReaderText(), this._runtime.Dispatcher().addEventListener("beforerender", this._beforerender_handler);
      }
      Release() {
        this._runtime.Dispatcher().removeEventListener("beforerender", this._beforerender_handler), this._beforerender_handler = null, this._SetIconObjectClass(null), this._CancelTypewriter(), this._screenReaderText && (this._screenReaderText.Release(), this._screenReaderText = null), this._rendererText.Release(), this._rendererText = null, super.Release();
      }
      _UpdateTextSettings() {
        const e2 = this._rendererText;
        e2.SetText(this._text), e2.SetBBCodeEnabled(this._enableBBcode), this._rendererText.IsBBCodeEnabled() && this._iconObjectClass ? this._rendererText.SetIconSet(this.GetRuntime().GetTextIconSet(this._iconObjectClass)) : this._rendererText.SetIconSet(null), e2.SetIconSmoothing("nearest" !== this._runtime.GetSampling()), e2.SetFontName(this._faceName), e2.SetLineHeight(this._lineHeightOffset), e2.SetBold(this._isBold), e2.SetItalic(this._isItalic), e2.SetColor(this._color), e2.SetHorizontalAlignment(x2[this._horizontalAlign]), e2.SetVerticalAlignment(G[this._verticalAlign]), e2.SetWordWrapMode(this._wrapMode), e2.SetTextDirection(m2[this._textDirection]);
      }
      _UpdateTextSize() {
        const e2 = this.GetWorldInfo();
        this._rendererText.SetText(this._text), this._rendererText.SetFontSize(this._ptSize), this._rendererText.SetFontSizeScale(e2.GetSceneGraphScale());
        const t3 = e2.GetLayer();
        let i2;
        "auto" === this._resolutionMode ? (i2 = t3.GetResolutionScaleFactorToZ(e2.GetTotalZElevation()), this._rendererText.SetMipMapEnabled(false)) : "fixed" === this._resolutionMode && (i2 = this._fixedScaleFactor, this._rendererText.SetMipMapEnabled(true)), e2.HasMesh() && i2 !== this._rendererText.GetZoom() && e2.SetMeshChanged(true), this._rendererText.SetSize(e2.GetWidth(), e2.GetHeight(), i2);
      }
      _SetIconObjectClass(t3) {
        t3 && (t3.IsFamily() || t3.GetPlugin().constructor !== e.Plugins.Sprite) || t3 !== this._iconObjectClass && (this._iconObjectClass && this._iconObjectClass.Dispatcher().removeEventListener("animationframeimagechange", this._animationframeimagechange_handler), this._iconObjectClass = t3, this._iconObjectClass && this._iconObjectClass.Dispatcher().addEventListener("animationframeimagechange", this._animationframeimagechange_handler), this._UpdateTextSettings(), this._isHtmlStringUpToDate = false, this._runtime.UpdateRender());
      }
      _OnIconObjectClassImageChanged() {
        this._runtime.DeleteTextIconSet(this._iconObjectClass), this._runtime.UpdateRender(), this._pendingUpdateIconSet = true;
      }
      _UpdateScreenReaderText() {
        if (this._readAloud) {
          let t3 = this._text;
          this._enableBBcode && (t3 = e.BBString.StripAnyTags(t3)), this._screenReaderText ? this._screenReaderText.SetText(t3) : this._screenReaderText = e.New(e.ScreenReaderText, this._runtime, t3);
        } else this._screenReaderText && (this._screenReaderText.Release(), this._screenReaderText = null);
      }
      _OnBeforeRender() {
        const e2 = this.GetWorldInfo(), t3 = e2.GetLayer(), i2 = e2.GetLayout();
        e2.IsVisible() && e2.IsInViewport(t3.GetViewport(), i2.HasVanishingPointOutsideViewport(), i2.IsOrthographicProjection()) && (this._UpdateTextSize(), this._pendingUpdateIconSet && (this._pendingUpdateIconSet = false, this._rendererText.IsBBCodeEnabled() && this._iconObjectClass && this._rendererText.SetIconSet(this.GetRuntime().GetTextIconSet(this._iconObjectClass))), this._rendererText.GetTexture());
      }
      Draw(e2) {
        const t3 = this._rendererText.GetTexture();
        if (!t3) return;
        const i2 = this.GetWorldInfo(), r3 = i2.GetLayer();
        if (0 === i2.GetAngle() && 0 === r3.GetAngle() && 0 === i2.GetTotalZElevation() && !i2.HasMesh() && r3.RendersIn2DMode()) {
          const s2 = i2.GetBoundingQuad(), [n2, a3] = r3.LayerToDrawSurface(s2.getTlx(), s2.getTly()), [o3, h3] = r3.LayerToDrawSurface(s2.getBrx(), s2.getBry()), _3 = n2 - Math.round(n2), l2 = a3 - Math.round(a3);
          w2.set(n2, a3, o3, h3), w2.offset(-_3, -l2), I2.setFromRect(w2);
          const [c3, d3] = e2.GetRenderTargetSize(e2.GetRenderTarget());
          e2.IsWebGL() ? this._runtime.GetCanvasManager().SetDeviceTransform(e2, c3, d3) : (e2.SetNormalizedCoordsProgramVariant(true), I2.divide(c3, d3)), e2.SetTexture(t3), e2.Quad3(I2, this._rendererText.GetTexRect()), e2.IsWebGL() ? r3._SetTransform(e2) : e2.SetNormalizedCoordsProgramVariant(false);
        } else e2.SetTexture(t3), i2.HasMesh() ? this._DrawMesh(i2, e2) : this._DrawStandard(i2, e2);
      }
      _DrawStandard(e2, t3) {
        let i2 = e2.GetBoundingQuad();
        this._runtime.IsPixelRoundingEnabled() && (i2 = this._PixelRoundQuad(i2)), t3.Quad3(i2, this._rendererText.GetTexRect());
      }
      _DrawMesh(e2, t3) {
        const i2 = e2.GetTransformedMesh();
        if (e2.IsMeshChanged()) {
          e2.CalculateBbox(w2, I2, false);
          let t4 = I2;
          this._runtime.IsPixelRoundingEnabled() && (t4 = this._PixelRoundQuad(t4)), i2.CalculateTransformedMesh(e2.GetSourceMesh(), t4, this._rendererText.GetTexRect()), e2.SetMeshChanged(false);
        }
        i2.Draw(t3, e2.GetTotalZElevation());
      }
      _PixelRoundQuad(e2) {
        const t3 = e2.getTlx() - Math.round(e2.getTlx()), i2 = e2.getTly() - Math.round(e2.getTly());
        return 0 === t3 && 0 === i2 ? e2 : (I2.copy(e2), I2.offset(-t3, -i2), I2);
      }
      GetCurrentSurfaceSize() {
        const e2 = this._rendererText.GetTexture();
        return e2 ? [e2.GetWidth(), e2.GetHeight()] : [100, 100];
      }
      GetCurrentTexRect() {
        return this._rendererText.GetTexRect();
      }
      IsCurrentTexRotated() {
        return false;
      }
      SaveToJson() {
        const e2 = { "t": this._text, "c": this._color.toJSON(), "fn": this._faceName, "ps": this._ptSize };
        return this._enableBBcode && (e2["bbc"] = this._enableBBcode), 0 !== this._horizontalAlign && (e2["ha"] = this._horizontalAlign), 0 !== this._verticalAlign && (e2["va"] = this._verticalAlign), "word" !== this._wrapMode && (e2["wr"] = this._wrapMode), 0 !== this._lineHeightOffset && (e2["lho"] = this._lineHeightOffset), this._isBold && (e2["b"] = this._isBold), this._isItalic && (e2["i"] = this._isItalic), -1 !== this._typewriterEndTime && (e2["tw"] = { "st": this._typewriterStartTime, "en": this._typewriterEndTime, "l": this._typewriterLength }), this._iconObjectClass && (e2["ioc"] = this._iconObjectClass.GetSID()), "fixed" === this._resolutionMode && (e2["fs"] = this._fixedScaleFactor), e2;
      }
      LoadFromJson(e2) {
        if (this._CancelTypewriter(), this._text = e2["t"], this._color.setFromJSON(e2["c"]), this._faceName = e2["fn"], this._ptSize = e2["ps"], this._enableBBcode = !!e2.hasOwnProperty("bbc") && e2["bbc"], this._horizontalAlign = e2.hasOwnProperty("ha") ? e2["ha"] : 0, this._verticalAlign = e2.hasOwnProperty("va") ? e2["va"] : 0, e2.hasOwnProperty("wr")) {
          const t3 = e2["wr"];
          this._wrapMode = "boolean" == typeof t3 ? t3 ? "word" : "character" : t3;
        } else this._wrapMode = "word";
        if (this._lineHeightOffset = e2.hasOwnProperty("lho") ? e2["lho"] : 0, this._isBold = !!e2.hasOwnProperty("b") && e2["b"], this._isItalic = !!e2.hasOwnProperty("i") && e2["i"], e2.hasOwnProperty("tw")) {
          const t3 = e2["tw"];
          this._typewriterStartTime = t3["st"], this._typewriterEndTime = t3["en"], this._typewriterLength = t3["l"];
        }
        if (e2.hasOwnProperty("ioc")) {
          const t3 = this.GetRuntime().GetObjectClassBySID(e2["ioc"]);
          t3 && this._SetIconObjectClass(t3);
        } else this._SetIconObjectClass(null);
        e2.hasOwnProperty("fs") ? (this._resolutionMode = "fixed", this._fixedScaleFactor = e2["fs"]) : this._resolutionMode = "auto", this._UpdateTextSettings(), this._UpdateScreenReaderText(), this._isHtmlStringUpToDate = false, -1 !== this._typewriterEndTime && this._StartTicking();
      }
      GetPropertyValueByIndex(e2) {
        switch (e2) {
          case r2:
            return this.GetText();
          case s:
            return this._enableBBcode;
          case n:
            return this._GetFontFace();
          case a2:
            return this._GetFontSize();
          case o2:
            return this._GetLineHeight();
          case h2:
            return this._IsBold();
          case _2:
            return this._IsItalic();
          case l:
            return i[0] = this._color.getR(), i[1] = this._color.getG(), i[2] = this._color.getB(), i;
          case c2:
            return this._GetHAlign();
          case d2:
            return this._GetVAlign();
          case g2:
            return this._GetWrapMode();
          case p2:
            return this._IsReadAloud();
        }
      }
      SetPropertyValueByIndex(e2, t3) {
        switch (e2) {
          case r2:
            this._SetText(t3);
            break;
          case s:
            if (this._enableBBcode === !!t3) return;
            this._enableBBcode = !!t3, this._UpdateTextSettings();
            break;
          case n:
            this._SetFontFace(t3);
            break;
          case a2:
            this._SetFontSize(t3);
            break;
          case o2:
            this._SetLineHeight(t3);
            break;
          case h2:
            this._SetBold(t3);
            break;
          case _2:
            this._SetItalic(t3);
            break;
          case l:
            const e3 = this._color, i2 = t3;
            if (e3.getR() === i2[0] && e3.getG() === i2[1] && e3.getB() === i2[2]) return;
            this._color.setRgb(i2[0], i2[1], i2[2]), this._UpdateTextSettings();
            break;
          case c2:
            this._SetHAlign(t3);
            break;
          case d2:
            this._SetVAlign(t3);
            break;
          case g2:
            this._SetWrapMode(t3);
        }
      }
      SetPropertyColorOffsetValueByIndex(e2, t3, i2, r3) {
        if ((0 !== t3 || 0 !== i2 || 0 !== r3) && e2 === l) this._color.addRgb(t3, i2, r3), this._UpdateTextSettings();
      }
      _SetText(e2) {
        this._text !== e2 && (this._text = e2, this._UpdateScreenReaderText(), this._isHtmlStringUpToDate = false, this._runtime.UpdateRender());
      }
      GetText() {
        return this._text;
      }
      _StartTypewriter(e2, t3) {
        this._SetText(e2), this._UpdateTextSize(), this._typewriterStartTime = this._runtime.GetWallTime(), this._typewriterEndTime = this._typewriterStartTime + t3 / this.GetInstance().GetActiveTimeScale(), this._typewriterLength = this._rendererText.GetLengthInGraphemes(), this._rendererText.SetDrawMaxCharacterCount(0), this._StartTicking();
      }
      _CancelTypewriter() {
        this._typewriterStartTime = -1, this._typewriterEndTime = -1, this._typewriterLength = 0, this._rendererText.SetDrawMaxCharacterCount(-1), this._StopTicking();
      }
      _FinishTypewriter() {
        -1 !== this._typewriterEndTime && (this._CancelTypewriter(), this.Trigger(e.Plugins.Text.Cnds.OnTypewriterTextFinished), this._runtime.UpdateRender());
      }
      _SetFontFace(e2) {
        this._faceName !== e2 && (this._faceName = e2, this._rendererText.SetFontName(e2), this._runtime.UpdateRender());
      }
      _GetFontFace() {
        return this._faceName;
      }
      _SetBold(e2) {
        e2 = !!e2, this._isBold !== e2 && (this._isBold = e2, this._rendererText.SetBold(e2), this._runtime.UpdateRender());
      }
      _IsBold() {
        return this._isBold;
      }
      _SetItalic(e2) {
        e2 = !!e2, this._isItalic !== e2 && (this._isItalic = e2, this._rendererText.SetItalic(e2), this._runtime.UpdateRender());
      }
      _IsItalic() {
        return this._isItalic;
      }
      _SetFontSize(e2) {
        this._ptSize !== e2 && (this._ptSize = e2, this._runtime.UpdateRender());
      }
      _GetFontSize() {
        return this._ptSize;
      }
      _SetFontColor(e2) {
        this._color.equalsIgnoringAlpha(e2) || (this._color.copyRgb(e2), this._rendererText.SetColor(this._color), this._runtime.UpdateRender());
      }
      _GetFontColor() {
        return this._color;
      }
      _SetLineHeight(e2) {
        this._lineHeightOffset !== e2 && (this._lineHeightOffset = e2, this._UpdateTextSettings(), this._runtime.UpdateRender());
      }
      _GetLineHeight() {
        return this._lineHeightOffset;
      }
      _SetHAlign(e2) {
        this._horizontalAlign !== e2 && (this._horizontalAlign = e2, this._UpdateTextSettings(), this._runtime.UpdateRender());
      }
      _GetHAlign() {
        return this._horizontalAlign;
      }
      _SetVAlign(e2) {
        this._verticalAlign !== e2 && (this._verticalAlign = e2, this._UpdateTextSettings(), this._runtime.UpdateRender());
      }
      _GetVAlign() {
        return this._verticalAlign;
      }
      _SetWrapModeByIndex(e2) {
        this._SetWrapMode(f2[e2]);
      }
      _SetWrapMode(e2) {
        this._wrapMode !== e2 && (this._wrapMode = e2, this._UpdateTextSettings(), this._runtime.UpdateRender());
      }
      _GetWrapMode() {
        return this._wrapMode;
      }
      _SetTextDirection(e2) {
        this._textDirection !== e2 && (this._textDirection = e2, this._UpdateTextSettings(), this._runtime.UpdateRender());
      }
      _GetTextDirection() {
        return this._textDirection;
      }
      _SetReadAloud(e2) {
        this._readAloud = !!e2, this._UpdateScreenReaderText();
      }
      _IsReadAloud() {
        return this._readAloud;
      }
      _SetResolutionMode(e2) {
        this._resolutionMode !== e2 && (this._resolutionMode = e2, this._runtime.UpdateRender());
      }
      _GetResolutionMode() {
        return this._resolutionMode;
      }
      _SetFixedScaleFactor(e2) {
        this._fixedScaleFactor !== e2 && (this._fixedScaleFactor = e2, "fixed" === this._resolutionMode && this._runtime.UpdateRender());
      }
      _GetFixedScaleFactor() {
        return this._fixedScaleFactor;
      }
      _GetTextWidth() {
        return this._UpdateTextSize(), this._rendererText.GetTextWidth();
      }
      _GetTextHeight() {
        return this._UpdateTextSize(), this._rendererText.GetTextHeight();
      }
      _GetTagAtPosition(e2, t3) {
        this._UpdateTextSize();
        const i2 = this.GetWorldInfo();
        y2.set(e2 - i2.GetX(), t3 - i2.GetY()), y2.rotate(-i2.GetAngle()), y2.offset(i2.GetWidth() * i2.GetOriginX(), i2.GetHeight() * i2.GetOriginY()), y2.divide(i2.GetWidth(), i2.GetHeight()), y2.scale(this._rendererText.GetWidth(), this._rendererText.GetHeight());
        const r3 = this._rendererText.HitTestFragment(y2.getX(), y2.getY());
        if (r3) {
          const e3 = r3.GetStyleTag("tag");
          if (e3) return e3.param;
        }
        return "";
      }
      _HasTagAtPosition(t3, i2, r3) {
        const s2 = this._GetTagAtPosition(i2, r3);
        return s2 && e.equalsNoCase(t3, s2);
      }
      _GetTagPosition(e2, t3) {
        this._UpdateTextSize(), t3 = Math.floor(t3);
        const i2 = this._rendererText.FindFragmentWithTag(e2, t3);
        if (!i2) return null;
        const r3 = this.GetWorldInfo(), s2 = this._rendererText.GetDrawScale(), n2 = i2.GetPosX(), a3 = i2.GetPosY() - (i2.GetHeight() - i2.GetFontBoundingBoxDescent()) * s2, o3 = i2.GetWidth() * s2 / this._rendererText.GetWidth() * r3.GetWidth(), h3 = i2.GetHeight() * s2 / this._rendererText.GetHeight() * r3.GetHeight();
        return y2.set(n2, a3), y2.divide(this._rendererText.GetWidth(), this._rendererText.GetHeight()), y2.scale(r3.GetWidth(), r3.GetHeight()), y2.offset(-r3.GetWidth() * r3.GetOriginX(), -r3.GetHeight() * r3.GetOriginY()), y2.rotate(r3.GetAngle()), y2.offset(r3.GetX(), r3.GetY()), { x: y2.getX(), y: y2.getY(), width: o3, height: h3 };
      }
      _GetTagCount(e2) {
        return this._UpdateTextSize(), this._rendererText.CountFragmentsWithTag(e2);
      }
      _GetHTMLCloseTag(e2) {
        let t3 = b2.get(e2);
        return null === t3 ? "" : (t3 || (t3 = "span"), `</${t3 || "span"}>`);
      }
      _GetHTMLOpenTag(e2, t3) {
        let i2 = b2.get(e2);
        if (null === i2) return "";
        switch (i2 || (i2 = "span"), e2) {
          case "color":
            return `<${i2} style="color: ${t3}">`;
          case "font":
            return `<${i2} style="font-family: '${t3}'">`;
          case "opacity":
            return `<${i2} style="opacity: ${t3}%">`;
          case "size":
            return `<${i2} style="font-size: ${t3}pt">`;
          case "background":
            return `<${i2} style="background-color: ${t3}">`;
          case "hide":
            return `<${i2} style="visibility: hidden">`;
          case "class":
            return `<${i2} class="${t3}">`;
          case "tag":
            return `<${i2} data-tag="${t3}">`;
          default:
            return `<${i2}>`;
        }
      }
      async _UpdateHTMLString() {
        if (this._isHtmlStringUpToDate) return this._htmlString;
        const t3 = new e.BBString(this._text, { noEscape: true }).toFragmentList(), i2 = /* @__PURE__ */ new Map();
        let r3 = '<span class="c3-text"';
        const s2 = [];
        s2.push(`font-family: '${this._GetFontFace()}';`), this._IsBold() && s2.push("font-weight: bold;"), this._IsItalic() && s2.push("font-style: italic;"), "character" === this._GetWrapMode() && s2.push("word-break: break-all;"), r3 += ` style="${s2.join(" ")}">`;
        const n2 = this._iconObjectClass ? this.GetRuntime().GetTextIconSet(this._iconObjectClass) : null;
        if (this._iconObjectClass) {
          const r4 = e.New(e.PromiseThrottle), s3 = [], a4 = /* @__PURE__ */ new Map();
          for (const e2 of t3) if (e2.IsIcon()) {
            const t4 = e2.GetTextIcon(n2);
            if (t4) {
              const e3 = t4.GetSource().GetImageInfo().GetImageAsset();
              if (a4.has(e3)) continue;
              a4.set(e3, null), s3.push(r4.Add(async () => {
                const t5 = await e3.LoadToDrawable();
                a4.set(e3, t5);
              }));
            }
          }
          await Promise.all(s3);
          const o4 = [];
          for (const e2 of t3) if (e2.IsIcon()) {
            const t4 = e2.GetTextIcon(n2);
            if (t4) {
              const e3 = t4.GetSource(), s4 = e3.GetImageInfo().GetImageAsset();
              o4.push(r4.Add(async () => {
                const r5 = await e3.GetImageInfo().ExtractImageToBlobURL(a4.get(s4));
                i2.set(t4, r5);
              }));
            }
          }
          await Promise.all(o4);
          for (const e2 of a4.values()) e2 instanceof ImageBitmap && e2["close"] && e2["close"]();
        }
        const a3 = /* @__PURE__ */ new Map();
        for (const s3 of t3) {
          const t4 = s3.GetStyleMap();
          let o4 = [...a3.keys()];
          o4.reverse();
          for (const e2 of o4) t4.has(e2) && t4.get(e2) === a3.get(e2) || (a3.delete(e2), r3 += this._GetHTMLCloseTag(e2));
          for (const [e2, i3] of t4) a3.has(e2) || (a3.set(e2, i3), r3 += this._GetHTMLOpenTag(e2, i3));
          if (s3.IsText() && (r3 += e.ReplaceAll(e.EscapeHTML(s3.GetCharacterArray().join("")), "\n", "<br>")), s3.IsIcon() && n2) {
            const e2 = s3.GetTextIcon(n2);
            if (e2) {
              const n3 = i2.get(e2);
              if (n3) {
                const i3 = [];
                let a4 = "0.2em";
                const o5 = t4.get("iconoffsety");
                if (o5) {
                  let e3 = o5.trim();
                  a4 = e3.endsWith("%") ? parseFloat(e3) / 100 + "em" : e3 + "px";
                }
                i3.push(`top: ${a4}`), "nearest" === this._runtime.GetSampling() && i3.push("image-rendering: pixelated"), r3 += `<img class="c3-text-icon" data-icon="${s3.GetIconParameter()}" width="${e2.GetWidth()}" height="${e2.GetHeight()}" style="${i3.join(";")}" src="${n3}">`;
              }
            }
          }
        }
        const o3 = [...a3.keys()];
        o3.reverse();
        for (const e2 of o3) r3 += this._GetHTMLCloseTag(e2);
        return r3 += "</span>", this._htmlString = r3, this._isHtmlStringUpToDate = true, this._htmlString;
      }
      Tick() {
        const t3 = this._runtime.GetWallTime();
        if (t3 >= this._typewriterEndTime) this._CancelTypewriter(), this.Trigger(e.Plugins.Text.Cnds.OnTypewriterTextFinished), this._runtime.UpdateRender();
        else {
          let i2 = e.relerp(this._typewriterStartTime, this._typewriterEndTime, t3, 0, this._typewriterLength);
          i2 = Math.floor(i2), i2 !== this._rendererText.GetDrawMaxCharacterCount() && (this._rendererText.SetDrawMaxCharacterCount(i2), this._runtime.UpdateRender());
        }
      }
      GetDebuggerProperties() {
        const e2 = "plugins.text";
        return [{ title: e2 + ".name", properties: [{ name: e2 + ".properties.text.name", value: this.GetText(), onedit: (e3) => this._SetText(e3) }, { name: e2 + ".properties.font.name", value: this._GetFontFace(), onedit: (e3) => this._SetFontFace(e3) }, { name: e2 + ".properties.size.name", value: this._GetFontSize(), onedit: (e3) => this._SetFontSize(e3) }, { name: e2 + ".properties.line-height.name", value: this._GetLineHeight(), onedit: (e3) => this._SetLineHeight(e3) }, { name: e2 + ".properties.bold.name", value: this._IsBold(), onedit: (e3) => this._SetBold(e3) }, { name: e2 + ".properties.italic.name", value: this._IsItalic(), onedit: (e3) => this._SetItalic(e3) }, { name: e2 + ".debugger.text-width", value: this._GetTextWidth() }, { name: e2 + ".debugger.text-height", value: this._GetTextHeight() }] }];
      }
      GetScriptInterfaceClass() {
        return self.ITextInstance;
      }
    };
    const C2 = /* @__PURE__ */ new WeakMap(), F = /* @__PURE__ */ new Map([["left", 0], ["center", 1], ["right", 2]]), M2 = /* @__PURE__ */ new Map([["top", 0], ["center", 1], ["bottom", 2]]), A = ["ltr", "rtl"];
    /* @__PURE__ */ new Set(["auto", "fixed"]);
    self.ITextInstance = class extends self.IWorldInstance {
      constructor() {
        super(), C2.set(this, self.IInstance._GetInitInst().GetSdkInstance());
      }
      get text() {
        return C2.get(this).GetText();
      }
      set text(e2) {
        t2.RequireString(e2);
        const i2 = C2.get(this);
        i2._CancelTypewriter(), i2._SetText(e2);
      }
      typewriterText(e2, i2) {
        t2.RequireString(e2), t2.RequireFiniteNumber(i2);
        const r3 = C2.get(this);
        r3._CancelTypewriter(), r3._StartTypewriter(e2, i2);
      }
      typewriterFinish() {
        C2.get(this)._FinishTypewriter();
      }
      set fontFace(e2) {
        t2.RequireString(e2), C2.get(this)._SetFontFace(e2);
      }
      get fontFace() {
        return C2.get(this)._GetFontFace();
      }
      set isBold(e2) {
        C2.get(this)._SetBold(e2);
      }
      get isBold() {
        return C2.get(this)._IsBold();
      }
      set isItalic(e2) {
        C2.get(this)._SetItalic(e2);
      }
      get isItalic() {
        return C2.get(this)._IsItalic();
      }
      set sizePt(e2) {
        t2.RequireFiniteNumber(e2), C2.get(this)._SetFontSize(e2);
      }
      get sizePt() {
        return C2.get(this)._GetFontSize();
      }
      set fontColor(e2) {
        if (t2.RequireArray(e2), e2.length < 3) throw new Error("expected 3 elements");
        R.setRgb(e2[0], e2[1], e2[2]), C2.get(this)._SetFontColor(R);
      }
      get fontColor() {
        const e2 = C2.get(this)._GetFontColor();
        return [e2.getR(), e2.getG(), e2.getB()];
      }
      set lineHeight(e2) {
        t2.RequireFiniteNumber(e2), C2.get(this)._SetLineHeight(e2);
      }
      get lineHeight() {
        return C2.get(this)._GetLineHeight();
      }
      set horizontalAlign(e2) {
        t2.RequireString(e2);
        const i2 = F.get(e2);
        if (void 0 === i2) throw new Error("invalid mode");
        C2.get(this)._SetHAlign(i2);
      }
      get horizontalAlign() {
        return x2[C2.get(this)._GetHAlign()];
      }
      set verticalAlign(e2) {
        t2.RequireString(e2);
        const i2 = M2.get(e2);
        if (void 0 === i2) throw new Error("invalid mode");
        C2.get(this)._SetVAlign(i2);
      }
      get verticalAlign() {
        return G[C2.get(this)._GetVAlign()];
      }
      set wordWrapMode(e2) {
        if (!f2.includes(e2)) throw new Error("invalid mode");
        C2.get(this)._SetWrapMode(e2);
      }
      get wordWrapMode() {
        return C2.get(this)._GetWrapMode();
      }
      set textDirection(e2) {
        t2.RequireString(e2);
        const i2 = A.indexOf(e2);
        if (-1 === i2) throw new Error("invalid text direction");
        C2.get(this)._SetTextDirection(i2);
      }
      get textDirection() {
        return A[C2.get(this)._GetTextDirection()];
      }
      set readAloud(e2) {
        C2.get(this)._SetReadAloud(!!e2);
      }
      get readAloud() {
        return C2.get(this)._IsReadAloud();
      }
      setFixedResolutionMode(e2) {
        t2.RequireFiniteNumber(e2);
        const i2 = C2.get(this);
        i2._SetResolutionMode("fixed"), i2._SetFixedScaleFactor(e2);
      }
      setAutoResolutionMode() {
        C2.get(this)._SetResolutionMode("auto");
      }
      get textWidth() {
        return C2.get(this)._GetTextWidth();
      }
      get textHeight() {
        return C2.get(this)._GetTextHeight();
      }
      getTextSize() {
        const e2 = C2.get(this);
        return [e2._GetTextWidth(), e2._GetTextHeight()];
      }
      hasTagAtPosition(e2, i2, r3) {
        return t2.RequireString(e2), t2.RequireFiniteNumber(i2), t2.RequireFiniteNumber(r3), C2.get(this)._HasTagAtPosition(e2, i2, r3);
      }
      getTagAtPosition(e2, i2) {
        return t2.RequireFiniteNumber(e2), t2.RequireFiniteNumber(i2), C2.get(this)._GetTagAtPosition(e2, i2);
      }
      getTagPositionAndSize(e2, i2 = 0) {
        return t2.RequireString(e2), t2.RequireFiniteNumber(i2), C2.get(this)._GetTagPosition(e2, i2);
      }
      getTagCount(e2) {
        return t2.RequireString(e2), C2.get(this)._GetTagCount(e2);
      }
      changeIconSet(e2) {
        const t3 = C2.get(this), i2 = t3.GetRuntime()._UnwrapIObjectClass(e2);
        t3._SetIconObjectClass(i2);
      }
      getAsHtmlString() {
        return C2.get(this)._UpdateHTMLString();
      }
    };
  }
  {
    const e = self.C3;
    e.Plugins.Text.Cnds = { CompareText(t2, i) {
      return i ? this._text === t2 : e.equalsNoCase(this._text, t2);
    }, IsRunningTypewriterText() {
      return -1 !== this._typewriterEndTime;
    }, OnTypewriterTextFinished: () => true, HasTagAtPosition(e2, t2, i) {
      return this._HasTagAtPosition(e2, t2, i);
    } };
  }
  {
    const e = self.C3, t2 = e.New(e.Color);
    e.Plugins.Text.Acts = { SetText(e2) {
      this._CancelTypewriter(), "number" == typeof e2 && e2 < 1e9 && (e2 = Math.round(1e10 * e2) / 1e10), this._SetText(e2.toString());
    }, AppendText(e2) {
      this._CancelTypewriter(), "number" == typeof e2 && e2 < 1e9 && (e2 = Math.round(1e10 * e2) / 1e10), (e2 = e2.toString()) && this._SetText(this._text + e2);
    }, TypewriterText(e2, t3) {
      this._CancelTypewriter(), "number" == typeof e2 && e2 < 1e9 && (e2 = Math.round(1e10 * e2) / 1e10), this._StartTypewriter(e2.toString(), t3);
    }, SetFontFace(e2, t3) {
      let i = false, r2 = false;
      switch (t3) {
        case 1:
          i = true;
          break;
        case 2:
          r2 = true;
          break;
        case 3:
          i = true, r2 = true;
      }
      e2 === this._faceName && i === this._isBold && r2 === this._isItalic || (this._SetFontFace(e2), this._SetBold(i), this._SetItalic(r2));
    }, SetFontSize(e2) {
      this._SetFontSize(e2);
    }, SetFontColor(e2) {
      t2.setFromRgbValue(e2), t2.clamp(), this._SetFontColor(t2);
    }, SetWebFont(e2, t3) {
      console.warn("[Text] 'Set web font' action is deprecated and no longer has any effect");
    }, SetEffect(e2) {
      this.GetWorldInfo().SetBlendMode(e2), this._runtime.UpdateRender();
    }, TypewriterFinish() {
      this._FinishTypewriter();
    }, SetLineHeight(e2) {
      this._SetLineHeight(e2);
    }, SetHAlign(e2) {
      this._SetHAlign(e2);
    }, SetVAlign(e2) {
      this._SetVAlign(e2);
    }, SetWrapping(e2) {
      this._SetWrapModeByIndex(e2);
    }, SetTextDirection(e2) {
      this._SetTextDirection(e2);
    }, ChangeIconSet(e2) {
      this._SetIconObjectClass(e2);
    }, UpdateHTML() {
      return this._UpdateHTMLString();
    }, SetReadAloud(e2) {
      this._SetReadAloud(e2);
    }, SetResolutionMode(e2, t3) {
      this._SetResolutionMode(["auto", "fixed"][e2]), this._SetFixedScaleFactor(t3);
    } };
  }
  {
    const e = self.C3;
    e.Plugins.Text.Exps = { Text() {
      return this._text;
    }, PlainText() {
      return this._enableBBcode ? e.BBString.StripAnyTags(this._text) : this._text;
    }, FaceName() {
      return this._faceName;
    }, FaceSize() {
      return this._ptSize;
    }, TextWidth() {
      return this._GetTextWidth();
    }, TextHeight() {
      return this._GetTextHeight();
    }, LineHeight() {
      return this._lineHeightOffset;
    }, TagAtPosition(e2, t2) {
      return this._GetTagAtPosition(e2, t2);
    }, TagCount(e2) {
      return this._GetTagCount(e2);
    }, TagX(e2, t2) {
      const i = this._GetTagPosition(e2, t2);
      return i ? i.x : 0;
    }, TagY(e2, t2) {
      const i = this._GetTagPosition(e2, t2);
      return i ? i.y : 0;
    }, TagWidth(e2, t2) {
      const i = this._GetTagPosition(e2, t2);
      return i ? i.width : 0;
    }, TagHeight(e2, t2) {
      const i = this._GetTagPosition(e2, t2);
      return i ? i.height : 0;
    }, AsHTML() {
      return this._htmlString;
    } };
  }
}
{
  {
    const t2 = self.C3;
    t2.Plugins.Sprite = class extends t2.SDKPluginBase {
      constructor(t3) {
        super(t3);
      }
      Release() {
        super.Release();
      }
    };
  }
  {
    const t2 = self.C3, e = self.C3X, n = [];
    t2.Plugins.Sprite.Type = class extends t2.SDKTypeBase {
      constructor(t3) {
        super(t3), this._animations = t3.GetAnimations();
      }
      Release() {
        t2.clearArray(this._animations), super.Release();
      }
      OnCreate() {
        for (const t3 of this._animations) t3.LoadAllAssets(this._runtime);
      }
      LoadTextures(t3) {
        const e2 = { sampling: this._runtime.GetSampling() };
        return Promise.all(this._animations.map((n2) => n2.LoadAllTextures(t3, e2)));
      }
      ReleaseTextures() {
        for (const t3 of this._animations) t3.ReleaseAllTextures();
      }
      OnDynamicTextureLoadComplete() {
        this._UpdateAllCurrentTexture();
      }
      _UpdateAllCurrentTexture() {
        for (const t3 of this._objectClass.instancesIncludingPendingCreate()) t3.GetSdkInstance()._UpdateCurrentTexture();
      }
      FinishCondition(e2) {
        t2.Plugins.Sprite.FinishCollisionCondition(this, e2);
      }
      BeforeRunAction(t3) {
        n.push({ objectClass: null, createHierarchy: false, instances: [] });
      }
      _SpawnPickInstance(t3, e2, i2) {
        const r2 = n.at(-1);
        r2.objectClass = t3, r2.createHierarchy = i2, r2.instances.push(e2);
      }
      AfterRunAction(t3) {
        const e2 = n.pop(), i2 = e2.objectClass, r2 = e2.createHierarchy;
        if (!i2) return;
        const a2 = /* @__PURE__ */ new Map();
        for (const t4 of e2.instances) t4.CollectInstancesToPick(a2, i2, r2);
        for (const [t4, e3] of a2) t4.GetCurrentSol().SetSetPicked(e3);
      }
      _AddAnimation(t3) {
        const e2 = this.GetObjectClass().AddAnimation(t3), n2 = this.GetRuntime();
        return e2.GetFrameAt(0).GetImageInfo().LoadStaticTexture(n2.GetRenderer(), { sampling: n2.GetSampling() }).then(() => this._UpdateAllCurrentTexture()), e2;
      }
      _RemoveAnimation(t3) {
        for (const e2 of this._objectClass.instancesIncludingPendingCreate()) e2.GetSdkInstance()._OnAnimationRemoved(t3);
        this.GetObjectClass().RemoveAnimation(t3);
      }
      _AddAnimationFrame(e2, n2) {
        const i2 = this._objectClass.GetAnimationByName(e2);
        if (!i2) throw new Error(`cannot find animation name '${e2}'`);
        let r2 = i2.FrameTagOrIndexToIndex(n2);
        r2 < 0 && (r2 += i2.GetFrameCount() + 1);
        const a2 = t2.AnimationFrameInfo.CreateDynamic(this.GetRuntime());
        i2.InsertFrameAt(a2, r2);
        const s = this.GetRuntime();
        a2.GetImageInfo().LoadStaticTexture(s.GetRenderer(), { sampling: s.GetSampling() }).then(() => this._UpdateAllCurrentTexture());
        for (const t3 of this._objectClass.instancesIncludingPendingCreate()) t3.GetSdkInstance()._OnAnimationFramesChanged();
        return a2;
      }
      _RemoveAnimationFrame(t3, e2) {
        const n2 = this._objectClass.GetAnimationByName(t3);
        if (!n2) throw new Error(`cannot find animation name '${t3}'`);
        if (1 === n2.GetFrameCount()) throw new Error(`cannot remove last frame from animation '${t3}'`);
        let i2 = n2.FrameTagOrIndexToIndex(e2);
        i2 < 0 && (i2 += n2.GetFrameCount()), n2.RemoveFrameAt(i2);
        for (const t4 of this._objectClass.instancesIncludingPendingCreate()) t4.GetSdkInstance()._OnAnimationFramesChanged();
      }
      GetScriptInterfaceClass() {
        return self.ISpriteObjectType;
      }
    };
    const i = /* @__PURE__ */ new WeakMap();
    self.ISpriteObjectType = class extends self.IObjectType {
      constructor(t3) {
        super(t3), i.set(this, t3.GetSdkType());
      }
      getAnimation(t3) {
        e.RequireString(t3);
        const n2 = i.get(this).GetObjectClass().GetAnimationByName(t3);
        return n2 ? n2.GetIAnimation() : null;
      }
      getAllAnimations() {
        return i.get(this).GetObjectClass().GetAllAnimations().map((t3) => t3.GetIAnimation());
      }
      addAnimation(t3) {
        return e.RequireString(t3), i.get(this)._AddAnimation(t3).GetIAnimation();
      }
      removeAnimation(t3) {
        e.RequireString(t3), i.get(this)._RemoveAnimation(t3);
      }
      addAnimationFrame(t3, n2) {
        if (e.RequireString(t3), "number" != typeof n2 && "string" != typeof n2) throw new TypeError("invalid insert location");
        return i.get(this)._AddAnimationFrame(t3, n2).GetIAnimationFrame();
      }
      removeAnimationFrame(t3, n2) {
        if (e.RequireString(t3), "number" != typeof n2 && "string" != typeof n2) throw new TypeError("invalid insert location");
        i.get(this)._RemoveAnimationFrame(t3, n2);
      }
    };
  }
  {
    const t2 = self.C3, e = self.C3X, n = 0, i = 1, r2 = 2, a2 = 3, s = t2.New(t2.Rect), o2 = t2.New(t2.Quad), m2 = t2.New(t2.Vector2), h2 = 1, u2 = 2, c2 = 4;
    t2.Plugins.Sprite.Instance = class extends t2.SDKWorldInstanceBase {
      constructor(e2, s2) {
        super(e2);
        let o3 = true, m3 = "", c3 = 0, l2 = true;
        s2 && (o3 = !!s2[n], m3 = s2[i], c3 = s2[r2], l2 = s2[a2]), this._currentAnimation = this._objectClass.GetAnimationByName(m3) || this._objectClass.GetAnimations()[0], this._currentFrameIndex = t2.clamp(c3, 0, this._currentAnimation.GetFrameCount() - 1), this._currentAnimationFrame = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
        const d3 = this._currentAnimationFrame.GetImageInfo();
        this._currentTexture = d3.GetTexture(), this._currentRcTex = d3.GetTexRect(), this._currentQuadTex = d3.GetTexQuad(), this.HandleRendererContextLoss(), e2.SetFlag(u2, true), e2.SetFlag(h2, this._currentAnimation.GetSpeed() >= 0), this._currentAnimationSpeed = Math.abs(this._currentAnimation.GetSpeed()), this._currentAnimationRepeatTo = this._currentAnimation.GetRepeatTo(), this._animationTimer = t2.New(t2.KahanSum), this._frameStartTime = 0, this._animationRepeats = 0, this._animTriggerName = "", this._changeAnimFrameIndex = -1, this._changeAnimationName = "", this._changeAnimationFrom = 0;
        const g2 = this.GetWorldInfo();
        this._bquadRef = g2.GetBoundingQuad(), g2.SetVisible(o3), g2.SetCollisionEnabled(l2), g2.SetOriginX(this._currentAnimationFrame.GetOriginX()), g2.SetOriginY(this._currentAnimationFrame.GetOriginY()), g2.SetSourceCollisionPoly(this._currentAnimationFrame.GetCollisionPoly()), g2.SetBboxChanged(), 1 === this._objectClass.GetAnimationCount() && 1 === this._objectClass.GetAnimations()[0].GetFrameCount() || 0 === this._currentAnimationSpeed || this._StartTicking();
      }
      Release() {
        this._currentAnimation = null, this._currentAnimationFrame = null, this._currentTexture = null, this._animationTimer = null, super.Release();
      }
      GetCurrentImageInfo() {
        return this._currentAnimationFrame.GetImageInfo();
      }
      IsOriginalSizeKnown() {
        return true;
      }
      OnRendererContextLost() {
        this._currentTexture = null;
      }
      OnRendererContextRestored() {
        this._UpdateCurrentTexture();
      }
      Draw(t3) {
        const e2 = this._currentTexture;
        if (null === e2) return;
        t3.SetTexture(e2);
        const n2 = this.GetWorldInfo();
        n2.HasMesh() ? this._DrawMesh(n2, t3) : this._DrawStandard(n2, t3);
      }
      _DrawStandard(t3, e2) {
        let n2 = this._bquadRef;
        this._runtime.IsPixelRoundingEnabled() && (n2 = t3.PixelRoundQuad(n2)), e2.Quad4(n2, this._currentQuadTex);
      }
      _DrawMesh(t3, e2) {
        const n2 = t3.GetTransformedMesh();
        if (t3.IsMeshChanged()) {
          t3.CalculateBbox(s, o2, false);
          let e3 = o2;
          this._runtime.IsPixelRoundingEnabled() && (e3 = t3.PixelRoundQuad(e3)), n2.CalculateTransformedMesh(t3.GetSourceMesh(), e3, this._currentQuadTex), t3.SetMeshChanged(false);
        }
        n2.Draw(e2, t3.GetTotalZElevation());
      }
      GetAnimationTime() {
        return this._animationTimer.Get();
      }
      IsAnimationPlaying() {
        return this._inst.GetFlag(u2);
      }
      SetAnimationPlaying(t3) {
        this._inst.SetFlag(u2, t3);
      }
      IsPlayingForwards() {
        return this._inst.GetFlag(h2);
      }
      SetPlayingForwards(t3) {
        this._inst.SetFlag(h2, t3);
      }
      IsInAnimationTrigger() {
        return this._inst.GetFlag(c2);
      }
      SetInAnimationTrigger(t3) {
        this._inst.SetFlag(c2, t3);
      }
      Tick() {
        this._changeAnimationName && this._DoChangeAnimation(), this._changeAnimFrameIndex >= 0 && this._DoChangeAnimFrame();
        const e2 = this._currentAnimationSpeed;
        if (!this.IsAnimationPlaying() || 0 === e2) return void this._StopTicking();
        const n2 = this._runtime.GetDt(this._inst);
        this._animationTimer.Add(n2);
        const i2 = this.GetAnimationTime(), r3 = this._currentAnimationFrame, a3 = r3.GetDuration() / e2;
        if (i2 < this._frameStartTime + a3) return;
        const s2 = this._currentAnimation, o3 = this._currentAnimationRepeatTo, m3 = s2.GetFrameCount(), h3 = s2.GetRepeatCount(), u3 = s2.IsLooping(), c3 = s2.IsPingPong();
        this.IsPlayingForwards() ? this._currentFrameIndex++ : this._currentFrameIndex--, this._frameStartTime += a3, this._currentFrameIndex >= m3 && (c3 ? (this.SetPlayingForwards(false), this._currentFrameIndex = m3 - 2) : u3 ? this._currentFrameIndex = o3 : (this._animationRepeats++, this._animationRepeats >= h3 ? this._FinishAnimation(false) : this._currentFrameIndex = o3)), this._currentFrameIndex < 0 && (c3 ? (this._currentFrameIndex = 1, this.SetPlayingForwards(true), u3 || (this._animationRepeats++, this._animationRepeats >= h3 && this._FinishAnimation(true))) : u3 ? this._currentFrameIndex = o3 : (this._animationRepeats++, this._animationRepeats >= h3 ? this._FinishAnimation(true) : this._currentFrameIndex = o3)), this._currentFrameIndex = t2.clamp(this._currentFrameIndex, 0, m3 - 1);
        const l2 = s2.GetFrameAt(this._currentFrameIndex);
        i2 > this._frameStartTime + l2.GetDuration() / e2 && (this._frameStartTime = i2), this._OnFrameChanged(r3, l2);
      }
      _FinishAnimation(e2) {
        this._currentFrameIndex = e2 ? 0 : this._currentAnimation.GetFrameCount() - 1, this.SetAnimationPlaying(false), this._animTriggerName = this._currentAnimation.GetName(), this.SetInAnimationTrigger(true), this.DispatchScriptEvent("animationend", false, { animationName: this._animTriggerName }), this.Trigger(t2.Plugins.Sprite.Cnds.OnAnyAnimFinished), this.Trigger(t2.Plugins.Sprite.Cnds.OnAnimFinished), this.SetInAnimationTrigger(false), this._animationRepeats = 0;
      }
      _OnFrameChanged(e2, n2, i2) {
        if (e2 === n2) return;
        const r3 = this.GetWorldInfo(), a3 = e2.GetImageInfo(), s2 = n2.GetImageInfo(), o3 = a3.GetWidth(), m3 = a3.GetHeight(), h3 = s2.GetWidth(), u3 = s2.GetHeight();
        i2 && i2.onFrameChange ? i2.onFrameChange(r3, o3, m3, h3, u3) : (o3 !== h3 && r3.SetWidth(r3.GetWidth() * (h3 / o3)), m3 !== u3 && r3.SetHeight(r3.GetHeight() * (u3 / m3))), r3.SetOriginX(n2.GetOriginX()), r3.SetOriginY(n2.GetOriginY()), r3.SetSourceCollisionPoly(n2.GetCollisionPoly()), r3.SetBboxChanged(), this._currentAnimationFrame = n2, this._currentTexture = s2.GetTexture(), this._currentRcTex = s2.GetTexRect(), this._currentQuadTex = s2.GetTexQuad();
        const c3 = this.GetInstance().GetBehaviorInstances();
        for (let t3 = 0, i3 = c3.length; t3 < i3; ++t3) c3[t3].OnSpriteFrameChanged(e2, n2);
        this.DispatchScriptEvent("framechange", false, { animationName: this._currentAnimation.GetName(), animationFrame: this._currentFrameIndex }), this.Trigger(t2.Plugins.Sprite.Cnds.OnFrameChanged), this._runtime.UpdateRender();
      }
      _StartAnim(t3) {
        this.SetAnimationPlaying(true), this._frameStartTime = this.GetAnimationTime(), 1 === t3 && 0 !== this._currentFrameIndex && (this._changeAnimFrameIndex = 0, this.IsInAnimationTrigger() || this._DoChangeAnimFrame()), this._StartTicking();
      }
      _SetAnim(t3, e2, n2) {
        this._changeAnimationName = t3, this._changeAnimationFrom = e2, this._StartTicking(), !n2 && this.IsInAnimationTrigger() || this._DoChangeAnimation();
      }
      _GetCurrentAnimation() {
        return this._currentAnimation;
      }
      _GetCurrentAnimationName() {
        return this._changeAnimationName ? this._changeAnimationName : this._currentAnimation.GetName();
      }
      _OnAnimationRemoved(e2) {
        t2.equalsNoCase(e2, this._GetCurrentAnimationName()) && this._SetAnim(this._objectClass.GetFirstAnimation().GetName(), 1, true);
      }
      _SetAnimFrame(t3) {
        if ("string" == typeof t3) if (String(Number(t3)) === t3) t3 = Number(t3);
        else {
          const e2 = this._objectClass.GetAnimationByName(this._GetCurrentAnimationName());
          if (!e2) return;
          if (-1 === (t3 = e2.GetFrameIndexByTag(t3))) return;
        }
        isFinite(t3) && (this._changeAnimFrameIndex = t3, this.IsInAnimationTrigger() || this._DoChangeAnimFrame());
      }
      _OnAnimationFramesChanged() {
        if (this._changeAnimationName || -1 !== this._changeAnimFrameIndex) return;
        const e2 = this._currentAnimationFrame, n2 = this._currentAnimation.GetFrameAt(t2.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1));
        e2 !== n2 && this._OnFrameChanged(e2, n2), this._currentAnimation.GetFrameCount() > 1 && this._currentAnimationSpeed > 0 && this._StartTicking();
      }
      _GetAnimFrame() {
        return this._currentFrameIndex;
      }
      _GetAnimFrameTag() {
        return this._currentAnimationFrame.GetTag();
      }
      _SetAnimSpeed(t3) {
        this._currentAnimationSpeed = Math.abs(t3), this.SetPlayingForwards(t3 >= 0), this._currentAnimationSpeed > 0 && this._StartTicking();
      }
      _GetAnimSpeed() {
        return this.IsPlayingForwards() ? this._currentAnimationSpeed : -this._currentAnimationSpeed;
      }
      _SetAnimRepeatToFrame(e2) {
        "string" == typeof e2 && -1 === (e2 = this._currentAnimation.GetFrameIndexByTag(e2)) || (e2 = t2.clamp(Math.floor(e2), 0, this._currentAnimation.GetFrameCount() - 1), this._currentAnimationRepeatTo = e2);
      }
      _GetAnimRepeatToFrame() {
        return this._currentAnimationRepeatTo;
      }
      _DoChangeAnimation(e2) {
        const n2 = this._currentAnimationFrame, i2 = this._objectClass.GetAnimationByName(this._changeAnimationName);
        if (this._changeAnimationName = "", !i2) return;
        if (i2 === this._currentAnimation && this.IsAnimationPlaying()) return;
        this._currentAnimation = i2, this.SetPlayingForwards(i2.GetSpeed() >= 0), this._currentAnimationSpeed = Math.abs(i2.GetSpeed()), this._currentAnimationRepeatTo = i2.GetRepeatTo(), this._currentFrameIndex = t2.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1), 1 === this._changeAnimationFrom && (this._currentFrameIndex = 0), this.SetAnimationPlaying(true), this._frameStartTime = this.GetAnimationTime();
        const r3 = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
        this._OnFrameChanged(n2, r3, e2);
      }
      _DoChangeAnimFrame(e2) {
        const n2 = this._currentAnimationFrame, i2 = this._currentFrameIndex;
        if (this._currentFrameIndex = t2.clamp(Math.floor(this._changeAnimFrameIndex), 0, this._currentAnimation.GetFrameCount() - 1), this._changeAnimFrameIndex = -1, !e2 && i2 === this._currentFrameIndex) return;
        const r3 = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
        this._OnFrameChanged(n2, r3), this._frameStartTime = this.GetAnimationTime();
      }
      _UpdateCurrentTexture() {
        const t3 = this._currentAnimationFrame.GetImageInfo();
        this._currentTexture = t3.GetTexture(), this._currentRcTex = t3.GetTexRect(), this._currentQuadTex = t3.GetTexQuad(), this.GetWorldInfo().SetMeshChanged(true);
      }
      GetTexture() {
        return this._currentTexture;
      }
      GetTexRect() {
        return this._currentRcTex;
      }
      GetTexQuad() {
        return this._currentQuadTex;
      }
      GetImagePointCount() {
        return this._currentAnimationFrame.GetImagePointCount();
      }
      GetImagePoint(t3) {
        const e2 = this._currentAnimationFrame, n2 = this.GetWorldInfo();
        let i2 = null;
        if ("string" == typeof t3) i2 = e2.GetImagePointByName(t3);
        else {
          if ("number" != typeof t3) throw new TypeError("expected string or number");
          i2 = e2.GetImagePointByIndex(t3 - 1);
        }
        let r3 = n2.GetTotalZElevation();
        if (!i2) return [n2.GetX(), n2.GetY(), r3];
        if (m2.copy(i2.GetVec2()), n2.HasMesh()) {
          const [t4, e3, i3] = n2.GetSourceMesh().TransformPoint(m2.getX(), m2.getY());
          m2.set(t4, e3), r3 += i3;
        }
        return m2.offset(-e2.GetOriginX(), -e2.GetOriginY()), m2.scale(n2.GetWidth(), n2.GetHeight()), m2.rotate(n2.GetAngle()), m2.offset(n2.GetX(), n2.GetY()), [m2.getX(), m2.getY(), r3];
      }
      GetCollisionPolyPointCount() {
        return this.GetWorldInfo().GetTransformedCollisionPoly().pointCount();
      }
      GetCollisionPolyPoint(t3) {
        t3 = Math.floor(t3);
        const e2 = this.GetWorldInfo(), n2 = e2.GetTransformedCollisionPoly(), i2 = n2.pointCount();
        if (t3 === i2 && (t3 = 0), t3 < 0 || t3 >= i2) return [0, 0];
        const r3 = n2.pointsArr();
        return [r3[2 * t3 + 0] + e2.GetX(), r3[2 * t3 + 1] + e2.GetY()];
      }
      GetDebuggerProperties() {
        const e2 = t2.Plugins.Sprite.Acts, n2 = "plugins.sprite.debugger.animation-properties";
        return [{ title: n2 + ".title", properties: [{ name: n2 + ".current-animation", value: this._currentAnimation.GetName(), onedit: (t3) => this.CallAction(e2.SetAnim, t3, 0) }, { name: n2 + ".current-frame", value: this._currentFrameIndex, onedit: (t3) => this.CallAction(e2.SetAnimFrame, t3) }, { name: n2 + ".is-playing", value: this.IsAnimationPlaying(), onedit: (t3) => t3 ? this.CallAction(e2.StartAnim, 0) : this.CallAction(e2.StopAnim) }, { name: n2 + ".speed", value: this._currentAnimationSpeed, onedit: (t3) => this.CallAction(e2.SetAnimSpeed, t3) }, { name: n2 + ".repeats", value: this._animationRepeats, onedit: (t3) => this._animationRepeats = t3 }] }];
      }
      SaveToJson() {
        const t3 = { "a": this._currentAnimation.GetSID() };
        0 !== this._frameStartTime && (t3["fs"] = this._frameStartTime);
        const e2 = this.GetAnimationTime();
        0 !== e2 && (t3["at"] = e2), 0 !== this._currentFrameIndex && (t3["f"] = this._currentFrameIndex), 0 !== this._currentAnimationSpeed && (t3["cas"] = this._currentAnimationSpeed), 1 !== this._animationRepeats && (t3["ar"] = this._animationRepeats), 0 !== this._currentAnimationRepeatTo && (t3["rt"] = this._currentAnimationRepeatTo), this.IsAnimationPlaying() || (t3["ap"] = this.IsAnimationPlaying()), this.IsPlayingForwards() || (t3["af"] = this.IsPlayingForwards());
        const n2 = this.GetWorldInfo();
        return n2.IsCollisionEnabled() && (t3["ce"] = n2.IsCollisionEnabled()), t3;
      }
      LoadFromJson(e2) {
        const n2 = this.GetObjectClass().GetAnimationBySID(e2["a"]);
        n2 && (this._currentAnimation = n2), this._frameStartTime = e2.hasOwnProperty("fs") ? e2["fs"] : 0, this._animationTimer.Set(e2.hasOwnProperty("at") ? e2["at"] : 0);
        const i2 = e2.hasOwnProperty("f") ? e2["f"] : 0;
        this._currentFrameIndex = t2.clamp(i2, 0, this._currentAnimation.GetFrameCount() - 1), this._currentAnimationSpeed = e2.hasOwnProperty("cas") ? e2["cas"] : 0, this._animationRepeats = e2.hasOwnProperty("ar") ? e2["ar"] : 1;
        const r3 = e2.hasOwnProperty("rt") ? e2["rt"] : 0;
        this._currentAnimationRepeatTo = t2.clamp(r3, 0, this._currentAnimation.GetFrameCount() - 1), this.SetAnimationPlaying(!e2.hasOwnProperty("ap") || !!e2["ap"]), this.SetPlayingForwards(!e2.hasOwnProperty("af") || !!e2["af"]);
        const a3 = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
        this._currentAnimationFrame = a3, this._UpdateCurrentTexture();
        const s2 = this.GetWorldInfo();
        s2.SetOriginX(a3.GetOriginX()), s2.SetOriginY(a3.GetOriginY()), s2.SetSourceCollisionPoly(a3.GetCollisionPoly()), s2.SetCollisionEnabled(!!e2["ce"]), this.IsAnimationPlaying() && this._StartTicking();
      }
      GetPropertyValueByIndex(e2) {
        const n2 = this.GetWorldInfo();
        switch (e2) {
          case a2:
            return n2.IsCollisionEnabled();
          case r2:
            return t2.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1);
          case i:
            return this._currentAnimation.GetName();
        }
      }
      SetPropertyValueByIndex(e2, n2, s2) {
        const o3 = this.GetWorldInfo();
        switch (e2) {
          case a2:
            o3.SetCollisionEnabled(!!n2);
            break;
          case r2: {
            this.SetAnimationPlaying(false);
            const e3 = this._currentAnimation.GetFrameCount() - 1, i2 = n2 = t2.clamp(n2, 0, e3), r3 = this._currentAnimation.GetFrameAt(this._currentFrameIndex), a3 = this._currentAnimation.GetFrameAt(i2);
            this._OnFrameChanged(r3, a3, s2), this._currentFrameIndex = t2.clamp(i2, 0, e3);
            break;
          }
          case i:
            this._changeAnimationName = n2, this._DoChangeAnimation(s2);
            this._currentAnimation.GetFrameCount() > 1 && this._currentAnimation.GetSpeed() > 0 ? this._StartTicking() : this._StopTicking();
            break;
        }
      }
      GetScriptInterfaceClass() {
        return self.ISpriteInstance;
      }
    };
    const l = /* @__PURE__ */ new WeakMap(), d2 = /* @__PURE__ */ new Map([["current-frame", 0], ["beginning", 1]]);
    self.ISpriteInstance = class extends self.IWorldInstance {
      constructor() {
        super(), l.set(this, self.IInstance._GetInitInst().GetSdkInstance());
      }
      getImagePointCount() {
        return l.get(this).GetImagePointCount();
      }
      getImagePointX(t3) {
        return this.getImagePoint(t3)[0];
      }
      getImagePointY(t3) {
        return this.getImagePoint(t3)[1];
      }
      getImagePointZ(t3) {
        return this.getImagePoint(t3)[2];
      }
      getImagePoint(t3) {
        if ("string" != typeof t3 && "number" != typeof t3) throw new TypeError("expected string or number");
        return l.get(this).GetImagePoint(t3);
      }
      getPolyPointCount() {
        return l.get(this).GetCollisionPolyPointCount();
      }
      getPolyPointX(t3) {
        return e.RequireFiniteNumber(t3), l.get(this).GetCollisionPolyPoint(t3)[0];
      }
      getPolyPointY(t3) {
        return e.RequireFiniteNumber(t3), l.get(this).GetCollisionPolyPoint(t3)[1];
      }
      getPolyPoint(t3) {
        return e.RequireFiniteNumber(t3), l.get(this).GetCollisionPolyPoint(t3);
      }
      stopAnimation() {
        l.get(this).SetAnimationPlaying(false);
      }
      startAnimation(t3 = "current-frame") {
        e.RequireString(t3);
        const n2 = d2.get(t3);
        if (void 0 === n2) throw new Error("invalid mode");
        l.get(this)._StartAnim(n2);
      }
      setAnimation(t3, n2 = "beginning") {
        e.RequireString(t3), e.RequireString(n2);
        const i2 = d2.get(n2);
        if (void 0 === i2) throw new Error("invalid mode");
        const r3 = l.get(this);
        if (!r3.GetObjectClass().GetAnimationByName(t3)) throw new Error(`animation name "${t3}" does not exist`);
        r3._SetAnim(t3, i2);
      }
      getAnimation(t3) {
        e.RequireString(t3);
        const n2 = l.get(this).GetObjectClass().GetAnimationByName(t3);
        return n2 ? n2.GetIAnimation() : null;
      }
      get animation() {
        return l.get(this)._GetCurrentAnimation().GetIAnimation();
      }
      get animationName() {
        return l.get(this)._GetCurrentAnimationName();
      }
      set animationFrame(t3) {
        e.RequireFiniteNumber(t3), l.get(this)._SetAnimFrame(t3);
      }
      get animationFrame() {
        return l.get(this)._GetAnimFrame();
      }
      set animationFrameTag(t3) {
        e.RequireString(t3), l.get(this)._SetAnimFrame(t3);
      }
      get animationFrameTag() {
        return l.get(this)._GetAnimFrameTag();
      }
      set animationSpeed(t3) {
        e.RequireFiniteNumber(t3), l.get(this)._SetAnimSpeed(t3);
      }
      get animationSpeed() {
        return l.get(this)._GetAnimSpeed();
      }
      set animationRepeatToFrame(t3) {
        e.RequireFiniteNumber(t3), l.get(this)._SetAnimRepeatToFrame(t3);
      }
      get animationRepeatToFrame() {
        return l.get(this)._GetAnimRepeatToFrame();
      }
      get imageWidth() {
        return l.get(this).GetCurrentImageInfo().GetWidth();
      }
      get imageHeight() {
        return l.get(this).GetCurrentImageInfo().GetHeight();
      }
      getImageSize() {
        const t3 = l.get(this).GetCurrentImageInfo();
        return [t3.GetWidth(), t3.GetHeight()];
      }
      async replaceCurrentAnimationFrame(n2) {
        e.RequireInstanceOf(n2, Blob);
        const i2 = l.get(this), r3 = i2.GetRuntime(), a3 = i2.GetCurrentImageInfo(), s2 = t2.New(t2.ImageInfo);
        if (s2.LoadDynamicBlobAsset(r3, n2), await s2.LoadStaticTexture(r3.GetRenderer(), { sampling: r3.GetSampling() }), i2.WasReleased()) return void s2.Release();
        a3.ReplaceWith(s2);
        const o3 = i2.GetSdkType();
        o3._UpdateAllCurrentTexture(), o3.GetObjectClass().Dispatcher().dispatchEvent(new t2.Event("animationframeimagechange")), r3.UpdateRender();
      }
      setSolidCollisionFilter(t3, n2) {
        e.RequireString(n2), l.get(this).GetWorldInfo().SetSolidCollisionFilter(!!t3, n2);
      }
    };
  }
  {
    const t2 = self.C3;
    t2.Plugins.Sprite.Cnds = { IsAnimPlaying(e) {
      return t2.equalsNoCase(this._GetCurrentAnimationName(), e);
    }, CompareFrame(e, n) {
      return t2.compare(this._currentFrameIndex, e, n);
    }, CompareFrameTag(e, n) {
      if ("string" != typeof n) return false;
      const i = this._currentAnimationFrame.GetTag();
      return t2.compare(i.toLowerCase(), e, n.toLowerCase());
    }, CompareAnimSpeed(e, n) {
      return t2.compare(this._GetAnimSpeed(), e, n);
    }, OnAnimFinished(e) {
      return t2.equalsNoCase(this._animTriggerName, e);
    }, OnAnyAnimFinished: () => true, OnFrameChanged: () => true, IsMirrored() {
      return this.GetWorldInfo().GetWidth() < 0;
    }, IsFlipped() {
      return this.GetWorldInfo().GetHeight() < 0;
    }, OnURLLoaded: () => true, OnURLFailed: () => true, IsCollisionEnabled() {
      return this.GetWorldInfo().IsCollisionEnabled();
    } };
  }
  {
    const t2 = self.C3;
    t2.Plugins.Sprite.Acts = { Spawn(t3, e, n, i, r2) {
      if (!t3 || !e) return;
      const [a2, s] = this.GetImagePoint(n), o2 = this._runtime.CreateInstance(t3, e, a2, s, i, r2);
      if (!o2) return;
      if (i && e.SortAndAddInstancesByZIndex(o2), t3.GetPlugin().IsRotatable()) {
        const t4 = o2.GetWorldInfo();
        t4.SetAngle(this.GetWorldInfo().GetAngle()), t4.SetBboxChanged();
      }
      const m2 = this._runtime.GetEventSheetManager();
      m2.BlockFlushingInstances(true), o2._TriggerOnCreatedOnSelfAndRelated(), m2.BlockFlushingInstances(false), t3 !== this._runtime.GetCurrentAction().GetObjectClass() && this._sdkType._SpawnPickInstance(t3, o2, i);
    }, StopAnim() {
      this.SetAnimationPlaying(false);
    }, StartAnim(t3) {
      this._StartAnim(t3);
    }, SetAnim(t3, e) {
      this._SetAnim(t3, e);
    }, SetAnimFrame(t3) {
      this._SetAnimFrame(t3);
    }, SetAnimSpeed(t3) {
      this._SetAnimSpeed(t3);
    }, SetAnimRepeatToFrame(t3) {
      this._SetAnimRepeatToFrame(t3);
    }, AddRemoveAnimation(t3, e) {
      try {
        0 === t3 ? this.GetSdkType()._AddAnimation(e) : this.GetSdkType()._RemoveAnimation(e);
      } catch (e2) {
        console.error(`[Construct] Error ${0 === t3 ? "adding" : "removing"} animation: `, e2);
      }
    }, AddRemoveAnimationFrame(t3, e, n) {
      try {
        0 === t3 ? this.GetSdkType()._AddAnimationFrame(e, n) : this.GetSdkType()._RemoveAnimationFrame(e, n);
      } catch (e2) {
        console.error(`[Construct] Error ${0 === t3 ? "adding" : "removing"} animation frame: `, e2);
      }
    }, SetMirrored(t3) {
      const e = this.GetWorldInfo(), n = e.GetWidth(), i = Math.abs(n) * (0 === t3 ? -1 : 1);
      n !== i && (e.SetWidth(i), e.SetBboxChanged());
    }, SetFlipped(t3) {
      const e = this.GetWorldInfo(), n = e.GetHeight(), i = Math.abs(n) * (0 === t3 ? -1 : 1);
      n !== i && (e.SetHeight(i), e.SetBboxChanged());
    }, SetScale(t3) {
      const e = this._currentAnimationFrame.GetImageInfo(), n = this.GetWorldInfo(), i = n.GetWidth() < 0 ? -1 : 1, r2 = n.GetHeight() < 0 ? -1 : 1, a2 = e.GetWidth() * t3 * i, s = e.GetHeight() * t3 * r2;
      n.GetWidth() === a2 && n.GetHeight() === s || (n.SetSize(a2, s), n.SetBboxChanged());
    }, async LoadURL(e, n, i) {
      const r2 = this._currentAnimationFrame.GetImageInfo(), a2 = this.GetWorldInfo(), s = this._runtime, o2 = this._sdkType;
      if (r2.GetURL() === e) return 0 === n && (a2.SetSize(r2.GetWidth(), r2.GetHeight()), a2.SetBboxChanged()), void this.Trigger(t2.Plugins.Sprite.Cnds.OnURLLoaded);
      const m2 = t2.New(t2.ImageInfo);
      try {
        if (await m2.LoadDynamicAsset(s, e), !m2.IsLoaded()) throw new Error("image failed to load");
        if (this.WasReleased()) return void m2.Release();
        await m2.LoadStaticTexture(s.GetRenderer(), { sampling: s.GetSampling() });
      } catch (e2) {
        return console.error("Load image from URL failed: ", e2), void (this.WasReleased() || this.Trigger(t2.Plugins.Sprite.Cnds.OnURLFailed));
      }
      this.WasReleased() ? m2.Release() : (r2.ReplaceWith(m2), o2._UpdateAllCurrentTexture(), o2.GetObjectClass().Dispatcher().dispatchEvent(new t2.Event("animationframeimagechange")), s.UpdateRender(), 0 === n && (a2.SetSize(r2.GetWidth(), r2.GetHeight()), a2.SetBboxChanged()), await this.TriggerAsync(t2.Plugins.Sprite.Cnds.OnURLLoaded));
    }, SetCollisions(t3) {
      this.GetWorldInfo().SetCollisionEnabled(t3);
    }, SetSolidCollisionFilter(t3, e) {
      this.GetWorldInfo().SetSolidCollisionFilter(0 === t3, e);
    }, SetEffect(t3) {
      this.GetWorldInfo().SetBlendMode(t3), this._runtime.UpdateRender();
    } };
  }
  self.C3.Plugins.Sprite.Exps = { AnimationFrame() {
    return this._GetAnimFrame();
  }, AnimationFrameTag() {
    return this._GetAnimFrameTag();
  }, AnimationFrameCount() {
    return this._currentAnimation.GetFrameCount();
  }, AnimationName() {
    return this._currentAnimation.GetName();
  }, AnimationSpeed() {
    return this._GetAnimSpeed();
  }, OriginalAnimationSpeed() {
    return this._currentAnimation.GetSpeed();
  }, ImagePointX(t2) {
    return this.GetImagePoint(t2)[0];
  }, ImagePointY(t2) {
    return this.GetImagePoint(t2)[1];
  }, ImagePointZ(t2) {
    return this.GetImagePoint(t2)[2];
  }, ImagePointCount() {
    return this.GetImagePointCount();
  }, ImageWidth() {
    return this.GetCurrentImageInfo().GetWidth();
  }, ImageHeight() {
    return this.GetCurrentImageInfo().GetHeight();
  }, PolyPointXAt(t2) {
    return this.GetCollisionPolyPoint(t2)[0];
  }, PolyPointYAt(t2) {
    return this.GetCollisionPolyPoint(t2)[1];
  }, PolyPointCount() {
    return this.GetCollisionPolyPointCount();
  } };
}
{
  {
    const e = self.C3, t2 = "progress-bar";
    e.Plugins.progressbar = class extends e.SDKDOMPluginBase {
      constructor(e2) {
        super(e2, t2), this.AddElementMessageHandler("click", (e3, t3) => e3._OnClick(t3));
      }
      Release() {
        super.Release();
      }
    };
  }
  {
    const e = self.C3;
    e.Plugins.progressbar.Type = class extends e.SDKTypeBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
      OnCreate() {
      }
    };
  }
  {
    const e = self.C3, t2 = self.C3X, s = 0, i = 1, r2 = 2, a2 = 3, n = 4, l = 5, o2 = "progress-bar";
    e.Plugins.progressbar.Instance = class extends e.SDKDOMInstanceBase {
      constructor(e2, t3) {
        super(e2, o2), this._value = 0, this._max = 100, this._title = "", this._id = "", this._className = "", t3 && (this._value = t3[s], this._max = t3[i], this._title = t3[r2], this.GetWorldInfo().SetVisible(t3[a2]), this._id = t3[n], this._className = t3[l]), this.CreateElement({ "id": this._id, "className": this._className });
      }
      Release() {
        super.Release();
      }
      GetElementState() {
        return { "value": this._value, "max": this._max, "title": this._title };
      }
      async _OnClick(t3) {
        this.DispatchScriptEvent("click"), await this.TriggerAsync(e.Plugins.progressbar.Cnds.OnClicked);
      }
      _SetTooltip(e2) {
        this._title !== e2 && (this._title = e2, this.UpdateElementState());
      }
      _GetTooltip() {
        return this._title;
      }
      _SetProgress(e2) {
        this._value !== e2 && (this._value = e2, this.UpdateElementState());
      }
      _GetProgress() {
        return this._value;
      }
      _SetMaximum(e2) {
        this._max !== e2 && (this._max = e2, this.UpdateElementState());
      }
      _GetMaximum() {
        return this._max;
      }
      _SetIndeterminate() {
        this._max = 0, this._value = 0, this.UpdateElementState();
      }
      Draw(e2) {
      }
      SaveToJson() {
        return { "v": this._value, "m": this._max, "t": this._title, "id": this._id };
      }
      LoadFromJson(e2) {
        this._value = e2["v"], this._max = e2["m"], this._title = e2["t"], this._id = e2["id"], this.UpdateElementState();
      }
      GetPropertyValueByIndex(e2) {
        switch (e2) {
          case s:
            return this._GetProgress();
          case i:
            return this._GetMaximum();
          case r2:
            return this._GetTooltip();
        }
      }
      SetPropertyValueByIndex(e2, t3) {
        switch (e2) {
          case s:
            this._SetProgress(t3);
            break;
          case i:
            this._SetMaximum(t3);
            break;
          case r2:
            this._SetTooltip(t3);
        }
      }
      GetDebuggerProperties() {
        const e2 = "plugins.progressbar";
        return [{ title: e2 + ".name", properties: [{ name: e2 + ".properties.value.name", value: this._GetProgress(), onedit: (e3) => this._SetProgress(e3) }, { name: e2 + ".properties.maximum.name", value: this._GetMaximum(), onedit: (e3) => this._SetMaximum(e3) }] }];
      }
      GetScriptInterfaceClass() {
        return self.IProgressBarInstance;
      }
    };
    const h2 = /* @__PURE__ */ new WeakMap();
    self.IProgressBarInstance = class extends self.IDOMInstance {
      constructor() {
        super(), h2.set(this, self.IInstance._GetInitInst().GetSdkInstance());
      }
      set progress(e2) {
        t2.RequireFiniteNumber(e2), h2.get(this)._SetProgress(e2);
      }
      get progress() {
        return h2.get(this)._GetProgress();
      }
      set maximum(e2) {
        t2.RequireFiniteNumber(e2), h2.get(this)._SetMaximum(e2);
      }
      get maximum() {
        return h2.get(this)._GetMaximum();
      }
      set tooltip(e2) {
        t2.RequireString(e2), h2.get(this)._SetTooltip(e2);
      }
      get tooltip() {
        return h2.get(this)._GetTooltip();
      }
      setIndeterminate() {
        h2.get(this)._SetIndeterminate();
      }
    };
  }
  {
    const e = self.C3;
    e.Plugins.progressbar.Cnds = { OnClicked: () => true, CompareProgress(t2, s) {
      return e.compare(this._GetProgress(), t2, s);
    } };
  }
  self.C3.Plugins.progressbar.Acts = { SetTooltip(e) {
    this._SetTooltip(e);
  }, SetProgress(e) {
    this._SetProgress(e);
  }, SetMaximum(e) {
    this._SetMaximum(e);
  }, SetIndeterminate() {
    this._SetIndeterminate();
  } };
  self.C3.Plugins.progressbar.Exps = { Progress() {
    return this._GetProgress();
  }, Maximum() {
    return this._GetMaximum();
  } };
}
{
  {
    const e = self.C3, t2 = "sliderbar";
    e.Plugins.sliderbar = class extends e.SDKDOMPluginBase {
      constructor(e2) {
        super(e2, t2), this.AddElementMessageHandler("click", (e3, t3) => e3._OnClick(t3)), this.AddElementMessageHandler("change", (e3, t3) => e3._OnChange(t3)), this.AddElementMessageHandler("input", (e3, t3) => e3._OnInput(t3));
      }
      Release() {
        super.Release();
      }
    };
  }
  {
    const e = self.C3;
    e.Plugins.sliderbar.Type = class extends e.SDKTypeBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
      OnCreate() {
      }
    };
  }
  {
    const e = self.C3, t2 = self.C3X, i = 0, s = 1, a2 = 2, n = 3, r2 = 4, l = 5, h2 = 6, u2 = 7, m2 = 8, _2 = "sliderbar";
    e.Plugins.sliderbar.Instance = class extends e.SDKDOMInstanceBase {
      constructor(e2, t3) {
        super(e2, _2), this._value = 0, this._min = 0, this._max = 100, this._step = 1, this._title = "", this._isEnabled = true, this._id = "", this._className = "", t3 && (this._value = t3[i], this._min = t3[s], this._max = t3[a2], this._step = t3[n], this._title = t3[r2], this.GetWorldInfo().SetVisible(t3[l]), this._isEnabled = t3[h2], this._id = t3[u2], this._className = t3[m2]), this.CreateElement({ "id": this._id, "className": this._className });
      }
      Release() {
        super.Release();
      }
      GetElementState() {
        return { "value": this._value, "min": this._min, "max": this._max, "step": this._step, "title": this._title, "isEnabled": this._isEnabled };
      }
      async _OnClick(t3) {
        this.DispatchScriptEvent("click", true), await this.TriggerAsync(e.Plugins.sliderbar.Cnds.OnClicked);
      }
      async _OnChange(t3) {
        this._value = t3["value"], this.DispatchScriptEvent("change", true), await this.TriggerAsync(e.Plugins.sliderbar.Cnds.OnChanged);
      }
      async _OnInput(t3) {
        this._value = t3["value"], this.DispatchScriptEvent("input", true), await this.TriggerAsync(e.Plugins.sliderbar.Cnds.OnChanging);
      }
      Draw(e2) {
      }
      _SetValue(e2) {
        this._value !== e2 && (this._value = e2, this.UpdateElementState());
      }
      _GetValue() {
        return this._value;
      }
      _SetMaximum(e2) {
        this._max !== e2 && (this._max = e2, this.UpdateElementState());
      }
      _GetMaximum() {
        return this._max;
      }
      _SetMinimum(e2) {
        this._min !== e2 && (this._min = e2, this.UpdateElementState());
      }
      _GetMinimum() {
        return this._min;
      }
      _SetTooltip(e2) {
        this._title !== e2 && (this._title = e2, this.UpdateElementState());
      }
      _GetTooltip() {
        return this._title;
      }
      _SetStep(e2) {
        this._step !== e2 && (this._step = e2, this.UpdateElementState());
      }
      _GetStep() {
        return this._step;
      }
      _SetEnabled(e2) {
        e2 = !!e2, this._isEnabled !== e2 && (this._isEnabled = e2, this.UpdateElementState());
      }
      _IsEnabled() {
        return this._isEnabled;
      }
      SaveToJson() {
        return { "v": this._value, "min": this._min, "max": this._max, "s": this._step, "t": this._title, "e": this._isEnabled, "id": this._id };
      }
      LoadFromJson(e2) {
        this._value = e2["v"], this._min = e2["min"], this._max = e2["max"], this._step = e2["s"], this._title = e2["t"], this._isEnabled = e2["e"], this._id = e2["id"], this.UpdateElementState();
      }
      GetPropertyValueByIndex(e2) {
        switch (e2) {
          case i:
            return this._GetValue();
          case s:
            return this._GetMinimum();
          case a2:
            return this._GetMaximum();
          case n:
            return this._GetStep();
          case r2:
            return this._GetTooltip();
          case h2:
            return this._IsEnbled();
        }
      }
      SetPropertyValueByIndex(e2, t3) {
        switch (e2) {
          case i:
            this._SetValue(t3);
            break;
          case s:
            this._SetMinimum(t3);
            break;
          case a2:
            this._SetMaximum(t3);
            break;
          case n:
            this._SetStep(t3);
            break;
          case r2:
            this._SetTooltip(t3);
            break;
          case h2:
            this._SetEnabled(t3);
        }
      }
      GetDebuggerProperties() {
        e.Plugins.sliderbar.Acts;
        const t3 = "plugins.sliderbar";
        return [{ title: t3 + ".name", properties: [{ name: t3 + ".properties.value.name", value: this._GetValue(), onedit: (e2) => this._SetValue(e2) }, { name: t3 + ".properties.minimum.name", value: this._GetMinimum(), onedit: (e2) => this._SetMinimum(e2) }, { name: t3 + ".properties.maximum.name", value: this._GetMaximum(), onedit: (e2) => this._SetMaximum(e2) }, { name: t3 + ".properties.step.name", value: this._GetStep(), onedit: (e2) => this._SetStep(e2) }, { name: t3 + ".properties.enabled.name", value: this._IsEnabled(), onedit: (e2) => this._SetEnabled(e2) }] }];
      }
      GetScriptInterfaceClass() {
        return self.ISliderBarInstance;
      }
    };
    const d2 = /* @__PURE__ */ new WeakMap();
    self.ISliderBarInstance = class extends self.IDOMInstance {
      constructor() {
        super(), d2.set(this, self.IInstance._GetInitInst().GetSdkInstance());
      }
      set value(e2) {
        t2.RequireFiniteNumber(e2), d2.get(this)._SetValue(e2);
      }
      get value() {
        return d2.get(this)._GetValue();
      }
      set maximum(e2) {
        t2.RequireFiniteNumber(e2), d2.get(this)._SetMaximum(e2);
      }
      get maximum() {
        return d2.get(this)._GetMaximum();
      }
      set minimum(e2) {
        t2.RequireFiniteNumber(e2), d2.get(this)._SetMinimum(e2);
      }
      get minimum() {
        return d2.get(this)._GetMinimum();
      }
      set step(e2) {
        t2.RequireFiniteNumber(e2), d2.get(this)._SetStep(e2);
      }
      get step() {
        return d2.get(this)._GetStep();
      }
      set tooltip(e2) {
        t2.RequireString(e2), d2.get(this)._SetTooltip(e2);
      }
      get tooltip() {
        return d2.get(this)._GetTooltip();
      }
      set isEnabled(e2) {
        d2.get(this)._SetEnabled(e2);
      }
      get isEnabled() {
        return d2.get(this)._IsEnabled();
      }
    };
  }
  {
    const e = self.C3;
    e.Plugins.sliderbar.Cnds = { OnClicked: () => true, OnChanged: () => true, OnChanging: () => true, CompareValue(t2, i) {
      return e.compare(this._GetValue(), t2, i);
    } };
  }
  self.C3.Plugins.sliderbar.Acts = { SetTooltip(e) {
    this._SetTooltip(e);
  }, SetValue(e) {
    this._SetValue(e);
  }, SetMaximum(e) {
    this._SetMaximum(e);
  }, SetMinimum(e) {
    this._SetMinimum(e);
  }, SetStep(e) {
    this._SetStep(e);
  } };
  self.C3.Plugins.sliderbar.Exps = { Value() {
    return this._GetValue();
  }, Maximum() {
    return this._GetMaximum();
  }, Minimum() {
    return this._GetMinimum();
  }, Step() {
    return this._GetStep();
  } };
}
{
  {
    const e = self.C3, t2 = "button";
    e.Plugins.Button = class extends e.SDKDOMPluginBase {
      constructor(e2) {
        super(e2, t2), this.AddElementMessageHandler("click", (e3, t3) => e3._OnClick(t3));
      }
      Release() {
        super.Release();
      }
    };
  }
  {
    const e = self.C3;
    e.Plugins.Button.Type = class extends e.SDKTypeBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
      OnCreate() {
      }
    };
  }
  {
    const e = self.C3, t2 = self.C3X, s = 0, i = 1, n = 2, h2 = 3, a2 = 4, l = 5, c2 = 6, r2 = 7, _2 = 8, o2 = "button";
    e.Plugins.Button.Instance = class extends e.SDKDOMInstanceBase {
      constructor(e2, t3) {
        super(e2, o2), this._text = "OK", this._isCheckbox = false, this._isChecked = false, this._title = "", this._id = "", this._className = "", this._isEnabled = true, this._autoFontSize = true, t3 && (this._isCheckbox = 1 === t3[s], this._text = t3[i], this._title = t3[n], this.GetWorldInfo().SetVisible(t3[h2]), this._isEnabled = t3[a2], this._autoFontSize = t3[l], this._isChecked = t3[c2], this._id = t3[r2], this._className = t3[_2]), this.CreateElement({ "id": this._id, "className": this._className, "usesAutoFontSize": this._autoFontSize });
      }
      Release() {
        super.Release();
      }
      GetElementState() {
        return { "text": this._text, "isCheckbox": this._isCheckbox, "isChecked": this._isChecked, "title": this._title, "isVisible": this.GetWorldInfo().IsVisible(), "isEnabled": this._isEnabled };
      }
      async _OnClick(t3) {
        this._isChecked = t3["isChecked"], this.DispatchScriptEvent("click", true), await this.TriggerAsync(e.Plugins.Button.Cnds.OnClicked);
      }
      _SetText(e2) {
        this._text !== e2 && (this._text = e2, this.UpdateElementState());
      }
      _GetText() {
        return this._text;
      }
      _SetTooltip(e2) {
        this._title !== e2 && (this._title = e2, this.UpdateElementState());
      }
      _GetTooltip() {
        return this._title;
      }
      _SetEnabled(e2) {
        e2 = !!e2, this._isEnabled !== e2 && (this._isEnabled = e2, this.UpdateElementState());
      }
      _IsEnabled() {
        return this._isEnabled;
      }
      _SetChecked(e2) {
        this._isCheckbox && (e2 = !!e2, this._isChecked !== e2 && (this._isChecked = e2, this.UpdateElementState()));
      }
      _IsChecked() {
        return this._isChecked;
      }
      Draw(e2) {
      }
      SaveToJson() {
        return { "text": this._text, "checked": this._isChecked, "title": this._title, "enabled": this._isEnabled };
      }
      LoadFromJson(e2) {
        this._text = e2["text"], this._isChecked = e2["checked"], this._title = e2["title"], this._isEnabled = e2["enabled"], this.UpdateElementState();
      }
      GetPropertyValueByIndex(e2) {
        switch (e2) {
          case i:
            return this._GetText();
          case n:
            return this._GetTooltip();
          case a2:
            return this._IsEnabled();
          case l:
            return this._autoFontSize;
          case c2:
            return this._IsChecked();
        }
      }
      SetPropertyValueByIndex(e2, t3) {
        switch (e2) {
          case i:
            this._SetText(t3);
            break;
          case n:
            this._SetTooltip(t3);
            break;
          case a2:
            this._SetEnabled(!!t3);
            break;
          case l:
            this._autoFontSize = !!t3;
            break;
          case c2:
            this._SetChecked(!!t3);
        }
      }
      GetDebuggerProperties() {
        const e2 = "plugins.button";
        return [{ title: e2 + ".name", properties: [{ name: e2 + ".properties.text.name", value: this._GetText(), onedit: (e3) => this._SetText(e3) }, { name: e2 + ".properties.enabled.name", value: this._IsEnabled(), onedit: (e3) => this._SetEnabled(e3) }, { name: e2 + ".properties.checked.name", value: this._IsChecked(), onedit: (e3) => this._SetChecked(e3) }] }];
      }
      GetScriptInterfaceClass() {
        return self.IButtonInstance;
      }
    };
    const d2 = /* @__PURE__ */ new WeakMap();
    self.IButtonInstance = class extends self.IDOMInstance {
      constructor() {
        super(), d2.set(this, self.IInstance._GetInitInst().GetSdkInstance());
      }
      set text(e2) {
        t2.RequireString(e2), d2.get(this)._SetText(e2);
      }
      get text() {
        return d2.get(this)._GetText();
      }
      set tooltip(e2) {
        t2.RequireString(e2), d2.get(this)._SetTooltip(e2);
      }
      get tooltip() {
        return d2.get(this)._GetTooltip();
      }
      set isEnabled(e2) {
        d2.get(this)._SetEnabled(e2);
      }
      get isEnabled() {
        return d2.get(this)._IsEnabled();
      }
      set isChecked(e2) {
        d2.get(this)._SetChecked(e2);
      }
      get isChecked() {
        return d2.get(this)._IsChecked();
      }
    };
  }
  {
    const e = self.C3;
    e.Plugins.Button.Cnds = { OnClicked: () => true, IsChecked() {
      return this._isChecked;
    }, CompareText(t2, s) {
      return s ? this._text === t2 : e.equalsNoCase(this._text, t2);
    } };
  }
  self.C3.Plugins.Button.Acts = { SetText(e) {
    this._SetText(e);
  }, SetTooltip(e) {
    this._SetTooltip(e);
  }, SetChecked(e) {
    this._SetChecked(0 !== e);
  }, ToggleChecked() {
    this._isCheckbox && (this._isChecked = !this._isChecked, this.UpdateElementState());
  } };
  self.C3.Plugins.Button.Exps = { Text() {
    return this._text;
  } };
}
{
  {
    const e = self.C3;
    e.Plugins.TiledBg = class extends e.SDKPluginBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
    };
  }
  {
    let WrapModeToStr = function(e) {
      switch (e) {
        case 0:
          return "clamp-to-edge";
        case 1:
          return "repeat";
        case 2:
          return "mirror-repeat";
      }
      return "repeat";
    };
    WrapModeToStr2 = WrapModeToStr;
    const t2 = self.C3;
    t2.Plugins.TiledBg.Type = class extends t2.SDKTypeBase {
      constructor(e, t3) {
        super(e), this._wrapX = "repeat", this._wrapY = "repeat", t3 && (this._wrapX = WrapModeToStr(t3[0]), this._wrapY = WrapModeToStr(t3[1]));
      }
      Release() {
        super.Release();
      }
      OnCreate() {
        this.GetImageInfo().LoadAsset(this._runtime);
      }
      LoadTextures(e) {
        return this.GetImageInfo().LoadStaticTexture(e, { sampling: this._runtime.GetSampling(), wrapX: this._wrapX, wrapY: this._wrapY });
      }
      ReleaseTextures() {
        this.GetImageInfo().ReleaseTexture();
      }
      GetWrapModeX() {
        return this._wrapX;
      }
      GetWrapModeY() {
        return this._wrapY;
      }
    };
  }
  {
    const i = globalThis.C3, a2 = globalThis.C3X, n = 0, s = 4, r2 = 5, l = 6, g2 = 7, m2 = 8, h2 = 9, d2 = 10, o2 = 11, _2 = 12, u2 = 13, R = 14, S2 = i.New(i.Rect), f2 = i.New(i.Quad), I2 = i.New(i.Rect), c2 = i.New(i.Quad);
    i.Plugins.TiledBg.Instance = class extends i.SDKWorldInstanceBase {
      constructor(e, t2) {
        super(e), this._imageOffsetX = 0, this._imageOffsetY = 0, this._imageScaleX = 1, this._imageScaleY = 1, this._imageAngle = 0, this._enableTileRandomization = false, this._tileXRandom = 0, this._tileYRandom = 0, this._tileAngleRandom = 0, this._tileBlendMarginX = 0, this._tileBlendMarginY = 0, this._ownImageInfo = null, t2 && (this.GetWorldInfo().SetVisible(!!t2[n]), this._imageOffsetX = t2[s], this._imageOffsetY = t2[r2], this._imageScaleX = t2[l], this._imageScaleY = t2[g2], this._imageAngle = i.toRadians(t2[m2]), this._enableTileRandomization = !!t2[h2], this._tileXRandom = t2[d2], this._tileYRandom = t2[o2], this._tileAngleRandom = t2[_2], this._tileBlendMarginX = t2[u2], this._tileBlendMarginY = t2[R]);
      }
      Release() {
        this._ReleaseOwnImage(), super.Release();
      }
      _ReleaseOwnImage() {
        this._ownImageInfo && (this._ownImageInfo.Release(), this._ownImageInfo = null);
      }
      CalculateTextureCoordsFor3DFace(e, t2, i2) {
        const a3 = this.GetCurrentImageInfo(), n2 = a3.GetWidth(), s2 = a3.GetHeight(), r3 = this._imageOffsetX / n2, l2 = this._imageOffsetY / s2, g3 = this._imageAngle;
        I2.set(0, 0, e / (n2 * this._imageScaleX), t2 / (s2 * this._imageScaleY)), I2.offset(-r3, -l2), 0 === g3 ? i2.setFromRect(I2) : i2.setFromRotatedRect(I2, -g3);
      }
      SetTilingShaderProgram(e, t2 = true) {
        if (this._enableTileRandomization) {
          const t3 = this.GetCurrentImageInfo();
          e.SetTileRandomizationMode(), e.SetTileRandomizationInfo(t3.GetWidth() * this._imageScaleX, t3.GetHeight() * this._imageScaleY, this._tileXRandom, this._tileYRandom, this._tileAngleRandom, this._tileBlendMarginX, this._tileBlendMarginY);
        } else t2 && e.SetTextureFillMode();
      }
      Draw(e) {
        const t2 = this.GetCurrentImageInfo(), i2 = t2.GetTexture();
        if (null === i2) return;
        this.SetTilingShaderProgram(e), e.SetTexture(i2);
        const a3 = t2.GetWidth(), n2 = t2.GetHeight();
        let s2 = this._imageOffsetX / a3, r3 = this._imageOffsetY / n2;
        0 !== this._imageAngle || this._enableTileRandomization || ("repeat" === this.GetSdkType().GetWrapModeX() && (s2 %= 1), "repeat" === this.GetSdkType().GetWrapModeY() && (r3 %= 1));
        const l2 = this.GetWorldInfo();
        I2.set(0, 0, l2.GetWidth() / (a3 * this._imageScaleX), l2.GetHeight() / (n2 * this._imageScaleY)), I2.offset(-s2, -r3), l2.HasMesh() ? this._DrawMesh(l2, e) : this._DrawStandard(l2, e);
      }
      _DrawStandard(e, t2) {
        let i2 = e.GetBoundingQuad();
        this._runtime.IsPixelRoundingEnabled() && (i2 = e.PixelRoundQuad(i2)), 0 === this._imageAngle ? t2.Quad3(i2, I2) : (c2.setFromRotatedRect(I2, -this._imageAngle), t2.Quad4(i2, c2));
      }
      _DrawMesh(e, t2) {
        const i2 = e.GetTransformedMesh();
        if (e.IsMeshChanged()) {
          e.CalculateBbox(S2, f2, false);
          let t3 = f2;
          this._runtime.IsPixelRoundingEnabled() && (t3 = e.PixelRoundQuad(t3));
          let a3 = I2;
          0 !== this._imageAngle && (c2.setFromRotatedRect(I2, -this._imageAngle), a3 = c2), i2.CalculateTransformedMesh(e.GetSourceMesh(), t3, a3), e.SetMeshChanged(false);
        }
        i2.Draw(t2, e.GetTotalZElevation());
      }
      GetCurrentImageInfo() {
        return this._ownImageInfo || this._objectClass.GetImageInfo();
      }
      IsOriginalSizeKnown() {
        return true;
      }
      GetTexture() {
        return this.GetCurrentImageInfo().GetTexture();
      }
      _SetMeshChanged() {
        this.GetWorldInfo().SetMeshChanged(true);
      }
      _SetImageOffsetX(e) {
        this._imageOffsetX !== e && (this._imageOffsetX = e, this._runtime.UpdateRender(), this._SetMeshChanged());
      }
      _GetImageOffsetX() {
        return this._imageOffsetX;
      }
      _SetImageOffsetY(e) {
        this._imageOffsetY !== e && (this._imageOffsetY = e, this._runtime.UpdateRender(), this._SetMeshChanged());
      }
      _GetImageOffsetY() {
        return this._imageOffsetY;
      }
      _SetImageScaleX(e) {
        this._imageScaleX !== e && (this._imageScaleX = e, this._runtime.UpdateRender(), this._SetMeshChanged());
      }
      _GetImageScaleX() {
        return this._imageScaleX;
      }
      _SetImageScaleY(e) {
        this._imageScaleY !== e && (this._imageScaleY = e, this._runtime.UpdateRender(), this._SetMeshChanged());
      }
      _GetImageScaleY() {
        return this._imageScaleY;
      }
      _SetImageAngle(e) {
        this._imageAngle !== e && (this._imageAngle = e, this._runtime.UpdateRender(), this._SetMeshChanged());
      }
      _GetImageAngle() {
        return this._imageAngle;
      }
      _SetTileRandomizationEnabled(e) {
        e = !!e, this._enableTileRandomization !== e && (this._enableTileRandomization = e, this._runtime.UpdateRender());
      }
      _IsTileRandomizationEnabled() {
        return this._enableTileRandomization;
      }
      _SetTileXRandom(e) {
        this._tileXRandom !== e && (this._tileXRandom = e, this._IsTileRandomizationEnabled() && this._runtime.UpdateRender());
      }
      _GetTileXRandom() {
        return this._tileXRandom;
      }
      _SetTileYRandom(e) {
        this._tileYRandom !== e && (this._tileYRandom = e, this._IsTileRandomizationEnabled() && this._runtime.UpdateRender());
      }
      _GetTileYRandom() {
        return this._tileYRandom;
      }
      _SetTileAngleRandom(e) {
        this._tileAngleRandom !== e && (this._tileAngleRandom = e, this._IsTileRandomizationEnabled() && this._runtime.UpdateRender());
      }
      _GetTileAngleRandom() {
        return this._tileAngleRandom;
      }
      _SetTileBlendMarginX(e) {
        this._tileBlendMarginX !== e && (this._tileBlendMarginX = e, this._IsTileRandomizationEnabled() && this._runtime.UpdateRender());
      }
      _GetTileBlendMarginX() {
        return this._tileBlendMarginX;
      }
      _SetTileBlendMarginY(e) {
        this._tileBlendMarginY !== e && (this._tileBlendMarginY = e, this._IsTileRandomizationEnabled() && this._runtime.UpdateRender());
      }
      _GetTileBlendMarginY() {
        return this._tileBlendMarginY;
      }
      SaveToJson() {
        const e = {};
        return 0 !== this._imageOffsetX && (e["iox"] = this._imageOffsetX), 0 !== this._imageOffsetY && (e["ioy"] = this._imageOffsetY), 1 !== this._imageScaleX && (e["isx"] = this._imageScaleX), 1 !== this._imageScaleY && (e["isy"] = this._imageScaleY), 0 !== this._imageAngle && (e["ia"] = this._imageAngle), this._enableTileRandomization && (e["tr"] = true), 1 !== this._tileXRandom && (e["trx"] = this._tileXRandom), 1 !== this._tileYRandom && (e["try"] = this._tileYRandom), 1 !== this._tileAngleRandom && (e["tra"] = this._tileAngleRandom), 0.1 !== this._tileBlendMarginX && (e["trbmx"] = this._tileBlendMarginX), 0.1 !== this._tileBlendMarginY && (e["trbmy"] = this._tileBlendMarginY), e;
      }
      LoadFromJson(e) {
        this._imageOffsetX = e["iox"] || 0, this._imageOffsetY = e["ioy"] || 0, this._imageScaleX = e.hasOwnProperty("isx") ? e["isx"] : 1, this._imageScaleY = e.hasOwnProperty("isy") ? e["isy"] : 1, this._imageAngle = e["ia"] || 0, this._enableTileRandomization = !!e["tr"], this._tileXRandom = e.hasOwnProperty("trx") ? e["trx"] : 1, this._tileYRandom = e.hasOwnProperty("try") ? e["try"] : 1, this._tileAngleRandom = e.hasOwnProperty("tra") ? e["tra"] : 1, this._tileBlendMarginX = e.hasOwnProperty("trbmx") ? e["trbmx"] : 0.1, this._tileBlendMarginY = e.hasOwnProperty("trbmy") ? e["trbmy"] : 0.1;
      }
      GetDebuggerProperties() {
        const e = "plugins.tiledbg.properties";
        return [{ title: e + ".image-transform.name", properties: [{ name: e + ".image-offset-x.name", value: this._GetImageOffsetX(), onedit: (e2) => this._SetImageOffsetX(e2) }, { name: e + ".image-offset-y.name", value: this._GetImageOffsetY(), onedit: (e2) => this._SetImageOffsetY(e2) }, { name: e + ".image-scale-x.name", value: 100 * this._GetImageScaleX(), onedit: (e2) => this._SetImageScaleX(e2 / 100) }, { name: e + ".image-scale-y.name", value: 100 * this._GetImageScaleY(), onedit: (e2) => this._SetImageScaleY(e2 / 100) }, { name: e + ".image-angle.name", value: i.toDegrees(this._GetImageAngle()), onedit: (e2) => this._SetImageAngle(i.toRadians(e2)) }] }, { title: e + ".tile-randomization.name", properties: [{ name: e + ".enable-tile-randomization.name", value: this._IsTileRandomizationEnabled(), onedit: (e2) => this._SetTileRandomizationEnabled(e2) }, { name: e + ".x-random.name", value: 100 * this._GetTileXRandom(), onedit: (e2) => this._SetTileXRandom(e2 / 100) }, { name: e + ".y-random.name", value: 100 * this._GetTileYRandom(), onedit: (e2) => this._SetTileYRandom(e2 / 100) }, { name: e + ".angle-random.name", value: 100 * this._GetTileAngleRandom(), onedit: (e2) => this._SetTileAngleRandom(e2 / 100) }, { name: e + ".blend-margin-x.name", value: 100 * this._GetTileBlendMarginX(), onedit: (e2) => this._SetTileBlendMarginX(e2 / 100) }, { name: e + ".blend-margin-y.name", value: 100 * this._GetTileBlendMarginY(), onedit: (e2) => this._SetTileBlendMarginY(e2 / 100) }] }];
      }
      GetPropertyValueByIndex(e) {
        switch (e) {
          case s:
            return this._GetImageOffsetX();
          case r2:
            return this._GetImageOffsetY();
          case l:
            return this._GetImageScaleX();
          case g2:
            return this._GetImageScaleY();
          case m2:
            return this._GetImageAngle();
          case h2:
            return this._IsTileRandomizationEnabled();
          case d2:
            return this._GetTileXRandom();
          case o2:
            return this._GetTileYRandom();
          case _2:
            return this._GetTileAngleRandom();
          case u2:
            return this._GetTileBlendMarginX();
          case R:
            return this._GetTileBlendMarginY();
        }
      }
      SetPropertyValueByIndex(e, t2) {
        switch (e) {
          case s:
            this._SetImageOffsetX(t2);
            break;
          case r2:
            this._SetImageOffsetY(t2);
            break;
          case l:
            this._SetImageScaleX(t2);
            break;
          case g2:
            this._SetImageScaleY(t2);
            break;
          case m2:
            this._SetImageAngle(t2);
            break;
          case h2:
            this._SetTileRandomizationEnabled(!!t2);
            break;
          case d2:
            this._SetTileXRandom(t2);
            break;
          case o2:
            this._SetTileYRandom(t2);
            break;
          case _2:
            this._SetTileAngleRandom(t2);
            break;
          case u2:
            this._SetTileBlendMarginX(t2);
            break;
          case R:
            this._SetTileBlendMarginY(t2);
        }
      }
      GetScriptInterfaceClass() {
        return globalThis.ITiledBackgroundInstance;
      }
    }, globalThis.ITiledBackgroundInstance = class extends globalThis.IWorldInstance {
      #e;
      constructor() {
        super(), this.#e = globalThis.IInstance._GetInitInst().GetSdkInstance();
      }
      set imageOffsetX(e) {
        a2.RequireFiniteNumber(e), this.#e._SetImageOffsetX(e);
      }
      get imageOffsetX() {
        return this.#e._GetImageOffsetX();
      }
      set imageOffsetY(e) {
        a2.RequireFiniteNumber(e), this.#e._SetImageOffsetY(e);
      }
      get imageOffsetY() {
        return this.#e._GetImageOffsetY();
      }
      setImageOffset(e, t2) {
        a2.RequireFiniteNumber(e), a2.RequireFiniteNumber(t2);
        const i2 = this.#e;
        i2._SetImageOffsetX(e), i2._SetImageOffsetY(t2);
      }
      getImageOffset() {
        const e = this.#e;
        return [e._GetImageOffsetX(), e._GetImageOffsetY()];
      }
      set imageScaleX(e) {
        a2.RequireFiniteNumber(e), this.#e._SetImageScaleX(e);
      }
      get imageScaleX() {
        return this.#e._GetImageScaleX();
      }
      set imageScaleY(e) {
        a2.RequireFiniteNumber(e), this.#e._SetImageScaleY(e);
      }
      get imageScaleY() {
        return this.#e._GetImageScaleY();
      }
      setImageScale(e, t2) {
        a2.RequireFiniteNumber(e), a2.RequireFiniteNumber(t2);
        const i2 = this.#e;
        i2._SetImageScaleX(e), i2._SetImageScaleY(t2);
      }
      getImageScale() {
        const e = this.#e;
        return [e._GetImageScaleX(), e._GetImageScaleY()];
      }
      set imageAngle(e) {
        a2.RequireFiniteNumber(e), this.#e._SetImageAngle(e);
      }
      get imageAngle() {
        return this.#e._GetImageAngle();
      }
      set imageAngleDegrees(e) {
        a2.RequireFiniteNumber(e), this.#e._SetImageAngle(i.toRadians(e));
      }
      get imageAngleDegrees() {
        return i.toDegrees(this.#e._GetImageAngle());
      }
      get imageWidth() {
        return this.#e.GetCurrentImageInfo().GetWidth();
      }
      get imageHeight() {
        return this.#e.GetCurrentImageInfo().GetHeight();
      }
      getImageSize() {
        const e = this.#e.GetCurrentImageInfo();
        return [e.GetWidth(), e.GetHeight()];
      }
      set enableTileRandomization(e) {
        this.#e._SetTileRandomizationEnabled(!!e);
      }
      get enableTileRandomization() {
        return this.#e._IsTileRandomizationEnabled();
      }
      set tileXRandom(e) {
        a2.RequireFiniteNumber(e), this.#e._SetTileXRandom(e);
      }
      get tileXRandom() {
        return this.#e._GetTileXRandom();
      }
      set tileYRandom(e) {
        a2.RequireFiniteNumber(e), this.#e._SetTileYRandom(e);
      }
      get tileYRandom() {
        return this.#e._GetTileYRandom();
      }
      setTileRandom(e, t2) {
        a2.RequireFiniteNumber(e), a2.RequireFiniteNumber(t2);
        const i2 = this.#e;
        i2._SetTileXRandom(e), i2._SetTileYRandom(t2);
      }
      getTileRandom() {
        const e = this.#e;
        return [e._GetTileXRandom(), e._GetTileYRandom()];
      }
      set tileAngleRandom(e) {
        a2.RequireFiniteNumber(e), this.#e._SetTileAngleRandom(e);
      }
      get tileAngleRandom() {
        return this.#e._GetTileAngleRandom();
      }
      set tileBlendMarginX(e) {
        a2.RequireFiniteNumber(e), this.#e._SetTileBlendMarginX(e);
      }
      get tileBlendMarginX() {
        return this.#e._GetTileBlendMarginX();
      }
      set tileBlendMarginY(e) {
        a2.RequireFiniteNumber(e), this.#e._SetTileBlendMarginY(e);
      }
      get tileBlendMarginY() {
        return this.#e._GetTileBlendMarginY();
      }
      setTileBlendMargin(e, t2) {
        a2.RequireFiniteNumber(e), a2.RequireFiniteNumber(t2);
        const i2 = this.#e;
        i2._SetTileBlendMarginX(e), i2._SetTileBlendMarginY(t2);
      }
      getTileBlendMargin() {
        const e = this.#e;
        return [e._GetTileBlendMarginX(), e._GetTileBlendMarginY()];
      }
      async replaceImage(e) {
        a2.RequireInstanceOf(e, Blob);
        const t2 = this.#e, n2 = t2.GetRuntime(), s2 = i.New(i.ImageInfo);
        s2.LoadDynamicBlobAsset(n2, e), await s2.LoadStaticTexture(n2.GetRenderer(), { sampling: n2.GetSampling(), wrapX: t2.GetSdkType().GetWrapModeX(), wrapY: t2.GetSdkType().GetWrapModeY() }), t2.WasReleased() ? s2.Release() : (t2._ReleaseOwnImage(), t2._ownImageInfo = s2, n2.UpdateRender());
      }
    };
  }
  self.C3.Plugins.TiledBg.Cnds = { OnURLLoaded: () => true, OnURLFailed: () => true, IsTileRandomizationEnabled() {
    return this._IsTileRandomizationEnabled();
  } };
  {
    const T2 = self.C3;
    T2.Plugins.TiledBg.Acts = { SetImageOffsetX(e) {
      this._SetImageOffsetX(e);
    }, SetImageOffsetY(e) {
      this._SetImageOffsetY(e);
    }, SetImageScaleX(e) {
      this._SetImageScaleX(e / 100);
    }, SetImageScaleY(e) {
      this._SetImageScaleY(e / 100);
    }, SetImageAngle(e) {
      this._SetImageAngle(T2.toRadians(e));
    }, SetTileRandomizationEnabled(e) {
      this._SetTileRandomizationEnabled(e);
    }, SetTilePosRandom(e, t2) {
      this._SetTileXRandom(e / 100), this._SetTileYRandom(t2 / 100);
    }, SetTileAngleRandom(e) {
      this._SetTileAngleRandom(e / 100);
    }, SetTileBlendMargin(e, t2) {
      this._SetTileBlendMarginX(e / 100), this._SetTileBlendMarginY(t2 / 100);
    }, SetEffect(e) {
      this.GetWorldInfo().SetBlendMode(e), this._runtime.UpdateRender();
    }, async LoadURL(e, t2) {
      if (this._ownImageInfo && this._ownImageInfo.GetURL() === e) return;
      const i = this._runtime, a2 = T2.New(T2.ImageInfo);
      try {
        if (await a2.LoadDynamicAsset(i, e, true), !a2.IsLoaded()) throw new Error("image failed to load");
        if (this.WasReleased()) return a2.Release(), null;
        if (!await a2.LoadStaticTexture(i.GetRenderer(), { sampling: i.GetSampling(), wrapX: this.GetSdkType().GetWrapModeX(), wrapY: this.GetSdkType().GetWrapModeY() })) return;
      } catch (e2) {
        return console.error("Load image from URL failed: ", e2), void (this.WasReleased() || this.Trigger(T2.Plugins.TiledBg.Cnds.OnURLFailed));
      }
      this.WasReleased() ? a2.Release() : (this._ReleaseOwnImage(), this._ownImageInfo = a2, i.UpdateRender(), await this.TriggerAsync(T2.Plugins.TiledBg.Cnds.OnURLLoaded));
    } };
  }
  {
    const p2 = self.C3;
    p2.Plugins.TiledBg.Exps = { ImageWidth() {
      return this.GetCurrentImageInfo().GetWidth();
    }, ImageHeight() {
      return this.GetCurrentImageInfo().GetHeight();
    }, ImageOffsetX() {
      return this._imageOffsetX;
    }, ImageOffsetY() {
      return this._imageOffsetY;
    }, ImageScaleX() {
      return 100 * this._imageScaleX;
    }, ImageScaleY() {
      return 100 * this._imageScaleY;
    }, ImageAngle() {
      return p2.toDegrees(this._imageAngle);
    }, TileXRandom() {
      return 100 * this._GetTileXRandom();
    }, TileYRandom() {
      return 100 * this._GetTileYRandom();
    }, TileAngleRandom() {
      return 100 * this._GetTileAngleRandom();
    }, TileBlendMarginX() {
      return 100 * this._GetTileBlendMarginX();
    }, TileBlendMarginY() {
      return 100 * this._GetTileBlendMarginY();
    } };
  }
}
var WrapModeToStr2;
{
  {
    const t2 = self.C3;
    t2.Plugins.Tilemap = class extends t2.SDKPluginBase {
      constructor(t3) {
        super(t3);
      }
      Release() {
        super.Release();
      }
    }, t2.Plugins.Tilemap.TILE_FLIPPED_HORIZONTAL = -2147483648, t2.Plugins.Tilemap.TILE_FLIPPED_VERTICAL = 1073741824, t2.Plugins.Tilemap.TILE_FLIPPED_DIAGONAL = 536870912, t2.Plugins.Tilemap.TILE_FLAGS_MASK = 3758096384, t2.Plugins.Tilemap.TILE_ID_MASK = 536870911;
  }
  {
    const e = self.C3, i = e.Plugins.Tilemap.TILE_FLIPPED_HORIZONTAL, s = e.Plugins.Tilemap.TILE_FLIPPED_VERTICAL, h2 = e.Plugins.Tilemap.TILE_FLIPPED_DIAGONAL, l = e.Plugins.Tilemap.TILE_ID_MASK;
    e.Plugins.Tilemap.Type = class extends e.SDKTypeBase {
      constructor(t2) {
        super(t2), this._tilePolys = [], this._areTilePolysCached = false, this._maxTileIndex = 0, this._brushesData = [], this._nameToIndexMap = null;
      }
      Release() {
        this._nameToIndexMap.clear(), this._nameToIndexMap = null, super.Release();
      }
      OnCreate() {
        this.GetImageInfo().LoadAsset(this._runtime);
      }
      LoadTextures(t2) {
        return this.GetImageInfo().LoadStaticTexture(t2, { sampling: this._runtime.GetSampling() });
      }
      ReleaseTextures() {
        this.GetImageInfo().ReleaseTexture();
      }
      OnDynamicTextureLoadComplete() {
        for (const t2 of this.GetObjectClass().instancesIncludingPendingCreate()) t2.GetSdkInstance()._OnDynamicTextureLoadComplete();
      }
      LoadTilemapData(t2, e2, i2) {
        this._maxTileIndex = e2;
        for (const e3 of t2) if (e3) {
          const t3 = e3[0], i3 = !!e3[1];
          this._tilePolys.push({ poly: t3, use: i3, flipmap: [[[null, null], [null, null]], [[null, null], [null, null]]] });
        } else this._tilePolys.push(null);
        for (const t3 of i2) {
          const e3 = t3[0], i3 = t3[1], s2 = t3[2];
          this._brushesData.push({ name: e3, type: i3, tileData: s2 });
        }
      }
      _ForceCacheOfTileCollisionPolys(t2, e2) {
        this._areTilePolysCached = false, this._MaybeCacheTileCollisionPolys(t2, e2);
      }
      _MaybeCacheTileCollisionPolys(t2, e2) {
        if (!this._areTilePolysCached) {
          this._areTilePolysCached = true;
          for (let i2 = 0, s2 = this._tilePolys.length; i2 < s2; ++i2) this._tilePolys[i2] && (this._CacheTilePoly(i2, t2, e2, false, false, false), this._CacheTilePoly(i2, t2, e2, false, false, true), this._CacheTilePoly(i2, t2, e2, false, true, false), this._CacheTilePoly(i2, t2, e2, false, true, true), this._CacheTilePoly(i2, t2, e2, true, false, false), this._CacheTilePoly(i2, t2, e2, true, false, true), this._CacheTilePoly(i2, t2, e2, true, true, false), this._CacheTilePoly(i2, t2, e2, true, true, true));
        }
      }
      _CacheTilePoly(t2, i2, s2, h3, l2, a2) {
        if (t2 < 0 || t2 >= this._tilePolys.length) return;
        const n = this._tilePolys[t2];
        if (!n) return;
        const r2 = e.New(e.CollisionPoly, n.poly, n.use);
        r2.transform(i2, s2, 0), a2 && r2.diag(), h3 && r2.mirror(i2 / 2), l2 && r2.flip(s2 / 2), n.flipmap[h3 ? 1 : 0][l2 ? 1 : 0][a2 ? 1 : 0] = null, n.flipmap[h3 ? 1 : 0][l2 ? 1 : 0][a2 ? 1 : 0] = r2;
      }
      GetTilePoly(t2) {
        if (-1 === t2) return null;
        const e2 = t2 & l;
        if (e2 < 0 || e2 >= this._tilePolys.length) return null;
        const a2 = this._tilePolys[e2];
        if (!a2) return null;
        const n = t2 & i ? 1 : 0, r2 = t2 & s ? 1 : 0, o2 = t2 & h2 ? 1 : 0;
        return a2.flipmap[n][r2][o2];
      }
      IsTilePolyEnabled(t2) {
        return !t2 || t2.IsEnabled();
      }
      GetMaxTileIndex() {
        return this._maxTileIndex;
      }
      GetBrushData(t2) {
        this._nameToIndexMap || (this._nameToIndexMap = /* @__PURE__ */ new Map());
        const e2 = this._nameToIndexMap.get(t2);
        if ("number" == typeof e2 && e2 >= 0) return this._brushesData[e2];
        for (let e3 = 0; e3 < this._brushesData.length; e3++) if (this._brushesData[e3].name === t2) return this._nameToIndexMap.set(t2, e3), this._brushesData[e3];
      }
    };
  }
  {
    let RunLengthDecode = function(t2) {
      const e = [], i = t2.split(",");
      for (let t3 = 0, s = i.length; t3 < s; ++t3) {
        const s2 = i[t3], h2 = s2.indexOf("x");
        if (h2 > -1) {
          let t4 = parseInt(s2.substring(0, h2), 10);
          const i2 = s2.substring(h2 + 1);
          let l = parseInt(i2, 10);
          for (i2.includes("h") && (l |= c2), i2.includes("v") && (l |= T2), i2.includes("d") && (l |= f2); t4 > 0; --t4) e.push(l);
        } else {
          let t4 = parseInt(s2, 10);
          s2.includes("h") && (t4 |= c2), s2.includes("v") && (t4 |= T2), s2.includes("d") && (t4 |= f2), e.push(t4);
        }
      }
      return e;
    };
    RunLengthDecode2 = RunLengthDecode;
    const a2 = self.C3, n = self.C3X, r2 = 0, o2 = 1, _2 = 2, u2 = 3, d2 = 4, g2 = 5, p2 = 6, c2 = a2.Plugins.Tilemap.TILE_FLIPPED_HORIZONTAL, T2 = a2.Plugins.Tilemap.TILE_FLIPPED_VERTICAL, f2 = a2.Plugins.Tilemap.TILE_FLIPPED_DIAGONAL, m2 = a2.Plugins.Tilemap.TILE_FLAGS_MASK, M2 = a2.Plugins.Tilemap.TILE_ID_MASK, G = a2.New(a2.Rect), I2 = a2.New(a2.Rect), y2 = a2.New(a2.Rect);
    a2.Plugins.Tilemap.Instance = class extends a2.SDKWorldInstanceBase {
      constructor(t2, e) {
        super(t2);
        const i = this.GetWorldInfo();
        this._tileWidth = 32, this._tileHeight = 32, this._tileXoffset = 0, this._tileYoffset = 0, this._tileXspacing = 0, this._tileYspacing = 0, this._mapWidth = 0, this._mapHeight = 0, this._lastWidth = i.GetWidth(), this._lastHeight = i.GetHeight(), this._cellWidth = 0, this._cellHeight = 0, this._tileCells = [], this._tileTexQuads = /* @__PURE__ */ new Map(), this._isAnyQuadMapChanged = true, this._ownImageInfo = null, e && (i.SetVisible(e[r2]), this._tileWidth = Math.max(e[o2], 1), this._tileHeight = Math.max(e[_2], 1), this._tileXoffset = e[u2], this._tileYoffset = e[d2], this._tileXspacing = e[g2], this._tileYspacing = e[p2]), this._cellWidth = Math.ceil(this._runtime.GetOriginalViewportWidth() / this._tileWidth), this._cellHeight = Math.ceil(this._runtime.GetOriginalViewportHeight() / this._tileHeight), this._sdkType._MaybeCacheTileCollisionPolys(this._tileWidth, this._tileHeight), this._brushManager = null;
      }
      Release() {
        this._ReleaseOwnImage(), a2.clearArray(this._tileCells), this._tileCells = null, this._tileTexQuads.clear(), this._tileTexQuads = null, super.Release();
      }
      _ReleaseOwnImage() {
        this._ownImageInfo && (this._ownImageInfo.Release(), this._ownImageInfo = null);
      }
      LoadTilemapData(t2, e, i) {
        this._mapWidth = e, this._mapHeight = i, this._MaybeResizeTilemap(true), this.SetTilesFromRLECSV(t2), this._MaybeBuildAllQuadMap();
      }
      _MaybeResizeTilemap(t2) {
        const [e, i] = this.GetMapDisplaySize();
        if (e <= this._mapWidth && i <= this._mapHeight && !t2) return;
        let s = 0, h2 = 0;
        t2 ? (s = Math.ceil(this._mapHeight / this._cellHeight), h2 = Math.ceil(this._mapWidth / this._cellWidth)) : (s = this._tileCells.length, h2 = Math.ceil(this._mapWidth / this._cellWidth), i > this._mapHeight && (this._mapHeight = i, s = Math.ceil(this._mapHeight / this._cellHeight)), e > this._mapWidth && (this._mapWidth = e, h2 = Math.ceil(this._mapWidth / this._cellWidth)), this._SetAllQuadMapChanged(), this._SetPhysicsChanged(), this._runtime.UpdateRender());
        const l = this._tileCells;
        if (l.length < s) for (let t3 = l.length; t3 < s; ++t3) l.push([]);
        for (let t3 = 0; t3 < s; ++t3) {
          const e2 = l[t3];
          for (let i2 = e2.length; i2 < h2; ++i2) e2.push(a2.New(a2.Plugins.Tilemap.TileCell, this, i2, t3));
        }
      }
      SetTilesFromRLECSV(t2) {
        const e = RunLengthDecode(t2);
        let i = 0;
        const s = this._mapWidth, h2 = this._cellWidth, l = this._cellHeight;
        for (let t3 = 0, a3 = this._mapHeight; t3 < a3; ++t3) for (let a4 = 0; a4 < s; ++a4) {
          const s2 = e[i++], n2 = this.GetCellAt(a4, t3);
          n2 && n2.SetTileAt(a4 % h2, t3 % l, s2);
        }
      }
      GetTilesAsRLECSV() {
        let t2 = "";
        if (this._mapWidth <= 0 || this._mapHeight <= 0) return t2;
        let e = 1, i = this.GetTileAt(0, 0);
        const [s, h2] = this.GetMapDisplaySize();
        let l = -1, a3 = false, n2 = false, r3 = false;
        for (let o3 = 0; o3 < h2; ++o3) for (let h3 = 0 === o3 ? 1 : 0; h3 < s; ++h3) {
          const s2 = this.GetTileAt(h3, o3);
          s2 === i ? ++e : (-1 === i ? (l = -1, a3 = false, n2 = false, r3 = false) : (l = i & M2, a3 = 0 !== (i & c2), n2 = 0 !== (i & T2), r3 = 0 !== (i & f2)), t2 += 1 === e ? "" + l : e + "x" + l, a3 && (t2 += "h"), n2 && (t2 += "v"), r3 && (t2 += "d"), t2 += ",", e = 1, i = s2);
        }
        return -1 === i ? (l = -1, a3 = false, n2 = false, r3 = false) : (l = i & M2, a3 = 0 !== (i & c2), n2 = 0 !== (i & T2), r3 = 0 !== (i & f2)), t2 += 1 === e ? "" + l : e + "x" + l, a3 && (t2 += "h"), n2 && (t2 += "v"), r3 && (t2 += "d"), t2;
      }
      _SetAllQuadMapChanged() {
        const t2 = this._tileCells;
        for (let e = 0, i = t2.length; e < i; ++e) {
          const i2 = t2[e];
          for (let t3 = 0, e2 = i2.length; t3 < e2; ++t3) i2[t3]._SetQuadMapChanged();
        }
        this._isAnyQuadMapChanged = true;
      }
      _MaybeBuildAllQuadMap() {
        if (!this._isAnyQuadMapChanged) return;
        this._isAnyQuadMapChanged = false;
        const t2 = this._tileCells;
        for (let e = 0, i = t2.length; e < i; ++e) {
          const i2 = t2[e];
          for (let t3 = 0, e2 = i2.length; t3 < e2; ++t3) i2[t3].MaybeBuildQuadMap();
        }
      }
      SetTileChanged() {
        this._isAnyQuadMapChanged = true, this._SetPhysicsChanged(), this._runtime.UpdateRender();
      }
      _SetPhysicsChanged() {
        this.GetWorldInfo().SetPhysicsBodyChanged(true);
      }
      GetCellAt(t2, e) {
        if (t2 < 0 || e < 0) return null;
        const i = Math.floor(e / this._cellHeight);
        if (i >= this._tileCells.length) return null;
        const s = this._tileCells[i], h2 = Math.floor(t2 / this._cellWidth);
        return h2 >= s.length ? null : s[h2];
      }
      GetCellAtIndex(t2, e) {
        if (t2 < 0 || e < 0 || e >= this._tileCells.length) return null;
        const i = this._tileCells[e];
        return t2 >= i.length ? null : i[t2];
      }
      GetTileAt(t2, e) {
        if (t2 = Math.floor(t2), e = Math.floor(e), t2 < 0 || e < 0 || t2 >= this._mapWidth || e >= this._mapHeight) return -1;
        const i = this.GetCellAt(t2, e);
        return i ? i.GetTilesArr()[e % this._cellHeight][t2 % this._cellWidth] : -1;
      }
      SetTileAt(t2, e, i) {
        if (t2 = Math.floor(t2), e = Math.floor(e), t2 < 0 || e < 0 || t2 >= this._mapWidth || e >= this._mapHeight) return;
        if (-1 !== i && (i & M2) > this.GetMaxTileIndex()) return;
        const s = this.GetCellAt(t2, e);
        s && s.SetTileAt(t2 % this._cellWidth, e % this._cellHeight, i);
      }
      GetMaxTileIndex() {
        return this._sdkType.GetMaxTileIndex();
      }
      WorldToCellX(t2) {
        return Math.floor((t2 - this.GetWorldInfo().GetX()) / (this._cellWidth * this._tileWidth));
      }
      WorldToCellY(t2) {
        return Math.floor((t2 - this.GetWorldInfo().GetY()) / (this._cellHeight * this._tileHeight));
      }
      WorldToTileX(t2) {
        return Math.floor((t2 - this.GetWorldInfo().GetX()) / this._tileWidth);
      }
      WorldToTileY(t2) {
        return Math.floor((t2 - this.GetWorldInfo().GetY()) / this._tileHeight);
      }
      GetMapWidth() {
        return this._mapWidth;
      }
      GetMapHeight() {
        return this._mapHeight;
      }
      GetMapDisplayWidth() {
        return Math.floor(this.GetWorldInfo().GetWidth() / this.GetTileWidth());
      }
      GetMapDisplayHeight() {
        return Math.floor(this.GetWorldInfo().GetHeight() / this.GetTileHeight());
      }
      GetMapDisplaySize() {
        const t2 = this.GetWorldInfo();
        return [Math.floor(t2.GetWidth() / this.GetTileWidth()), Math.floor(t2.GetHeight() / this.GetTileHeight())];
      }
      GetTileWidth() {
        return this._tileWidth;
      }
      GetTileHeight() {
        return this._tileHeight;
      }
      GetCellWidth() {
        return this._cellWidth;
      }
      GetCellHeight() {
        return this._cellHeight;
      }
      GetCollisionRectCandidates(t2, e) {
        const i = this.WorldToCellX(t2.getLeft()), s = this.WorldToCellY(t2.getTop()), h2 = this.WorldToCellX(t2.getRight()), l = this.WorldToCellY(t2.getBottom());
        for (let t3 = i; t3 <= h2; ++t3) for (let i2 = s; i2 <= l; ++i2) {
          const s2 = this.GetCellAtIndex(t3, i2);
          s2 && (s2.MaybeBuildQuadMap(), a2.appendArray(e, s2.GetCollisionRects()));
        }
      }
      TestPointOverlapTile(t2, e) {
        const i = this.WorldToTileX(t2), s = this.WorldToTileY(e), h2 = this.GetTileAt(i, s);
        if (-1 === h2) return false;
        const l = this._sdkType.GetTilePoly(h2);
        if (!l) return true;
        if (!this._sdkType.IsTilePolyEnabled(l)) return false;
        const a3 = this.GetWorldInfo();
        return t2 -= Math.floor((t2 - a3.GetX()) / this._tileWidth) * this._tileWidth + a3.GetX(), e -= Math.floor((e - a3.GetY()) / this._tileHeight) * this._tileHeight + a3.GetY(), l.containsPoint(t2, e);
      }
      GetAllCollisionRects(t2) {
        const e = this._tileCells;
        for (let i = 0, s = e.length; i < s; ++i) {
          const s2 = e[i];
          for (let e2 = 0, i2 = s2.length; e2 < i2; ++e2) {
            const i3 = s2[e2];
            i3.MaybeBuildQuadMap(), a2.appendArray(t2, i3.GetCollisionRects());
          }
        }
      }
      GetCurrentImageInfo() {
        return this._ownImageInfo || this._objectClass.GetImageInfo();
      }
      GetTileUvQuad(t2) {
        const e = this._tileTexQuads, i = e.get(t2);
        if (i) return i;
        const s = t2 & M2, h2 = 0 !== (t2 & c2), l = 0 !== (t2 & T2), n2 = 0 !== (t2 & f2), r3 = this.GetCurrentImageInfo(), o3 = r3.GetWidth(), _3 = this._tileWidth, u3 = this._tileXoffset, d3 = this._tileXspacing, g3 = Math.floor((o3 - u3) / (_3 + d3) * _3) + d3, p3 = Math.floor(g3 / _3), m3 = s % p3, I3 = Math.floor(s / p3), y3 = r3.GetOffsetX() + this._tileXoffset + (this._tileWidth + this._tileXspacing) * m3, W2 = r3.GetOffsetY() + this._tileYoffset + (this._tileHeight + this._tileYspacing) * I3;
        G.setWH(y3, W2, this._tileWidth, this._tileHeight), G.divide(r3.GetSheetWidth(), r3.GetSheetHeight());
        const C4 = a2.New(a2.Quad);
        return C4.setFromRect(G), n2 && C4.diag(), h2 && C4.mirror(), l && C4.flip(), C4.offset(m3, I3), e.set(t2, C4), C4;
      }
      _OnDynamicTextureLoadComplete() {
        this._tileTexQuads.clear(), this._SetAllQuadMapChanged();
      }
      Draw(t2) {
        const e = this.GetCurrentImageInfo(), i = e.GetTexture();
        if (!i) return;
        G.copy(e.GetTexRect()), G.offsetLeft(this._tileXoffset / i.GetWidth()), G.offsetTop(this._tileYoffset / i.GetHeight()), t2.SetTilemapFillMode(), t2.SetTilemapInfo(G, i.GetWidth(), i.GetHeight(), this._tileWidth, this._tileHeight, this._tileXspacing, this._tileYspacing), t2.SetTexture(i);
        const s = this.GetWorldInfo(), h2 = s.GetLayer();
        s.GetWidth() === this._lastWidth && s.GetHeight() === this._lastHeight || (this._SetPhysicsChanged(), this._SetAllQuadMapChanged(), this._lastWidth = s.GetWidth(), this._lastHeight = s.GetHeight());
        let l = s.GetX(), a3 = s.GetY();
        this._runtime.IsPixelRoundingEnabled() && (l = Math.round(l), a3 = Math.round(a3));
        const n2 = this._cellWidth * this._tileWidth, r3 = this._cellHeight * this._tileHeight, o3 = s.GetTotalZElevation(), _3 = I2;
        if (h2.Has3DCamera()) {
          _3.set(-1 / 0, -1 / 0, 1 / 0, 1 / 0);
          const e2 = y2, i2 = h2._GetViewFrustum();
          for (const s2 of this._tileCells) for (const h3 of s2) h3.GetLayoutRect(e2), i2.ContainsAABB(e2.getLeft(), e2.getTop(), o3, e2.getRight(), e2.getBottom(), o3) && (h3.MaybeBuildQuadMap(), h3.Draw(t2, _3, l, a3));
        } else {
          h2.GetViewportForZ(o3, _3);
          const e2 = Math.floor((_3.getLeft() - l) / n2), i2 = Math.floor((_3.getRight() - l) / n2), s2 = Math.floor((_3.getTop() - a3) / r3), u3 = Math.floor((_3.getBottom() - a3) / r3);
          for (let h3 = e2; h3 <= i2; ++h3) for (let e3 = s2; e3 <= u3; ++e3) {
            const i3 = this.GetCellAtIndex(h3, e3);
            i3 && (i3.MaybeBuildQuadMap(), i3.Draw(t2, _3, l, a3));
          }
        }
      }
      SaveToJson() {
        this._MaybeResizeTilemap();
        const [t2, e] = this.GetMapDisplaySize();
        return { "tw": this._tileWidth, "th": this._tileHeight, "tox": this._tileXoffset, "toy": this._tileYoffset, "tsx": this._tileXspacing, "tsy": this._tileYspacing, "w": t2, "h": e, "d": this.GetTilesAsRLECSV() };
      }
      LoadFromJson(t2) {
        this._tileWidth = t2["tw"], this._tileHeight = t2["th"], this._tileXoffset = t2["tox"], this._tileYoffset = t2["toy"], this._tileXspacing = t2["tsx"], this._tileYspacing = t2["tsy"], this._mapWidth = t2["w"], this._mapHeight = t2["h"], this._MaybeResizeTilemap(true), this.SetTilesFromRLECSV(t2["d"]), this._SetPhysicsChanged(), this._SetAllQuadMapChanged();
      }
      GetAsJsonString() {
        this._MaybeResizeTilemap();
        const [t2, e] = this.GetMapDisplaySize();
        return JSON.stringify({ "c2tilemap": true, "width": t2, "height": e, "data": this.GetTilesAsRLECSV() });
      }
      StateComboToFlags(t2) {
        switch (t2) {
          case 0:
          default:
            return 0;
          case 1:
            return c2;
          case 2:
            return T2;
          case 3:
            return c2 | f2;
          case 4:
            return c2 | T2;
          case 5:
            return T2 | f2;
          case 6:
            return c2 | T2 | f2;
          case 7:
            return f2;
        }
      }
      GetPropertyValueByIndex(t2) {
        switch (t2) {
          case o2:
            return this._tileWidth;
          case _2:
            return this._tileHeight;
          case u2:
            return this._tileXoffset;
          case d2:
            return this._tileYoffset;
          case g2:
            return this._tileXspacing;
          case p2:
            return this._tileYspacing;
        }
      }
      SetPropertyValueByIndex(t2, e) {
        switch (t2) {
          case o2:
            if (this._tileWidth === e) return;
            this._tileWidth = Math.max(e, 1), this._cellWidth = Math.ceil(this._runtime.GetOriginalViewportWidth() / this._tileWidth), this._sdkType._ForceCacheOfTileCollisionPolys(), this._UpdateQuadMaps();
            break;
          case _2:
            if (this._tileHeight === e) return;
            this._tileHeight = Math.max(e, 1), this._cellHeight = Math.ceil(this._runtime.GetOriginalViewportHeight() / this._tileHeight), this._sdkType._ForceCacheOfTileCollisionPolys(), this._UpdateQuadMaps();
            break;
          case u2:
            if (this._tileXoffset === e) return;
            this._tileXoffset = e, this._UpdateQuadMaps();
            break;
          case d2:
            if (this._tileYoffset === e) return;
            this._tileYoffset = e, this._UpdateQuadMaps();
            break;
          case g2:
            if (this._tileXspacing === e) return;
            this._tileXspacing = e, this._UpdateQuadMaps();
            break;
          case p2:
            if (this._tileYspacing === e) return;
            this._tileYspacing = e, this._UpdateQuadMaps();
        }
      }
      _UpdateQuadMaps() {
        this._tileTexQuads.clear(), this._SetAllQuadMapChanged(), this._MaybeBuildAllQuadMap();
      }
      GetScriptInterfaceClass() {
        return C2;
      }
    };
    const W = /* @__PURE__ */ new WeakMap(), C2 = self.ITilemapInstance = class extends self.IWorldInstance {
      constructor() {
        super(), W.set(this, self.IInstance._GetInitInst().GetSdkInstance());
      }
      get mapWidth() {
        return W.get(this).GetMapWidth();
      }
      get mapHeight() {
        return W.get(this).GetMapHeight();
      }
      getMapSize() {
        const t2 = W.get(this);
        return [t2.GetMapWidth(), t2.GetMapHeight()];
      }
      get mapDisplayWidth() {
        return W.get(this).GetMapDisplayWidth();
      }
      get mapDisplayHeight() {
        return W.get(this).GetMapDisplayHeight();
      }
      getMapDisplaySize() {
        const t2 = W.get(this);
        return [t2.GetMapDisplayWidth(), t2.GetMapDisplayHeight()];
      }
      get tileWidth() {
        return W.get(this).GetTileWidth();
      }
      get tileHeight() {
        return W.get(this).GetTileHeight();
      }
      getTileSize() {
        const t2 = W.get(this);
        return [t2.GetTileWidth(), t2.GetTileHeight()];
      }
      getTileAt(t2, e) {
        return n.RequireFiniteNumber(t2), n.RequireFiniteNumber(e), W.get(this).GetTileAt(t2, e);
      }
      setTileAt(t2, e, i) {
        n.RequireFiniteNumber(t2), n.RequireFiniteNumber(e), n.RequireFiniteNumber(i);
        const s = W.get(this);
        s._MaybeResizeTilemap(), s.SetTileAt(t2, e, i);
      }
      async replaceImage(t2) {
        n.RequireInstanceOf(t2, Blob);
        const e = W.get(this), i = e.GetRuntime(), s = a2.New(a2.ImageInfo);
        s.LoadDynamicBlobAsset(i, t2), await s.LoadStaticTexture(i.GetRenderer(), { sampling: i.GetSampling() }), e.WasReleased() ? s.Release() : (e._ReleaseOwnImage(), e._ownImageInfo = s, e._tileTexQuads.clear(), e._SetAllQuadMapChanged(), i.UpdateRender());
      }
    };
    C2.TILE_FLIPPED_HORIZONTAL = c2, C2.TILE_FLIPPED_VERTICAL = T2, C2.TILE_FLIPPED_DIAGONAL = f2, C2.TILE_FLAGS_MASK = m2, C2.TILE_ID_MASK = M2;
  }
  {
    const P2 = self.C3, S2 = P2.Plugins.Tilemap.TILE_FLAGS_MASK, A = P2.Plugins.Tilemap.TILE_ID_MASK;
    P2.Plugins.Tilemap.Cnds = { CompareTileAt(t2, e, i, s) {
      let h2 = this.GetTileAt(t2, e);
      return -1 !== h2 && (h2 &= A), P2.compare(h2, i, s);
    }, CompareTileStateAt(t2, e, i) {
      const s = this.GetTileAt(t2, e);
      let h2 = 0;
      return -1 !== s && (h2 = s & S2), h2 === this.StateComboToFlags(i);
    }, OnURLLoaded: () => true, OnURLFailed: () => true, BrushExists(t2) {
      return this._brushManager || (this._brushManager = new P2.Plugins.Tilemap.BrushManager(this, this._sdkType)), this._brushManager.BrushExists(t2);
    } };
  }
  {
    const b2 = self.C3, L = b2.Plugins.Tilemap.TILE_ID_MASK;
    b2.Plugins.Tilemap.Acts = { EraseTile(t2, e) {
      this._MaybeResizeTilemap(), this.SetTileAt(t2, e, -1);
    }, SetTile(t2, e, i, s) {
      this._MaybeResizeTilemap(), this.SetTileAt(t2, e, i & L | this.StateComboToFlags(s));
    }, SetTileState(t2, e, i) {
      const s = this.GetTileAt(t2, e);
      -1 !== s && (this._MaybeResizeTilemap(), this.SetTileAt(t2, e, s & L | this.StateComboToFlags(i)));
    }, EraseTileRange(t2, e, i, s) {
      const h2 = Math.floor(Math.max(t2, 0)), l = Math.floor(Math.max(e, 0)), a2 = Math.floor(Math.min(t2 + i, this._mapWidth)), n = Math.floor(Math.min(e + s, this._mapHeight));
      for (let t3 = l; t3 < n; ++t3) for (let e2 = h2; e2 < a2; ++e2) this.SetTileAt(e2, t3, -1);
    }, SetTileRange(t2, e, i, s, h2, l) {
      this._MaybeResizeTilemap();
      const a2 = Math.floor(Math.max(t2, 0)), n = Math.floor(Math.max(e, 0)), r2 = Math.floor(Math.min(t2 + i, this._mapWidth)), o2 = Math.floor(Math.min(e + s, this._mapHeight)), _2 = h2 & L | this.StateComboToFlags(l);
      for (let t3 = n; t3 < o2; ++t3) for (let e2 = a2; e2 < r2; ++e2) this.SetTileAt(e2, t3, _2);
    }, SetTileStateRange(t2, e, i, s, h2) {
      this._MaybeResizeTilemap();
      const l = Math.floor(Math.max(t2, 0)), a2 = Math.floor(Math.max(e, 0)), n = Math.floor(Math.min(t2 + i, this._mapWidth)), r2 = Math.floor(Math.min(e + s, this._mapHeight)), o2 = this.StateComboToFlags(h2);
      for (let t3 = a2; t3 < r2; ++t3) for (let e2 = l; e2 < n; ++e2) {
        const i2 = this.GetTileAt(e2, t3);
        -1 !== i2 && this.SetTileAt(e2, t3, i2 & L | o2);
      }
    }, LoadFromJSON(t2) {
      let e = null;
      try {
        e = JSON.parse(t2);
      } catch (t3) {
        return void console.error("[Construct] Failed to parse tilemap JSON: ", t3);
      }
      e["c2tilemap"] ? (this._mapWidth = e["width"], this._mapHeight = e["height"], this._MaybeResizeTilemap(true), this.SetTilesFromRLECSV(e["data"]), this._SetAllQuadMapChanged(), this._SetPhysicsChanged()) : console.error("[Construct] Unrecognized JSON data format");
    }, JSONDownload(t2) {
      const e = URL.createObjectURL(new Blob([this.GetAsJsonString()], { type: "application/json" }));
      this._runtime.InvokeDownload(e, t2);
    }, async LoadURL(t2, e) {
      if (this._ownImageInfo && this._ownImageInfo.GetURL() === t2) return;
      const i = this._runtime, s = b2.New(b2.ImageInfo);
      try {
        if (await s.LoadDynamicAsset(i, t2), !s.IsLoaded()) throw new Error("image failed to load");
        if (this.WasReleased()) return s.Release(), null;
        if (!await s.LoadStaticTexture(i.GetRenderer(), { sampling: i.GetSampling() })) return;
      } catch (t3) {
        return console.error("Load image from URL failed: ", t3), void (this.WasReleased() || this.Trigger(b2.Plugins.Tilemap.Cnds.OnURLFailed));
      }
      this.WasReleased() ? s.Release() : (this._ReleaseOwnImage(), this._ownImageInfo = s, i.UpdateRender(), this._tileTexQuads.clear(), this._SetAllQuadMapChanged(), await this.TriggerAsync(b2.Plugins.Tilemap.Cnds.OnURLLoaded));
    }, SetEffect(t2) {
      t2 >= 2 && t2++, this.GetWorldInfo().SetBlendMode(t2), this._runtime.UpdateRender();
    }, SetTileWithBrush(t2, e, i) {
      if (this._MaybeResizeTilemap(), this._brushManager || (this._brushManager = new b2.Plugins.Tilemap.BrushManager(this, this._sdkType)), this._brushManager.BrushExists(i)) switch (this._brushManager.GetBrushType(i)) {
        case 0:
        case 1:
          this._brushManager.SetAutoTile(t2, e, i);
          break;
        case 2:
          this._brushManager.SetPatchTile(t2, e, i);
      }
    }, SetTileWithPatchBrush(t2, e, i, s, h2, l, a2) {
      if (this._MaybeResizeTilemap(), this._brushManager || (this._brushManager = new b2.Plugins.Tilemap.BrushManager(this, this._sdkType)), this._brushManager.BrushExists(i) && 2 === this._brushManager.GetBrushType(i)) this._brushManager.SetPatchTile(t2, e, i, s, h2, l, a2);
    }, EraseTileWithBrush(t2, e, i) {
      if (this._MaybeResizeTilemap(), this._brushManager || (this._brushManager = new b2.Plugins.Tilemap.BrushManager(this, this._sdkType)), this._brushManager.BrushExists(i)) switch (this._brushManager.GetBrushType(i)) {
        case 0:
        case 1:
          this._brushManager.EraseAutoTile(t2, e, i);
          break;
        case 2:
          this._brushManager.ErasePatchTile(t2, e, i);
      }
    }, EraseTileWithPatchBrush(t2, e, i, s, h2, l) {
      if (this._MaybeResizeTilemap(), this._brushManager || (this._brushManager = new b2.Plugins.Tilemap.BrushManager(this, this._sdkType)), this._brushManager.BrushExists(i) && 2 === this._brushManager.GetBrushType(i)) this._brushManager.ErasePatchTile(t2, e, i, s, h2, l);
    }, SetTileWithPatchBrushByName(t2, e, i, s, h2, l, a2) {
      b2.Plugins.Tilemap.Acts.SetTileWithPatchBrush.call(this, t2, e, i, s, h2, l, a2);
    }, EraseTileWithPatchBrushByName(t2, e, i, s, h2, l) {
      b2.Plugins.Tilemap.Acts.EraseTileWithPatchBrush.call(this, t2, e, i, s, h2, l);
    }, SetTileWithBrushByName(t2, e, i) {
      b2.Plugins.Tilemap.Acts.SetTileWithBrush.call(this, t2, e, i);
    }, EraseTileWithBrushByName(t2, e, i) {
      b2.Plugins.Tilemap.Acts.EraseTileWithBrush.call(this, t2, e, i);
    } };
  }
  {
    const H = self.C3, R = H.Plugins.Tilemap.TILE_ID_MASK;
    H.Plugins.Tilemap.Exps = { TileAt(t2, e) {
      const i = this.GetTileAt(t2, e);
      return -1 === i ? -1 : i & R;
    }, PositionToTileX(t2) {
      return this.WorldToTileX(t2);
    }, PositionToTileY(t2) {
      return this.WorldToTileY(t2);
    }, TileToPositionX(t2) {
      return t2 * this._tileWidth + this.GetWorldInfo().GetX() + this._tileWidth / 2;
    }, TileToPositionY(t2) {
      return t2 * this._tileHeight + this.GetWorldInfo().GetY() + this._tileHeight / 2;
    }, SnapX(t2) {
      const e = this.GetWorldInfo().GetX();
      return Math.floor((t2 - e) / this._tileWidth) * this._tileWidth + e + this._tileWidth / 2;
    }, SnapY(t2) {
      const e = this.GetWorldInfo().GetY();
      return Math.floor((t2 - e) / this._tileHeight) * this._tileHeight + e + this._tileHeight / 2;
    }, TilesJSON() {
      return this.GetAsJsonString();
    }, TileWidth() {
      return this.GetTileWidth();
    }, TileHeight() {
      return this.GetTileHeight();
    }, MapDisplayWidth() {
      return this.GetMapDisplayWidth();
    }, MapDisplayHeight() {
      return this.GetMapDisplayHeight();
    }, BrushWidth(t2) {
      return this._brushManager || (this._brushManager = new H.Plugins.Tilemap.BrushManager(this, this._sdkType)), this._brushManager.BrushExists(t2) && 2 === this._brushManager.GetBrushType(t2) ? this._brushManager.GetBrushWidth(t2) : 0;
    }, BrushHeight(t2) {
      return this._brushManager || (this._brushManager = new H.Plugins.Tilemap.BrushManager(this, this._sdkType)), this._brushManager.BrushExists(t2) && 2 === this._brushManager.GetBrushType(t2) ? this._brushManager.GetBrushHeight(t2) : 0;
    } };
  }
}
var RunLengthDecode2;
{
  const C32 = self.C3, TILE_FLIPPED_HORIZONTAL = C32.Plugins.Tilemap.TILE_FLIPPED_HORIZONTAL, TILE_FLIPPED_VERTICAL = C32.Plugins.Tilemap.TILE_FLIPPED_VERTICAL, TILE_FLIPPED_DIAGONAL = C32.Plugins.Tilemap.TILE_FLIPPED_DIAGONAL, TILE_ID_MASK = C32.Plugins.Tilemap.TILE_ID_MASK, tempRect = C32.New(C32.Rect), tempQuad = C32.New(C32.Quad);
  C32.Plugins.Tilemap.TileQuad = class extends C32.DefendedBase {
    constructor() {
      super(), this._id = -1, this._tileId = -1, this._isHorizFlip = false, this._isVertFlip = false, this._isDiagFlip = false, this._rc = C32.New(C32.Rect), this._uv = null;
    }
    Update(i, t2, e, s, _2, I2, L, T2) {
      this._id = i, this._tileId = i & TILE_ID_MASK, this._isHorizFlip = 0 !== (i & TILE_FLIPPED_HORIZONTAL), this._isVertFlip = 0 !== (i & TILE_FLIPPED_VERTICAL), this._isDiagFlip = 0 !== (i & TILE_FLIPPED_DIAGONAL), this._rc.setWH(s * t2 + I2, _2 * e + L, t2, e), this._uv = T2.GetTileUvQuad(this._id);
    }
    Draw(i, t2, e, s, _2) {
      tempRect.copy(this._rc), tempRect.offset(e, s), tempRect.intersectsRect(t2) && (tempQuad.setFromRect(tempRect), i.Quad4(tempQuad, this._uv));
    }
  };
}
{
  const C32 = self.C3;
  C32.Plugins.Tilemap.TileCollisionRect = class extends C32.DefendedBase {
    constructor() {
      super(), this._id = -1, this._poly = null, this._rc = C32.New(C32.Rect);
    }
    Update(t2, e, s, i, l, r2, h2, c2) {
      this._id = t2, this._poly = e, this._rc.setWH(l * s + h2, r2 * i + c2, s, i);
    }
    ExtendRight(t2) {
      this._rc.setRight(this._rc.getRight() + t2);
    }
    GetTileId() {
      return this._id;
    }
    HasPoly() {
      return !!this._poly;
    }
    GetPoly() {
      return this._poly;
    }
    GetRect() {
      return this._rc;
    }
  };
}
{
  const C32 = self.C3, TILE_ID_MASK = C32.Plugins.Tilemap.TILE_ID_MASK;
  C32.Plugins.Tilemap.TileCell = class extends C32.DefendedBase {
    constructor(t2, e, i) {
      super();
      const l = t2.GetCellWidth(), s = t2.GetCellHeight();
      this._sdkInst = t2, this._x = e, this._y = i, this._left = this._x * l * t2.GetTileWidth(), this._top = this._y * s * t2.GetTileHeight(), this._tiles = [], this._quads = [], this._collisionRects = [], this._isQuadMapValid = false;
      for (let t3 = 0; t3 < s; ++t3) {
        const t4 = new Int32Array(l);
        t4.fill(-1), this._tiles.push(t4);
      }
    }
    Clear() {
      const t2 = this._sdkInst.GetCellWidth(), e = this._sdkInst.GetCellHeight(), i = this._tiles;
      if (i.length < e) for (let l = i.length; l < e; ++l) i.push(new Int32Array(t2));
      else i.length > e && C32.truncateArray(i, e);
      for (let e2 = 0, l = i.length; e2 < l; ++e2) {
        let l2 = i[e2];
        l2.length !== t2 && (l2 = new Int32Array(t2), i[e2] = l2), l2.fill(-1);
      }
    }
    GetLayoutRect(t2) {
      const e = this._sdkInst, i = e.GetWorldInfo(), l = e.GetCellWidth() * e.GetTileWidth(), s = e.GetCellHeight() * e.GetTileHeight(), h2 = i.GetX() + this._left, n = i.GetY() + this._top;
      t2.set(h2, n, h2 + l, n + s);
    }
    _SetQuadMapChanged() {
      this._isQuadMapValid = false;
    }
    MaybeBuildQuadMap() {
      if (this._isQuadMapValid) return;
      const t2 = this._sdkInst, e = t2.GetSdkType(), i = t2.GetWorldInfo(), l = t2.GetTileWidth(), s = t2.GetTileHeight(), h2 = t2.GetCellWidth(), n = t2.GetCellHeight(), o2 = this._left, a2 = this._top;
      if (l <= 0 || s <= 0) return;
      let d2 = Math.min(t2.GetMapWidth(), Math.floor(i.GetWidth() / l)), r2 = Math.min(t2.GetMapHeight(), Math.floor(i.GetHeight() / s));
      d2 -= o2 / l, r2 -= a2 / s, d2 > h2 && (d2 = h2), r2 > n && (r2 = n);
      const g2 = this._tiles, _2 = this._quads;
      let u2 = 0;
      for (let e2 = 0; e2 < r2; ++e2) {
        const i2 = g2[e2];
        for (let h3 = 0; h3 < d2; ++h3) {
          const n2 = i2[h3];
          if (-1 === n2) continue;
          let d3 = null;
          u2 < _2.length ? d3 = _2[u2] : (d3 = C32.New(C32.Plugins.Tilemap.TileQuad), _2.push(d3)), d3.Update(n2, l, s, h3, e2, o2, a2, t2), ++u2;
        }
      }
      u2 < _2.length && C32.truncateArray(_2, u2);
      let c2 = null, f2 = false;
      const p2 = this._collisionRects;
      C32.clearArray(p2);
      for (let t3 = 0; t3 < r2; ++t3) {
        const i2 = g2[t3];
        for (let h3 = 0; h3 < d2; ++h3) {
          const n2 = i2[h3], d3 = e.GetTilePoly(n2), r3 = e.IsTilePolyEnabled(d3);
          -1 !== n2 && r3 ? !c2 || d3 || f2 ? (c2 && p2.push(c2), c2 = C32.New(C32.Plugins.Tilemap.TileCollisionRect), c2.Update(n2, d3, l, s, h3, t3, o2, a2), f2 = !!d3) : c2.ExtendRight(l) : c2 && (p2.push(c2), c2 = null, f2 = false);
        }
        c2 && (p2.push(c2), c2 = null, f2 = false);
      }
      let G = p2.length;
      for (let t3 = 0; t3 < G; ++t3) {
        const e2 = p2[t3];
        if (e2.HasPoly()) continue;
        const i2 = e2.GetRect();
        for (let e3 = t3 + 1; e3 < G; ++e3) {
          const t4 = p2[e3], l2 = t4.GetRect();
          l2.getTop() < i2.getBottom() || (l2.getTop() > i2.getBottom() || l2.getRight() > i2.getRight() || l2.getLeft() > i2.getLeft() || t4.HasPoly() || l2.getLeft() === i2.getLeft() && l2.getRight() === i2.getRight() && (p2.splice(e3, 1), --G, i2.setBottom(i2.getBottom() + s), --e3));
        }
      }
      this._isQuadMapValid = true;
    }
    SetTileAt(t2, e, i) {
      this._tiles[e][t2] !== i && (this._tiles[e][t2] = i, this._isQuadMapValid = false, this._sdkInst.SetTileChanged());
    }
    GetTilesArr() {
      return this._tiles;
    }
    GetCollisionRects() {
      return this._collisionRects;
    }
    Draw(t2, e, i, l) {
      const s = this._sdkInst, h2 = this._quads;
      for (let n = 0, o2 = h2.length; n < o2; ++n) h2[n].Draw(t2, e, i, l, s);
    }
  };
}
{
  const C32 = self.C3, IGNORE_INDEX = -999, FORCE_INDEX = -998, EMPTY_INDEX = -1, PAINT_MODE = 0, ERASE_MODE = 1, AUTO_TILING_PATCH = Object.freeze([[0, 0, 0], [0, 0, 0], [0, 0, 0]]);
  C32.Plugins.Tilemap.BrushManager = class {
    constructor(t2, e) {
      this._sdkInst = t2, this._sdkType = e, this._brushAdapterInstances = [null, null, null], this._brushAdapterConstructors = [C32.Plugins.Tilemap.AutoTiling16, C32.Plugins.Tilemap.AutoTiling47, C32.Plugins.Tilemap.Patch], this._probabilityTable = new C32.ProbabilityTable();
    }
    get AUTO_TILING_PATCH() {
      return AUTO_TILING_PATCH;
    }
    get IGNORE_INDEX() {
      return -999;
    }
    get FORCE_INDEX() {
      return -998;
    }
    get EMPTY_INDEX() {
      return -1;
    }
    get PAINT_MODE() {
      return 0;
    }
    get ERASE_MODE() {
      return 1;
    }
    GetSdkIntance() {
      return this._sdkInst;
    }
    GetSdkType() {
      return this._sdkType;
    }
    GetProbabilityTable() {
      return this._probabilityTable;
    }
    GetBrushWidth(t2) {
      return this.BrushExists(t2) ? this._GetBrushWidth(t2) : 0;
    }
    GetBrushHeight(t2) {
      return this.BrushExists(t2) ? this._GetBrushHeight(t2) : 0;
    }
    SetAutoTile(t2, e, s) {
      this.BrushExists(s) && (this._SetMode(s, 0), this._SetAutoTilePatch(t2, e, this._GetPatch(t2, e, s)));
    }
    EraseAutoTile(t2, e, s) {
      this.BrushExists(s) && (this._SetMode(s, 1), this._EraseTile(t2, e), this._SetAutoTilePatch(t2, e, this._GetPatch(t2, e, s)));
    }
    SetPatchTile(t2, e, s, h2, i, r2, a2) {
      this.BrushExists(s) && (this._SetMode(s, 0), this._SetTilePatch(t2, e, s, this._GetPatch(t2, e, s), h2, i, r2, a2, 0));
    }
    ErasePatchTile(t2, e, s, h2, i, r2) {
      this.BrushExists(s) && (this._SetMode(s, 1), this._SetTilePatch(t2, e, s, this._GetPatch(t2, e, s), h2, i, r2, 0, 1));
    }
    GetBrushType(t2) {
      return this._GetBrushType(t2);
    }
    BrushExists(t2) {
      return !!this.GetSdkType().GetBrushData(t2);
    }
    GetTile(t2, e) {
      return this.GetSdkIntance().GetTileAt(t2, e);
    }
    _SetTile(t2, e, s) {
      this.GetSdkIntance().SetTileAt(t2, e, s);
    }
    _EraseTile(t2, e) {
      this.GetSdkIntance().SetTileAt(t2, e, -1);
    }
    _SetAutoTilePatch(t2, e, s) {
      s && (this._SetTile(t2 - 1, e - 1, s[0][0]), this._SetTile(t2, e - 1, s[1][0]), this._SetTile(t2 + 1, e - 1, s[2][0]), this._SetTile(t2 - 1, e, s[0][1]), this._SetTile(t2, e, s[1][1]), this._SetTile(t2 + 1, e, s[2][1]), this._SetTile(t2 - 1, e + 1, s[0][2]), this._SetTile(t2, e + 1, s[1][2]), this._SetTile(t2 + 1, e + 1, s[2][2]));
    }
    _SetTilePatch(t2, e, s, h2, i = false, r2 = false, a2 = 0, u2 = 0, _2 = 0) {
      if (!h2) return;
      const n = (h2 = this._TransformPatch(h2, s, i, r2, a2, u2, _2))[0].length, T2 = h2.length;
      for (let s2 = 0; s2 < T2; s2++) for (let i2 = 0; i2 < n; i2++) if (h2[s2][i2] !== this.IGNORE_INDEX) switch (u2) {
        case 0:
          h2[s2][i2] === this.EMPTY_INDEX ? this._EraseTile(t2 + i2, e + s2) : this._SetTile(t2 + i2, e + s2, h2[s2][i2]);
          break;
        case 1:
          -1 !== h2[s2][i2] && this._SetTile(t2 + i2, e + s2, h2[s2][i2]);
      }
    }
    _GetBrushType(t2) {
      return this.GetSdkType().GetBrushData(t2).type;
    }
    _MaybeCreateBrushAdapter(t2) {
      const e = this._GetBrushType(t2);
      this._brushAdapterInstances[e] || (this._brushAdapterInstances[e] = new this._brushAdapterConstructors[e](this));
    }
    _SetMode(t2, e) {
      this._MaybeCreateBrushAdapter(t2);
      const s = this._GetBrushType(t2);
      this._brushAdapterInstances[s] && this._brushAdapterInstances[s].SetMode(e);
    }
    _GetMode(t2) {
      this._MaybeCreateBrushAdapter(t2);
      const e = this._GetBrushType(t2);
      if (this._brushAdapterInstances[e]) return this._brushAdapterInstances[e].GetMode();
    }
    _GetPatch(t2, e, s) {
      this._MaybeCreateBrushAdapter(s);
      const h2 = this.GetSdkType().GetBrushData(s);
      if (this._brushAdapterInstances[h2.type]) return this._brushAdapterInstances[h2.type].BuildPatch(t2, e, h2);
    }
    _TransformPatch(t2, e, s = false, h2 = false, i = 0, r2 = 0, a2 = 0) {
      this._MaybeCreateBrushAdapter(e);
      const u2 = this.GetSdkType().GetBrushData(e);
      if (this._brushAdapterInstances[u2.type]) return this._brushAdapterInstances[u2.type].TransformPatch(t2, s, h2, i, r2, a2);
    }
    _GetBrushWidth(t2) {
      this._MaybeCreateBrushAdapter(t2);
      const e = this.GetSdkType().GetBrushData(t2);
      if (this._brushAdapterInstances[e.type]) return this._brushAdapterInstances[e.type].GetBrushWidth(e);
    }
    _GetBrushHeight(t2) {
      this._MaybeCreateBrushAdapter(t2);
      const e = this.GetSdkType().GetBrushData(t2);
      if (this._brushAdapterInstances[e.type]) return this._brushAdapterInstances[e.type].GetBrushHeight(e);
    }
  };
}
{
  const C32 = self.C3;
  C32.Plugins.Tilemap.AutoTilingHelper = class {
    constructor(e) {
      this._manager = e;
    }
    DoesTileExist(e, t2, i) {
      const n = this._manager.GetTile(e, t2);
      return !!this.IsTileValid(n, true, n, i);
    }
    IsTileValid(e, t2, i, n) {
      return e === this._manager.EMPTY_INDEX ? 0 : t2 && e === this._manager.FORCE_INDEX ? 1 : t2 && n && !this._IsTileIndexInBrush(i, n) ? 0 : 1;
    }
    GetTileIndex(e, t2, i, n) {
      const r2 = n.tileData[e];
      if (!r2.length) return this._manager.EMPTY_INDEX;
      if (1 === r2.length) return r2[0][0];
      const s = this._manager.GetTile(t2, i);
      if (this.IsTileValid(s)) {
        if (r2.some((e2) => s === e2[0])) return s;
      }
      const a2 = this._manager.GetProbabilityTable();
      a2.Clear();
      for (let [e2, t3] of r2) e2 > this._manager.GetSdkIntance().GetMaxTileIndex() || ("number" != typeof t3 && (t3 = 1), a2.AddItem(t3, e2));
      return a2.Sample();
    }
    _IsTileIndexInBrush(e, t2) {
      for (const i of t2.tileData) for (const [t3] of i) if (t3 === e) return true;
      return false;
    }
  };
}
{
  const C32 = self.C3;
  C32.Plugins.Tilemap.AutoTiling16 = class {
    constructor(t2) {
      this._manager = t2, this._helper = new C32.Plugins.Tilemap.AutoTilingHelper(t2), this._mode = t2.PAINT_MODE;
    }
    SetMode(t2) {
      this._mode = t2;
    }
    GetMode() {
      return this._mode;
    }
    GetBrushWidth(t2) {
      return 0;
    }
    GetBrushHeight(t2) {
      return 0;
    }
    TransformPatch(t2, e = false, i = false, _2 = 0, s = 0, h2 = 0) {
      return t2;
    }
    BuildPatch(t2, e, i) {
      return this._Build4BitAutoTilePatch(t2, e, i);
    }
    _Build4BitAutoTilePatch(t2, e, i) {
      const _2 = this._mode === this._manager.PAINT_MODE ? this._4BitAutoTiling(t2, e, void 0, i) : this._manager.EMPTY_INDEX, s = this._Get4BitAutoTile(t2, e - 1, "s", i), h2 = this._Get4BitAutoTile(t2 - 1, e, "e", i), a2 = this._Get4BitAutoTile(t2 + 1, e, "w", i), r2 = this._Get4BitAutoTile(t2, e + 1, "n", i), n = this._manager.AUTO_TILING_PATCH;
      return n[0][0] = this._manager.IGNORE_INDEX, n[1][0] = this._Get4BitTileIndex(s, t2, e - 1, i), n[2][0] = this._manager.IGNORE_INDEX, n[0][1] = this._Get4BitTileIndex(h2, t2 - 1, e, i), n[1][1] = this._Get4BitTileIndex(_2, t2, e, i), n[2][1] = this._Get4BitTileIndex(a2, t2 + 1, e, i), n[0][2] = this._manager.IGNORE_INDEX, n[1][2] = this._Get4BitTileIndex(r2, t2, e + 1, i), n[2][2] = this._manager.IGNORE_INDEX, n;
    }
    _Get4BitAutoTile(t2, e, i, _2) {
      return this._helper.DoesTileExist(t2, e, _2) ? this._4BitAutoTiling(t2, e, i, _2) : this._manager.IGNORE_INDEX;
    }
    _4BitAutoTiling(t2, e, i, _2) {
      this._mode === this._manager.ERASE_MODE && (i = void 0);
      const s = this._manager.GetTile(t2, e - 1), h2 = this._manager.GetTile(t2 - 1, e), a2 = this._manager.GetTile(t2 + 1, e), r2 = this._manager.GetTile(t2, e + 1), n = "n" === i ? this._manager.FORCE_INDEX : s, l = "w" === i ? this._manager.FORCE_INDEX : h2, T2 = "e" === i ? this._manager.FORCE_INDEX : a2, I2 = "s" === i ? this._manager.FORCE_INDEX : r2;
      return 1 * this._helper.IsTileValid(n, true, s, _2) + 2 * this._helper.IsTileValid(l, true, h2, _2) + 4 * this._helper.IsTileValid(T2, true, a2, _2) + 8 * this._helper.IsTileValid(I2, true, r2, _2);
    }
    _Get4BitTileIndex(t2, e, i, _2) {
      return t2 === this._manager.IGNORE_INDEX || t2 === this._manager.EMPTY_INDEX ? t2 : this._helper.GetTileIndex(t2, e, i, _2);
    }
  };
}
{
  const C32 = self.C3, TILE_INDEX_MAP = /* @__PURE__ */ new Map([[2, 1], [8, 2], [10, 3], [11, 4], [16, 5], [18, 6], [22, 7], [24, 8], [26, 9], [27, 10], [30, 11], [31, 12], [64, 13], [66, 14], [72, 15], [74, 16], [75, 17], [80, 18], [82, 19], [86, 20], [88, 21], [90, 22], [91, 23], [94, 24], [95, 25], [104, 26], [106, 27], [107, 28], [120, 29], [122, 30], [123, 31], [126, 32], [127, 33], [208, 34], [210, 35], [214, 36], [216, 37], [218, 38], [219, 39], [222, 40], [223, 41], [248, 42], [250, 43], [251, 44], [254, 45], [255, 46], [0, 47]]);
  C32.Plugins.Tilemap.AutoTiling47 = class {
    constructor(e) {
      this._manager = e, this._helper = new C32.Plugins.Tilemap.AutoTilingHelper(e), this._mode = e.PAINT_MODE;
    }
    SetMode(e) {
      this._mode = e;
    }
    GetMode() {
      return this._mode;
    }
    GetBrushWidth(e) {
      return 0;
    }
    GetBrushHeight(e) {
      return 0;
    }
    TransformPatch(e, t2 = false, i = false, s = 0, _2 = 0, h2 = 0) {
      return e;
    }
    BuildPatch(e, t2, i) {
      return this._Build8BitAutoTilePatch(e, t2, i);
    }
    _Build8BitAutoTilePatch(e, t2, i) {
      const s = this._mode === this._manager.PAINT_MODE ? this._8BitAutoTiling(e, t2, void 0, i) : this._manager.EMPTY_INDEX, _2 = this._Get8BitAutoTile(e - 1, t2 - 1, "se", i), h2 = this._Get8BitAutoTile(e, t2 - 1, "s", i), l = this._Get8BitAutoTile(e + 1, t2 - 1, "sw", i), a2 = this._Get8BitAutoTile(e - 1, t2, "e", i), n = this._Get8BitAutoTile(e + 1, t2, "w", i), r2 = this._Get8BitAutoTile(e - 1, t2 + 1, "ne", i), T2 = this._Get8BitAutoTile(e, t2 + 1, "n", i), I2 = this._Get8BitAutoTile(e + 1, t2 + 1, "nw", i), E2 = this._manager.AUTO_TILING_PATCH;
      return E2[0][0] = this._Get8BitTileIndex(_2, e - 1, t2 - 1, i), E2[1][0] = this._Get8BitTileIndex(h2, e, t2 - 1, i), E2[2][0] = this._Get8BitTileIndex(l, e + 1, t2 - 1, i), E2[0][1] = this._Get8BitTileIndex(a2, e - 1, t2, i), E2[1][1] = this._Get8BitTileIndex(s, e, t2, i), E2[2][1] = this._Get8BitTileIndex(n, e + 1, t2, i), E2[0][2] = this._Get8BitTileIndex(r2, e - 1, t2 + 1, i), E2[1][2] = this._Get8BitTileIndex(T2, e, t2 + 1, i), E2[2][2] = this._Get8BitTileIndex(I2, e + 1, t2 + 1, i), E2;
    }
    _Get8BitAutoTile(e, t2, i, s) {
      return this._helper.DoesTileExist(e, t2, s) ? this._8BitAutoTiling(e, t2, i, s) : this._manager.IGNORE_INDEX;
    }
    _8BitAutoTiling(e, t2, i, s) {
      this._mode === this._manager.ERASE_MODE && (i = void 0);
      const _2 = this._manager.GetTile(e, t2 - 1), h2 = this._manager.GetTile(e - 1, t2), l = this._manager.GetTile(e + 1, t2), a2 = this._manager.GetTile(e, t2 + 1), n = this._manager.GetTile(e - 1, t2 - 1), r2 = this._manager.GetTile(e + 1, t2 - 1), T2 = this._manager.GetTile(e - 1, t2 + 1), I2 = this._manager.GetTile(e + 1, t2 + 1), E2 = "n" === i ? this._manager.FORCE_INDEX : _2, G = "w" === i ? this._manager.FORCE_INDEX : h2, g2 = "e" === i ? this._manager.FORCE_INDEX : l, u2 = "s" === i ? this._manager.FORCE_INDEX : a2, d2 = "nw" === i ? this._manager.FORCE_INDEX : n, m2 = "ne" === i ? this._manager.FORCE_INDEX : r2, o2 = "sw" === i ? this._manager.FORCE_INDEX : T2, B2 = "se" === i ? this._manager.FORCE_INDEX : I2, A = this._helper.IsTileValid(E2, true, _2, s), N = this._helper.IsTileValid(G, true, h2, s), D2 = this._helper.IsTileValid(g2, true, l, s), p2 = this._helper.IsTileValid(u2, true, a2, s);
      return 1 * (A && N ? this._helper.IsTileValid(d2, true, n, s) : 0) + 2 * A + 4 * (A && D2 ? this._helper.IsTileValid(m2, true, r2, s) : 0) + 8 * N + 16 * D2 + 32 * (p2 && N ? this._helper.IsTileValid(o2, true, T2, s) : 0) + 64 * p2 + 128 * (p2 && D2 ? this._helper.IsTileValid(B2, true, I2, s) : 0);
    }
    _Get8BitTileIndex(e, t2, i, s) {
      return e === this._manager.IGNORE_INDEX || e === this._manager.EMPTY_INDEX ? e : this._helper.GetTileIndex(TILE_INDEX_MAP.get(e), t2, i, s);
    }
  };
}
{
  const C32 = self.C3;
  C32.Plugins.Tilemap.Patch = class {
    constructor(r2) {
      this._manager = r2, this._mode = r2.PAINT_MODE, this._mirror = 0, this._flip = 0, this._diagonal = 0, this._indexTransformMirror = 0, this._indexTransformFlip = 0, this._indexTransformDiagonal = 0;
    }
    SetMode(r2) {
      this._mode = r2;
    }
    GetMode() {
      return this._mode;
    }
    GetBrushWidth(r2) {
      return r2.tileData[0].length;
    }
    GetBrushHeight(r2) {
      return r2.tileData.length;
    }
    TransformPatch(r2, t2 = false, i = false, e = 0, a2 = 0, s = 0) {
      switch (r2 = this._SetTransformState(0, 0, e, r2), this._indexTransformMirror = this._mirror, this._indexTransformFlip = this._flip, this._indexTransformDiagonal = this._diagonal, this._diagonal && (r2 = this._TransposePatch(r2)), this._mirror && (r2 = this._MirrorPatch(r2, s === this._manager.PAINT_MODE)), this._flip && (r2 = this._FlipPatch(r2, s === this._manager.PAINT_MODE)), r2 = this._SetTransformState(t2 ? 1 : 0, i ? 1 : 0, 0, r2), e) {
        case 0:
          this._indexTransformMirror = this._mirror, this._indexTransformFlip = this._flip;
          break;
        case 1:
          this._indexTransformMirror = 1 ^ this._mirror, this._indexTransformFlip = this._flip;
          break;
        case 2:
          this._indexTransformMirror = 1 ^ this._mirror, this._indexTransformFlip = 1 ^ this._flip;
          break;
        case 3:
          this._indexTransformMirror = this._mirror, this._indexTransformFlip = 1 ^ this._flip;
      }
      return this._mirror && (r2 = this._MirrorPatch(r2, s === this._manager.PAINT_MODE)), this._flip && (r2 = this._FlipPatch(r2, s === this._manager.PAINT_MODE)), r2;
    }
    BuildPatch(r2, t2, i) {
      const e = i.tileData[0].length, a2 = i.tileData.length, s = Array.from({ length: a2 }, () => new Array(e).fill(this._manager.EMPTY_INDEX)), n = this._manager.GetProbabilityTable();
      n.Clear();
      for (let r3 = 0; r3 < a2; r3++) for (let t3 = 0; t3 < e; t3++) {
        const e2 = i.tileData[r3][t3];
        switch (this._mode) {
          case this._manager.PAINT_MODE:
            if (1 === e2.length) {
              const i2 = e2[0][0];
              if (i2 > this._manager.GetSdkIntance().GetMaxTileIndex()) continue;
              s[r3][t3] = i2;
            } else {
              for (let [r4, t4] of e2) r4 > this._manager.GetSdkIntance().GetMaxTileIndex() || ("number" != typeof t4 && (t4 = 1), n.AddItem(t4, r4));
              s[r3][t3] = n.Sample();
            }
            break;
          case this._manager.ERASE_MODE:
            i.tileData[r3][t3][0][0] === this._manager.EMPTY_INDEX ? s[r3][t3] = this._manager.IGNORE_INDEX : s[r3][t3] = this._manager.EMPTY_INDEX;
        }
      }
      return s;
    }
    _SetTransformState(r2, t2, i, e) {
      switch (i) {
        case 0:
          this._mirror = r2, this._flip = t2, this._diagonal = 0;
          break;
        case 1:
          this._mirror = 1 ^ t2, this._flip = r2, this._diagonal = 1;
          break;
        case 2:
          this._mirror = 1 ^ r2, this._flip = 1 ^ t2, this._diagonal = 0;
          break;
        case 3:
          this._mirror = t2, this._flip = 1 ^ r2, this._diagonal = 1;
      }
      return e;
    }
    _GetTileIndexTransformation(r2) {
      if (r2 === this._manager.IGNORE_INDEX || r2 === this._manager.EMPTY_INDEX) return r2;
      const t2 = globalThis.ITilemapInstance;
      let i = r2 & t2.TILE_ID_MASK;
      return this._indexTransformDiagonal && (i |= t2.TILE_FLIPPED_DIAGONAL), this._indexTransformMirror && (i |= t2.TILE_FLIPPED_HORIZONTAL), this._indexTransformFlip && (i |= t2.TILE_FLIPPED_VERTICAL), i;
    }
    _MirrorPatch(r2, t2) {
      for (let t3 = 0; t3 < r2.length; t3++) r2[t3].reverse();
      if (t2) {
        let t3 = r2[0].length, i = r2.length;
        for (let e = 0; e < i; e++) for (let i2 = 0; i2 < t3; i2++) {
          const t4 = this._GetTileIndexTransformation(r2[e][i2]);
          r2[e][i2] = t4;
        }
      }
      return r2;
    }
    _FlipPatch(r2, t2) {
      if (r2.reverse(), t2) {
        let t3 = r2[0].length, i = r2.length;
        for (let e = 0; e < i; e++) for (let i2 = 0; i2 < t3; i2++) {
          const t4 = this._GetTileIndexTransformation(r2[e][i2]);
          r2[e][i2] = t4;
        }
      }
      return r2;
    }
    _TransposePatch(r2) {
      let t2 = [], i = r2.length, e = r2[0].length;
      for (let a2 = 0; a2 < e; a2++) {
        let e2 = [];
        for (let t3 = 0; t3 < i; t3++) e2.push(r2[t3][a2]);
        t2.push(e2);
      }
      return t2;
    }
  };
}
{
  {
    const e = self.C3;
    e.Plugins.Particles = class extends e.SDKPluginBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
    };
  }
  {
    const t2 = self.C3;
    t2.Plugins.Particles.Type = class extends t2.SDKTypeBase {
      constructor(e) {
        super(e);
      }
      Release() {
        super.Release();
      }
      OnCreate() {
        this.GetImageInfo().LoadAsset(this._runtime);
      }
      LoadTextures(e) {
        return this.GetImageInfo().LoadStaticTexture(e, { sampling: this._runtime.GetSampling() });
      }
      ReleaseTextures() {
        this.GetImageInfo().ReleaseTexture();
      }
    };
  }
  {
    let GetParticleEngine = function(e) {
      return w2.get(e).GetParticleEngine();
    };
    GetParticleEngine2 = GetParticleEngine;
    const i = self.C3, n = self.C3X, a2 = 0, r2 = 1, s = 2, o2 = 3, c2 = 4, l = 5, S2 = 6, d2 = 7, p2 = 8, G = 9, m2 = 10, u2 = 11, h2 = 12, g2 = 13, R = 14, I2 = 15, y2 = 16, _2 = 17, E2 = 18, P2 = 19, f2 = 20, b2 = 0, C2 = 1, O2 = i.New(i.Rect);
    i.Plugins.Particles.Instance = class extends i.SDKWorldInstanceBase {
      constructor(e, t2) {
        super(e), this._isFirstTick = true;
        const n2 = i.New(self.ParticleEngine);
        this._particleEngine = n2, n2.ononeshotfinish = () => this._OnOneShotFinish(), this._spawnObjectClass = null, this._particleUpdateCallback = (e2, t3, i2, n3, a3, r3) => this._OnParticleUpdate(e2, t3, i2, n3, a3, r3), this._particleDestroyCallback = (e2) => this._OnParticleDestroy(e2), this._hasAnyDefaultParticle = true;
        let b3 = true;
        t2 && (n2.SetRate(t2[a2]), n2.SetSprayCone(i.toRadians(t2[r2])), n2.SetSprayType(t2[s] ? "one-shot" : "continuous-spray"), this._SetParticleObjectClass(this._runtime.GetObjectClassBySID(t2[o2])), b3 = t2[c2], n2.SetInitSpeed(t2[l]), n2.SetInitSize(t2[S2]), n2.SetInitOpacity(t2[d2] / 100), n2.SetGrowRate(t2[p2]), n2.SetInitXRandom(t2[G]), n2.SetInitYRandom(t2[m2]), n2.SetInitSpeedRandom(t2[u2]), n2.SetInitSizeRandom(t2[h2]), n2.SetGrowRandom(t2[g2]), n2.SetAcceleration(t2[R]), n2.SetGravity(t2[I2]), n2.SetLifeAngleRandom(t2[y2]), n2.SetLifeSpeedRandom(t2[_2]), n2.SetLifeOpacityRandom(t2[E2]), n2.SetDestroyModeIndex(t2[P2]), n2.SetTimeout(t2[f2])), this._UpdateEngineParameters(), this._spawnObjectClass && (this._hasAnyDefaultParticle = false), "one-shot" === n2.GetSprayType() ? n2.CreateOneShotSpray() : n2.SetSpraying(true);
        const C4 = this.GetWorldInfo();
        C4.SetVisible(b3), C4.SetBboxChangeEventEnabled(true), this._inst.Dispatcher().addEventListener("bboxchange", () => {
          C4.OverwriteBoundingBox(this._particleEngine.GetBoundingBox());
        }), this.GetRuntime().GetRenderer().IsWebGPU() && C4.SetUsePointsShaderProgram(), this._afterLoad = (e2) => this._OnAfterLoad(e2), this.GetRuntime().Dispatcher().addEventListener("afterload", this._afterLoad), this._StartTicking();
      }
      Release() {
        this.GetRuntime().Dispatcher().removeEventListener("afterload", this._afterLoad), this._afterLoad = null, this._particleEngine.Release(), this._particleEngine = null, this._particleUpdateCallback = null, this._particleDestroyCallback = null, super.Release();
      }
      GetParticleEngine() {
        return this._particleEngine;
      }
      _SetRate(e) {
        this._particleEngine.SetRate(e), "one-shot" === this._particleEngine.GetSprayType() && this._isFirstTick && this._particleEngine.SetParticleCount(e);
      }
      _SetParticleObjectClass(e) {
        e === this.GetObjectClass() && (e = null), e !== this._spawnObjectClass && (this._spawnObjectClass = e, this._particleEngine.onparticlecreate = e ? (e2) => this._OnParticleCreate(e2) : null, this._spawnObjectClass || (this._hasAnyDefaultParticle = true));
      }
      _UpdateEngineParameters() {
        const e = this._particleEngine, t2 = this.GetWorldInfo();
        e.SetMasterOpacity(t2.GetOpacity()), e.SetPixelRounding(this._runtime.IsPixelRoundingEnabled()), e.SetSpawnX(t2.GetX()), e.SetSpawnY(t2.GetY()), e.SetSpawnAngle(t2.GetAngle()), e.SetInitSizeScale(Math.abs(t2.GetSceneGraphScale()));
      }
      _OnOneShotFinish() {
        this._runtime.DestroyInstance(this._inst);
      }
      Draw(e) {
        if (!this._hasAnyDefaultParticle) return;
        const t2 = this._objectClass.GetImageInfo(), i2 = t2.GetTexture();
        if (!i2) return;
        const n2 = this.GetWorldInfo(), a3 = n2.GetLayer(), r3 = O2;
        this._runtime.GetCanvasManager().IsPastingToDrawingCanvas() ? r3.set(-1 / 0, -1 / 0, 1 / 0, 1 / 0) : a3.Has3DCamera() ? a3.CalculateViewport3D(n2.GetTotalZElevation(), r3) : a3.GetViewportForZ(n2.GetTotalZElevation(), r3), e.SetTexture(i2);
        const s2 = a3.Get2DScaleFactorToZ(n2.GetTotalZElevation());
        this._particleEngine.SetParticleScale(a3.GetRenderScale() * s2), this._particleEngine.Draw(e, t2.GetTexQuad(), r3, a3.Has3DCamera());
      }
      SaveToJson() {
        const e = this._particleEngine;
        return { "r": e.GetRate(), "sc": e.GetSprayCone(), "st": e.GetSprayType(), "isp": e.GetInitSpeed(), "isz": e.GetInitSize(), "io": e.GetInitOpacity(), "gr": e.GetGrowRate(), "xr": e.GetInitXRandom(), "yr": e.GetInitYRandom(), "spr": e.GetInitSpeedRandom(), "szr": e.GetInitSizeRandom(), "grnd": e.GetGrowRandom(), "acc": e.GetAcceleration(), "g": e.GetGravity(), "lar": e.GetLifeAngleRandom(), "lsr": e.GetLifeSpeedRandom(), "lor": e.GetLifeOpacityRandom(), "dm": e.GetDestroyModeIndex(), "to": e.GetTimeout(), "s": e.IsSpraying(), "pcc": e._GetCreateCounter(), "ft": this._isFirstTick, "soc": this._spawnObjectClass ? this._spawnObjectClass.GetSID() : null, "p": e.GetParticles().map((e2) => e2.toJSON()) };
      }
      LoadFromJson(e, t2) {
        const i2 = this._particleEngine;
        if (i2.SetRate(e["r"]), i2.SetSprayCone(e["sc"]), i2.SetSprayType(e["st"]), i2.SetInitSpeed(e["isp"]), i2.SetInitSize(e["isz"]), i2.SetInitOpacity(e["io"]), i2.SetGrowRate(e["gr"]), i2.SetInitXRandom(e["xr"]), i2.SetInitYRandom(e["yr"]), i2.SetInitSpeedRandom(e["spr"]), i2.SetInitSizeRandom(e["szr"]), i2.SetGrowRandom(e["grnd"]), i2.SetAcceleration(e["acc"]), i2.SetGravity(e["g"]), i2.SetLifeAngleRandom(e["lar"]), i2.SetLifeSpeedRandom(e["lsr"]), i2.SetLifeOpacityRandom(e["lor"]), i2.SetDestroyModeIndex(e["dm"]), i2.SetTimeout(e["to"]), i2.SetSpraying(e["s"]), i2._SetCreateCounter(e["pcc"]), this._isFirstTick = e["ft"], e.hasOwnProperty("soc")) {
          const t3 = this.GetRuntime().GetObjectClassBySID(e["soc"]);
          t3 && this._SetParticleObjectClass(t3);
        }
        const n2 = e["p"];
        i2.SetParticleCount(n2.length, false);
        const a3 = i2.GetParticles();
        for (let e2 = 0, t3 = a3.length; e2 < t3; ++e2) a3[e2].setFromJSON(n2[e2]);
        "state" === t2 && this._spawnObjectClass && (i2.UpdateAllParticlesUserData(), i2.ApplyParticleDataToUserData(this));
      }
      _OnAfterLoad() {
        const e = this._particleEngine;
        e.UpdateAllParticlesUserData(), e.ApplyParticleDataToUserData(this);
        const t2 = e.GetParticles();
        for (let e2 = 0, i2 = t2.length; e2 < i2; ++e2) {
          const i3 = t2[e2], n2 = i3.GetUserData();
          if (!n2) continue;
          const a3 = n2.GetWorldInfo();
          if (!a3) continue;
          const r3 = a3.GetInstance();
          if (!r3) continue;
          const s2 = i3.GetUserDataUID(), o3 = r3.GetUID();
          if (("number" != typeof s2 || "number" != typeof o3 || s2 !== o3) && "number" == typeof s2) {
            const e3 = this.GetRuntime(), t3 = e3.GetInstanceByUID(s2);
            t3 && e3.DestroyInstance(t3);
          }
        }
      }
      Tick() {
        const e = this._runtime.GetDt(this._inst);
        this._UpdateEngineParameters(), this._isFirstTick && "one-shot" === this._particleEngine.GetSprayType() && this._particleEngine.ReInitAllParticles(), this._particleEngine.Tick(e), this._particleEngine.IsSpraying() && this._runtime.UpdateRender(), this.GetWorldInfo().SetBboxChanged(), this._isFirstTick = false;
      }
      _FastForward(e) {
        const t2 = 1 / 60;
        for (this._isFirstTick && "one-shot" === this._particleEngine.GetSprayType() && this._particleEngine.ReInitAllParticles(); e > 0; ) this._particleEngine.Tick(t2), e -= t2;
        this._particleEngine.IsSpraying() && this._runtime.UpdateRender(), this.GetWorldInfo().SetBboxChanged(), this._isFirstTick = false;
      }
      _OnParticleCreate(e, t2) {
        let i2;
        "number" == typeof t2 && (i2 = this._runtime.GetInstanceByUID(t2)), i2 && i2.GetObjectClass() !== this._spawnObjectClass && (i2 = null), i2 || (i2 = this._runtime.CreateInstance(this._spawnObjectClass, this.GetWorldInfo().GetLayer(), e.GetX(), e.GetY()));
        const n2 = i2.GetWorldInfo();
        return n2.SetSize(e.GetSize(), e.GetSize()), n2.SetAngle(e.GetAngle()), n2.SetOpacity(e.GetOpacity()), n2.SetUnpremultipliedColor(this.GetWorldInfo().GetUnpremultipliedColor()), n2.SetBboxChanged(), n2.ZOrderMoveAdjacentToInstance(this.GetInstance(), true), i2._TriggerOnCreated(), e.SetUpdateCallback(this._particleUpdateCallback), e.SetDestroyCallback(this._particleDestroyCallback), i2;
      }
      _OnParticleUpdate(e, t2, i2, n2, a3, r3) {
        if (e.IsDestroyed()) return;
        const s2 = e.GetWorldInfo();
        s2.OffsetXY(t2, i2), s2.SetSize(s2.GetWidth() + n2, s2.GetHeight() + n2), s2.SetAngle(s2.GetAngle() + a3), s2.SetOpacity(s2.GetOpacity() + r3), s2.SetBboxChanged();
      }
      _OnParticleDestroy(e) {
        e.IsDestroyed() || this._runtime.DestroyInstance(e);
      }
      GetPropertyValueByIndex(e) {
        const t2 = this._particleEngine;
        switch (e) {
          case a2:
            return t2.GetRate();
          case r2:
            return i.toDegrees(t2.GetSprayCone());
          case s:
            return "one-shot" === t2.GetSprayType() ? C2 : b2;
          case l:
            return t2.GetInitSpeed();
          case S2:
            return t2.GetInitSize();
          case d2:
            return 100 * t2.GetInitOpacity();
          case p2:
            return t2.GetGrowRate();
          case G:
            return t2.GetInitXRandom();
          case m2:
            return t2.GetInitYRandom();
          case u2:
            return t2.GetInitSpeedRandom();
          case h2:
            return t2.GetInitSizeRandom();
          case g2:
            return t2.GetGrowRandom();
          case R:
            return t2.GetAcceleration();
          case I2:
            return t2.GetGravity();
          case y2:
            return t2.GetLifeAngleRandom();
          case _2:
            return t2.GetLifeSpeedRandom();
          case E2:
            return t2.GetLifeOpacityRandom();
          case P2:
            return t2.GetDestroyModeIndex();
          case f2:
            return t2.GetTimeout();
        }
      }
      SetPropertyValueByIndex(e, t2) {
        const n2 = this._particleEngine;
        switch (e) {
          case a2:
            n2.SetRate(t2);
            break;
          case r2:
            n2.SetSprayCone(i.toRadians(t2));
            break;
          case s:
            n2.SetSprayType(t2 ? "one-shot" : "continuous-spray");
            break;
          case l:
            n2.SetInitSpeed(t2);
            break;
          case S2:
            n2.SetInitSize(t2);
            break;
          case d2:
            n2.SetInitOpacity(t2 / 100);
            break;
          case p2:
            n2.SetGrowRate(t2);
            break;
          case G:
            n2.SetInitXRandom(t2);
            break;
          case m2:
            n2.SetInitYRandom(t2);
            break;
          case u2:
            n2.SetInitSpeedRandom(t2);
            break;
          case h2:
            n2.SetInitSizeRandom(t2);
            break;
          case g2:
            n2.SetGrowRandom(t2);
            break;
          case R:
            n2.SetAcceleration(t2);
            break;
          case I2:
            n2.SetGravity(t2);
            break;
          case y2:
            n2.SetLifeAngleRandom(t2);
            break;
          case _2:
            n2.SetLifeSpeedRandom(t2);
            break;
          case E2:
            n2.SetLifeOpacityRandom(t2);
            break;
          case P2:
            n2.SetDestroyModeIndex(t2);
            break;
          case f2:
            n2.SetTimeout(t2);
        }
      }
      GetDebuggerProperties() {
        const e = "plugins.particles", t2 = e + ".properties", n2 = e + ".debugger", a3 = this._particleEngine;
        return [{ title: e + ".name", properties: [{ name: n2 + ".particle-count", value: a3.GetParticleCount() }, { name: t2 + ".type.name", value: [t2 + ".type.items." + a3.GetSprayType()] }, { name: n2 + ".is-spraying", value: a3.IsSpraying(), onedit: (e2) => a3.SetSpraying(e2) }, { name: t2 + ".rate.name", value: a3.GetRate(), onedit: (e2) => a3.SetRate(e2) }, { name: t2 + ".spray-cone.name", value: i.toDegrees(a3.GetSprayCone()), onedit: (e2) => a3.SetSprayCone(i.toRadians(e2)) }, { name: t2 + ".speed.name", value: a3.GetInitSpeed(), onedit: (e2) => a3.SetInitSpeed(e2) }, { name: t2 + ".size.name", value: a3.GetInitSize(), onedit: (e2) => a3.SetInitSize(e2) }, { name: t2 + ".opacity.name", value: a3.GetInitOpacity(), onedit: (e2) => a3.SetInitOpacity(e2) }, { name: t2 + ".grow-rate.name", value: a3.GetGrowRate(), onedit: (e2) => a3.SetGrowRate(e2) }, { name: t2 + ".x-randomiser.name", value: a3.GetInitXRandom(), onedit: (e2) => a3.SetInitXRandom(e2) }, { name: t2 + ".y-randomiser.name", value: a3.GetInitYRandom(), onedit: (e2) => a3.SetInitYRandom(e2) }, { name: t2 + ".initial-speed-randomiser.name", value: a3.GetInitSpeedRandom(), onedit: (e2) => a3.SetInitSpeedRandom(e2) }, { name: t2 + ".size-randomiser.name", value: a3.GetInitSizeRandom(), onedit: (e2) => a3.SetInitSizeRandom(e2) }, { name: t2 + ".grow-rate-randomiser.name", value: a3.GetGrowRandom(), onedit: (e2) => a3.SetGrowRandom(e2) }, { name: t2 + ".acceleration.name", value: a3.GetAcceleration(), onedit: (e2) => a3.SetAcceleration(e2) }, { name: t2 + ".gravity.name", value: a3.GetGravity(), onedit: (e2) => a3.SetGravity(e2) }, { name: t2 + ".angle-randomiser.name", value: a3.GetLifeAngleRandom(), onedit: (e2) => a3.SetLifeAngleRandom(e2) }, { name: t2 + ".life-speed-randomiser.name", value: a3.GetLifeSpeedRandom(), onedit: (e2) => a3.SetLifeSpeedRandom(e2) }, { name: t2 + ".opacity-randomiser.name", value: a3.GetLifeOpacityRandom(), onedit: (e2) => a3.SetLifeOpacityRandom(e2) }, { name: t2 + ".timeout.name", value: a3.GetTimeout(), onedit: (e2) => a3.SetTimeout(e2) }] }];
      }
      GetScriptInterfaceClass() {
        return self.IParticlesInstance;
      }
    };
    const w2 = /* @__PURE__ */ new WeakMap();
    self.IParticlesInstance = class extends self.IWorldInstance {
      constructor() {
        super(), w2.set(this, self.IInstance._GetInitInst().GetSdkInstance());
      }
      set isSpraying(e) {
        GetParticleEngine(this).SetSpraying(!!e);
      }
      get isSpraying() {
        return GetParticleEngine(this).IsSpraying();
      }
      set rate(e) {
        n.RequireFiniteNumber(e), w2.get(this)._SetRate(e);
      }
      get rate() {
        return GetParticleEngine(this).GetRate();
      }
      set sprayCone(e) {
        n.RequireFiniteNumber(e), GetParticleEngine(this).SetSprayCone(e);
      }
      get sprayCone() {
        return GetParticleEngine(this).GetSprayCone();
      }
      set initSpeed(e) {
        n.RequireFiniteNumber(e), GetParticleEngine(this).SetInitSpeed(e);
      }
      get initSpeed() {
        return GetParticleEngine(this).GetInitSpeed();
      }
      set initSize(e) {
        n.RequireFiniteNumber(e), GetParticleEngine(this).SetInitSize(e);
      }
      get initSize() {
        return GetParticleEngine(this).GetInitSize();
      }
      set initOpacity(e) {
        n.RequireFiniteNumber(e), GetParticleEngine(this).SetInitOpacity(e);
      }
      get initOpacity() {
        return GetParticleEngine(this).GetInitOpacity();
      }
      set initXRandom(e) {
        n.RequireFiniteNumber(e), GetParticleEngine(this).SetInitXRandom(e);
      }
      get initXRandom() {
        return GetParticleEngine(this).GetInitXRandom();
      }
      set initYRandom(e) {
        n.RequireFiniteNumber(e), GetParticleEngine(this).SetInitYRandom(e);
      }
      get initYRandom() {
        return GetParticleEngine(this).GetInitYRandom();
      }
      set initSpeedRandom(e) {
        n.RequireFiniteNumber(e), GetParticleEngine(this).SetInitSpeedRandom(e);
      }
      get initSpeedRandom() {
        return GetParticleEngine(this).GetInitSpeedRandom();
      }
      set initSizeRandom(e) {
        n.RequireFiniteNumber(e), GetParticleEngine(this).SetInitSizeRandom(e);
      }
      get initSizeRandom() {
        return GetParticleEngine(this).GetInitSizeRandom();
      }
      set initGrowRate(e) {
        n.RequireFiniteNumber(e), GetParticleEngine(this).SetGrowRate(e);
      }
      get initGrowRate() {
        return GetParticleEngine(this).GetGrowRate();
      }
      set initGrowRandom(e) {
        n.RequireFiniteNumber(e), GetParticleEngine(this).SetGrowRandom(e);
      }
      get initGrowRandom() {
        return GetParticleEngine(this).GetGrowRandom();
      }
      set acceleration(e) {
        n.RequireFiniteNumber(e), GetParticleEngine(this).SetAcceleration(e);
      }
      get acceleration() {
        return GetParticleEngine(this).GetAcceleration();
      }
      set gravity(e) {
        n.RequireFiniteNumber(e), GetParticleEngine(this).SetGravity(e);
      }
      get gravity() {
        return GetParticleEngine(this).GetGravity();
      }
      set lifeAngleRandom(e) {
        n.RequireFiniteNumber(e), GetParticleEngine(this).SetLifeAngleRandom(e);
      }
      get lifeAngleRandom() {
        return GetParticleEngine(this).GetLifeAngleRandom();
      }
      set lifeSpeedRandom(e) {
        n.RequireFiniteNumber(e), GetParticleEngine(this).SetLifeSpeedRandom(e);
      }
      get lifeSpeedRandom() {
        return GetParticleEngine(this).GetLifeSpeedRandom();
      }
      set lifeOpacityRandom(e) {
        n.RequireFiniteNumber(e), GetParticleEngine(this).SetLifeOpacityRandom(e);
      }
      get lifeOpacityRandom() {
        return GetParticleEngine(this).GetLifeOpacityRandom();
      }
      set timeout(e) {
        n.RequireFiniteNumber(e), GetParticleEngine(this).SetTimeout(e);
      }
      get timeout() {
        return GetParticleEngine(this).GetTimeout();
      }
      fastForward(e) {
        n.RequireFiniteNumber(e), w2.get(this)._FastForward(e);
      }
      setParticleObjectClass(e) {
        const t2 = w2.get(this);
        e ? t2._SetParticleObjectClass(t2.GetRuntime()._UnwrapIObjectClass(e)) : t2._SetParticleObjectClass(null);
      }
    };
  }
  self.C3.Plugins.Particles.Cnds = { IsSpraying() {
    return this._particleEngine.IsSpraying();
  } };
  {
    const T2 = self.C3;
    T2.Plugins.Particles.Acts = { SetSpraying(e) {
      this._particleEngine.SetSpraying(0 !== e);
    }, SetRate(e) {
      this._SetRate(e);
    }, SetParticleObject(e) {
      this._SetParticleObjectClass(e);
    }, UnsetParticleObject() {
      this._SetParticleObjectClass(null);
    }, SetSprayCone(e) {
      this._particleEngine.SetSprayCone(T2.toRadians(e));
    }, SetInitSpeed(e) {
      this._particleEngine.SetInitSpeed(e);
    }, SetInitSize(e) {
      this._particleEngine.SetInitSize(e);
    }, SetInitOpacity(e) {
      this._particleEngine.SetInitOpacity(e / 100);
    }, SetGrowRate(e) {
      this._particleEngine.SetGrowRate(e);
    }, SetXRandomiser(e) {
      this._particleEngine.SetInitXRandom(e);
    }, SetYRandomiser(e) {
      this._particleEngine.SetInitYRandom(e);
    }, SetSpeedRandomiser(e) {
      this._particleEngine.SetInitSpeedRandom(e);
    }, SetSizeRandomiser(e) {
      this._particleEngine.SetInitSizeRandom(e);
    }, SetGrowRateRandomiser(e) {
      this._particleEngine.SetGrowRandom(e);
    }, SetParticleAcc(e) {
      this._particleEngine.SetAcceleration(e);
    }, SetGravity(e) {
      this._particleEngine.SetGravity(e);
    }, SetAngleRandomiser(e) {
      this._particleEngine.SetLifeAngleRandom(e);
    }, SetLifeSpeedRandomiser(e) {
      this._particleEngine.SetLifeSpeedRandom(e);
    }, SetOpacityRandomiser(e) {
      this._particleEngine.SetLifeOpacityRandom(e);
    }, SetTimeout(e) {
      this._particleEngine.SetTimeout(e);
    }, FastForward(e) {
      this._FastForward(e);
    }, SetEffect(e) {
      this.GetWorldInfo().SetBlendMode(e), this._runtime.UpdateRender();
    } };
  }
  {
    const D2 = self.C3;
    D2.Plugins.Particles.Exps = { ParticleCount() {
      return this._particleEngine.GetParticleCount();
    }, Rate() {
      return this._particleEngine.GetRate();
    }, SprayCone() {
      return D2.toDegrees(this._particleEngine.GetSprayCone());
    }, InitSpeed() {
      return this._particleEngine.GetInitSpeed();
    }, InitSize() {
      return this._particleEngine.GetInitSize();
    }, InitOpacity() {
      return 100 * this._particleEngine.GetInitOpacity();
    }, InitGrowRate() {
      return this._particleEngine.GetGrowRate();
    }, XRandom() {
      return this._particleEngine.GetInitXRandom();
    }, YRandom() {
      return this._particleEngine.GetInitYRandom();
    }, InitSizeRandom() {
      return this._particleEngine.GetInitSizeRandom();
    }, InitSpeedRandom() {
      return this._particleEngine.GetInitSpeedRandom();
    }, InitGrowRandom() {
      return this._particleEngine.GetGrowRandom();
    }, ParticleAcceleration() {
      return this._particleEngine.GetAcceleration();
    }, Gravity() {
      return this._particleEngine.GetGravity();
    }, ParticleAngleRandom() {
      return this._particleEngine.GetLifeAngleRandom();
    }, ParticleSpeedRandom() {
      return this._particleEngine.GetLifeSpeedRandom();
    }, ParticleOpacityRandom() {
      return this._particleEngine.GetLifeOpacityRandom();
    }, Timeout() {
      return this._particleEngine.GetTimeout();
    } };
  }
}
var GetParticleEngine2;
{
  const C32 = self.C3, inactiveParticles = [], MAX_RECYCLE_PARTICLES = 1e3, VALID_SPRAY_TYPES = /* @__PURE__ */ new Set(["continuous-spray", "one-shot"]), DESTROY_MODES = ["fade-to-invisible", "timeout-expired", "particle-stopped"], tempRect = C32.New(C32.Rect);
  self.ParticleEngine = class {
    constructor() {
      this._rate = 0, this._sprayCone = 0, this._sprayType = "continuous-spray", this._isSpraying = false, this._masterOpacity = 0, this._isPixelRounding = false, this._spawnX = 0, this._spawnY = 0, this._spawnAngle = 0, this._initSpeed = 0, this._initSize = 0, this._initSizeScale = 1, this._initOpacity = 0, this._growRate = 0, this._xRandom = 0, this._yRandom = 0, this._initSpeedRandom = 0, this._initSizeRandom = 0, this._growRandom = 0, this._acceleration = 0, this._gravity = 0, this._lifeAngleRandom = 0, this._lifeSpeedRandom = 0, this._lifeOpacityRandom = 0, this._destroyMode = 0, this._timeout = 0, this._createCounter = 0, this._particleScale = 1, this.ononeshotfinish = null, this.onparticlecreate = null, this._particles = [], this._boundingBox = new C32.Rect(), this._color = new C32.Color(), this._devicePixelRatio = globalThis.devicePixelRatio || 1;
    }
    Release() {
      this.Cancel(), C32.clearArray(this._particles), this._particles = null, this.ononeshotfinish = null, this.onparticlecreate = null, this._boundingBox = null, this._color = null;
    }
    Cancel() {
      const t2 = this._particles;
      for (let e = 0, i = t2.length; e < i; ++e) t2[e].Destroy();
      C32.appendArray(inactiveParticles, t2), C32.clearArray(t2), inactiveParticles.length > 1e3 && C32.truncateArray(inactiveParticles, 1e3), this._isSpraying = false;
    }
    CreateOneShotSpray() {
      for (let t2 = 0, e = this._rate; t2 < e; ++t2) this._CreateParticle();
      this._particles.length && (this._isSpraying = true);
    }
    _CreateParticle(t2 = true) {
      let e = null;
      return inactiveParticles.length ? (e = inactiveParticles.pop(), e.SetEngine(this)) : e = C32.New(self.Particle, this), this._particles.push(e), t2 ? e.Init(this.onparticlecreate) : e.Init(), e;
    }
    ReInitAllParticles() {
      const t2 = this._particles, e = this.onparticlecreate;
      for (let i = 0, n = t2.length; i < n; ++i) t2[i].Init(e);
    }
    UpdateAllParticlesUserData() {
      const t2 = this._particles, e = this.onparticlecreate;
      for (let i = 0, n = t2.length; i < n; ++i) t2[i].UpdateUserData(e);
    }
    ApplyParticleDataToUserData(t2) {
      const e = this._particles;
      for (let i = 0, n = e.length; i < n; ++i) {
        const n2 = e[i], s = n2.GetUserData();
        if (s) {
          const e2 = s.GetWorldInfo();
          e2.SetX(n2.GetX()), e2.SetY(n2.GetY()), e2.SetSize(n2.GetSize(), n2.GetSize()), e2.SetOpacity(n2.GetOpacity()), e2.SetAngle(n2.GetAngle()), e2.SetUnpremultipliedColor(t2.GetWorldInfo().GetUnpremultipliedColor()), e2.SetBboxChanged();
        }
      }
    }
    SetParticleCount(t2, e = true) {
      const i = this._particles;
      if (t2 < i.length) {
        const e2 = i.length - t2;
        for (let t3 = 0; t3 < e2; ++t3) {
          const t4 = i.pop();
          t4.Destroy(), inactiveParticles.push(t4);
        }
        inactiveParticles.length > 1e3 && C32.truncateArray(inactiveParticles, 1e3);
      } else if (t2 > i.length) {
        const n = t2 - i.length;
        for (let t3 = 0; t3 < n; ++t3) this._CreateParticle(e);
      }
    }
    GetParticles() {
      return this._particles;
    }
    GetParticleCount() {
      return this._particles.length;
    }
    Tick(t2) {
      this._SpawnContinuous(t2), this._TickParticles(t2), this._MaybeFinishOneShot();
    }
    _SpawnContinuous(t2) {
      if ("continuous-spray" === this._sprayType && this._isSpraying) {
        this._createCounter += t2 * this._rate;
        const e = Math.floor(this._createCounter);
        this._createCounter -= e;
        for (let t3 = 0; t3 < e; ++t3) this._CreateParticle();
      }
    }
    _SetCreateCounter(t2) {
      this._createCounter = t2;
    }
    _GetCreateCounter() {
      return this._createCounter;
    }
    _TickParticles(t2) {
      const e = this._boundingBox;
      e.set(this._spawnX, this._spawnY, this._spawnX, this._spawnY);
      const i = this._particles;
      let n = 0;
      for (let s = 0, r2 = i.length; s < r2; ++s) {
        const r3 = i[s];
        i[n] = r3, r3.Tick(t2), r3.IsActive() ? (++n, e.expandToContain(r3.GetBoundingBox())) : (r3.Destroy(), inactiveParticles.push(r3));
      }
      C32.truncateArray(i, n), inactiveParticles.length > 1e3 && C32.truncateArray(inactiveParticles, 1e3);
    }
    _MaybeFinishOneShot() {
      "one-shot" === this._sprayType && 0 === this._particles.length && this._isSpraying && (this.ononeshotfinish && this.ononeshotfinish(), this._isSpraying = false);
    }
    Draw(t2, e, i, n) {
      this._devicePixelRatio = globalThis.devicePixelRatio || 1, tempRect.set(e.getTlx(), e.getTly(), e.getBrx(), e.getBry()), t2.StartRenderingPoints(tempRect), this._color.copy(t2.GetColor());
      const s = this._particles;
      for (let r2 = 0, a2 = s.length; r2 < a2; ++r2) {
        const a3 = s[r2];
        i.intersectsRect(a3.GetBoundingBox()) && a3.Draw(t2, e, n);
      }
      t2.FinishRenderingPoints();
    }
    GetColor() {
      return this._color;
    }
    SetRate(t2) {
      this._rate = +t2;
    }
    GetRate() {
      return this._rate;
    }
    SetSprayCone(t2) {
      this._sprayCone = +t2;
    }
    GetSprayCone() {
      return this._sprayCone;
    }
    SetSprayType(t2) {
      if (!VALID_SPRAY_TYPES.has(t2)) throw new Error("invalid spray type");
      this._sprayType = t2;
    }
    GetSprayType() {
      return this._sprayType;
    }
    SetSpraying(t2) {
      this._isSpraying = !!t2;
    }
    IsSpraying() {
      return this._isSpraying;
    }
    SetMasterOpacity(t2) {
      this._masterOpacity = +t2;
    }
    GetMasterOpacity() {
      return this._masterOpacity;
    }
    SetPixelRounding(t2) {
      this._isPixelRounding = !!t2;
    }
    IsPixelRounding() {
      return this._isPixelRounding;
    }
    SetSpawnX(t2) {
      this._spawnX = +t2;
    }
    GetSpawnX() {
      return this._spawnX;
    }
    SetSpawnY(t2) {
      this._spawnY = +t2;
    }
    GetSpawnY() {
      return this._spawnY;
    }
    SetSpawnAngle(t2) {
      this._spawnAngle = +t2;
    }
    GetInitAngle() {
      return this._spawnAngle;
    }
    SetInitSpeed(t2) {
      this._initSpeed = +t2;
    }
    GetInitSpeed() {
      return this._initSpeed;
    }
    SetInitSize(t2) {
      this._initSize = +t2;
    }
    GetInitSize() {
      return this._initSize;
    }
    SetInitSizeScale(t2) {
      this._initSizeScale = +t2;
    }
    GetInitSizeScale() {
      return this._initSizeScale;
    }
    SetInitOpacity(t2) {
      this._initOpacity = +t2;
    }
    GetInitOpacity() {
      return this._initOpacity;
    }
    SetGrowRate(t2) {
      this._growRate = +t2;
    }
    GetGrowRate() {
      return this._growRate;
    }
    SetInitXRandom(t2) {
      this._xRandom = +t2;
    }
    GetInitXRandom() {
      return this._xRandom;
    }
    SetInitYRandom(t2) {
      this._yRandom = +t2;
    }
    GetInitYRandom() {
      return this._yRandom;
    }
    SetInitSpeedRandom(t2) {
      this._initSpeedRandom = +t2;
    }
    GetInitSpeedRandom() {
      return this._initSpeedRandom;
    }
    SetInitSizeRandom(t2) {
      this._initSizeRandom = +t2;
    }
    GetInitSizeRandom() {
      return this._initSizeRandom;
    }
    SetGrowRandom(t2) {
      this._growRandom = +t2;
    }
    GetGrowRandom() {
      return this._growRandom;
    }
    SetAcceleration(t2) {
      this._acceleration = +t2;
    }
    GetAcceleration() {
      return this._acceleration;
    }
    SetGravity(t2) {
      this._gravity = +t2;
    }
    GetGravity() {
      return this._gravity;
    }
    SetLifeAngleRandom(t2) {
      this._lifeAngleRandom = +t2;
    }
    GetLifeAngleRandom() {
      return this._lifeAngleRandom;
    }
    SetLifeSpeedRandom(t2) {
      this._lifeSpeedRandom = +t2;
    }
    GetLifeSpeedRandom() {
      return this._lifeSpeedRandom;
    }
    SetLifeOpacityRandom(t2) {
      this._lifeOpacityRandom = +t2;
    }
    GetLifeOpacityRandom() {
      return this._lifeOpacityRandom;
    }
    SetDestroyMode(t2) {
      let e = DESTROY_MODES.indexOf(t2);
      if (-1 === e) throw new Error("invalid destroy mode");
      this._destroyMode = e;
    }
    SetDestroyModeIndex(t2) {
      this.SetDestroyMode(DESTROY_MODES[t2]);
    }
    GetDestroyMode() {
      return DESTROY_MODES[this._destroyMode];
    }
    GetDestroyModeIndex() {
      return this._destroyMode;
    }
    SetTimeout(t2) {
      this._timeout = +t2;
    }
    GetTimeout() {
      return this._timeout;
    }
    SetParticleScale(t2) {
      this._particleScale = +t2;
    }
    GetParticleScale() {
      return this._particleScale;
    }
    GetBoundingBox() {
      return this._boundingBox;
    }
    GetDevicePixelRatio() {
      return this._devicePixelRatio;
    }
  };
}
{
  let randomOffset = function(t2) {
    return Math.random() * t2 - t2 / 2;
  };
  randomOffset2 = randomOffset;
  const C32 = self.C3, ParticleEngine = self.ParticleEngine;
  const tmpQuad = new C32.Quad(), tmpColor = new C32.Color();
  let didChangeColor = false;
  self.Particle = class {
    constructor(t2) {
      this._engine = t2, this._isActive = false, this._x = 0, this._y = 0, this._speed = 0, this._angle = 0, this._opacity = 1, this._lastOpacity = 0, this._grow = 0, this._size = 0, this._halfSize = 0, this._gs = 0, this._age = 0, this._bbox = new C32.Rect(), this._userData = null, this._userDataUid = NaN, this._updateCallback = null, this._destroyCallback = null;
    }
    SetEngine(t2) {
      this._engine = t2;
    }
    Init(t2) {
      const e = this._engine;
      this._isActive = true, this._x = e.GetSpawnX() + randomOffset(e.GetInitXRandom()), this._y = e.GetSpawnY() + randomOffset(e.GetInitYRandom()), this._speed = e.GetInitSpeed() + randomOffset(e.GetInitSpeedRandom()), this._angle = e.GetInitAngle() + randomOffset(e.GetSprayCone()), this._opacity = e.GetInitOpacity(), this._lastOpacity = this._opacity, this._size = (e.GetInitSize() + randomOffset(e.GetInitSizeRandom())) * e.GetInitSizeScale(), this._halfSize = this._size / 2, this._grow = e.GetGrowRate() + randomOffset(e.GetGrowRandom()), this._gs = 0, this._age = 0, this._UpdateBoundingBox(), t2 ? this._userData || (this._userData = t2(this)) : (this._userData = null, this._updateCallback = null, this._destroyCallback = null);
    }
    UpdateUserData(t2) {
      t2 ? this._userData && !this._userData.IsDestroyed() || (this._userData = t2(this, this._userDataUid)) : (this._userData = null, this._updateCallback = null, this._destroyCallback = null);
    }
    SetUpdateCallback(t2) {
      this._updateCallback = t2;
    }
    SetDestroyCallback(t2) {
      this._destroyCallback = t2;
    }
    Destroy() {
      const t2 = this._destroyCallback;
      t2 && t2(this._userData), this._userData = null, this._updateCallback = null, this._destroyCallback = null;
    }
    toJSON() {
      let t2;
      return this._userData && this._userData.GetWorldInfo() && (t2 = this._userData.GetWorldInfo().GetInstance().GetUID()), [this._x, this._y, this._speed, this._angle, this._opacity, this._grow, this._size, this._gs, this._age, t2];
    }
    setFromJSON(t2) {
      this._x = t2[0], this._y = t2[1], this._speed = t2[2], this._angle = t2[3], this._opacity = t2[4], this._lastOpacity = this._opacity, this._grow = t2[5], this._size = t2[6], this._gs = t2[7], this._age = t2[8], this._userDataUid = t2[9], this._halfSize = this._size / 2, this._UpdateBoundingBox();
    }
    Tick(t2) {
      const e = this._engine, i = this._speed * t2, s = this._angle, a2 = Math.cos(s) * i, h2 = Math.sin(s) * i + this._gs * t2;
      this._x += a2, this._y += h2;
      const n = this._grow * t2;
      this._size += n, this._halfSize = this._size / 2, this._speed += e.GetAcceleration() * t2, this._gs += e.GetGravity() * t2, this._age += t2, this._UpdateBoundingBox();
      const _2 = e.GetLifeAngleRandom(), o2 = e.GetLifeSpeedRandom(), l = e.GetLifeOpacityRandom();
      let r2 = 0;
      0 !== _2 && (r2 = randomOffset(_2 * t2), this._angle += r2), 0 !== o2 && (this._speed += randomOffset(o2 * t2)), 0 !== l && (this._opacity = C32.clamp(this._opacity + randomOffset(l * t2), 0, 1));
      const d2 = this._size >= 1 && (2 === e.GetDestroyModeIndex() ? this._speed > 0 : this._age < e.GetTimeout()), c2 = this._updateCallback;
      if (c2 && d2) {
        let t3 = e.GetMasterOpacity() * this._opacity;
        0 === e.GetDestroyModeIndex() && (t3 *= 1 - this._age / e.GetTimeout());
        const i2 = t3 - this._lastOpacity;
        this._lastOpacity = t3, c2(this._userData, a2, h2, n, r2, i2);
      }
      this._isActive = d2;
    }
    IsActive() {
      return this._isActive;
    }
    GetBoundingBox() {
      return this._bbox;
    }
    _UpdateBoundingBox() {
      const t2 = this._x, e = this._y, i = this._halfSize;
      this._bbox.set(t2 - i, e - i, t2 + i, e + i);
    }
    Draw(t2, e, i) {
      if (this._userData) return;
      const s = this._engine;
      let a2 = s.GetMasterOpacity() * this._opacity;
      if (0 === s.GetDestroyModeIndex() && (a2 *= 1 - this._age / s.GetTimeout()), a2 <= 0) return;
      const h2 = this._size, n = h2 * s.GetParticleScale() * s.GetDevicePixelRatio();
      if (n < 1) return;
      let _2 = this._x, o2 = this._y;
      s.IsPixelRounding() && (_2 = _2 + 0.5 | 0, o2 = o2 + 0.5 | 0), t2.IsWebGPU() ? t2.Point(_2, o2, h2, a2) : i || n > t2.GetMaxPointSize() || n < t2.GetMinPointSize() ? (tmpColor.copy(s.GetColor()), tmpColor.multiplyAlpha(a2), t2.SetColor(tmpColor), didChangeColor = true, tmpQuad.setFromRect(this._bbox), t2.Quad4(tmpQuad, e)) : (didChangeColor && (t2.SetColor(s.GetColor()), didChangeColor = false), t2.Point(_2, o2, n, a2));
    }
    GetUserData() {
      return this._userData;
    }
    GetUserDataUID() {
      return this._userDataUid;
    }
    GetX() {
      return this._x;
    }
    GetY() {
      return this._y;
    }
    GetSize() {
      return this._size;
    }
    GetAngle() {
      return this._angle;
    }
    GetOpacity() {
      return this._opacity;
    }
  };
}
var randomOffset2;
{
  {
    const t2 = self.C3;
    t2.Plugins.shadowlight = class extends t2.SDKPluginBase {
      constructor(t3) {
        super(t3);
      }
      Release() {
        super.Release();
      }
    };
  }
  {
    const t2 = self.C3;
    t2.Plugins.shadowlight.Type = class extends t2.SDKTypeBase {
      constructor(t3) {
        super(t3);
      }
      Release() {
        super.Release();
      }
      OnCreate() {
      }
      LoadTextures(t3) {
      }
      ReleaseTextures() {
      }
    };
  }
  {
    const t2 = self.C3, e = self.C3X, s = 0, i = 1, h2 = 2, r2 = 3, a2 = 4, o2 = 0, n = 1, l = 2, g2 = [0, 0, 0], _2 = ["all", "same-tag", "different-tag"], d2 = t2.New(t2.Color), c2 = t2.New(t2.CollisionPoly), u2 = [], w2 = t2.New(t2.Rect);
    t2.Plugins.shadowlight.Instance = class extends t2.SDKWorldInstanceBase {
      constructor(e2, o3) {
        super(e2);
        const n2 = this.GetWorldInfo();
        if (this._lightX = n2.GetX(), this._lightY = n2.GetY(), this._lightZ = 0, this._maxExtrude = 1e3, this._lightRadius = 0, this._color = t2.New(t2.Color), this._castFrom = 0, this._tag = "", this._lastKnownX = n2.GetX(), this._lastKnownY = n2.GetY(), o3) {
          this._lightZ = o3[s], this._lightRadius = 0 === this._lightZ ? o3[i] : 0;
          const t3 = o3[h2];
          this._color.setRgb(t3[0], t3[1], t3[2]), this._castFrom = o3[r2], this._tag = o3[a2];
        }
        this._shadowRenderer = t2.New(self.ShadowRenderer), this._StartTicking2();
      }
      Release() {
        this._shadowRenderer && (this._shadowRenderer.Release(), this._shadowRenderer = null), this._color = null, super.Release();
      }
      SaveToJson() {
        return { "lx": this._lightX, "ly": this._lightY, "lh": this._lightZ, "lr": this._lightRadius, "lkx": this._lastKnownX, "lky": this._lastKnownY, "sc": this._color.toJSON(), "cf": this._castFrom, "t": this._tag };
      }
      LoadFromJson(t3) {
        t3.hasOwnProperty("lx") && (this._lightX = t3["lx"]), t3.hasOwnProperty("ly") && (this._lightY = t3["ly"]), this._lightZ = t3["lh"], this._lightRadius = t3["lr"], t3.hasOwnProperty("lkx") && (this._lastKnownX = t3["lkx"]), t3.hasOwnProperty("lky") && (this._lastKnownY = t3["lky"]), this._color.setFromJSON(t3["sc"]), this._castFrom = t3["cf"], this._tag = t3["t"];
      }
      _CastsFrom(e2) {
        switch (this._castFrom) {
          case o2:
            return true;
          case n:
            return t2.equalsNoCase(this._tag, e2);
          case l:
            return !t2.equalsNoCase(this._tag, e2);
        }
      }
      Tick2() {
        const e2 = this.GetWorldInfo();
        this._lastKnownX === e2.GetX() && this._lastKnownY === e2.GetY() || (this._lightX = e2.GetX(), this._lightY = e2.GetY());
        const s2 = w2;
        e2.GetLayer().GetViewportForZ(e2.GetTotalZElevation(), s2), this._maxExtrude = 15 * t2.distanceTo(s2.getLeft(), s2.getTop(), s2.getRight(), s2.getBottom());
        const i2 = s2.midX(), h3 = s2.midY();
        let r3 = s2.width() + this._maxExtrude, a3 = s2.height() + this._maxExtrude;
        e2.HasParent() ? (r3 += 2 * Math.abs(e2.GetX() - i2), a3 += 2 * Math.abs(e2.GetY() - h3), r3 === e2.GetWidth() && a3 === e2.GetHeight() || (e2.SetSize(r3, a3), e2.SetBboxChanged())) : i2 === e2.GetX() && h3 === e2.GetY() && r3 === e2.GetWidth() && a3 === e2.GetHeight() || (e2.SetXY(i2, h3), e2.SetSize(r3, a3), e2.SetBboxChanged()), this._lastKnownX = e2.GetX(), this._lastKnownY = e2.GetY();
      }
      _GetShadowCasterCandidates() {
        const e2 = t2.AddonManager.GetBehaviorByConstructorFunction(t2.Behaviors.shadowcaster);
        if (!e2) return [];
        const s2 = this.GetWorldInfo(), i2 = s2.GetLayer(), h3 = s2.GetBoundingBox(), r3 = e2.GetObjectClasses(), a3 = [];
        return this._runtime.GetCollisionEngine().GetObjectClassesCollisionCandidates(i2, r3, h3, a3), [...new Set(a3)];
      }
      _UpdateShadowRendererParameters() {
        this._shadowRenderer.SetLightX(this._lightX), this._shadowRenderer.SetLightY(this._lightY), this._shadowRenderer.SetLightZ(this._lightZ), this._shadowRenderer.SetLightRadius(this._lightRadius), this._shadowRenderer.SetCastFrom(_2[this._castFrom]), this._shadowRenderer.SetTag(this._tag), this._shadowRenderer.SetMaxExtrude(this._maxExtrude);
      }
      Draw(t3) {
        this._UpdateShadowRendererParameters();
        const e2 = this.GetWorldInfo();
        d2.copyRgb(this._color), d2.setA(e2.GetOpacity()), d2.premultiply(), t3.SetColor(d2), t3.SetColorFillMode();
        for (const e3 of this._GetShadowCasterCandidates()) this._DrawInstanceShadow(t3, e3);
      }
      _DrawInstanceShadow(t3, e2) {
        const s2 = e2.GetSavedDataMap();
        if (!s2.get("shadowcasterEnabled") || !this._CastsFrom(s2.get("shadowcasterTag"))) return;
        const i2 = s2.get("shadowcasterHeight");
        if (e2.HasTilemap()) this._DrawTilemapShadow(t3, e2, i2);
        else {
          const s3 = e2.GetWorldInfo(), h3 = s3.GetTransformedCollisionPoly();
          c2.copy(h3), c2.offset(s3.GetX(), s3.GetY()), this._shadowRenderer.RenderShadow(t3, c2, i2);
        }
      }
      _DrawTilemapShadow(e2, s2, i2) {
        const h3 = u2, r3 = this.GetWorldInfo().GetBoundingBox();
        s2.GetSdkInstance().GetCollisionRectCandidates(r3, h3);
        const a3 = s2.GetWorldInfo(), o3 = a3.GetX(), n2 = a3.GetY();
        for (let t3 = 0, s3 = h3.length; t3 < s3; ++t3) {
          const s4 = h3[t3], r4 = s4.GetRect(), a4 = s4.GetPoly();
          a4 ? (c2.copy(a4), c2.offset(o3 + r4.getLeft(), n2 + r4.getTop())) : c2.setFromRect(r4, -o3, -n2), this._shadowRenderer.RenderShadow(e2, c2, i2);
        }
        t2.clearArray(h3);
      }
      _SetLightX(t3) {
        this._lightX !== t3 && (this._lightX = t3, this._runtime.UpdateRender());
      }
      _GetLightX() {
        return this._lightX;
      }
      _SetLightY(t3) {
        this._lightY !== t3 && (this._lightY = t3, this._runtime.UpdateRender());
      }
      _GetLightY() {
        return this._lightY;
      }
      _SetLightHeight(t3) {
        this._lightZ !== t3 && (this._lightZ = t3, this._runtime.UpdateRender());
      }
      _GetLightHeight() {
        return this._lightZ;
      }
      _SetLightColor(t3) {
        this._color.equalsIgnoringAlpha(t3) || (this._color.copyRgb(t3), this._runtime.UpdateRender());
      }
      _GetLightColor() {
        return this._color;
      }
      _SetTag(t3) {
        this._tag !== t3 && (this._tag = t3, this._runtime.UpdateRender());
      }
      _GetTag() {
        return this._tag;
      }
      _SetCastFrom(t3) {
        this._castFrom !== t3 && (this._castFrom = t3, this._runtime.UpdateRender());
      }
      _GetCastFrom() {
        return this._castFrom;
      }
      GetPropertyValueByIndex(t3) {
        switch (t3) {
          case s:
            return this._GetLightHeight();
          case i:
            return this._lightRadius;
          case h2:
            return g2[0] = this._color.getR(), g2[1] = this._color.getG(), g2[2] = this._color.getB(), g2.slice(0);
          case r2:
            return this._GetCastFrom();
          case a2:
            return this._GetTag();
        }
      }
      SetPropertyValueByIndex(t3, e2) {
        switch (t3) {
          case s:
            this._SetLightHeight(e2);
            break;
          case i:
            this._lightRadius = e2;
            break;
          case h2:
            this._color.setRgb(e2[0], e2[1], e2[2]);
            break;
          case r2:
            this._SetCastFrom(e2);
            break;
          case a2:
            this._SetTag(e2);
        }
      }
      SetPropertyColorOffsetValueByIndex(t3, e2, s2, i2) {
        if ((0 !== e2 || 0 !== s2 || 0 !== i2) && t3 === h2) this._color.addRgb(e2, s2, i2);
      }
      GetDebuggerProperties() {
        const t3 = "plugins.shadowlight";
        return [{ title: t3 + ".name", properties: [{ name: t3 + ".properties.light-height.name", value: this._GetLightHeight(), onedit: (t4) => this._SetLightHeight(t4) }, { name: t3 + ".properties.tag.name", value: this._GetTag(), onedit: (t4) => this._SetTag(t4) }] }];
      }
      GetScriptInterfaceClass() {
        return self.IShadowLightInstance;
      }
    };
    const G = /* @__PURE__ */ new WeakMap(), S2 = ["all", "same-tag", "different-tag"];
    self.IShadowLightInstance = class extends self.IWorldInstance {
      constructor() {
        super(), G.set(this, self.IInstance._GetInitInst().GetSdkInstance());
      }
      set lightX(t3) {
        e.RequireFiniteNumber(t3), G.get(this)._SetLightX(t3);
      }
      get lightX() {
        return G.get(this)._GetLightX();
      }
      set lightY(t3) {
        e.RequireFiniteNumber(t3), G.get(this)._SetLightY(t3);
      }
      get lightY() {
        return G.get(this)._GetLightY();
      }
      set lightHeight(t3) {
        e.RequireFiniteNumber(t3), G.get(this)._SetLightHeight(t3);
      }
      get lightHeight() {
        return G.get(this)._GetLightHeight();
      }
      set shadowColor(t3) {
        if (e.RequireArray(t3), t3.length < 3) throw new Error("expected 3 elements");
        d2.setRgb(t3[0], t3[1], t3[2]), G.get(this)._SetLightColor(d2);
      }
      get shadowColor() {
        const t3 = G.get(this)._GetLightColor();
        return [t3.getR(), t3.getG(), t3.getB()];
      }
      set tag(t3) {
        e.RequireString(t3), G.get(this)._SetTag(t3);
      }
      get tag() {
        return G.get(this)._GetTag();
      }
      set castFrom(t3) {
        const e2 = S2.indexOf(t3);
        if (-1 === e2) throw new Error("invalid mode");
        G.get(this)._SetCastFrom(e2);
      }
      get castFrom() {
        return S2[G.get(this)._GetCastFrom()];
      }
    };
  }
  self.C3.Plugins.shadowlight.Cnds = {};
  {
    const t2 = self.C3, e = t2.New(t2.Color);
    t2.Plugins.shadowlight.Acts = { SetLightHeight(t3) {
      this._SetLightHeight(t3);
    }, SetLightColor(t3) {
      e.setFromRgbValue(t3), e.clamp(), this._SetLightColor(e);
    }, SetTag(t3) {
      this._SetTag(t3);
    }, SetCastFrom(t3) {
      this._SetCastFrom(t3);
    }, SetLightPosition(t3, e2) {
      this._SetLightX(t3), this._SetLightY(e2);
    } };
  }
  self.C3.Plugins.shadowlight.Exps = { LightX() {
    return this._GetLightX();
  }, LightY() {
    return this._GetLightY();
  }, Tag() {
    return this._GetTag();
  } };
}
{
  let IsBackFace = function(t2, s, i, a2, h2, e) {
    let _2 = C32.angleTo(i, a2, h2, e) - Math.PI / 2, r2 = C32.angleTo(i, a2, t2, s);
    return C32.angleDiff(r2, _2) >= Math.PI / 2;
  }, SegmentIntersectionAt = function(t2, s, i, a2, h2, e, _2, r2) {
    let c2 = i - t2, l = a2 - s, o2 = _2 - h2, d2 = r2 - e, g2 = -o2 * l + c2 * d2;
    if (0 === g2) return false;
    let u2 = (-l * (t2 - h2) + c2 * (s - e)) / g2;
    if (g2 = -o2 * l + c2 * d2, 0 === g2) return false;
    let n = (o2 * (s - e) - d2 * (t2 - h2)) / g2;
    return u2 >= 0 && u2 <= 1 && n >= 0 && n <= 1 && (segmentIntersectX = t2 + n * c2, segmentIntersectY = s + n * l, true);
  };
  IsBackFace2 = IsBackFace, SegmentIntersectionAt2 = SegmentIntersectionAt;
  const C32 = self.C3;
  let segmentIntersectX = 0, segmentIntersectY = 0;
  let posQuad = new C32.Quad(), uvQuad = new C32.Quad();
  const VALID_CASTFROM = /* @__PURE__ */ new Set(["all", "same-tag", "different-tag"]);
  self.ShadowRenderer = class {
    constructor() {
      this._lightX = 0, this._lightY = 0, this._lightZ = 0, this._lightRadius = 0, this._castFrom = "all", this._tag = "", this._maxExtrude = 1e3, this._backFaces1 = [], this._backFaces2 = [], this._umbraPts = [], this._cwEdge1 = -1, this._cwEdge2 = -1, this._acwEdge1 = -1, this._acwEdge2 = -1, this._acwUmbraRootX = 0, this._acwUmbraRootY = 0, this._cwUmbraRootX = 0, this._cwUmbraRootY = 0, this._acwUmbraProjX = 0, this._acwUmbraProjY = 0, this._cwUmbraProjX = 0, this._cwUmbraProjY = 0, this._polyMidX = 0, this._polyMidY = 0;
    }
    Release() {
      this.Reset(), this._backFaces1 = null, this._backFaces2 = null, this._umbraPts = null;
    }
    Reset() {
      C32.clearArray(this._backFaces1), C32.clearArray(this._backFaces2), C32.clearArray(this._umbraPts), this._cwEdge1 = -1, this._cwEdge2 = -1, this._acwEdge1 = -1, this._acwEdge2 = -1, this._acwUmbraRootX = 0, this._acwUmbraRootY = 0, this._cwUmbraRootX = 0, this._cwUmbraRootY = 0, this._acwUmbraProjX = 0, this._acwUmbraProjY = 0, this._cwUmbraProjX = 0, this._cwUmbraProjY = 0, this._polyMidX = 0, this._polyMidY = 0;
    }
    SetLightX(t2) {
      this._lightX = t2;
    }
    GetLightX() {
      return this._lightX;
    }
    SetLightY(t2) {
      this._lightY = t2;
    }
    GetLightY() {
      return this._lightY;
    }
    SetLightZ(t2) {
      this._lightZ = t2;
    }
    GetLightZ() {
      return this._lightZ;
    }
    SetLightRadius(t2) {
      t2 < 0 && (t2 = 0), this._lightRadius = t2;
    }
    GetLightRadius() {
      return this._lightRadius;
    }
    SetCastFrom(t2) {
      if (!VALID_CASTFROM.has(t2)) throw new Error("invalid cast-from");
      this._castFrom = t2;
    }
    GetCastFrom() {
      return this._castFrom;
    }
    SetTag(t2) {
      this._tag = t2;
    }
    GetTag() {
      return this._tag;
    }
    SetMaxExtrude(t2) {
      this._maxExtrude = t2;
    }
    GetMaxExtrude() {
      return this._maxExtrude;
    }
    RenderShadow(t2, s, i) {
      this.Reset(), this.CalculateShadow(s, i), t2.SetColorFillMode(), this._umbraPts.length >= 6 && t2.ConvexPoly(this._umbraPts), this._lightRadius > 0 && (this._cwEdge1 > -1 && this._cwEdge2 > -1 && (t2.SetPenumbraFillMode(), this.FillPenumbra(t2, s, true)), this._acwEdge1 > -1 && this._acwEdge2 > -1 && (t2.SetPenumbraFillMode(), this.FillPenumbra(t2, s, false)));
    }
    CalculateShadow(t2, s) {
      this._polyMidX = t2.GetMidX(), this._polyMidY = t2.GetMidY(), this._lightRadius > 0 ? this._CalculateShadowWithRadius(t2, s) : this._CalculateShadowWithoutRadius(t2, s);
    }
    _CalculateShadowWithRadius(t2, s) {
      this._CalcBackFaces(t2, -this._lightRadius), this._FindEdges(), C32.shallowAssignArray(this._backFaces2, this._backFaces1), this._cwEdge2 = this._cwEdge1, this._acwEdge2 = this._acwEdge1, C32.clearArray(this._backFaces1), this._cwEdge1 = -1, this._acwEdge1 = -1, this._CalcBackFaces(t2, this._lightRadius), this._FindEdges(), -1 !== this._cwEdge1 && -1 !== this._acwEdge1 && -1 !== this._cwEdge2 && -1 !== this._acwEdge2 && this._CalcUmbraWithRadius(t2, s);
    }
    _CalculateShadowWithoutRadius(t2, s) {
      this._CalcBackFaces(t2, 0), this._FindEdges();
      let i = t2.GetPointsArray();
      for (let t3 = 0, a2 = i.length; t3 < a2; t3 += 2) {
        let a3 = i[t3], h2 = i[t3 + 1];
        this._CalcShadowSegment(t3 / 2, this._lightX, this._lightY, a3, h2, s);
      }
    }
    _CalcBackFaces(t2, s) {
      let i = this._lightX, a2 = this._lightY, h2 = i, e = a2, _2 = 0;
      0 !== s && (_2 = C32.angleTo(i, a2, this._polyMidX, this._polyMidY) - Math.PI / 2);
      let r2 = t2.GetPointsArray();
      for (let t3 = 0, c2 = r2.length; t3 < c2; t3 += 2) {
        let l = t3 + 2;
        l === c2 && (l = 0);
        let o2 = r2[t3], d2 = r2[t3 + 1], g2 = r2[l], u2 = r2[l + 1];
        0 !== s && (h2 = i + Math.cos(_2) * s, e = a2 + Math.sin(_2) * s), this._backFaces1.push(IsBackFace(h2, e, o2, d2, g2, u2));
      }
    }
    _GetBackFaceAt(t2) {
      return (t2 %= this._backFaces1.length) < 0 && (t2 += this._backFaces1.length), this._backFaces1[t2];
    }
    _FindEdges() {
      for (let t2 = 0, s = this._backFaces1.length; t2 < s; ++t2) {
        let s2 = this._backFaces1[t2], i = this._GetBackFaceAt(t2 - 1);
        i && !s2 && (this._cwEdge1 = t2), !i && s2 && (this._acwEdge1 = t2);
      }
    }
    _CalcShadowSegment(t2, s, i, a2, h2, e) {
      let _2 = this._backFaces1[t2], r2 = this._GetBackFaceAt(t2 - 1), c2 = t2 === this._cwEdge1, l = t2 === this._acwEdge1, o2 = 0, d2 = 0;
      if (_2 || r2) {
        let t3 = C32.angleTo(s, i, a2, h2), _3 = C32.distanceTo(s, i, a2, h2), r3 = this._CalculateExtrusion(s, i, a2, h2, e);
        o2 = s + Math.cos(t3) * (_3 + r3), d2 = i + Math.sin(t3) * (_3 + r3);
      } else o2 = a2, d2 = h2;
      l && (this._umbraPts.push(a2), this._umbraPts.push(h2)), this._umbraPts.push(o2), this._umbraPts.push(d2), c2 && (this._umbraPts.push(a2), this._umbraPts.push(h2));
    }
    _CalculateExtrusion(t2, s, i, a2, h2) {
      if (h2 >= this._lightZ) return this._maxExtrude;
      if (h2 <= 0) return 0;
      let e = h2 * (C32.distanceTo(t2, s, i, a2) / (this._lightZ - h2));
      return C32.clamp(e, 0, this._maxExtrude);
    }
    _CalcUmbraWithRadius(t2, s) {
      let i = this._cwEdge2, a2 = 0, h2 = 0, e = t2.GetPointCount(), _2 = t2.GetPointsArray();
      for (; ; ++i) {
        i === e && (i = 0);
        let t3 = 2 * i;
        if (a2 = _2[t3], h2 = _2[t3 + 1], this._umbraPts.push(a2), this._umbraPts.push(h2), i === this._acwEdge1) break;
      }
      let r2 = this._lightRadius, c2 = a2, l = h2, o2 = C32.angleTo(this._lightX, this._lightY, this._polyMidX, this._polyMidY), d2 = this._lightX + Math.cos(o2 - Math.PI / 2) * r2, g2 = this._lightY + Math.sin(o2 - Math.PI / 2) * r2, u2 = C32.angleTo(d2, g2, c2, l), n = C32.distanceTo(d2, g2, c2, l), m2 = d2 + Math.cos(u2) * (n + this._maxExtrude), w2 = g2 + Math.sin(u2) * (n + this._maxExtrude), b2 = 2 * this._cwEdge2, E2 = _2[b2], P2 = _2[b2 + 1];
      o2 = C32.angleTo(this._lightX, this._lightY, this._polyMidX, this._polyMidY);
      let C2 = this._lightX + Math.cos(o2 + Math.PI / 2) * r2, M2 = this._lightY + Math.sin(o2 + Math.PI / 2) * r2;
      u2 = C32.angleTo(C2, M2, E2, P2), n = C32.distanceTo(C2, M2, E2, P2);
      let X = C2 + Math.cos(u2) * (n + this._maxExtrude), Y = M2 + Math.sin(u2) * (n + this._maxExtrude);
      this._acwUmbraRootX = c2, this._acwUmbraRootY = l, this._cwUmbraRootX = E2, this._cwUmbraRootY = P2, SegmentIntersectionAt(c2, l, m2, w2, E2, P2, X, Y) ? (this._umbraPts.push(segmentIntersectX), this._umbraPts.push(segmentIntersectY), this._acwUmbraProjX = segmentIntersectX, this._acwUmbraProjY = segmentIntersectY, this._cwUmbraProjX = segmentIntersectX, this._cwUmbraProjY = segmentIntersectY) : (this._umbraPts.push(m2), this._umbraPts.push(w2), this._umbraPts.push(X), this._umbraPts.push(Y), this._acwUmbraProjX = m2, this._acwUmbraProjY = w2, this._cwUmbraProjX = X, this._cwUmbraProjY = Y);
    }
    FillPenumbra(t2, s, i) {
      let a2 = this._lightX, h2 = this._lightY, e = s.GetPointsArray(), _2 = 0, r2 = 0, c2 = 0, l = 0;
      i ? (_2 = this._cwUmbraRootX, r2 = this._cwUmbraRootY, c2 = this._cwUmbraProjX, l = this._cwUmbraProjY) : (_2 = this._acwUmbraRootX, r2 = this._acwUmbraRootY, c2 = this._acwUmbraProjX, l = this._acwUmbraProjY);
      let o2 = this._lightRadius, d2 = C32.angleTo(a2, h2, this._polyMidX, this._polyMidY), g2 = Math.PI / 2;
      i && (g2 = -g2), a2 += Math.cos(d2 + g2) * o2, h2 += Math.sin(d2 + g2) * o2;
      let u2 = false, n = 0, m2 = 0;
      i ? (u2 = this._cwEdge1 !== this._cwEdge2, u2 && (n = e[2 * this._cwEdge1], m2 = e[2 * this._cwEdge1 + 1])) : (u2 = this._acwEdge1 !== this._acwEdge2, u2 && (n = e[2 * this._acwEdge2], m2 = e[2 * this._acwEdge2 + 1])), d2 = u2 ? C32.angleTo(n, m2, _2, r2) : C32.angleTo(a2, h2, _2, r2);
      let w2 = _2 + Math.cos(d2) * this._maxExtrude, b2 = r2 + Math.sin(d2) * this._maxExtrude, E2 = 0, P2 = 0, C2 = 0;
      if (u2) {
        let t3 = C32.angleTo(a2, h2, n, m2);
        E2 = n + Math.cos(t3) * this._maxExtrude, P2 = m2 + Math.sin(t3) * this._maxExtrude;
        let s2 = d2, i2 = C32.angleTo(_2, r2, c2, l);
        C2 = C32.angleDiff(s2, t3) / C32.angleDiff(i2, t3);
      }
      posQuad.set(_2, r2, c2, l, w2, b2, w2, b2), uvQuad.set(0, 1, 1, 0, C2, 0, C2, 0), t2.Quad4(posQuad, uvQuad), u2 && (posQuad.set(n, m2, w2, b2, E2, P2, E2, P2), uvQuad.set(0, 1, C2, 0, 0, 0, 0, 0), t2.Quad4(posQuad, uvQuad));
    }
  };
}
var IsBackFace2;
var SegmentIntersectionAt2;
{
  {
    const e = self.C3;
    e.Plugins.Keyboard = class extends e.SDKPluginBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
    };
  }
  {
    let GetKeyboardSdkInstance = function() {
      return t2.GetSingleGlobalInstance().GetSdkInstance();
    };
    GetKeyboardSdkInstance2 = GetKeyboardSdkInstance;
    const r2 = self.C3;
    self.C3X;
    r2.Plugins.Keyboard.Type = class extends r2.SDKTypeBase {
      constructor(e) {
        super(e);
      }
      Release() {
        super.Release();
      }
      OnCreate() {
      }
      GetScriptInterfaceClass() {
        return self.IKeyboardObjectType;
      }
    };
    let t2 = null;
    self.IKeyboardObjectType = class extends self.IObjectType {
      constructor(e) {
        super(e), t2 = e, e.GetRuntime()._GetCommonScriptInterfaces().keyboard = this;
      }
      isKeyDown(e) {
        const r3 = GetKeyboardSdkInstance();
        if ("string" == typeof e) return r3.IsKeyDown(e);
        if ("number" == typeof e) return r3.IsKeyCodeDown(e);
        throw new TypeError("expected string or number");
      }
    };
  }
  {
    const s = self.C3, n = "keyboard";
    s.Plugins.Keyboard.Instance = class extends s.SDKInstanceBase {
      constructor(e, r2) {
        super(e, n), this._keysDownByString = /* @__PURE__ */ new Set(), this._keysDownByWhich = /* @__PURE__ */ new Set(), this._triggerWhich = 0, this._triggerString = "", this._triggerTypedKey = "", this._isKeyboardLockSupported = false;
        const t2 = this.GetRuntime().Dispatcher();
        this._disposables = new s.CompositeDisposable(s.Disposable.From(t2, "keydown", (e2) => this._OnKeyDown(e2.data)), s.Disposable.From(t2, "keyup", (e2) => this._OnKeyUp(e2.data)), s.Disposable.From(t2, "window-blur", () => this._OnWindowOrKeyboardBlur()), s.Disposable.From(t2, "keyboard-blur", () => this._OnWindowOrKeyboardBlur())), this._runtime.AddLoadPromise(this._Init());
      }
      Release() {
        super.Release();
      }
      async _Init() {
        const e = await this.PostToDOMAsync("init");
        this._isKeyboardLockSupported = e["isKeyboardLockSupported"];
      }
      _OnKeyDown(e) {
        const r2 = e["which"], t2 = e["code"] || r2.toString(), n2 = e["key"];
        this._keysDownByString.has(t2) || (this._keysDownByString.add(t2), this._keysDownByWhich.add(r2), this._triggerString = t2, this._triggerWhich = r2, this._triggerTypedKey = n2, this.Trigger(s.Plugins.Keyboard.Cnds.OnAnyKey), this.Trigger(s.Plugins.Keyboard.Cnds.OnKey), this.Trigger(s.Plugins.Keyboard.Cnds.OnLeftRightKeyPressed), this.Trigger(s.Plugins.Keyboard.Cnds.OnKeyCode));
      }
      _OnKeyUp(e) {
        const r2 = e["which"], t2 = e["code"] || r2.toString(), n2 = e["key"];
        this._keysDownByString.delete(t2), this._keysDownByWhich.delete(r2), this._triggerString = t2, this._triggerWhich = r2, this._triggerTypedKey = n2, this.Trigger(s.Plugins.Keyboard.Cnds.OnAnyKeyReleased), this.Trigger(s.Plugins.Keyboard.Cnds.OnKeyReleased), this.Trigger(s.Plugins.Keyboard.Cnds.OnLeftRightKeyReleased), this.Trigger(s.Plugins.Keyboard.Cnds.OnKeyCodeReleased);
      }
      _OnWindowOrKeyboardBlur() {
        for (const e of this._keysDownByWhich) this._keysDownByWhich.delete(e), this._triggerWhich = e, this.Trigger(s.Plugins.Keyboard.Cnds.OnAnyKeyReleased), this.Trigger(s.Plugins.Keyboard.Cnds.OnKeyReleased), this.Trigger(s.Plugins.Keyboard.Cnds.OnKeyCodeReleased);
        this._keysDownByString.clear();
      }
      IsKeyDown(e) {
        return this._keysDownByString.has(e);
      }
      IsKeyCodeDown(e) {
        return this._keysDownByWhich.has(e);
      }
      SaveToJson() {
        return { "tk": this._triggerWhich, "tkk": this._triggerTypedKey };
      }
      LoadFromJson(e) {
        this._triggerWhich = e["tk"], e.hasOwnProperty("tkk") && (this._triggerTypedKey = e["tkk"]);
      }
      GetDebuggerProperties() {
        const e = "plugins.keyboard";
        return [{ title: e + ".name", properties: [{ name: e + ".debugger.last-key-code", value: this._triggerWhich }, { name: e + ".debugger.last-key-string", value: s.Plugins.Keyboard.Exps.StringFromKeyCode(this._triggerWhich) }, { name: e + ".debugger.last-typed-key", value: this._triggerTypedKey }] }];
      }
    };
  }
  {
    const i = self.C3, a2 = ["ShiftLeft", "ShiftRight", "ControlLeft", "ControlRight", "AltLeft", "AltRight", "MetaLeft", "MetaRight"];
    i.Plugins.Keyboard.Cnds = { IsKeyDown(e) {
      return this._keysDownByWhich.has(e);
    }, OnKey(e) {
      return this._triggerWhich === e;
    }, OnAnyKey: () => true, OnAnyKeyReleased: () => true, OnKeyReleased(e) {
      return this._triggerWhich === e;
    }, IsKeyCodeDown(e) {
      return e = Math.floor(e), this._keysDownByWhich.has(e);
    }, OnKeyCode(e) {
      return this._triggerWhich === e;
    }, OnKeyCodeReleased(e) {
      return this._triggerWhich === e;
    }, OnLeftRightKeyPressed(e) {
      const r2 = a2[e];
      return this._triggerString === r2;
    }, OnLeftRightKeyReleased(e) {
      const r2 = a2[e];
      return this._triggerString === r2;
    }, IsLeftRightKeyDown(e) {
      const r2 = a2[e];
      return this._keysDownByString.has(r2);
    }, IsKeyboardLockSupported() {
      return this._isKeyboardLockSupported;
    }, OnKeyboardLocked: () => true, OnKeyboardLockError: () => true };
  }
  {
    const o2 = self.C3;
    o2.Plugins.Keyboard.Acts = { async LockKeyboard(e) {
      if (!this._isKeyboardLockSupported) return;
      let r2 = [];
      e && (r2 = e.split(","));
      (await this.PostToDOMAsync("lock-keyboard", { "keysArr": r2 }))["isOk"] ? this.Trigger(o2.Plugins.Keyboard.Cnds.OnKeyboardLocked) : this.Trigger(o2.Plugins.Keyboard.Cnds.OnKeyboardLockError);
    }, UnlockKeyboard() {
      this._isKeyboardLockSupported && this.PostToDOMAsync("unlock-keyboard");
    } };
  }
  {
    let StringFromCharCode = function(e) {
      switch (e = Math.floor(e)) {
        case 8:
          return "backspace";
        case 9:
          return "tab";
        case 13:
          return "enter";
        case 16:
          return "shift";
        case 17:
          return "control";
        case 18:
          return "alt";
        case 19:
          return "pause";
        case 20:
          return "capslock";
        case 27:
          return "esc";
        case 33:
          return "pageup";
        case 34:
          return "pagedown";
        case 35:
          return "end";
        case 36:
          return "home";
        case 37:
          return "\u2190";
        case 38:
          return "\u2191";
        case 39:
          return "\u2192";
        case 40:
          return "\u2193";
        case 45:
          return "insert";
        case 46:
          return "del";
        case 91:
          return "left window key";
        case 92:
          return "right window key";
        case 93:
          return "select";
        case 96:
          return "numpad 0";
        case 97:
          return "numpad 1";
        case 98:
          return "numpad 2";
        case 99:
          return "numpad 3";
        case 100:
          return "numpad 4";
        case 101:
          return "numpad 5";
        case 102:
          return "numpad 6";
        case 103:
          return "numpad 7";
        case 104:
          return "numpad 8";
        case 105:
          return "numpad 9";
        case 106:
          return "numpad *";
        case 107:
          return "numpad +";
        case 109:
          return "numpad -";
        case 110:
          return "numpad .";
        case 111:
          return "numpad /";
        case 112:
          return "F1";
        case 113:
          return "F2";
        case 114:
          return "F3";
        case 115:
          return "F4";
        case 116:
          return "F5";
        case 117:
          return "F6";
        case 118:
          return "F7";
        case 119:
          return "F8";
        case 120:
          return "F9";
        case 121:
          return "F10";
        case 122:
          return "F11";
        case 123:
          return "F12";
        case 144:
          return "numlock";
        case 145:
          return "scroll lock";
        case 186:
          return ";";
        case 187:
          return "=";
        case 188:
          return ",";
        case 189:
          return "-";
        case 190:
          return ".";
        case 191:
          return "/";
        case 192:
          return "'";
        case 219:
          return "[";
        case 220:
          return "\\";
        case 221:
          return "]";
        case 222:
          return "#";
        case 223:
          return "`";
        default:
          return String.fromCharCode(e);
      }
    };
    StringFromCharCode2 = StringFromCharCode;
    self.C3.Plugins.Keyboard.Exps = { LastKeyCode() {
      return this._triggerWhich;
    }, StringFromKeyCode: (e) => StringFromCharCode(e), TypedKey() {
      return this._triggerTypedKey;
    } };
  }
}
var GetKeyboardSdkInstance2;
var StringFromCharCode2;
{
  {
    const e = self.C3;
    e.Plugins.Mouse = class extends e.SDKPluginBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
    };
  }
  {
    let GetMouseSdkInstance = function() {
      return n.GetSingleGlobalInstance().GetSdkInstance();
    };
    GetMouseSdkInstance2 = GetMouseSdkInstance;
    const t2 = self.C3, s = self.C3X;
    t2.Plugins.Mouse.Type = class extends t2.SDKTypeBase {
      constructor(e) {
        super(e);
      }
      Release() {
        super.Release();
      }
      OnCreate() {
      }
      GetScriptInterfaceClass() {
        return self.IMouseObjectType;
      }
    };
    let n = null;
    self.IMouseObjectType = class extends self.IObjectType {
      constructor(e) {
        super(e), n = e, e.GetRuntime()._GetCommonScriptInterfaces().mouse = this;
      }
      getMouseX(e) {
        return GetMouseSdkInstance().GetMousePositionForLayer(e)[0];
      }
      getMouseY(e) {
        return GetMouseSdkInstance().GetMousePositionForLayer(e)[1];
      }
      getMousePosition(e) {
        return GetMouseSdkInstance().GetMousePositionForLayer(e);
      }
      isMouseButtonDown(e) {
        return GetMouseSdkInstance().IsMouseButtonDown(e);
      }
      setCursorStyle(e) {
        s.RequireString(e), GetMouseSdkInstance().SetCursorStyle(e);
      }
      setCursorObjectClass(e) {
        const t3 = GetMouseSdkInstance(), s2 = t3.GetRuntime()._UnwrapIObjectClass(e);
        t3.SetCursorObjectClass(s2);
      }
    };
  }
  {
    const o2 = self.C3, i = "mouse";
    let r2 = null;
    o2.Plugins.Mouse.Instance = class extends o2.SDKInstanceBase {
      constructor(e, t2) {
        super(e, i), this._buttonMap = [false, false, false, false, false], this._mouseXcanvas = 0, this._mouseYcanvas = 0, this._triggerButton = 0, this._triggerType = 0, this._triggerDir = 0, this._wheelDeltaX = 0, this._wheelDeltaY = 0, this._wheelDeltaZ = 0, this._hasPointerLock = false, this._movementX = 0, this._movementY = 0, this.AddDOMMessageHandlers([["pointer-lock-change", (e2) => this._OnPointerLockChange(e2)], ["pointer-lock-error", (e2) => this._OnPointerLockError(e2)]]);
        const s = this.GetRuntime().Dispatcher();
        this._disposables = new o2.CompositeDisposable(o2.Disposable.From(s, "pointermove", (e2) => this._OnPointerMove(e2.data)), o2.Disposable.From(s, "pointerdown", (e2) => this._OnPointerDown(e2.data)), o2.Disposable.From(s, "pointerup", (e2) => this._OnPointerUp(e2.data)), o2.Disposable.From(s, "dblclick", (e2) => this._OnDoubleClick(e2.data)), o2.Disposable.From(s, "wheel", (e2) => this._OnMouseWheel(e2.data)), o2.Disposable.From(s, "window-blur", () => this._OnWindowBlur()));
      }
      Release() {
        super.Release();
      }
      _OnPointerDown(e) {
        "mouse" === e["pointerType"] && (this._mouseXcanvas = e["pageX"] - this._runtime.GetCanvasClientX(), this._mouseYcanvas = e["pageY"] - this._runtime.GetCanvasClientY(), this._CheckButtonChanges(e["lastButtons"], e["buttons"]));
      }
      _OnPointerMove(e) {
        this._movementX = e["movementX"], this._movementY = e["movementY"], this.Trigger(o2.Plugins.Mouse.Cnds.OnMovement), this._movementX = 0, this._movementY = 0, "mouse" === e["pointerType"] && (this._mouseXcanvas = e["pageX"] - this._runtime.GetCanvasClientX(), this._mouseYcanvas = e["pageY"] - this._runtime.GetCanvasClientY(), this._CheckButtonChanges(e["lastButtons"], e["buttons"]));
      }
      _OnPointerUp(e) {
        "mouse" === e["pointerType"] && this._CheckButtonChanges(e["lastButtons"], e["buttons"]);
      }
      _CheckButtonChanges(e, t2) {
        this._CheckButtonChange(e, t2, 1, 0), this._CheckButtonChange(e, t2, 4, 1), this._CheckButtonChange(e, t2, 2, 2), this._CheckButtonChange(e, t2, 8, 3), this._CheckButtonChange(e, t2, 16, 4);
      }
      _CheckButtonChange(e, t2, s, n) {
        !(e & s) && t2 & s ? this._OnMouseDown(n) : e & s && !(t2 & s) && this._OnMouseUp(n);
      }
      _OnMouseDown(e) {
        this._buttonMap[e] = true, this.Trigger(o2.Plugins.Mouse.Cnds.OnAnyClick), this._triggerButton = e, this._triggerType = 0, this.Trigger(o2.Plugins.Mouse.Cnds.OnClick), this.Trigger(o2.Plugins.Mouse.Cnds.OnObjectClicked);
      }
      _OnMouseUp(e) {
        this._buttonMap[e] && (this._buttonMap[e] = false, this._triggerButton = e, this.Trigger(o2.Plugins.Mouse.Cnds.OnRelease));
      }
      _OnDoubleClick(e) {
        this._triggerButton = e["button"], this._triggerType = 1, this.Trigger(o2.Plugins.Mouse.Cnds.OnClick), this.Trigger(o2.Plugins.Mouse.Cnds.OnObjectClicked);
      }
      _OnMouseWheel(e) {
        this._triggerDir = e["deltaY"] < 0 ? 1 : 0, this._wheelDeltaX = e["deltaX"], this._wheelDeltaY = e["deltaY"], this._wheelDeltaZ = e["deltaZ"], this.Trigger(o2.Plugins.Mouse.Cnds.OnWheel);
      }
      _OnWindowBlur() {
        for (let e = 0, t2 = this._buttonMap.length; e < t2; ++e) {
          if (!this._buttonMap[e]) return;
          this._buttonMap[e] = false, this._triggerButton = e, this.Trigger(o2.Plugins.Mouse.Cnds.OnRelease);
        }
      }
      GetMousePositionForLayer(e) {
        const t2 = this._runtime.GetMainRunningLayout(), s = this._mouseXcanvas, n = this._mouseYcanvas;
        if (void 0 === e) {
          return t2.GetLayerByIndex(0).CanvasCssToLayer_DefaultTransform(s, n);
        }
        {
          const o3 = t2.GetLayer(e);
          return o3 ? o3.CanvasCssToLayer(s, n) : [0, 0];
        }
      }
      IsMouseButtonDown(e) {
        return e = Math.floor(e), !!this._buttonMap[e];
      }
      _IsMouseOverCanvas() {
        return this._mouseXcanvas >= 0 && this._mouseYcanvas >= 0 && this._mouseXcanvas < this._runtime.GetCanvasCssWidth() && this._mouseYcanvas < this._runtime.GetCanvasCssHeight();
      }
      SetCursorStyle(e) {
        r2 !== e && (r2 = e, this.PostToDOM("cursor", e));
      }
      async SetCursorObjectClass(e) {
        if (o2.Platform.IsMobile || !e) return;
        const t2 = e.GetFirstPicked();
        if (!t2) return;
        const s = t2.GetWorldInfo(), n = t2.GetCurrentImageInfo();
        if (!s || !n) return;
        if (r2 === n) return;
        r2 = n;
        const i2 = `url(${await n.ExtractImageToBlobURL()}) ${Math.round(s.GetOriginX() * n.GetWidth())} ${Math.round(s.GetOriginY() * n.GetHeight())}, auto`;
        this.PostToDOM("cursor", i2);
      }
      _OnPointerLockChange(e) {
        this._UpdatePointerLockState(e["has-pointer-lock"]);
      }
      _OnPointerLockError(e) {
        this._UpdatePointerLockState(e["has-pointer-lock"]), this.Trigger(o2.Plugins.Mouse.Cnds.OnPointerLockError);
      }
      _UpdatePointerLockState(e) {
        this._hasPointerLock !== e && (this._hasPointerLock = e, this._hasPointerLock ? this.Trigger(o2.Plugins.Mouse.Cnds.OnPointerLocked) : this.Trigger(o2.Plugins.Mouse.Cnds.OnPointerUnlocked));
      }
      GetDebuggerProperties() {
        const e = "plugins.mouse";
        return [{ title: e + ".name", properties: [{ name: e + ".debugger.absolute-position", value: this._mouseXcanvas + "," + this._mouseYcanvas }, { name: e + ".debugger.left-button", value: this._buttonMap[0] }, { name: e + ".debugger.middle-button", value: this._buttonMap[1] }, { name: e + ".debugger.right-button", value: this._buttonMap[2] }, { name: e + ".debugger.button-4", value: this._buttonMap[3] }, { name: e + ".debugger.button-5", value: this._buttonMap[4] }] }, { title: e + ".debugger.position-on-each-layer", properties: this._runtime.GetMainRunningLayout().GetLayers().map((e2) => ({ name: "$" + e2.GetName(), value: e2.CanvasCssToLayer(this._mouseXcanvas, this._mouseYcanvas).join(", ") })) }];
      }
    };
  }
  {
    const u2 = self.C3;
    u2.Plugins.Mouse.Cnds = { OnClick(e, t2) {
      return this._triggerButton === e && this._triggerType === t2;
    }, OnAnyClick: () => true, IsButtonDown(e) {
      return this._buttonMap[e];
    }, OnRelease(e) {
      return this._triggerButton === e;
    }, IsOverObject(e) {
      const t2 = this._runtime.GetCurrentCondition().IsInverted(), s = [];
      return this._IsMouseOverCanvas() && s.push([this._mouseXcanvas, this._mouseYcanvas]), u2.xor(this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(e, s, t2), t2);
    }, OnObjectClicked(e, t2, s) {
      if (e !== this._triggerButton || t2 !== this._triggerType) return false;
      if (!this._IsMouseOverCanvas()) return false;
      const n = this._mouseXcanvas, o2 = this._mouseYcanvas;
      return this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(s, [[n, o2]], false);
    }, OnWheel(e) {
      return 2 === e || this._triggerDir === e;
    }, OnPointerLocked: () => true, OnPointerUnlocked: () => true, OnPointerLockError: () => true, HasPointerLock() {
      return this._hasPointerLock;
    }, OnMovement: () => true };
  }
  {
    const a2 = self.C3, h2 = ["auto", "pointer", "text", "crosshair", "move", "help", "wait", "none"], l = ["auto", "all-scroll", "none", "help", "pointer", "progress", "wait", "cell", "crosshair", "text", "vertical-text", "alias", "copy", "move", "not-allowed", "grab", "grabbing", "col-resize", "row-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out"];
    a2.Plugins.Mouse.Acts = { SetCursor(e) {
      this.SetCursorStyle(h2[e]);
    }, SetCursor2(e) {
      this.SetCursorStyle(l[e]);
    }, SetCursorSprite(e) {
      this.SetCursorObjectClass(e);
    }, RequestPointerLock(e) {
      this._PostToDOMMaybeSync("request-pointer-lock", { "unadjustedMovement": e });
    }, ReleasePointerLock() {
      this.PostToDOM("release-pointer-lock");
    } };
  }
  self.C3.Plugins.Mouse.Exps = { X(e) {
    return this.GetMousePositionForLayer(e)[0];
  }, Y(e) {
    return this.GetMousePositionForLayer(e)[1];
  }, AbsoluteX() {
    return this._mouseXcanvas;
  }, AbsoluteY() {
    return this._mouseYcanvas;
  }, MovementX() {
    return this._movementX;
  }, MovementY() {
    return this._movementY;
  }, WheelDeltaX() {
    return this._wheelDeltaX;
  }, WheelDeltaY() {
    return this._wheelDeltaY;
  }, WheelDeltaZ() {
    return this._wheelDeltaZ;
  } };
}
var GetMouseSdkInstance2;
{
  {
    const t2 = self.C3, e = [];
    t2.Plugins.Audio = class extends t2.SDKPluginBase {
      constructor(t3) {
        super(t3);
      }
      _AddActionPromise(t3) {
        e.push(t3);
      }
      static async WaitForAllActionPromises() {
        await Promise.all(e), t2.clearArray(e);
      }
      Release() {
        super.Release();
      }
    };
  }
  {
    let GetAudioSdkInstance = function() {
      return a2.GetSingleGlobalInstance().GetSdkInstance();
    }, GetAudioDOMInterface = function() {
      if (self["C3Audio_DOMInterface"]) return self["C3Audio_DOMInterface"];
      throw new Error("audio scripting API cannot be used here - make sure the project is using DOM mode, not worker mode");
    };
    GetAudioSdkInstance2 = GetAudioSdkInstance, GetAudioDOMInterface2 = GetAudioDOMInterface;
    const s = self.C3, i = self.C3X;
    s.Plugins.Audio.Type = class extends s.SDKTypeBase {
      constructor(t2) {
        super(t2);
      }
      Release() {
        super.Release();
      }
      OnCreate() {
      }
      GetScriptInterfaceClass() {
        return self.IAudioObjectType;
      }
    };
    let a2 = null;
    self.IAudioObjectType = class extends self.IObjectType {
      constructor(t2) {
        super(t2), a2 = t2;
      }
      get audioContext() {
        return GetAudioDOMInterface()["GetAudioContextExtern"]();
      }
      get destinationNode() {
        return GetAudioDOMInterface()["GetDestinationNodeExtern"]();
      }
      get isSilent() {
        return GetAudioSdkInstance()._IsSilent();
      }
      set isSilent(t2) {
        GetAudioSdkInstance()._SetSilent(t2);
      }
      get masterVolume() {
        return GetAudioSdkInstance()._GetMasterVolume();
      }
      set masterVolume(t2) {
        i.RequireFiniteNumber(t2), GetAudioSdkInstance()._SetMasterVolume(t2);
      }
      stopAll() {
        GetAudioSdkInstance()._StopAll();
      }
    };
  }
  {
    const n = self.C3, r2 = "audio", o2 = ["interactive", "balanced", "playback"];
    n.Plugins.Audio.Instance = class extends n.SDKInstanceBase {
      constructor(t2, e) {
        super(t2, r2), this._nextPlayTime = 0, this._nextPlayOffset = 0, this._triggerTags = [], this._enableMultiTags = true, this._timeScaleMode = 0, this._saveLoadMode = 0, this._playInBackground = false, this._panningModel = 1, this._distanceModel = 1, this._listenerPos = [this._runtime.GetViewportWidth() / 2, this._runtime.GetViewportHeight() / 2, 600], this._listenerForwardVec = [0, 0, -1], this._listenerUpVec = [0, 1, 0], this._referenceDistance = 600, this._maxDistance = 1e4, this._rolloffFactor = 1, this._listenerInst = null, this._loadListenerUid = -1, this._masterVolume = 1, this._isSilent = false, this._sampleRate = 0, this._audioContextState = "suspended", this._outputLatency = 0, this._effectCount = /* @__PURE__ */ new Map(), this._preloadTotal = 0, this._preloadCount = 0, this._bufferMetadata = /* @__PURE__ */ new Map(), this._remoteUrls = /* @__PURE__ */ new Map();
        let s = "interactive";
        e && (this._timeScaleMode = e[0], this._saveLoadMode = e[1], this._playInBackground = e[2], s = o2[e[3]], this._enableMultiTags = e[4], this._panningModel = e[5], this._distanceModel = e[6], this._listenerPos[2] = e[7], this._referenceDistance = e[8], this._maxDistance = e[9], this._rolloffFactor = e[10]), this._lastAIState = [], this._lastFxState = [], this._lastAnalysersData = [], this.AddDOMMessageHandlers([["state", (t3) => this._OnUpdateState(t3)], ["audiocontext-state", (t3) => this._OnAudioContextStateChanged(t3)], ["fxstate", (t3) => this._OnUpdateFxState(t3)], ["trigger", (t3) => this._OnTrigger(t3)], ["buffer-metadata", (t3) => this._OnBufferMetadata(t3)]]);
        const i = this.GetRuntime().Dispatcher();
        this._disposables = new n.CompositeDisposable(n.Disposable.From(i, "instancedestroy", (t3) => this._OnInstanceDestroyed(t3.instance)), n.Disposable.From(i, "afterload", () => this._OnAfterLoad()), n.Disposable.From(i, "suspend", () => this._OnSuspend()), n.Disposable.From(i, "resume", () => this._OnResume()));
        const a2 = this._runtime.GetExportType(), l = "Safari" === n.Platform.Browser, h2 = this._runtime.IsiOSWebView() || "macos-wkwebview" === a2, u2 = "playable-ad-single-file" === a2, c2 = "cordova" === a2 && "Android" === n.Platform.OS, d2 = l || h2 || u2 || c2;
        this._runtime.AddLoadPromise(this.PostToDOMAsync("create-audio-context", { "preloadList": this._runtime.GetAssetManager().GetAudioToPreload().map((t3) => ({ "originalUrl": t3.originalUrl, "url": t3.url, "type": t3.type, "fileSize": t3.fileSize })), "timeScaleMode": this._timeScaleMode, "latencyHint": s, "panningModel": this._panningModel, "distanceModel": this._distanceModel, "refDistance": this._referenceDistance, "maxDistance": this._maxDistance, "rolloffFactor": this._rolloffFactor, "listenerPos": this._listenerPos, "usePlayMusicAsSoundWorkaround": d2 }).then((t3) => {
          this._sampleRate = t3["sampleRate"], this._audioContextState = t3["audioContextState"], this._outputLatency = t3["outputLatency"];
        })), this._StartTicking();
      }
      Release() {
        this._listenerInst = null, super.Release();
      }
      _SplitTags(t2) {
        return this._enableMultiTags ? t2.split(" ").filter((t3) => !!t3) : t2 ? [t2] : [];
      }
      _MatchTagLists(t2, e) {
        for (const s of e) {
          let e2 = false;
          for (const i of t2) if (n.equalsNoCase(i, s)) {
            e2 = true;
            break;
          }
          if (!e2) return false;
        }
        return true;
      }
      _MatchTagListToStr(t2, e) {
        return this._MatchTagLists(t2, this._SplitTags(e));
      }
      _AddActionPromise(t2) {
        this.GetPlugin()._AddActionPromise(t2);
      }
      _OnInstanceDestroyed(t2) {
        this._listenerInst === t2 && (this._listenerInst = null);
      }
      DbToLinearNoCap(t2) {
        return Math.pow(10, t2 / 20);
      }
      DbToLinear(t2) {
        const e = this.DbToLinearNoCap(t2);
        return isFinite(e) ? Math.max(Math.min(e, 1), 0) : 0;
      }
      LinearToDbNoCap(t2) {
        return Math.log(t2) / Math.log(10) * 20;
      }
      LinearToDb(t2) {
        return this.LinearToDbNoCap(Math.max(Math.min(t2, 1), 0));
      }
      _GetScheduledPlayInfo() {
        let t2 = 0;
        const e = !!self["C3_GetAudioContextCurrentTime"];
        return t2 = e ? this._nextPlayTime : this._nextPlayOffset, this._nextPlayTime = 0, this._nextPlayOffset = 0, { playOffset: t2, isTrueClock: e };
      }
      _OnSuspend() {
        this._playInBackground || this.PostToDOM("set-suspended", { "isSuspended": true });
      }
      _OnResume() {
        this._playInBackground || this.PostToDOM("set-suspended", { "isSuspended": false });
      }
      _OnUpdateState(t2) {
        const e = t2["tickCount"];
        this._outputLatency = t2["outputLatency"];
        const s = this._lastAIState.filter((t3) => t3.hasOwnProperty("placeholder") && (t3["placeholder"] > e || -1 === t3["placeholder"]));
        this._lastAIState = t2["audioInstances"], this._lastAnalysersData = t2["analysers"], s.length > 0 && n.appendArray(this._lastAIState, s);
      }
      _OnBufferMetadata(t2) {
        this._bufferMetadata.set(t2["originalUrl"], { duration: t2["duration"] });
      }
      _OnAudioContextStateChanged(t2) {
        this._audioContextState = t2["audioContextState"];
      }
      GetAudioContextState() {
        return this._runtime.IsExportToVideo() ? "running" : this._audioContextState;
      }
      _OnUpdateFxState(t2) {
        this._lastFxState = t2["fxstate"];
      }
      _GetFirstAudioStateByTags(t2) {
        const e = this._SplitTags(t2);
        for (const t3 of this._lastAIState) if (this._MatchTagLists(t3["tags"], e)) return t3;
        return null;
      }
      _IsTagPlaying(t2) {
        const e = this._SplitTags(t2);
        return this._lastAIState.some((t3) => this._MatchTagLists(t3["tags"], e) && t3["isPlaying"]);
      }
      _MaybeMarkAsPlaying(t2, e, s, i, a2) {
        if (this._IsTagPlaying(e)) return null;
        const n2 = this._bufferMetadata.get(t2), r3 = { "tags": this._SplitTags(e), "duration": n2 ? n2.duration : 0, "volume": a2, "isPlaying": true, "playbackTime": 0, "playbackRate": 1, "uid": -1, "bufferOriginalUrl": t2, "bufferUrl": "", "bufferType": "", "isMusic": s, "isLooping": i, "isMuted": false, "resumePosition": 0, "pan": null, "placeholder": -1 };
        return this._lastAIState.push(r3), r3;
      }
      _MaybeMarkAsStopped(t2) {
        const e = this._SplitTags(t2);
        for (const t3 of this._lastAIState) this._MatchTagLists(t3["tags"], e) && (t3["isPlaying"] = false);
      }
      async _OnTrigger(t2) {
        const e = t2["type"];
        this._triggerTags = t2["tags"];
        const s = t2["aiid"];
        if ("ended" === e) {
          for (const t3 of this._lastAIState) if (t3["aiid"] === s) {
            t3["isPlaying"] = false;
            break;
          }
          await this.TriggerAsync(n.Plugins.Audio.Cnds.OnEnded);
        } else "fade-ended" === e && await this.TriggerAsync(n.Plugins.Audio.Cnds.OnFadeEnded);
      }
      _MatchTriggerTag(t2) {
        return this._MatchTagListToStr(this._triggerTags, t2);
      }
      Tick() {
        const t2 = { "timeScale": this._runtime.GetTimeScale(), "gameTime": this._runtime.GetGameTimeRaw(), "instPans": this.GetInstancePans(), "tickCount": this._runtime.GetTickCountNoSave() };
        if (this._listenerInst) {
          const e = this._listenerInst.GetWorldInfo();
          this._listenerPos[0] = e.GetX(), this._listenerPos[1] = e.GetY(), t2["listenerPos"] = this._listenerPos, t2["listenerOrientation"] = [...this._listenerForwardVec, ...this._listenerUpVec];
        }
        this.PostToDOM("tick", t2);
      }
      rotatePtAround(t2, e, s, i, a2) {
        if (0 === s) return [t2, e];
        const n2 = Math.sin(s), r3 = Math.cos(s), o3 = (t2 -= i) * n2;
        return t2 = t2 * r3 - (e -= a2) * n2, e = e * r3 + o3, [t2 += i, e += a2];
      }
      GetInstancePans() {
        return this._lastAIState.filter((t2) => -1 !== t2["uid"]).map((t2) => this._runtime.GetInstanceByUID(t2["uid"])).filter((t2) => t2).map((t2) => {
          const e = t2.GetWorldInfo(), s = e.GetLayer().GetAngle(), [i, a2] = this.rotatePtAround(e.GetX(), e.GetY(), -s, this._listenerPos[0], this._listenerPos[1]);
          return { "uid": t2.GetUID(), "x": i, "y": a2, "z": e.GetTotalZElevation(), "angle": e.GetAngle() - s };
        });
      }
      GetAnalyserData(t2, e) {
        for (const s of this._lastAnalysersData) if (s.index === e && n.equalsNoCase(s["tag"], t2)) return s;
        return null;
      }
      _IncrementEffectCount(t2) {
        for (const e of this._SplitTags(t2)) {
          const t3 = e.toLowerCase();
          this._effectCount.set(t3, (this._effectCount.get(t3) || 0) + 1);
        }
      }
      _IsSilent() {
        return this._isSilent;
      }
      _SetSilent(t2) {
        t2 = !!t2, this._isSilent !== t2 && (this._isSilent = t2, this.PostToDOM("set-silent", { "isSilent": t2 }));
      }
      _GetMasterVolume() {
        return this._masterVolume;
      }
      _SetMasterVolume(t2) {
        this._masterVolume !== t2 && (this._masterVolume = t2, this.PostToDOM("set-master-volume", { "vol": t2 }));
      }
      _StopAll() {
        this.PostToDOM("stop-all");
        for (const t2 of this._lastAIState) t2["isPlaying"] = false;
      }
      _ShouldSave(t2) {
        return !t2.hasOwnProperty("placeholder") && (3 !== this._saveLoadMode && ((!t2["isMusic"] || 1 !== this._saveLoadMode) && !(!t2["isMusic"] && 2 === this._saveLoadMode)));
      }
      SaveToJson() {
        return { "isSilent": this._isSilent, "masterVolume": this._masterVolume, "listenerZ": this._listenerPos[2], "listenerForwardVec": this._listenerForwardVec, "listenerUpVec": this._listenerUpVec, "listenerUid": this._listenerInst ? this._listenerInst.GetUID() : -1, "remoteUrls": [...this._remoteUrls.entries()], "playing": this._lastAIState.filter((t2) => this._ShouldSave(t2)), "effects": this._lastFxState, "analysers": this._lastAnalysersData };
      }
      LoadFromJson(t2) {
        if (this._isSilent = t2["isSilent"], this._masterVolume = t2["masterVolume"], this._listenerPos[2] = t2["listenerZ"], this._listenerInst = null, this._loadListenerUid = t2["listenerUid"], t2.hasOwnProperty("listenerForwardVec") ? this._listenerForwardVec = t2["listenerForwardVec"] : this._listenerForwardVec = [0, 0, -1], t2.hasOwnProperty("listenerUpVec") ? this._listenerUpVec = t2["listenerUpVec"] : this._listenerUpVec = [0, 1, 0], this._remoteUrls.clear(), t2["remoteUrls"]) for (const [e, s] of t2["remoteUrls"]) this._remoteUrls.set(e, s);
        this._lastAIState = t2["playing"];
        for (const t3 of this._lastAIState) t3.hasOwnProperty("tag") && !t3.hasOwnProperty("tags") && (t3["tags"] = [t3["tag"]].filter((t4) => !!t4));
        this._lastFxState = t2["effects"], this._lastAnalysersData = t2["analysers"];
      }
      _OnAfterLoad() {
        if (-1 !== this._loadListenerUid && (this._listenerInst = this._runtime.GetInstanceByUID(this._loadListenerUid), this._loadListenerUid = -1, this._listenerInst)) {
          const t2 = this._listenerInst.GetWorldInfo();
          this._listenerPos[0] = t2.GetX(), this._listenerPos[1] = t2.GetY();
        }
        for (const t2 of this._lastAIState) {
          const e = this._runtime.GetAssetManager().GetProjectAudioFileUrl(t2["bufferOriginalUrl"]);
          e ? (t2["bufferUrl"] = e.url, t2["bufferType"] = e.type) : t2["bufferUrl"] = null;
        }
        for (const t2 of Object.values(this._lastFxState)) for (const e of t2) if (e.hasOwnProperty("bufferOriginalUrl")) {
          const t3 = this._runtime.GetAssetManager().GetProjectAudioFileUrl(e["bufferOriginalUrl"]);
          t3 && (e["bufferUrl"] = t3.url, e["bufferType"] = t3.type);
        }
        this.PostToDOM("load-state", { "saveLoadMode": this._saveLoadMode, "timeScale": this._runtime.GetTimeScale(), "gameTime": this._runtime.GetGameTimeRaw(), "listenerPos": this._listenerPos, "listenerOrientation": [...this._listenerForwardVec, ...this._listenerUpVec], "isSilent": this._isSilent, "masterVolume": this._masterVolume, "playing": this._lastAIState.filter((t2) => null !== t2["bufferUrl"]), "effects": this._lastFxState });
      }
      GetDebuggerProperties() {
        const t2 = [];
        for (const [e2, s] of Object.entries(this._lastFxState)) t2.push({ name: "$" + e2, value: s.map((t3) => t3["type"]).join(", ") });
        const e = "plugins.audio.debugger";
        return [{ title: e + ".tag-effects", properties: t2 }, { title: e + ".currently-playing", properties: [{ name: e + ".currently-playing-count", value: this._lastAIState.length }, ...this._lastAIState.map((t3, e2) => ({ name: "$#" + e2, value: `${t3["bufferOriginalUrl"]} ("${t3["tags"]}") ${Math.round(10 * t3["playbackTime"]) / 10} / ${Math.round(10 * t3["duration"]) / 10}` }))] }];
      }
    };
  }
  self.C3.Plugins.Audio.Cnds = { OnEnded(t2) {
    return this._MatchTriggerTag(t2);
  }, OnFadeEnded(t2) {
    return this._MatchTriggerTag(t2);
  }, PreloadsComplete() {
    return this._preloadCount === this._preloadTotal;
  }, AdvancedAudioSupported: () => true, IsSilent() {
    return this._IsSilent();
  }, IsAnyPlaying() {
    for (const t2 of this._lastAIState) if (t2["isPlaying"]) return true;
    return false;
  }, IsTagPlaying(t2) {
    return this._IsTagPlaying(t2);
  } };
  {
    const l = self.C3, h2 = ["lowpass", "highpass", "bandpass", "lowshelf", "highshelf", "peaking", "notch", "allpass"];
    l.Plugins.Audio.Acts = { Play(t2, e, s, i, a2) {
      const n = l.Plugins.Audio.Acts._DoPlay.call(this, t2, e, s, i, a2);
      return this._AddActionPromise(n), n;
    }, PlayFromTimeline(t2, e, s, i) {
      l.Plugins.Audio.Acts._DoPlay.call(this, t2, 0, e, 0, s, i);
    }, async _DoPlay(t2, e, s, i, a2, n) {
      if (this._isSilent) return;
      const r2 = t2[1], o2 = this._runtime.GetAssetManager().GetProjectAudioFileUrl(t2[0]);
      if (!o2) return;
      const { playOffset: h3, isTrueClock: u2 } = this._GetScheduledPlayInfo(), c2 = this._MaybeMarkAsPlaying(t2[0], a2, r2, 0 !== e, this.DbToLinear(s));
      try {
        await this.PostToDOMAsync("play", { "originalUrl": t2[0], "url": o2.url, "type": o2.type, "isMusic": r2, "tags": this._SplitTags(a2), "isLooping": 0 !== e, "vol": this.DbToLinear(s), "stereoPan": l.clamp(i / 100, -1, 1), "pos": n || 0, "off": h3, "trueClock": u2 });
      } finally {
        c2 && (c2["placeholder"] = this._runtime.GetTickCountNoSave());
      }
    }, async PlayAtPosition(t2, e, s, i, a2, n, r2, o2, h3, u2, c2) {
      if (this._isSilent) return;
      const d2 = t2[1], _2 = this._runtime.GetAssetManager().GetProjectAudioFileUrl(t2[0]);
      if (!_2) return;
      const { playOffset: f2, isTrueClock: p2 } = this._GetScheduledPlayInfo(), g2 = this._MaybeMarkAsPlaying(t2[0], c2, d2, 0 !== e, this.DbToLinear(s));
      try {
        await this.PostToDOMAsync("play", { "originalUrl": t2[0], "url": _2.url, "type": _2.type, "isMusic": d2, "tags": this._SplitTags(c2), "isLooping": 0 !== e, "vol": this.DbToLinear(s), "pos": 0, "off": f2, "trueClock": p2, "panning": { "x": i, "y": a2, "z": n, "angle": l.toRadians(r2), "innerAngle": l.toRadians(o2), "outerAngle": l.toRadians(h3), "outerGain": this.DbToLinear(u2) } });
      } finally {
        g2 && (g2["placeholder"] = this._runtime.GetTickCountNoSave());
      }
    }, async PlayAtObject(t2, e, s, i, a2, n, r2, o2) {
      if (this._isSilent) return;
      if (!i) return;
      const h3 = i.GetFirstPicked();
      if (!h3 || !h3.GetWorldInfo()) return;
      const u2 = h3.GetWorldInfo(), c2 = u2.GetLayer().GetAngle(), [d2, _2] = this.rotatePtAround(u2.GetX(), u2.GetY(), -c2, this._listenerPos[0], this._listenerPos[1]), f2 = t2[1], p2 = this._runtime.GetAssetManager().GetProjectAudioFileUrl(t2[0]);
      if (!p2) return;
      const { playOffset: g2, isTrueClock: y2 } = this._GetScheduledPlayInfo(), m2 = this._MaybeMarkAsPlaying(t2[0], o2, f2, 0 !== e, this.DbToLinear(s));
      try {
        await this.PostToDOMAsync("play", { "originalUrl": t2[0], "url": p2.url, "type": p2.type, "isMusic": f2, "tags": this._SplitTags(o2), "isLooping": 0 !== e, "vol": this.DbToLinear(s), "pos": 0, "off": g2, "trueClock": y2, "panning": { "x": d2, "y": _2, "z": u2.GetTotalZElevation(), "angle": u2.GetAngle() - c2, "innerAngle": l.toRadians(a2), "outerAngle": l.toRadians(n), "outerGain": this.DbToLinear(r2), "uid": h3.GetUID() } });
      } finally {
        m2 && (m2["placeholder"] = this._runtime.GetTickCountNoSave());
      }
    }, async PlayByName(t2, e, s, i, a2, n) {
      if (this._isSilent) return;
      const r2 = 1 === t2, o2 = this._runtime.GetAssetManager().GetProjectAudioFileUrl(e) || this._remoteUrls.get(e.toLowerCase());
      if (!o2) return;
      const { playOffset: h3, isTrueClock: u2 } = this._GetScheduledPlayInfo(), c2 = this._MaybeMarkAsPlaying(e, n, r2, 0 !== s, this.DbToLinear(i));
      try {
        await this.PostToDOMAsync("play", { "originalUrl": e, "url": o2.url, "type": o2.type, "isMusic": r2, "tags": this._SplitTags(n), "isLooping": 0 !== s, "vol": this.DbToLinear(i), "stereoPan": l.clamp(a2 / 100, -1, 1), "pos": 0, "off": h3, "trueClock": u2 });
      } finally {
        c2 && (c2["placeholder"] = this._runtime.GetTickCountNoSave());
      }
    }, async PlayAtPositionByName(t2, e, s, i, a2, n, r2, o2, h3, u2, c2, d2) {
      if (this._isSilent) return;
      const _2 = 1 === t2, f2 = this._runtime.GetAssetManager().GetProjectAudioFileUrl(e) || this._remoteUrls.get(e.toLowerCase());
      if (!f2) return;
      const { playOffset: p2, isTrueClock: g2 } = this._GetScheduledPlayInfo(), y2 = this._MaybeMarkAsPlaying(e, d2, _2, 0 !== s, this.DbToLinear(i));
      try {
        await this.PostToDOMAsync("play", { "originalUrl": e, "url": f2.url, "type": f2.type, "isMusic": _2, "tags": this._SplitTags(d2), "isLooping": 0 !== s, "vol": this.DbToLinear(i), "pos": 0, "off": p2, "trueClock": g2, "panning": { "x": a2, "y": n, "z": r2, "angle": l.toRadians(o2), "innerAngle": l.toRadians(h3), "outerAngle": l.toRadians(u2), "outerGain": this.DbToLinear(c2) } });
      } finally {
        y2 && (y2["placeholder"] = this._runtime.GetTickCountNoSave());
      }
    }, async PlayAtObjectByName(t2, e, s, i, a2, n, r2, o2, h3) {
      if (this._isSilent) return;
      if (this._isSilent) return;
      if (!a2) return;
      const u2 = a2.GetFirstPicked();
      if (!u2 || !u2.GetWorldInfo()) return;
      const c2 = u2.GetWorldInfo(), d2 = c2.GetLayer().GetAngle(), [_2, f2] = this.rotatePtAround(c2.GetX(), c2.GetY(), -d2, this._listenerPos[0], this._listenerPos[1]), p2 = 1 === t2, g2 = this._runtime.GetAssetManager().GetProjectAudioFileUrl(e) || this._remoteUrls.get(e.toLowerCase());
      if (!g2) return;
      const { playOffset: y2, isTrueClock: m2 } = this._GetScheduledPlayInfo(), T2 = this._MaybeMarkAsPlaying(e, h3, p2, 0 !== s, this.DbToLinear(i));
      try {
        await this.PostToDOMAsync("play", { "originalUrl": e, "url": g2.url, "type": g2.type, "isMusic": p2, "tags": this._SplitTags(h3), "isLooping": 0 !== s, "vol": this.DbToLinear(i), "pos": 0, "off": y2, "trueClock": m2, "panning": { "x": _2, "y": f2, "z": c2.GetTotalZElevation(), "angle": c2.GetAngle() - d2, "innerAngle": l.toRadians(n), "outerAngle": l.toRadians(r2), "outerGain": this.DbToLinear(o2), "uid": u2.GetUID() } });
      } finally {
        T2 && (T2["placeholder"] = this._runtime.GetTickCountNoSave());
      }
    }, SetLooping(t2, e) {
      this.PostToDOM("set-looping", { "tags": this._SplitTags(t2), "isLooping": 0 === e });
    }, SetMuted(t2, e) {
      this.PostToDOM("set-muted", { "tags": this._SplitTags(t2), "isMuted": 0 === e });
    }, SetVolume(t2, e) {
      this.PostToDOM("set-volume", { "tags": this._SplitTags(t2), "vol": this.DbToLinear(e) });
    }, FadeVolume(t2, e, s, i) {
      this.PostToDOM("fade-volume", { "tags": this._SplitTags(t2), "vol": this.DbToLinear(e), "duration": s, "stopOnEnd": 0 === i });
    }, SetStereoPan(t2, e) {
      this.PostToDOM("set-stereo-pan", { "tags": this._SplitTags(t2), "p": l.clamp(e / 100, -1, 1) });
    }, async Preload(t2) {
      const e = t2[1], s = this._runtime.GetAssetManager().GetProjectAudioFileUrl(t2[0]);
      s && (this._preloadTotal++, await this.PostToDOMAsync("preload", { "originalUrl": t2[0], "url": s.url, "type": s.type, "isMusic": e }), this._preloadCount++);
    }, async PreloadByName(t2, e) {
      const s = 1 === t2, i = this._runtime.GetAssetManager().GetProjectAudioFileUrl(e) || this._remoteUrls.get(e.toLowerCase());
      i && (this._preloadTotal++, await this.PostToDOMAsync("preload", { "originalUrl": e, "url": i.url, "type": i.type, "isMusic": s }), this._preloadCount++);
    }, SetPlaybackRate(t2, e) {
      this.PostToDOM("set-playback-rate", { "tags": this._SplitTags(t2), "rate": Math.max(e, 0) });
    }, Stop(t2) {
      this._MaybeMarkAsStopped(t2), this.PostToDOM("stop", { "tags": this._SplitTags(t2) });
    }, StopAll() {
      this._StopAll();
    }, SetPaused(t2, e) {
      this.PostToDOM("set-paused", { "tags": this._SplitTags(t2), "paused": 0 === e });
    }, Seek(t2, e) {
      this.PostToDOM("seek", { "tags": this._SplitTags(t2), "pos": e });
    }, SetSilent(t2) {
      2 === t2 && (t2 = this._IsSilent() ? 1 : 0), this._SetSilent(0 === t2);
    }, SetMasterVolume(t2) {
      const e = this.DbToLinear(t2);
      this._SetMasterVolume(e);
    }, AddFilterEffect(t2, e, s, i, a2, n, r2) {
      const o2 = h2[e];
      this._IncrementEffectCount(t2), this.PostToDOM("add-effect", { "type": "filter", "tags": this._SplitTags(t2), "params": [o2, s, i, a2, n, l.clamp(r2 / 100, 0, 1)] });
    }, AddDelayEffect(t2, e, s, i) {
      this._IncrementEffectCount(t2), this.PostToDOM("add-effect", { "type": "delay", "tags": this._SplitTags(t2), "params": [e, this.DbToLinear(s), l.clamp(i / 100, 0, 1)] });
    }, AddFlangerEffect(t2, e, s, i, a2, n) {
      this._IncrementEffectCount(t2), this.PostToDOM("add-effect", { "type": "flanger", "tags": this._SplitTags(t2), "params": [e / 1e3, s / 1e3, i, a2 / 100, l.clamp(n / 100, 0, 1)] });
    }, AddPhaserEffect(t2, e, s, i, a2, n, r2) {
      this._IncrementEffectCount(t2), this.PostToDOM("add-effect", { "type": "phaser", "tags": this._SplitTags(t2), "params": [e, s, i, a2, n, l.clamp(r2 / 100, 0, 1)] });
    }, AddConvolutionEffect(t2, e, s, i) {
      const a2 = this._runtime.GetAssetManager().GetProjectAudioFileUrl(e[0]);
      a2 && (this._IncrementEffectCount(t2), this.PostToDOM("add-effect", { "type": "convolution", "tags": this._SplitTags(t2), "bufferOriginalUrl": e[0], "bufferUrl": a2.url, "bufferType": a2.type, "params": [0 === s, l.clamp(i / 100, 0, 1)] }));
    }, AddGainEffect(t2, e) {
      this._IncrementEffectCount(t2), this.PostToDOM("add-effect", { "type": "gain", "tags": this._SplitTags(t2), "params": [this.DbToLinear(e)] });
    }, AddStereoPanEffect(t2, e) {
      this._IncrementEffectCount(t2), this.PostToDOM("add-effect", { "type": "stereopan", "tags": this._SplitTags(t2), "params": [l.clamp(e / 100, -1, 1)] });
    }, AddMuteEffect(t2) {
      this._IncrementEffectCount(t2), this.PostToDOM("add-effect", { "type": "gain", "tags": this._SplitTags(t2), "params": [0] });
    }, AddTremoloEffect(t2, e, s) {
      this._IncrementEffectCount(t2), this.PostToDOM("add-effect", { "type": "tremolo", "tags": this._SplitTags(t2), "params": [e, l.clamp(s / 100, 0, 1)] });
    }, AddRingModEffect(t2, e, s) {
      this._IncrementEffectCount(t2), this.PostToDOM("add-effect", { "type": "ringmod", "tags": this._SplitTags(t2), "params": [e, l.clamp(s / 100, 0, 1)] });
    }, AddDistortionEffect(t2, e, s, i, a2, n) {
      this._IncrementEffectCount(t2), this.PostToDOM("add-effect", { "type": "distortion", "tags": this._SplitTags(t2), "params": [this.DbToLinearNoCap(e), this.DbToLinearNoCap(s), i, this.DbToLinearNoCap(a2), l.clamp(n / 100, 0, 1)] });
    }, AddCompressorEffect(t2, e, s, i, a2, n) {
      this._IncrementEffectCount(t2), this.PostToDOM("add-effect", { "type": "compressor", "tags": this._SplitTags(t2), "params": [e, s, i, a2 / 1e3, n / 1e3] });
    }, AddAnalyserEffect(t2, e, s) {
      this._IncrementEffectCount(t2), this.PostToDOM("add-effect", { "type": "analyser", "tags": this._SplitTags(t2), "params": [e, s] });
    }, RemoveEffects(t2) {
      const e = this._SplitTags(t2);
      for (const t3 of e) this._effectCount.set(t3.toLowerCase(), 0);
      this.PostToDOM("remove-effects", { "tags": e }), this._lastFxState = {};
    }, SetEffectParameter(t2, e, s, i, a2, n) {
      this.PostToDOM("set-effect-param", { "tags": this._SplitTags(t2), "index": Math.floor(e), "param": s, "value": i, "ramp": a2, "time": n });
    }, SetListenerObject(t2) {
      if (!t2) return;
      const e = t2.GetFirstPicked();
      e && e.GetWorldInfo() && (this._listenerInst = e);
    }, SetListenerZ(t2) {
      this._listenerPos[2] = t2;
    }, SetListenerOrientation(t2, e, s, i, a2, n) {
      this._listenerForwardVec[0] = t2, this._listenerForwardVec[1] = e, this._listenerForwardVec[2] = -s, this._listenerUpVec[0] = i, this._listenerUpVec[1] = a2, this._listenerUpVec[2] = -n;
    }, ScheduleNextPlay(t2) {
      this._nextPlayTime = Math.max(t2, 0), this._nextPlayOffset = Math.max(t2 - performance.now() / 1e3, 0);
    }, UnloadAudio(t2) {
      const e = t2[1], s = this._runtime.GetAssetManager().GetProjectAudioFileUrl(t2[0]);
      s && this.PostToDOM("unload", { "url": s.url, "type": s.type, "isMusic": e });
    }, UnloadAudioByName(t2, e) {
      const s = 1 === t2, i = this._runtime.GetAssetManager().GetProjectAudioFileUrl(e) || this._remoteUrls.get(e.toLowerCase());
      i && this.PostToDOM("unload", { "url": i.url, "type": i.type, "isMusic": s });
    }, UnloadAll() {
      this.PostToDOM("unload-all");
    }, AddRemoteURL(t2, e, s) {
      this._remoteUrls.set(s.toLowerCase(), { url: t2, type: e });
    } };
  }
  {
    const u2 = self.C3;
    u2.Plugins.Audio.Exps = { Duration(t2) {
      const e = this._GetFirstAudioStateByTags(t2);
      return e ? e["duration"] : 0;
    }, PlaybackTime(t2) {
      const e = this._GetFirstAudioStateByTags(t2);
      return e ? e["playbackTime"] : 0;
    }, PlaybackRate(t2) {
      const e = this._GetFirstAudioStateByTags(t2);
      return e ? e["playbackRate"] : 0;
    }, Volume(t2) {
      const e = this._GetFirstAudioStateByTags(t2);
      return e ? this.LinearToDb(e["volume"]) : 0;
    }, MasterVolume() {
      return this.LinearToDb(this._GetMasterVolume());
    }, EffectCount(t2) {
      return this._effectCount.get(t2.toLowerCase()) || 0;
    }, AnalyserFreqBinCount(t2, e) {
      const s = this.GetAnalyserData(t2, Math.floor(e));
      return s ? s["binCount"] : 0;
    }, AnalyserFreqBinAt(t2, e, s) {
      const i = this.GetAnalyserData(t2, Math.floor(e));
      return i ? (s = Math.floor(s)) < 0 || s >= i["binCount"] ? 0 : i["freqBins"][s] : 0;
    }, AnalyserPeakLevel(t2, e) {
      const s = this.GetAnalyserData(t2, Math.floor(e));
      return s ? s["peak"] : 0;
    }, AnalyserRMSLevel(t2, e) {
      const s = this.GetAnalyserData(t2, Math.floor(e));
      return s ? s["rms"] : 0;
    }, SampleRate() {
      return this._sampleRate;
    }, CurrentTime: () => self["C3_GetAudioContextCurrentTime"] ? self["C3_GetAudioContextCurrentTime"]() : performance.now() / 1e3, OutputLatency() {
      return this._outputLatency;
    }, NormalizedVolume(t2, e) {
      return 0 === (t2 = u2.clamp(+t2, 0, 100) / 100) ? -1 / 0 : t2 < 0.1 ? this.LinearToDb(u2.lerp(0, this.DbToLinear(e), 10 * t2)) : u2.lerp(e, 0, (t2 - 0.1) / 0.9);
    } };
  }
}
var GetAudioSdkInstance2;
var GetAudioDOMInterface2;
{
  {
    const t2 = self.C3;
    t2.Behaviors.Anchor = class extends t2.SDKBehaviorBase {
      constructor(t3) {
        super(t3);
      }
      Release() {
        super.Release();
      }
    };
  }
  {
    const t2 = self.C3;
    t2.Behaviors.Anchor.Type = class extends t2.SDKBehaviorTypeBase {
      constructor(t3) {
        super(t3);
      }
      Release() {
        super.Release();
      }
      OnCreate() {
      }
    };
  }
  {
    const t2 = self.C3, e = (self.C3X, self.IBehaviorInstance), i = 0, s = 1, h2 = 2, o2 = 3, n = 4;
    t2.Behaviors.Anchor.Instance = class extends t2.SDKBehaviorInstanceBase {
      constructor(e2, a3) {
        super(e2), this._anchorLeft = 2, this._anchorTop = 2, this._anchorRight = 0, this._anchorBottom = 0, this._isEnabled = true;
        const r2 = this._inst.GetWorldInfo().GetBoundingBox();
        this._xLeft = r2.getLeft(), this._yTop = r2.getTop(), this._xRight = this._runtime.GetOriginalViewportWidth() - r2.getLeft(), this._yBottom = this._runtime.GetOriginalViewportHeight() - r2.getTop(), this._rDiff = this._runtime.GetOriginalViewportWidth() - r2.getRight(), this._bDiff = this._runtime.GetOriginalViewportHeight() - r2.getBottom(), a3 && (this._anchorLeft = a3[i], this._anchorTop = a3[s], this._anchorRight = a3[h2], this._anchorBottom = a3[o2], this._isEnabled = !!a3[n]);
        const _2 = this._runtime.Dispatcher();
        this._disposables = new t2.CompositeDisposable(t2.Disposable.From(_2, "layoutchange", () => this._OnLayoutChange())), this._isEnabled && this._StartTicking();
      }
      Release() {
        super.Release();
      }
      SaveToJson() {
        return { "xl": this._xLeft, "yt": this._yTop, "xr": this._xRight, "yb": this._yBottom, "rd": this._rDiff, "bd": this._bDiff, "al": this._anchorLeft, "at": this._anchorTop, "ar": this._anchorRight, "ab": this._anchorBottom, "e": this._isEnabled };
      }
      LoadFromJson(t3) {
        this._xLeft = t3["xl"], this._yTop = t3["yt"], this._xRight = t3["xr"], this._yBottom = t3["yb"], this._rDiff = t3["rd"], this._bDiff = t3["bd"], this._anchorLeft = t3["al"], this._anchorTop = t3["at"], this._anchorRight = t3["ar"], this._anchorBottom = t3["ab"], this._isEnabled = t3["e"], this._isEnabled ? this._StartTicking() : this._StopTicking();
      }
      _SetEnabled(t3) {
        if (this._isEnabled && !t3) this._isEnabled = false, this._StopTicking();
        else if (!this._isEnabled && t3) {
          const t4 = this._inst.GetWorldInfo().GetBoundingBox();
          this._xLeft = t4.getLeft(), this._yTop = t4.getTop(), this._xRight = this._runtime.GetOriginalViewportWidth() - t4.getLeft(), this._yBottom = this._runtime.GetOriginalViewportHeight() - t4.getTop(), this._rDiff = this._runtime.GetOriginalViewportWidth() - t4.getRight(), this._bDiff = this._runtime.GetOriginalViewportHeight() - t4.getBottom(), this._isEnabled = true, this._StartTicking();
        }
      }
      _IsEnabled() {
        return this._isEnabled;
      }
      _UpdatePosition() {
        if (!this._isEnabled) return;
        const t3 = this._inst.GetWorldInfo(), e2 = t3.GetLayer().GetViewport();
        if (0 === this._anchorLeft) {
          const i2 = e2.getLeft() + this._xLeft - t3.GetBoundingBox().getLeft();
          0 !== i2 && (t3.OffsetX(i2), t3.SetBboxChanged());
        } else if (1 === this._anchorLeft) {
          const i2 = e2.getRight() - this._xRight - t3.GetBoundingBox().getLeft();
          0 !== i2 && (t3.OffsetX(i2), t3.SetBboxChanged());
        }
        if (0 === this._anchorTop) {
          const i2 = e2.getTop() + this._yTop - t3.GetBoundingBox().getTop();
          0 !== i2 && (t3.OffsetY(i2), t3.SetBboxChanged());
        } else if (1 === this._anchorTop) {
          const i2 = e2.getBottom() - this._yBottom - t3.GetBoundingBox().getTop();
          0 !== i2 && (t3.OffsetY(i2), t3.SetBboxChanged());
        }
        if (1 === this._anchorRight) {
          const i2 = e2.getRight() - this._rDiff - t3.GetBoundingBox().getRight();
          0 !== i2 && (t3.OffsetX(t3.GetOriginX() * i2), t3.SetWidth(Math.max(t3.GetWidth() + i2), 0), t3.SetBboxChanged(), this._rDiff = e2.getRight() - t3.GetBoundingBox().getRight());
        }
        if (1 === this._anchorBottom) {
          const i2 = e2.getBottom() - this._bDiff - t3.GetBoundingBox().getBottom();
          0 !== i2 && (t3.OffsetY(t3.GetOriginY() * i2), t3.SetHeight(Math.max(t3.GetHeight() + i2, 0)), t3.SetBboxChanged(), this._bDiff = e2.getBottom() - t3.GetBoundingBox().getBottom());
        }
      }
      Tick() {
        this._UpdatePosition();
      }
      _OnLayoutChange() {
        this._UpdatePosition();
      }
      GetPropertyValueByIndex(t3) {
        switch (t3) {
          case i:
            return this._anchorLeft;
          case s:
            return this._anchorTop;
          case h2:
            return this._anchorRight;
          case o2:
            return this._anchorBottom;
          case n:
            return this._isEnabled;
        }
      }
      SetPropertyValueByIndex(t3, e2) {
        switch (t3) {
          case i:
            this._anchorLeft = e2;
            break;
          case s:
            this._anchorTop = e2;
            break;
          case h2:
            this._anchorRight = e2;
            break;
          case o2:
            this._anchorBottom = e2;
            break;
          case n:
            this._isEnabled = !!e2, this._isEnabled ? this._StartTicking() : this._StopTicking();
        }
      }
      GetDebuggerProperties() {
        return [{ title: "$" + this.GetBehaviorType().GetName(), properties: [{ name: "behaviors.anchor.properties.enabled.name", value: this._IsEnabled(), onedit: (t3) => this._SetEnabled(t3) }] }];
      }
      GetScriptInterfaceClass() {
        return self.IAnchorBehaviorInstance;
      }
    };
    const a2 = /* @__PURE__ */ new WeakMap();
    self.IAnchorBehaviorInstance = class extends e {
      constructor() {
        super(), a2.set(this, e._GetInitInst().GetSdkInstance());
      }
      get isEnabled() {
        return a2.get(this)._IsEnabled();
      }
      set isEnabled(t3) {
        a2.get(this)._SetEnabled(t3);
      }
    };
  }
  self.C3.Behaviors.Anchor.Cnds = { IsEnabled() {
    return this._IsEnabled();
  } };
  self.C3.Behaviors.Anchor.Acts = { SetEnabled(t2) {
    this._SetEnabled(0 !== t2);
  } };
  self.C3.Behaviors.Anchor.Exps = {};
}
{
  {
    const t2 = self.C3;
    t2.Behaviors.Pin = class extends t2.SDKBehaviorBase {
      constructor(t3) {
        super(t3);
      }
      Release() {
        super.Release();
      }
    };
  }
  {
    const t2 = self.C3;
    t2.Behaviors.Pin.Type = class extends t2.SDKBehaviorTypeBase {
      constructor(t3) {
        super(t3);
      }
      Release() {
        super.Release();
      }
      OnCreate() {
      }
    };
  }
  {
    const t2 = self.C3;
    t2.Behaviors.Pin.Instance = class extends t2.SDKBehaviorInstanceBase {
      constructor(s, e) {
        super(s), this._pinInst = null, this._pinUid = -1, this._mode = "", this._propSet = /* @__PURE__ */ new Set(), this._pinDist = 0, this._pinAngle = 0, this._pinImagePoint = 0, this._dx = 0, this._dy = 0, this._dWidth = 0, this._dHeight = 0, this._dAngle = 0, this._dz = 0, this._lastKnownAngle = 0, this._destroy = false, e && (this._destroy = e[0]);
        const i = this._runtime.Dispatcher();
        this._disposables = new t2.CompositeDisposable(t2.Disposable.From(i, "instancedestroy", (t3) => this._OnInstanceDestroyed(t3.instance)), t2.Disposable.From(i, "afterload", (t3) => this._OnAfterLoad()));
      }
      Release() {
        this._pinInst = null, super.Release();
      }
      _SetPinInst(t3) {
        t3 ? (this._pinInst = t3, this._StartTicking2()) : (this._pinInst = null, this._StopTicking2());
      }
      _Pin(s, e, i) {
        if (!s) return;
        const h2 = s.GetFirstPicked(this._inst);
        if (!h2) return;
        this._mode = e, this._SetPinInst(h2);
        const n = this._inst.GetWorldInfo(), a2 = h2.GetWorldInfo();
        if ("properties" === this._mode) {
          const s2 = this._propSet;
          s2.clear();
          for (const t3 of i) s2.add(t3);
          this._dx = n.GetX() - a2.GetX(), this._dy = n.GetY() - a2.GetY(), this._dAngle = n.GetAngle() - a2.GetAngle(), this._lastKnownAngle = n.GetAngle(), this._dz = n.GetZElevation() - a2.GetZElevation(), s2.has("x") && s2.has("y") && (this._pinAngle = t2.angleTo(a2.GetX(), a2.GetY(), n.GetX(), n.GetY()) - a2.GetAngle(), this._pinDist = t2.distanceTo(a2.GetX(), a2.GetY(), n.GetX(), n.GetY())), s2.has("width-abs") ? this._dWidth = n.GetWidth() - a2.GetWidth() : s2.has("width-scale") && (this._dWidth = n.GetWidth() / a2.GetWidth()), s2.has("height-abs") ? this._dHeight = n.GetHeight() - a2.GetHeight() : s2.has("height-scale") && (this._dHeight = n.GetHeight() / a2.GetHeight());
        } else this._pinDist = t2.distanceTo(a2.GetX(), a2.GetY(), n.GetX(), n.GetY());
      }
      SaveToJson() {
        const t3 = this._propSet, s = this._mode, e = { "uid": this._pinInst && !this._pinInst.IsDestroyed() ? this._pinInst.GetUID() : -1, "m": s, "d": this._destroy };
        return "rope" === s || "bar" === s ? e["pd"] = this._pinDist : "properties" === s && (e["ps"] = [...this._propSet], t3.has("imagepoint") ? e["ip"] = this._pinImagePoint : t3.has("x") && t3.has("y") ? (e["pa"] = this._pinAngle, e["pd"] = this._pinDist) : (t3.has("x") && (e["dx"] = this._dx), t3.has("y") && (e["dy"] = this._dy)), t3.has("angle") && (e["da"] = this._dAngle, e["lka"] = this._lastKnownAngle), (t3.has("width-abs") || t3.has("width-scale")) && (e["dw"] = this._dWidth), (t3.has("height-abs") || t3.has("height-scale")) && (e["dh"] = this._dHeight), t3.has("z") && (e["dz"] = this._dz)), e;
      }
      LoadFromJson(t3) {
        const s = t3["m"], e = this._propSet;
        if (e.clear(), this._pinUid = t3["uid"], "number" != typeof s) {
          if (this._mode = s, t3.hasOwnProperty("d") && (this._destroy = !!t3["d"]), "rope" === s || "bar" === s) this._pinDist = t3["pd"];
          else if ("properties" === s) {
            for (const s2 of t3["ps"]) e.add(s2);
            e.has("imagepoint") ? this._pinImagePoint = t3["ip"] : e.has("x") && e.has("y") ? (this._pinAngle = t3["pa"], this._pinDist = t3["pd"]) : (e.has("x") && (this._dx = t3["dx"]), e.has("y") && (this._dy = t3["dy"])), e.has("angle") && (this._dAngle = t3["da"], this._lastKnownAngle = t3["lka"] || 0), (e.has("width-abs") || e.has("width-scale")) && (this._dWidth = t3["dw"]), (e.has("height-abs") || e.has("height-scale")) && (this._dHeight = t3["dh"]), e.has("z") && (this._dz = t3["dz"]);
          }
        } else this._LoadFromJson_Legacy(t3);
      }
      _LoadFromJson_Legacy(t3) {
        const s = this._propSet, e = t3["msa"], i = t3["tsa"], h2 = t3["pa"], n = t3["pd"];
        switch (t3["m"]) {
          case 0:
            this._mode = "properties", s.add("x").add("y").add("angle"), this._pinAngle = h2, this._pinDist = n, this._dAngle = e - i, this._lastKnownAngle = t3["lka"];
            break;
          case 1:
            this._mode = "properties", s.add("x").add("y"), this._pinAngle = h2, this._pinDist = n;
            break;
          case 2:
            this._mode = "properties", s.add("angle"), this._dAngle = e - i, this._lastKnownAngle = t3["lka"];
            break;
          case 3:
            this._mode = "rope", this._pinDist = t3["pd"];
            break;
          case 4:
            this._mode = "bar", this._pinDist = t3["pd"];
        }
      }
      _OnAfterLoad() {
        -1 === this._pinUid ? this._SetPinInst(null) : (this._SetPinInst(this._runtime.GetInstanceByUID(this._pinUid)), this._pinUid = -1);
      }
      _OnInstanceDestroyed(t3) {
        this._pinInst === t3 && (this._SetPinInst(null), this._destroy && this._runtime.DestroyInstance(this._inst));
      }
      Tick2() {
        const s = this._pinInst;
        if (!s || s.IsDestroyed()) return;
        const e = s.GetWorldInfo(), i = this._inst.GetWorldInfo(), h2 = this._mode;
        let n = false;
        if ("rope" === h2 || "bar" === h2) {
          const s2 = t2.distanceTo(i.GetX(), i.GetY(), e.GetX(), e.GetY());
          if (s2 > this._pinDist || "bar" === h2 && s2 < this._pinDist) {
            const s3 = t2.angleTo(e.GetX(), e.GetY(), i.GetX(), i.GetY());
            i.SetXY(e.GetX() + Math.cos(s3) * this._pinDist, e.GetY() + Math.sin(s3) * this._pinDist), n = true;
          }
        } else {
          const h3 = this._propSet;
          let a2 = 0;
          if (h3.has("imagepoint")) {
            const [t3, e2] = s.GetImagePoint(this._pinImagePoint);
            i.EqualsXY(t3, e2) || (i.SetXY(t3, e2), n = true);
          } else if (h3.has("x") && h3.has("y")) {
            const t3 = e.GetX() + Math.cos(e.GetAngle() + this._pinAngle) * this._pinDist, s2 = e.GetY() + Math.sin(e.GetAngle() + this._pinAngle) * this._pinDist;
            i.EqualsXY(t3, s2) || (i.SetXY(t3, s2), n = true);
          } else a2 = e.GetX() + this._dx, h3.has("x") && a2 !== i.GetX() && (i.SetX(a2), n = true), a2 = e.GetY() + this._dy, h3.has("y") && a2 !== i.GetY() && (i.SetY(a2), n = true);
          h3.has("angle") && (this._lastKnownAngle !== i.GetAngle() && (this._dAngle = t2.clampAngle(this._dAngle + (i.GetAngle() - this._lastKnownAngle))), a2 = t2.clampAngle(e.GetAngle() + this._dAngle), a2 !== i.GetAngle() && (i.SetAngle(a2), n = true), this._lastKnownAngle = i.GetAngle()), h3.has("width-abs") && (a2 = e.GetWidth() + this._dWidth, a2 !== i.GetWidth() && (i.SetWidth(a2), n = true)), h3.has("width-scale") && (a2 = e.GetWidth() * this._dWidth, a2 !== i.GetWidth() && (i.SetWidth(a2), n = true)), h3.has("height-abs") && (a2 = e.GetHeight() + this._dHeight, a2 !== i.GetHeight() && (i.SetHeight(a2), n = true)), h3.has("height-scale") && (a2 = e.GetHeight() * this._dHeight, a2 !== i.GetHeight() && (i.SetHeight(a2), n = true)), h3.has("z") && (a2 = e.GetZElevation() + this._dz, a2 !== i.GetZElevation() && (i.SetZElevation(a2), this._runtime.UpdateRender()));
        }
        n && i.SetBboxChanged();
      }
      GetDebuggerProperties() {
        const t3 = "behaviors.pin.debugger";
        return [{ title: "$" + this.GetBehaviorType().GetName(), properties: [{ name: t3 + ".is-pinned", value: !!this._pinInst }, { name: t3 + ".pinned-uid", value: this._pinInst ? this._pinInst.GetUID() : 0 }] }];
      }
    };
  }
  self.C3.Behaviors.Pin.Cnds = { IsPinned() {
    return !!this._pinInst;
  }, WillDestroy() {
    return this._destroy;
  } };
  self.C3.Behaviors.Pin.Acts = { PinByDistance(t2, s) {
    this._Pin(t2, 0 === s ? "rope" : "bar");
  }, PinByProperties(t2, s, e, i, h2, n, a2) {
    const o2 = [];
    s && o2.push("x"), e && o2.push("y"), i && o2.push("angle"), a2 && o2.push("z"), 1 === h2 ? o2.push("width-abs") : 2 === h2 && o2.push("width-scale"), 1 === n ? o2.push("height-abs") : 2 === n && o2.push("height-scale"), 0 !== o2.length && this._Pin(t2, "properties", o2);
  }, PinByImagePoint(t2, s, e, i, h2, n) {
    const a2 = ["imagepoint"];
    e && a2.push("angle"), n && a2.push("z"), 1 === i ? a2.push("width-abs") : 2 === i && a2.push("width-scale"), 1 === h2 ? a2.push("height-abs") : 2 === h2 && a2.push("height-scale"), this._pinImagePoint = s, this._Pin(t2, "properties", a2);
  }, SetPinDistance(t2) {
    "rope" !== this._mode && "bar" !== this._mode || (this._pinDist = Math.max(t2, 0));
  }, SetDestroy(t2) {
    this._destroy = t2;
  }, Unpin() {
    this._SetPinInst(null), this._mode = "", this._propSet.clear(), this._pinImagePoint = "";
  }, Pin(t2, s) {
    switch (s) {
      case 0:
        this._Pin(t2, "properties", ["x", "y", "angle"]);
        break;
      case 1:
        this._Pin(t2, "properties", ["x", "y"]);
        break;
      case 2:
        this._Pin(t2, "properties", ["angle"]);
        break;
      case 3:
        this._Pin(t2, "rope");
        break;
      case 4:
        this._Pin(t2, "bar");
    }
  } };
  self.C3.Behaviors.Pin.Exps = { PinnedUID() {
    return this._pinInst ? this._pinInst.GetUID() : -1;
  } };
}
{
  {
    const e = self.C3;
    e.Behaviors.Sin = class extends e.SDKBehaviorBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
    };
  }
  {
    const e = self.C3;
    e.Behaviors.Sin.Type = class extends e.SDKBehaviorTypeBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
      OnCreate() {
      }
    };
  }
  {
    const e = self.C3, t2 = self.C3X, i = self.IBehaviorInstance, s = 0, a2 = 1, n = 2, h2 = 3, _2 = 4, r2 = 5, o2 = 6, l = 7, u2 = 8, d2 = 0, m2 = 1, g2 = 2, v2 = 3, c2 = 4, p2 = 5, G = 6, b2 = 7, S2 = 8, V = 9, w2 = 0, P2 = 1, M2 = 2, I2 = 3, f2 = 4, k = 2 * Math.PI, W = Math.PI / 2, E2 = 3 * Math.PI / 2, R = [0, 1, 8, 3, 4, 2, 5, 6, 9, 7];
    e.Behaviors.Sin.Instance = class extends e.SDKBehaviorInstanceBase {
      constructor(t3, i2) {
        super(t3), this._i = 0, this._movement = 0, this._wave = 0, this._period = 0, this._mag = 0, this._isEnabled = true, this._basePeriod = 0, this._basePeriodOffset = 0, this._baseMag = 0, this._periodRandom = 0, this._periodOffsetRandom = 0, this._magnitudeRandom = 0, this._initialValue = 0, this._initialValue2 = 0, this._lastKnownValue = 0, this._lastKnownValue2 = 0, this._ratio = 0, i2 && (this._movement = R[i2[s]], this._wave = i2[a2], this._periodRandom = this._runtime.Random() * i2[h2], this._basePeriod = i2[n], this._period = i2[n], this._period += this._periodRandom, this._basePeriodOffset = i2[_2], 0 !== this._period && (this._periodOffsetRandom = this._runtime.Random() * i2[r2], this._i = i2[_2] / this._period * k, this._i += this._periodOffsetRandom / this._period * k), this._magnitudeRandom = this._runtime.Random() * i2[l], this._baseMag = i2[o2], this._mag = i2[o2], this._mag += this._magnitudeRandom, this._isEnabled = !!i2[u2]), this._movement === p2 && (this._mag = e.toRadians(this._mag)), this.Init(), this._isEnabled && this._StartTicking();
      }
      Release() {
        super.Release();
      }
      SaveToJson() {
        return { "i": this._i, "e": this._isEnabled, "mv": this._movement, "w": this._wave, "p": this._period, "mag": this._mag, "iv": this._initialValue, "iv2": this._initialValue2, "r": this._ratio, "lkv": this._lastKnownValue, "lkv2": this._lastKnownValue2 };
      }
      LoadFromJson(e2) {
        this._i = e2["i"], this._SetEnabled(e2["e"]), this._movement = e2["mv"], this._wave = e2["w"], this._period = e2["p"], this._mag = e2["mag"], this._initialValue = e2["iv"], this._initialValue2 = e2["iv2"], this._ratio = e2["r"], this._lastKnownValue = e2["lkv"], this._lastKnownValue2 = e2["lkv2"];
      }
      Init() {
        const e2 = this._inst.GetWorldInfo();
        switch (this._movement) {
          case d2:
            this._initialValue = e2.GetX();
            break;
          case m2:
            this._initialValue = e2.GetY();
            break;
          case g2:
            this._initialValue = e2.GetWidth(), this._ratio = e2.GetHeight() / e2.GetWidth();
            break;
          case v2:
            this._initialValue = e2.GetWidth();
            break;
          case c2:
            this._initialValue = e2.GetHeight();
            break;
          case p2:
            this._initialValue = e2.GetAngle();
            break;
          case G:
            this._initialValue = e2.GetOpacity();
            break;
          case b2:
            this._initialValue = 0;
            break;
          case S2:
            this._initialValue = e2.GetX(), this._initialValue2 = e2.GetY();
            break;
          case V:
            this._initialValue = e2.GetZElevation();
        }
        this._lastKnownValue = this._initialValue, this._lastKnownValue2 = this._initialValue2;
      }
      WaveFunc(e2) {
        switch (e2 %= k, this._wave) {
          case w2:
            return Math.sin(e2);
          case P2:
            return e2 <= W ? e2 / W : e2 <= E2 ? 1 - 2 * (e2 - W) / Math.PI : (e2 - E2) / W - 1;
          case M2:
            return 2 * e2 / k - 1;
          case I2:
            return -2 * e2 / k + 1;
          case f2:
            return e2 < Math.PI ? -1 : 1;
        }
        return 0;
      }
      Tick() {
        const e2 = this._runtime.GetDt(this._inst);
        this._isEnabled && 0 !== e2 && (0 === this._period ? this._i = 0 : this._i = (this._i + e2 / this._period * k) % k, this._UpdateFromPhase());
      }
      _UpdateFromPhase() {
        const t3 = this._inst.GetWorldInfo();
        switch (this._movement) {
          case d2:
            t3.GetX() !== this._lastKnownValue && (this._initialValue += t3.GetX() - this._lastKnownValue), t3.SetX(this._initialValue + this.WaveFunc(this._i) * this._mag), this._lastKnownValue = t3.GetX();
            break;
          case m2:
            t3.GetY() !== this._lastKnownValue && (this._initialValue += t3.GetY() - this._lastKnownValue), t3.SetY(this._initialValue + this.WaveFunc(this._i) * this._mag), this._lastKnownValue = t3.GetY();
            break;
          case g2:
            t3.SetWidth(this._initialValue + this.WaveFunc(this._i) * this._mag), t3.SetHeight(t3.GetWidth() * this._ratio);
            break;
          case v2:
            t3.SetWidth(this._initialValue + this.WaveFunc(this._i) * this._mag);
            break;
          case c2:
            t3.SetHeight(this._initialValue + this.WaveFunc(this._i) * this._mag);
            break;
          case p2:
            t3.GetAngle() !== this._lastKnownValue && (this._initialValue = e.clampAngle(this._initialValue + (t3.GetAngle() - this._lastKnownValue))), t3.SetAngle(this._initialValue + this.WaveFunc(this._i) * this._mag), this._lastKnownValue = t3.GetAngle();
            break;
          case G:
            t3.SetOpacity(this._initialValue + this.WaveFunc(this._i) * this._mag / 100);
            break;
          case S2:
            t3.GetX() !== this._lastKnownValue && (this._initialValue += t3.GetX() - this._lastKnownValue), t3.GetY() !== this._lastKnownValue2 && (this._initialValue2 += t3.GetY() - this._lastKnownValue2), t3.SetX(this._initialValue + Math.cos(t3.GetAngle()) * this.WaveFunc(this._i) * this._mag), t3.SetY(this._initialValue2 + Math.sin(t3.GetAngle()) * this.WaveFunc(this._i) * this._mag), this._lastKnownValue = t3.GetX(), this._lastKnownValue2 = t3.GetY();
            break;
          case V:
            t3.SetZElevation(this._initialValue + this.WaveFunc(this._i) * this._mag);
        }
        t3.SetBboxChanged();
      }
      _OnSpriteFrameChanged(e2, t3) {
      }
      _SetPeriod(e2) {
        this._period = e2;
      }
      _GetPeriod() {
        return this._period;
      }
      _SetMagnitude(e2) {
        this._mag = e2;
      }
      _SetMagnitude_ConvertAngle(t3) {
        5 === this._movement && (t3 = e.toRadians(t3)), this._SetMagnitude(t3);
      }
      _GetMagnitude() {
        return this._mag;
      }
      _GetMagnitude_ConvertAngle() {
        let t3 = this._GetMagnitude();
        return 5 === this._movement && (t3 = e.toDegrees(t3)), t3;
      }
      _SetMovement(t3) {
        5 === this._movement && 5 !== t3 && (this._mag = e.toDegrees(this._mag)), this._movement = t3, this.Init();
      }
      _GetMovement() {
        return this._movement;
      }
      _SetWave(e2) {
        this._wave = e2;
      }
      _GetWave() {
        return this._wave;
      }
      _SetPhase(t3) {
        this._i = e.clamp(t3, 0, 2 * Math.PI), this._UpdateFromPhase();
      }
      _GetPhase() {
        return this._i;
      }
      _SetEnabled(e2) {
        this._isEnabled = !!e2, this._isEnabled ? this._StartTicking() : this._StopTicking();
      }
      _IsEnabled() {
        return this._isEnabled;
      }
      GetPropertyValueByIndex(e2) {
        switch (e2) {
          case s:
            return this._movement;
          case a2:
            return this._wave;
          case n:
            return this._basePeriod;
          case o2:
            return this._baseMag;
          case u2:
            return this._isEnabled;
        }
      }
      SetPropertyValueByIndex(t3, i2) {
        switch (t3) {
          case s:
            this._movement = R[i2], this.Init();
            break;
          case a2:
            this._wave = i2;
            break;
          case n:
            this._basePeriod = i2, this._period = this._basePeriod + this._periodRandom, this._isEnabled || (0 !== this._period ? (this._i = this._basePeriodOffset / this._period * k, this._i += this._periodOffsetRandom / this._period * k) : this._i = 0);
            break;
          case o2:
            this._baseMag = i2, this._mag = this._baseMag + this._magnitudeRandom, this._movement === p2 && (this._mag = e.toRadians(this._mag));
            break;
          case u2:
            this._isEnabled = !!i2;
        }
      }
      GetDebuggerProperties() {
        const e2 = "behaviors.sin";
        return [{ title: "$" + this.GetBehaviorType().GetName(), properties: [{ name: e2 + ".properties.enabled.name", value: this._IsEnabled(), onedit: (e3) => this._SetEnabled(e3) }, { name: e2 + ".properties.period.name", value: this._GetPeriod(), onedit: (e3) => this._SetPeriod(e3) }, { name: e2 + ".properties.magnitude.name", value: this._GetMagnitude_ConvertAngle(), onedit: (e3) => this._SetMagnitude_ConvertAngle(e3) }, { name: e2 + ".debugger.value", value: this.WaveFunc(this._GetPhase()) * this._GetMagnitude_ConvertAngle() }] }];
      }
      GetScriptInterfaceClass() {
        return self.ISineBehaviorInstance;
      }
    };
    const C2 = /* @__PURE__ */ new WeakMap(), K = ["horizontal", "vertical", "size", "width", "height", "angle", "opacity", "value-only", "forwards-backwards", "z-elevation"], F = ["sine", "triangle", "sawtooth", "reverse-sawtooth", "square"];
    self.ISineBehaviorInstance = class extends i {
      constructor() {
        super(), C2.set(this, i._GetInitInst().GetSdkInstance());
      }
      set period(e2) {
        t2.RequireFiniteNumber(e2), C2.get(this)._SetPeriod(e2);
      }
      get period() {
        return C2.get(this)._GetPeriod();
      }
      set magnitude(e2) {
        t2.RequireFiniteNumber(e2), C2.get(this)._SetMagnitude(e2);
      }
      get magnitude() {
        return C2.get(this)._GetMagnitude();
      }
      set phase(e2) {
        C2.get(this)._SetPhase(e2);
      }
      get phase() {
        return C2.get(this)._GetPhase();
      }
      set movement(e2) {
        t2.RequireString(e2);
        const i2 = K.indexOf(e2);
        if (-1 === i2) throw new Error("invalid movement");
        C2.get(this)._SetMovement(i2);
      }
      get movement() {
        return K[C2.get(this)._GetMovement()];
      }
      set wave(e2) {
        t2.RequireString(e2);
        const i2 = F.indexOf(e2);
        if (-1 === i2) throw new Error("invalid wave");
        C2.get(this)._SetWave(i2);
      }
      get wave() {
        return F[C2.get(this)._GetWave()];
      }
      get value() {
        const e2 = C2.get(this);
        return e2.WaveFunc(e2._GetPhase()) * e2._GetMagnitude();
      }
      updateInitialState() {
        C2.get(this).Init();
      }
      set isEnabled(e2) {
        C2.get(this)._SetEnabled(!!e2);
      }
      get isEnabled() {
        return C2.get(this)._IsEnabled();
      }
    };
  }
  {
    const e = self.C3;
    e.Behaviors.Sin.Cnds = { IsEnabled() {
      return this._IsEnabled();
    }, CompareMovement(e2) {
      return this._GetMovement() === e2;
    }, ComparePeriod(t2, i) {
      return e.compare(this._GetPeriod(), t2, i);
    }, CompareMagnitude(t2, i) {
      return e.compare(this._GetMagnitude_ConvertAngle(), t2, i);
    }, CompareWave(e2) {
      return this._GetWave() === e2;
    } };
  }
  self.C3.Behaviors.Sin.Acts = { SetEnabled(e) {
    this._SetEnabled(0 !== e);
  }, SetPeriod(e) {
    this._SetPeriod(e);
  }, SetMagnitude(e) {
    this._SetMagnitude_ConvertAngle(e);
  }, SetMovement(e) {
    this._SetMovement(e);
  }, SetWave(e) {
    this._wave = e;
  }, SetPhase(e) {
    const t2 = 2 * Math.PI;
    this._SetPhase(e * t2 % t2);
  }, UpdateInitialState() {
    this.Init();
  } };
  self.C3.Behaviors.Sin.Exps = { CyclePosition() {
    return this._GetPhase() / (2 * Math.PI);
  }, Period() {
    return this._GetPeriod();
  }, Magnitude() {
    return this._GetMagnitude_ConvertAngle();
  }, Value() {
    return this.WaveFunc(this._GetPhase()) * this._GetMagnitude_ConvertAngle();
  } };
}
{
  {
    const e = self.C3;
    e.Behaviors.Flash = class extends e.SDKBehaviorBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
    };
  }
  {
    const e = self.C3;
    e.Behaviors.Flash.Type = class extends e.SDKBehaviorTypeBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
      OnCreate() {
      }
    };
  }
  {
    const e = self.C3, t2 = self.C3X, s = self.IBehaviorInstance;
    e.Behaviors.Flash.Instance = class extends e.SDKBehaviorInstanceBase {
      constructor(e2, t3) {
        super(e2), this._onTime = 0, this._offTime = 0, this._stage = 0, this._stageTimeLeft = 0, this._timeLeft = 0, this._StartTicking();
      }
      Release() {
        super.Release();
      }
      _Flash(e2, t3, s2) {
        this._onTime = e2, this._offTime = t3, this._stage = 1, this._stageTimeLeft = t3, this._timeLeft = s2, this._inst.GetWorldInfo().SetVisible(false), this._runtime.UpdateRender();
      }
      _StopFlashing() {
        this._timeLeft = 0, this._inst.GetWorldInfo().SetVisible(true), this._runtime.UpdateRender();
      }
      _IsFlashing() {
        return this._timeLeft > 0;
      }
      SaveToJson() {
        return { "on": this._onTime, "off": this._offTime, "s": this._stage, "stl": this._stageTimeLeft, "tl": this._timeLeft };
      }
      LoadFromJson(e2) {
        this._onTime = e2["on"], this._offTime = e2["off"], this._stage = e2["s"], this._stageTimeLeft = e2["stl"], this._timeLeft = null === e2["tl"] ? 1 / 0 : e2["tl"];
      }
      Tick() {
        if (this._timeLeft <= 0) return;
        const t3 = this._runtime.GetDt(this._inst);
        if (this._timeLeft -= t3, this._timeLeft <= 0) return this._timeLeft = 0, this._inst.GetWorldInfo().SetVisible(true), this._runtime.UpdateRender(), this.DispatchScriptEvent("flashend"), this.DebugTrigger(e.Behaviors.Flash.Cnds.OnFlashEnded);
        this._stageTimeLeft -= t3, this._stageTimeLeft <= 0 && (0 === this._stage ? (this._inst.GetWorldInfo().SetVisible(false), this._stage = 1, this._stageTimeLeft += this._offTime) : (this._inst.GetWorldInfo().SetVisible(true), this._stage = 0, this._stageTimeLeft += this._onTime), this._runtime.UpdateRender());
      }
      GetDebuggerProperties() {
        const e2 = "behaviors.flash.debugger";
        return [{ title: "$" + this.GetBehaviorType().GetName(), properties: [{ name: e2 + ".on-time", value: this._onTime, onedit: (e3) => this._onTime = e3 }, { name: e2 + ".off-time", value: this._offTime, onedit: (e3) => this._offTime = e3 }, { name: e2 + ".is-flashing", value: this._timeLeft > 0 }, { name: e2 + ".time-left", value: this._timeLeft }] }];
      }
      GetScriptInterfaceClass() {
        return self.IFlashBehaviorInstance;
      }
    };
    const i = /* @__PURE__ */ new WeakMap();
    self.IFlashBehaviorInstance = class extends s {
      constructor() {
        super(), i.set(this, s._GetInitInst().GetSdkInstance());
      }
      flash(e2, s2, h2) {
        t2.RequireFiniteNumber(e2), t2.RequireFiniteNumber(s2), t2.RequireFiniteNumber(h2), i.get(this)._Flash(e2, s2, h2);
      }
      stop() {
        i.get(this)._StopFlashing();
      }
      get isFlashing() {
        return i.get(this)._IsFlashing();
      }
    };
  }
  self.C3.Behaviors.Flash.Cnds = { IsFlashing() {
    return this._IsFlashing();
  }, OnFlashEnded: () => true };
  self.C3.Behaviors.Flash.Acts = { Flash(e, t2, s) {
    this._Flash(e, t2, s);
  }, StopFlashing() {
    this._StopFlashing();
  } };
  self.C3.Behaviors.Flash.Exps = {};
}
{
  {
    const e = self.C3;
    e.Behaviors.scrollto = class extends e.SDKBehaviorBase {
      constructor(e2) {
        super(e2), this._shakeMag = 0, this._shakeStart = 0, this._shakeEnd = 0, this._shakeMode = 0;
      }
      Release() {
        super.Release();
      }
      SetShakeMagnitude(e2) {
        this._shakeMag = e2;
      }
      GetShakeMagnitude() {
        return this._shakeMag;
      }
      SetShakeStart(e2) {
        this._shakeStart = e2;
      }
      GetShakeStart() {
        return this._shakeStart;
      }
      SetShakeEnd(e2) {
        this._shakeEnd = e2;
      }
      GetShakeEnd() {
        return this._shakeEnd;
      }
      SetShakeMode(e2) {
        this._shakeMode = e2;
      }
      GetShakeMode() {
        return this._shakeMode;
      }
    };
  }
  {
    const e = self.C3;
    e.Behaviors.scrollto.Type = class extends e.SDKBehaviorTypeBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
      OnCreate() {
      }
    };
  }
  {
    const e = self.C3, t2 = 0;
    e.Behaviors.scrollto.Instance = class extends e.SDKBehaviorInstanceBase {
      constructor(e2, s) {
        super(e2), this._isEnabled = true, s && (this._isEnabled = s[t2]), this._isEnabled && this._StartTicking2();
      }
      Release() {
        super.Release();
      }
      SaveToJson() {
        const e2 = this.GetBehavior();
        return { "e": this._isEnabled, "smg": e2.GetShakeMagnitude(), "ss": e2.GetShakeStart(), "se": e2.GetShakeEnd(), "smd": e2.GetShakeMode() };
      }
      LoadFromJson(e2) {
        const t3 = this.GetBehavior();
        t3.SetShakeMagnitude(e2["smg"]), t3.SetShakeStart(e2["ss"]), t3.SetShakeEnd(e2["se"]), t3.SetShakeMode(e2["smd"]), this._isEnabled = e2["e"], this._isEnabled ? this._StartTicking2() : this._StopTicking2();
      }
      _SetEnabled(e2) {
        this._isEnabled = !!e2, this._isEnabled ? this._StartTicking2() : this._StopTicking2();
      }
      IsEnabled() {
        return this._isEnabled;
      }
      Tick2() {
        if (!this.IsEnabled()) return;
        this._runtime.GetDt(this._inst);
        const t3 = this.GetBehavior(), s = t3.GetInstances();
        let a2 = 0, i = 0, h2 = 0;
        for (const t4 of s) {
          const s2 = t4.GetBehaviorInstanceFromCtor(e.Behaviors.scrollto);
          if (!s2 || !s2.GetSdkInstance().IsEnabled()) continue;
          const n2 = t4.GetWorldInfo();
          a2 += n2.GetX(), i += n2.GetY(), ++h2;
        }
        const n = this._inst.GetWorldInfo().GetLayout(), r2 = this._runtime.GetGameTime();
        let o2 = 0, S2 = 0;
        if (r2 >= t3.GetShakeStart() && r2 < t3.GetShakeEnd()) {
          let e2 = t3.GetShakeMagnitude() * Math.min(this._runtime.GetTimeScale(), 1);
          0 === t3.GetShakeMode() && (e2 *= 1 - (r2 - t3.GetShakeStart()) / (t3.GetShakeEnd() - t3.GetShakeStart()));
          const s2 = this._runtime.Random() * Math.PI * 2, a3 = this._runtime.Random() * e2;
          o2 = Math.cos(s2) * a3, S2 = Math.sin(s2) * a3;
        }
        n.SetScrollX(a2 / h2 + o2), n.SetScrollY(i / h2 + S2);
      }
      GetPropertyValueByIndex(e2) {
        if (e2 === t2) return this._isEnabled;
      }
      SetPropertyValueByIndex(e2, s) {
        if (e2 === t2) this._isEnabled = !!s, this._isEnabled ? this._StartTicking2() : this._StopTicking2();
      }
      GetDebuggerProperties() {
        return [{ title: "$" + this.GetBehaviorType().GetName(), properties: [{ name: "behaviors.scrollto.properties.enabled.name", value: this.IsEnabled(), onedit: (e2) => this._SetEnabled(e2) }] }];
      }
    };
  }
  self.C3.Behaviors.scrollto.Cnds = { IsEnabled() {
    return this.IsEnabled();
  } };
  self.C3.Behaviors.scrollto.Acts = { Shake(e, t2, s) {
    const a2 = this.GetBehavior();
    a2.SetShakeMagnitude(e), a2.SetShakeStart(this._runtime.GetGameTime()), a2.SetShakeEnd(this._runtime.GetGameTime() + t2), a2.SetShakeMode(s);
  }, SetEnabled(e) {
    this._SetEnabled(0 !== e);
  } };
  self.C3.Behaviors.scrollto.Exps = {};
}
{
  {
    const e = self.C3;
    e.Behaviors.solid = class extends e.SDKBehaviorBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
    };
  }
  {
    const e = self.C3;
    e.Behaviors.solid.Type = class extends e.SDKBehaviorTypeBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
      OnCreate() {
      }
    };
  }
  {
    const e = self.C3, s = self.C3X, t2 = self.IBehaviorInstance, a2 = 0, n = 1, i = /* @__PURE__ */ new Set();
    e.Behaviors.solid.Instance = class extends e.SDKBehaviorInstanceBase {
      constructor(e2, s2) {
        super(e2), this.SetEnabled(true), s2 && (this.SetEnabled(s2[a2]), this.SetTags(s2[n]));
      }
      Release() {
        super.Release();
      }
      SetEnabled(e2) {
        this._inst._SetSolidEnabled(!!e2);
      }
      IsEnabled() {
        return this._inst._IsSolidEnabled();
      }
      SetTags(e2) {
        const s2 = this._inst.GetSavedDataMap();
        if (!e2.trim()) return void s2.delete("solidTags");
        let t3 = s2.get("solidTags");
        t3 || (t3 = /* @__PURE__ */ new Set(), s2.set("solidTags", t3)), t3.clear();
        for (const s3 of e2.split(" ")) s3 && t3.add(s3.toLowerCase());
      }
      GetTags() {
        return this._inst.GetSavedDataMap().get("solidTags") || i;
      }
      _GetTagsString() {
        return [...this.GetTags()].join(" ");
      }
      SaveToJson() {
        return { "e": this.IsEnabled() };
      }
      LoadFromJson(e2) {
        this.SetEnabled(e2["e"]);
      }
      GetPropertyValueByIndex(e2) {
        if (e2 === a2) return this.IsEnabled();
      }
      SetPropertyValueByIndex(e2, s2) {
        if (e2 === a2) this.SetEnabled(s2);
      }
      GetDebuggerProperties() {
        return [{ title: "$" + this.GetBehaviorType().GetName(), properties: [{ name: "behaviors.solid.properties.enabled.name", value: this.IsEnabled(), onedit: (e2) => this.SetEnabled(e2) }, { name: "behaviors.solid.properties.tags.name", value: this._GetTagsString(), onedit: (e2) => this.SetTags(e2) }] }];
      }
      GetScriptInterfaceClass() {
        return self.ISolidBehaviorInstance;
      }
    };
    const r2 = /* @__PURE__ */ new WeakMap();
    self.ISolidBehaviorInstance = class extends t2 {
      constructor() {
        super(), r2.set(this, t2._GetInitInst().GetSdkInstance());
      }
      set isEnabled(e2) {
        r2.get(this).SetEnabled(!!e2);
      }
      get isEnabled() {
        return r2.get(this).IsEnabled();
      }
      set tags(e2) {
        s.RequireString(e2), r2.get(this).SetTags(e2);
      }
      get tags() {
        return r2.get(this)._GetTagsString();
      }
    };
  }
  self.C3.Behaviors.solid.Cnds = { IsEnabled() {
    return this.IsEnabled();
  } };
  self.C3.Behaviors.solid.Acts = { SetEnabled(e) {
    this.SetEnabled(e);
  }, SetTags(e) {
    this.SetTags(e);
  } };
  self.C3.Behaviors.solid.Exps = {};
}
{
  {
    const e = self.C3;
    e.Behaviors.shadowcaster = class extends e.SDKBehaviorBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
    };
  }
  {
    const e = self.C3;
    e.Behaviors.shadowcaster.Type = class extends e.SDKBehaviorTypeBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
      OnCreate() {
      }
    };
  }
  {
    const e = self.C3, t2 = self.C3X, s = self.IBehaviorInstance, a2 = 0, i = 1, h2 = 2;
    e.Behaviors.shadowcaster.Instance = class extends e.SDKBehaviorInstanceBase {
      constructor(e2, t3) {
        super(e2), t3 ? (this.SetHeight(t3[a2]), this.SetTag(t3[i]), this.SetEnabled(!!t3[h2])) : (this.SetHeight(100), this.SetTag(""), this.SetEnabled(true));
      }
      Release() {
        super.Release();
      }
      SetHeight(e2) {
        this.GetHeight() !== e2 && (this._inst.GetSavedDataMap().set("shadowcasterHeight", e2), this._runtime.UpdateRender());
      }
      GetHeight() {
        return this._inst.GetSavedDataMap().get("shadowcasterHeight");
      }
      SetTag(e2) {
        this.GetTag() !== e2 && (this._inst.GetSavedDataMap().set("shadowcasterTag", e2), this._runtime.UpdateRender());
      }
      GetTag() {
        return this._inst.GetSavedDataMap().get("shadowcasterTag");
      }
      SetEnabled(e2) {
        this._inst.GetSavedDataMap().set("shadowcasterEnabled", !!e2);
      }
      IsEnabled() {
        return this._inst.GetSavedDataMap().get("shadowcasterEnabled");
      }
      SaveToJson() {
        return { "h": this.GetHeight(), "t": this.GetTag(), "e": this.IsEnabled() };
      }
      LoadFromJson(e2) {
        this.SetHeight(e2["h"]), this.SetTag(e2["t"]), this.SetEnabled(e2["e"]);
      }
      GetPropertyValueByIndex(e2) {
        switch (e2) {
          case a2:
            return this.GetHeight();
          case i:
            return this.GetTag();
          case h2:
            return this.IsEnabled();
        }
      }
      SetPropertyValueByIndex(e2, t3) {
        switch (e2) {
          case a2:
            this.SetHeight(t3);
            break;
          case i:
            this.SetTag(t3);
            break;
          case h2:
            this.SetEnabled(t3);
        }
      }
      GetDebuggerProperties() {
        const e2 = "behaviors.shadowcaster";
        this._inst.GetSavedDataMap();
        return [{ title: "$" + this.GetBehaviorType().GetName(), properties: [{ name: e2 + ".properties.enabled.name", value: this.IsEnabled(), onedit: (e3) => this.SetEnabled(e3) }, { name: e2 + ".properties.height.name", value: this.GetHeight(), onedit: (e3) => this.SetHeight(e3) }, { name: e2 + ".properties.tag.name", value: this.GetTag(), onedit: (e3) => this.SetTag(e3) }] }];
      }
      GetScriptInterfaceClass() {
        return self.IShadowCasterBehaviorInstance;
      }
    };
    const r2 = /* @__PURE__ */ new WeakMap();
    self.IShadowCasterBehaviorInstance = class extends s {
      constructor() {
        super(), r2.set(this, s._GetInitInst().GetSdkInstance());
      }
      set height(e2) {
        t2.RequireFiniteNumber(e2), r2.get(this).SetHeight(e2);
      }
      get height() {
        return r2.get(this).GetHeight();
      }
      set tag(e2) {
        t2.RequireString(e2), r2.get(this).SetTag(e2);
      }
      get tag() {
        return r2.get(this).GetTag();
      }
      get isEnabled() {
        return r2.get(this).IsEnabled();
      }
      set isEnabled(e2) {
        r2.get(this).SetEnabled(e2);
      }
    };
  }
  {
    const e = self.C3;
    e.Behaviors.shadowcaster.Cnds = { IsEnabled() {
      return this.IsEnabled();
    }, CompareHeight(t2, s) {
      return e.compare(this.GetHeight(), t2, s);
    } };
  }
  self.C3.Behaviors.shadowcaster.Acts = { SetEnabled(e) {
    this.SetEnabled(e);
  }, SetHeight(e) {
    this.SetHeight(e);
  }, SetTag(e) {
    this.SetTag(e);
  } };
  self.C3.Behaviors.shadowcaster.Exps = { Height() {
    return this.GetHeight();
  }, Tag() {
    return this.GetTag();
  } };
}
{
  {
    const e = self.C3;
    e.Behaviors.jumpthru = class extends e.SDKBehaviorBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
    };
  }
  {
    const e = self.C3;
    e.Behaviors.jumpthru.Type = class extends e.SDKBehaviorTypeBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
      OnCreate() {
      }
    };
  }
  {
    const e = self.C3, s = self.IBehaviorInstance, t2 = 0;
    e.Behaviors.jumpthru.Instance = class extends e.SDKBehaviorInstanceBase {
      constructor(e2, s2) {
        super(e2), this.SetEnabled(true), s2 && this.SetEnabled(s2[t2]);
      }
      Release() {
        super.Release();
      }
      SetEnabled(e2) {
        this._inst._SetJumpthruEnabled(!!e2);
      }
      IsEnabled() {
        return this._inst._IsJumpthruEnabled();
      }
      SaveToJson() {
        return { "e": this.IsEnabled() };
      }
      LoadFromJson(e2) {
        this.SetEnabled(e2["e"]);
      }
      GetPropertyValueByIndex(e2) {
        if (e2 === t2) return this.IsEnabled();
      }
      SetPropertyValueByIndex(e2, s2) {
        if (e2 === t2) this.SetEnabled(s2);
      }
      GetDebuggerProperties() {
        return [{ title: "$" + this.GetBehaviorType().GetName(), properties: [{ name: "behaviors.jumpthru.properties.enabled.name", value: this.IsEnabled(), onedit: (e2) => this.SetEnabled(e2) }] }];
      }
      GetScriptInterfaceClass() {
        return self.IJumpthruBehaviorInstance;
      }
    };
    const r2 = /* @__PURE__ */ new WeakMap();
    self.IJumpthruBehaviorInstance = class extends s {
      constructor() {
        super(), r2.set(this, s._GetInitInst().GetSdkInstance());
      }
      set isEnabled(e2) {
        r2.get(this).SetEnabled(!!e2);
      }
      get isEnabled() {
        return r2.get(this).IsEnabled();
      }
    };
  }
  self.C3.Behaviors.jumpthru.Cnds = { IsEnabled() {
    return this.IsEnabled();
  } };
  self.C3.Behaviors.jumpthru.Acts = { SetEnabled(e) {
    this.SetEnabled(e);
  } };
  self.C3.Behaviors.jumpthru.Exps = {};
}
{
  {
    const t2 = self.C3;
    t2.Behaviors.Bullet = class extends t2.SDKBehaviorBase {
      constructor(t3) {
        super(t3);
      }
      Release() {
        super.Release();
      }
    };
  }
  {
    const t2 = self.C3;
    t2.Behaviors.Bullet.Type = class extends t2.SDKBehaviorTypeBase {
      constructor(t3) {
        super(t3);
      }
      Release() {
        super.Release();
      }
      OnCreate() {
      }
    };
  }
  {
    const t2 = self.C3, e = self.C3X, s = self.IBehaviorInstance, i = 0, n = 1, h2 = 2, a2 = 3, _2 = 4, l = 5, o2 = 6;
    t2.Behaviors.Bullet.Instance = class extends t2.SDKBehaviorInstanceBase {
      constructor(t3, e2) {
        super(t3);
        const s2 = this.GetWorldInfo();
        this._speed = 0, this._acc = 0, this._g = 0, this._bounceOffSolid = false, this._setAngle = false, this._isStepping = false, this._isEnabled = true, this._dx = 0, this._dy = 0, this._lastX = s2.GetX(), this._lastY = s2.GetY(), this._lastKnownAngle = s2.GetAngle(), this._travelled = 0, this._stepSize = Math.min(Math.abs(s2.GetWidth()), Math.abs(s2.GetHeight()) / 2), this._stopStepping = false, e2 && (this._speed = e2[i], this._acc = e2[n], this._g = e2[h2], this._bounceOffSolid = !!e2[a2], this._setAngle = !!e2[_2], this._isStepping = !!e2[l], this._isEnabled = !!e2[o2]);
        const r3 = s2.GetAngle();
        this._dx = Math.cos(r3) * this._speed, this._dy = Math.sin(r3) * this._speed, this._isEnabled && (this._StartTicking(), this._bounceOffSolid && this._StartPostTicking());
      }
      Release() {
        super.Release();
      }
      SaveToJson() {
        const t3 = { "dx": this._dx, "dy": this._dy, "lx": this._lastX, "ly": this._lastY, "lka": this._lastKnownAngle, "t": this._travelled };
        return 0 !== this._acc && (t3["acc"] = this._acc), 0 !== this._g && (t3["g"] = this._g), this._isStepping && (t3["st"] = this._isStepping), this._isEnabled || (t3["e"] = this._isEnabled), this._bounceOffSolid && (t3["bos"] = this._bounceOffSolid), this._setAngle && (t3["sa"] = this._setAngle), t3;
      }
      LoadFromJson(t3) {
        this._dx = t3["dx"], this._dy = t3["dy"], this._lastX = t3["lx"], this._lastY = t3["ly"], this._lastKnownAngle = t3["lka"], this._travelled = t3["t"], this._acc = t3.hasOwnProperty("acc") ? t3["acc"] : 0, this._g = t3.hasOwnProperty("g") ? t3["g"] : 0, this._isStepping = !!t3.hasOwnProperty("st") && t3["st"], this._bounceOffSolid = !!t3.hasOwnProperty("bos") && t3["bos"], this._setAngle = !!t3.hasOwnProperty("sa") && t3["sa"], this._SetEnabled(!t3.hasOwnProperty("e") || t3["e"]);
      }
      Tick() {
        if (!this._isEnabled) return;
        const e2 = this._runtime.GetDt(this._inst), s2 = this._inst.GetWorldInfo();
        if (s2.GetAngle() !== this._lastKnownAngle) {
          const e3 = s2.GetAngle();
          if (this._setAngle) {
            const s3 = t2.distanceTo(0, 0, this._dx, this._dy);
            this._dx = Math.cos(e3) * s3, this._dy = Math.sin(e3) * s3;
          }
          this._lastKnownAngle = e3;
        }
        let i2 = 0, n2 = 0;
        if (0 !== this._acc) {
          let h3 = t2.distanceTo(0, 0, this._dx, this._dy), a3 = 0;
          a3 = 0 === this._dx && 0 === this._dy ? s2.GetAngle() : t2.angleTo(0, 0, this._dx, this._dy), h3 += this._acc * e2, i2 = Math.cos(a3) * this._acc, n2 = Math.sin(a3) * this._acc, h3 < 0 && (h3 = 0, i2 = 0, n2 = 0), this._dx = Math.cos(a3) * h3, this._dy = Math.sin(a3) * h3;
        }
        if (0 !== this._g && (this._dy += this._g * e2, n2 += this._g), this._lastX = s2.GetX(), this._lastY = s2.GetY(), 0 !== this._dx || 0 !== this._dy) {
          const h3 = this._dx * e2 + 0.5 * i2 * e2 * e2, a3 = this._dy * e2 + 0.5 * n2 * e2 * e2, _3 = t2.distanceTo(0, 0, h3, a3);
          if (this._MoveBy(h3, a3, _3), this._travelled += _3, this._setAngle && (0 !== h3 || 0 !== a3)) {
            const e3 = t2.angleTo(0, 0, h3, a3);
            s2.SetAngle(e3), this._lastKnownAngle = s2.GetAngle();
          }
          s2.SetBboxChanged();
        }
      }
      _MoveBy(e2, s2, i2) {
        const n2 = this.GetWorldInfo();
        if (!this._isStepping || i2 <= this._stepSize) return n2.OffsetXY(e2, s2), n2.SetBboxChanged(), void (this._isStepping && this.Trigger(t2.Behaviors.Bullet.Cnds.OnStep));
        this._stopStepping = false;
        const h3 = n2.GetX(), a3 = n2.GetY(), _3 = h3 + e2, l2 = a3 + s2, o3 = t2.angleTo(0, 0, e2, s2), r3 = Math.cos(o3) * this._stepSize, d2 = Math.sin(o3) * this._stepSize, c2 = Math.floor(i2 / this._stepSize);
        for (let e3 = 1; e3 <= c2; ++e3) if (n2.SetXY(h3 + r3 * e3, a3 + d2 * e3), n2.SetBboxChanged(), this.Trigger(t2.Behaviors.Bullet.Cnds.OnStep), this._inst.IsDestroyed() || this._stopStepping) return;
        n2.SetXY(_3, l2), n2.SetBboxChanged(), this.Trigger(t2.Behaviors.Bullet.Cnds.OnStep);
      }
      PostTick() {
        if (!this._isEnabled || !this._bounceOffSolid || 0 === this._dx && 0 === this._dy) return;
        const e2 = this._runtime.GetDt(this._inst), s2 = this._inst.GetWorldInfo(), i2 = this._runtime.GetCollisionEngine(), n2 = i2.TestOverlapSolid(this._inst);
        if (n2) {
          i2.RegisterCollision(this._inst, n2);
          const h3 = t2.distanceTo(0, 0, this._dx, this._dy), a3 = i2.CalculateBounceAngle(this._inst, this._lastX, this._lastY);
          this._dx = Math.cos(a3) * h3, this._dy = Math.sin(a3) * h3, s2.OffsetXY(this._dx * e2, this._dy * e2), s2.SetBboxChanged(), this._setAngle && (s2.SetAngle(a3), this._lastKnownAngle = s2.GetAngle(), s2.SetBboxChanged()), i2.PushOutSolid(this._inst, this._dx / h3, this._dy / h3, Math.max(2.5 * h3 * e2, 30)) || i2.PushOutSolidNearest(this._inst, 100);
        }
      }
      GetPropertyValueByIndex(t3) {
        switch (t3) {
          case i:
            return this._GetSpeed();
          case n:
            return this._GetAcceleration();
          case h2:
            return this._GetGravity();
          case _2:
            return this._setAngle;
          case l:
            return this._isStepping;
          case o2:
            return this._IsEnabled();
        }
      }
      SetPropertyValueByIndex(t3, e2) {
        switch (t3) {
          case i:
            this._SetSpeed(e2);
            break;
          case n:
            this._acc = e2;
            break;
          case h2:
            this._g = e2;
            break;
          case _2:
            this._setAngle = !!e2;
            break;
          case l:
            this._isStepping = !!e2;
            break;
          case o2:
            this._SetEnabled(!!e2);
        }
      }
      _SetSpeed(e2) {
        const s2 = t2.angleTo(0, 0, this._dx, this._dy);
        this._dx = Math.cos(s2) * e2, this._dy = Math.sin(s2) * e2;
      }
      _GetSpeed() {
        return t2.roundToDp(t2.distanceTo(0, 0, this._dx, this._dy), 6);
      }
      _SetAcceleration(t3) {
        this._acc = t3;
      }
      _GetAcceleration() {
        return this._acc;
      }
      _SetGravity(t3) {
        this._g = t3;
      }
      _GetGravity() {
        return this._g;
      }
      _SetAngleOfMotion(e2) {
        const s2 = t2.distanceTo(0, 0, this._dx, this._dy);
        this._dx = Math.cos(e2) * s2, this._dy = Math.sin(e2) * s2;
      }
      _GetAngleOfMotion() {
        return t2.angleTo(0, 0, this._dx, this._dy);
      }
      _SetBounceOffSolids(t3) {
        t3 = !!t3, this._bounceOffSolid !== t3 && (this._bounceOffSolid = t3, this._isEnabled && (this._bounceOffSolid ? this._StartPostTicking() : this._StopPostTicking()));
      }
      _IsBounceOffSolids() {
        return this._bounceOffSolid;
      }
      _SetDistanceTravelled(t3) {
        this._travelled = t3;
      }
      _GetDistanceTravelled() {
        return this._travelled;
      }
      _SetEnabled(t3) {
        this._isEnabled = !!t3, this._isEnabled ? (this._StartTicking(), this._bounceOffSolid && this._StartPostTicking()) : (this._StopTicking(), this._StopPostTicking());
      }
      _IsEnabled() {
        return this._isEnabled;
      }
      GetDebuggerProperties() {
        const e2 = "behaviors.bullet";
        return [{ title: "$" + this.GetBehaviorType().GetName(), properties: [{ name: e2 + ".debugger.vector-x", value: this._dx, onedit: (t3) => this._dx = t3 }, { name: e2 + ".debugger.vector-y", value: this._dy, onedit: (t3) => this._dy = t3 }, { name: e2 + ".properties.speed.name", value: this._GetSpeed(), onedit: (t3) => this._SetSpeed(t3) }, { name: e2 + ".debugger.angle-of-motion", value: t2.toDegrees(this._GetAngleOfMotion()) }, { name: e2 + ".properties.gravity.name", value: this._GetGravity(), onedit: (t3) => this._SetGravity(t3) }, { name: e2 + ".properties.acceleration.name", value: this._GetAcceleration(), onedit: (t3) => this._SetAcceleration(t3) }, { name: e2 + ".debugger.distance-travelled", value: this._GetDistanceTravelled() }, { name: e2 + ".properties.enabled.name", value: this._IsEnabled(), onedit: (t3) => this._SetEnabled(t3) }] }];
      }
      GetScriptInterfaceClass() {
        return self.IBulletBehaviorInstance;
      }
    };
    const r2 = /* @__PURE__ */ new WeakMap();
    self.IBulletBehaviorInstance = class extends s {
      constructor() {
        super(), r2.set(this, s._GetInitInst().GetSdkInstance());
      }
      get speed() {
        return r2.get(this)._GetSpeed();
      }
      set speed(t3) {
        e.RequireFiniteNumber(t3), r2.get(this)._SetSpeed(t3);
      }
      get acceleration() {
        return r2.get(this)._GetAcceleration();
      }
      set acceleration(t3) {
        e.RequireFiniteNumber(t3), r2.get(this)._SetAcceleration(t3);
      }
      get gravity() {
        return r2.get(this)._GetGravity();
      }
      set gravity(t3) {
        e.RequireFiniteNumber(t3), r2.get(this)._SetGravity(t3);
      }
      get angleOfMotion() {
        return r2.get(this)._GetAngleOfMotion();
      }
      set angleOfMotion(t3) {
        e.RequireFiniteNumber(t3), r2.get(this)._SetAngleOfMotion(t3);
      }
      get bounceOffSolids() {
        return r2.get(this)._IsBounceOffSolids();
      }
      set bounceOffSolids(t3) {
        r2.get(this)._SetBounceOffSolids(!!t3);
      }
      get distanceTravelled() {
        return r2.get(this)._GetDistanceTravelled();
      }
      set distanceTravelled(t3) {
        e.RequireFiniteNumber(t3), r2.get(this)._SetDistanceTravelled(t3);
      }
      get isEnabled() {
        return r2.get(this)._IsEnabled();
      }
      set isEnabled(t3) {
        r2.get(this)._SetEnabled(t3);
      }
    };
  }
  {
    const t2 = self.C3;
    t2.Behaviors.Bullet.Cnds = { CompareSpeed(e, s) {
      const i = Math.hypot(this._dx, this._dy);
      return t2.compare(i, e, s);
    }, CompareTravelled(e, s) {
      return t2.compare(this._GetDistanceTravelled(), e, s);
    }, OnStep: () => true, IsEnabled() {
      return this._IsEnabled();
    } };
  }
  {
    const t2 = self.C3;
    t2.Behaviors.Bullet.Acts = { SetSpeed(t3) {
      this._SetSpeed(t3);
    }, SetAcceleration(t3) {
      this._SetAcceleration(t3);
    }, SetGravity(t3) {
      this._SetGravity(t3);
    }, SetAngleOfMotion(e) {
      this._SetAngleOfMotion(t2.toRadians(e));
    }, Bounce(e) {
      if (!e) return;
      const s = e.GetFirstPicked(this._inst);
      if (!s) return;
      const i = this._inst.GetWorldInfo(), n = this._runtime.GetCollisionEngine(), h2 = this._runtime.GetDt(this._inst), a2 = t2.distanceTo(0, 0, this._dx, this._dy), _2 = n.CalculateBounceAngle(this._inst, this._lastX, this._lastY, s);
      this._dx = Math.cos(_2) * a2, this._dy = Math.sin(_2) * a2, i.OffsetXY(this._dx * h2, this._dy * h2), i.SetBboxChanged(), this._setAngle && (i.SetAngle(_2), this._lastKnownAngle = i.GetAngle(), i.SetBboxChanged()), 0 !== a2 && (this._bounceOffSolid ? n.PushOutSolid(this._inst, this._dx / a2, this._dy / a2, Math.max(2.5 * a2 * h2, 30)) || n.PushOutSolidNearest(this._inst, 100) : n.PushOut(this._inst, this._dx / a2, this._dy / a2, Math.max(2.5 * a2 * h2, 30), s));
    }, SetBounceOffSolids(t3) {
      this._SetBounceOffSolids(t3);
    }, SetDistanceTravelled(t3) {
      this._SetDistanceTravelled(t3);
    }, SetEnabled(t3) {
      this._SetEnabled(t3);
    }, StopStepping() {
      this._stopStepping = true;
    } };
  }
  {
    const t2 = self.C3;
    t2.Behaviors.Bullet.Exps = { Speed() {
      return this._GetSpeed();
    }, Acceleration() {
      return this._GetAcceleration();
    }, AngleOfMotion() {
      return t2.toDegrees(this._GetAngleOfMotion());
    }, DistanceTravelled() {
      return this._GetDistanceTravelled();
    }, Gravity() {
      return this._GetGravity();
    } };
  }
}
{
  {
    const e = self.C3;
    e.Behaviors.Turret = class extends e.SDKBehaviorBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
    };
  }
  {
    const e = self.C3;
    e.Behaviors.Turret.Type = class extends e.SDKBehaviorTypeBase {
      constructor(e2) {
        super(e2), this._targetTypes = [];
      }
      Release() {
        e.clearArray(this._targetTypes), super.Release();
      }
      OnCreate() {
      }
      GetTargetTypes() {
        return this._targetTypes;
      }
    };
  }
  {
    const e = self.C3, t2 = self.C3X, r2 = self.IBehaviorInstance, i = 0, s = 1, a2 = 2, n = 3, o2 = 4, h2 = 5, _2 = 6, l = 7, c2 = 8, d2 = e.New(e.Rect), g2 = [];
    e.Behaviors.Turret.Instance = class extends e.SDKBehaviorInstanceBase {
      constructor(t3, r3) {
        super(t3), this._range = 300, this._rateOfFire = 1, this._isRotateEnabled = true, this._rotateSpeed = e.toRadians(180), this._targetMode = 0, this._predictiveAim = false, this._projectileSpeed = 500, this._useCollisionCells = true, this._isEnabled = true, this._lastCheckTime = 0, this._fireTimeCount = 0, this._currentTarget = null, this._loadTargetUid = -1, this._oldTargetX = 0, this._oldTargetY = 0, r3 && (this._range = r3[i], this._rateOfFire = r3[s], this._isRotateEnabled = !!r3[a2], this._rotateSpeed = e.toRadians(r3[n]), this._targetMode = r3[o2], this._predictiveAim = !!r3[h2], this._projectileSpeed = r3[_2], this._useCollisionCells = !!r3[l], this._isEnabled = !!r3[c2]), this._fireTimeCount = this._rateOfFire;
        const d3 = this._runtime.Dispatcher();
        this._disposables = new e.CompositeDisposable(e.Disposable.From(d3, "instancedestroy", (e2) => this._OnInstanceDestroyed(e2.instance)), e.Disposable.From(d3, "afterload", (e2) => this._OnAfterLoad())), this._isEnabled && this._StartTicking();
      }
      Release() {
        this._currentTarget = null, super.Release();
      }
      _OnAfterLoad() {
        -1 === this._loadTargetUid ? this._currentTarget = null : this._currentTarget = this._runtime.GetInstanceByUID(this._loadTargetUid);
      }
      _OnInstanceDestroyed(e2) {
        this._currentTarget === e2 && (this._currentTarget = null);
      }
      _MaybeAcquireTargetInstance(e2) {
        return !(this._currentTarget === e2 || this._inst === e2 || !this.IsInRange(e2)) && (this._currentTarget = e2, this._OnTargetAcquired(), true);
      }
      _UnacquireTarget() {
        this._currentTarget = null;
      }
      _SetRange(e2) {
        this._range = e2;
      }
      _GetRange() {
        return this._range;
      }
      _SetRateOfFire(e2) {
        this._rateOfFire = e2;
      }
      _GetRateOfFire() {
        return this._rateOfFire;
      }
      _SetRotateEnabled(e2) {
        this._isRotateEnabled = !!e2;
      }
      _IsRotateEnabled() {
        return this._isRotateEnabled;
      }
      _SetRotateSpeed(e2) {
        this._rotateSpeed = e2;
      }
      _GetRotateSpeed() {
        return this._rotateSpeed;
      }
      _SetTargetMode(e2) {
        this._targetMode = e2;
      }
      _GetTargetMode() {
        return this._targetMode;
      }
      _SetPredictiveAim(e2) {
        this._predictiveAim = !!e2;
      }
      _IsPredictiveAim() {
        return this._predictiveAim;
      }
      _SetProjectileSpeed(e2) {
        this._projectileSpeed = e2;
      }
      _GetProjectileSpeed() {
        return this._projectileSpeed;
      }
      _SetEnabled(e2) {
        this._isEnabled = !!e2, this._isEnabled ? this._StartTicking() : this._StopTicking();
      }
      _IsEnabled() {
        return this._isEnabled;
      }
      SaveToJson() {
        return { "r": this._range, "rof": this._rateOfFire, "re": this._isRotateEnabled, "rs": this._rotateSpeed, "tm": this._targetMode, "pa": this._predictiveAim, "ps": this._projectileSpeed, "ucc": this._useCollisionCells, "e": this._isEnabled, "ftc": this._fireTimeCount, "t": this._currentTarget ? this._currentTarget.GetUID() : -1, "ox": this._oldTargetX, "oy": this._oldTargetY, "targs": this.GetSdkType().GetTargetTypes().map((e2) => e2.GetSID()) };
      }
      LoadFromJson(t3) {
        this._range = t3["r"], this._rateOfFire = t3["rof"], this._isRotateEnabled = t3["re"], this._rotateSpeed = t3["rs"], this._targetMode = t3["tm"], this._predictiveAim = t3["pa"], this._projectileSpeed = t3["ps"], this._useCollisionCells = t3["ucc"], this._SetEnabled(t3["e"]), this._fireTimeCount = t3["ftc"], this._loadTargetUid = t3["t"], this._oldTargetX = t3["ox"], this._oldTargetY = t3["oy"], this._lastCheckTime = 0;
        const r3 = this.GetSdkType().GetTargetTypes();
        e.clearArray(r3);
        for (const e2 of t3["targs"]) {
          const t4 = this._runtime.GetObjectClassBySID(e2);
          t4 && r3.push(t4);
        }
      }
      IsInRange(e2) {
        const t3 = this.GetWorldInfo(), r3 = e2.GetWorldInfo(), i2 = r3.GetX() - t3.GetX(), s2 = r3.GetY() - t3.GetY();
        return i2 * i2 + s2 * s2 <= this._range * this._range;
      }
      LookForFirstTarget() {
        const t3 = this.GetWorldInfo(), r3 = this.GetSdkType().GetTargetTypes(), i2 = this._runtime.GetCollisionEngine();
        if (this._useCollisionCells) d2.set(t3.GetX() - this._range, t3.GetY() - this._range, t3.GetX() + this._range, t3.GetY() + this._range), i2.GetObjectClassesCollisionCandidates(t3.GetLayer(), r3, d2, g2);
        else for (const t4 of r3) e.appendArray(g2, t4.GetInstances());
        for (const t4 of g2) if (t4 !== this._inst && this.IsInRange(t4)) return this._currentTarget = t4, void e.clearArray(g2);
        e.clearArray(g2);
      }
      LookForNearestTarget() {
        const t3 = this.GetWorldInfo(), r3 = this.GetSdkType().GetTargetTypes(), i2 = this._runtime.GetCollisionEngine(), s2 = t3.GetX(), a3 = t3.GetY();
        let n2 = this._range * this._range;
        if (this._currentTarget = null, this._useCollisionCells) d2.set(s2 - this._range, a3 - this._range, s2 + this._range, a3 + this._range), i2.GetObjectClassesCollisionCandidates(t3.GetLayer(), r3, d2, g2);
        else for (const t4 of r3) e.appendArray(g2, t4.GetInstances());
        for (const e2 of g2) {
          if (e2 === this._inst) continue;
          const t4 = e2.GetWorldInfo(), r4 = s2 - t4.GetX(), i3 = a3 - t4.GetY(), o3 = r4 * r4 + i3 * i3;
          o3 < n2 && (this._currentTarget = e2, n2 = o3);
        }
        e.clearArray(g2);
      }
      _OnTargetAcquired() {
        const t3 = this._currentTarget.GetWorldInfo();
        this._oldTargetX = t3.GetX(), this._oldTargetY = t3.GetY(), this.DispatchScriptEvent("targetacquired", false, { targetInst: this._currentTarget.GetInterfaceClass() }), this.Trigger(e.Behaviors.Turret.Cnds.OnTargetAcquired);
      }
      Tick() {
        if (!this._isEnabled) return;
        const t3 = this._runtime.GetDt(this._inst), r3 = this._runtime.GetGameTime(), i2 = this.GetWorldInfo();
        if (this._currentTarget && !this.IsInRange(this._currentTarget) && (this._currentTarget = null), r3 >= this._lastCheckTime + 0.1) if (this._lastCheckTime = r3, 0 !== this._targetMode || this._currentTarget) {
          if (1 === this._targetMode) {
            const e2 = this._currentTarget;
            this.LookForNearestTarget(), this._currentTarget && this._currentTarget !== e2 && this._OnTargetAcquired();
          }
        } else this.LookForFirstTarget(), this._currentTarget && this._OnTargetAcquired();
        if (this._fireTimeCount += t3, this._currentTarget) {
          let r4 = this._currentTarget.GetWorldInfo();
          const s2 = i2.GetX(), a3 = i2.GetY(), n2 = r4.GetX(), o3 = r4.GetY(), h3 = e.angleTo(s2, a3, r4.GetX(), r4.GetY());
          let _3 = 0;
          if (this._predictiveAim) {
            const r5 = n2 - s2, i3 = o3 - a3, l2 = (n2 - this._oldTargetX) / t3, c3 = (o3 - this._oldTargetY) / t3, d3 = r5 * c3 - i3 * l2, g3 = Math.asin(e.clamp(d3 / (this._projectileSpeed * e.hypot2DFast(r5, i3)), -1, 1)) + h3;
            _3 = (Math.cos(g3) * c3 - Math.sin(g3) * l2) * d3 > 0 ? g3 : h3;
          } else _3 = h3;
          this._isRotateEnabled && (i2.SetAngle(e.angleRotate(i2.GetAngle(), _3, this._rotateSpeed * t3)), i2.SetBboxChanged()), this._fireTimeCount >= this._rateOfFire && (!this._isRotateEnabled || e.toDegrees(e.angleDiff(i2.GetAngle(), _3)) <= 0.1) && (this._fireTimeCount -= this._rateOfFire, this._fireTimeCount >= this._rateOfFire && (this._fireTimeCount = 0), this.DispatchScriptEvent("shoot", false, { targetInst: this._currentTarget.GetInterfaceClass() }), this.Trigger(e.Behaviors.Turret.Cnds.OnShoot)), this._currentTarget && (r4 = this._currentTarget.GetWorldInfo(), this._oldTargetX = r4.GetX(), this._oldTargetY = r4.GetY());
        }
        this._fireTimeCount > this._rateOfFire && (this._fireTimeCount = this._rateOfFire);
      }
      GetPropertyValueByIndex(t3) {
        switch (t3) {
          case i:
            return this._GetRange();
          case s:
            return this._GetRateOfFire();
          case a2:
            return this._IsRotateEnabled();
          case n:
            return e.toDegrees(this._GetRotateSpeed());
          case o2:
            return this._GetTargetMode();
          case h2:
            return this._IsPredictiveAim();
          case _2:
            return this._GetProjectileSpeed();
          case l:
            return this._useCollisionCells;
          case c2:
            return this._IsEnabled();
        }
      }
      SetPropertyValueByIndex(t3, r3) {
        switch (t3) {
          case i:
            this._SetRange(r3);
            break;
          case s:
            this._SetRateOfFire(r3);
            break;
          case a2:
            this._SetRotateEnabled(!!r3);
            break;
          case n:
            if (!this._IsRotateEnabled()) return;
            this._SetRotateSpeed(e.toRadians(r3));
            break;
          case o2:
            this._SetTargetMode(r3);
            break;
          case h2:
            this._SetPredictiveAim(!!r3);
            break;
          case _2:
            if (!this._IsPredictiveAim()) return;
            this._SetProjectileSpeed(r3);
            break;
          case l:
            this._useCollisionCells = !!r3;
            break;
          case c2:
            this._SetEnabled(r3);
        }
      }
      GetDebuggerProperties() {
        const t3 = "behaviors.turret";
        return [{ title: "$" + this.GetBehaviorType().GetName(), properties: [{ name: t3 + ".properties.range.name", value: this._GetRange(), onedit: (e2) => this._SetRange(e2) }, { name: t3 + ".properties.rate-of-fire.name", value: this._GetRateOfFire(), onedit: (e2) => this._SetRateOfFire(e2) }, { name: t3 + ".properties.rotate-speed.name", value: e.toDegrees(this._GetRotateSpeed()), onedit: (t4) => this._SetRotateSpeed(e.toRadians(t4)) }, { name: t3 + ".properties.predictive-aim.name", value: this._IsPredictiveAim(), onedit: (e2) => this._SetPredictiveAim(e2) }, { name: t3 + ".properties.projectile-speed.name", value: this._GetProjectileSpeed(), onedit: (e2) => this._SetProjectileSpeed(e2) }, { name: t3 + ".debugger.has-target", value: !!this._currentTarget }, { name: t3 + ".debugger.target-uid", value: this._currentTarget ? this._currentTarget.GetUID() : 0 }, { name: t3 + ".properties.enabled.name", value: this._IsEnabled(), onedit: (e2) => this._SetEnabled(e2) }] }];
      }
      GetScriptInterfaceClass() {
        return self.ITurretBehaviorInstance;
      }
    };
    const u2 = /* @__PURE__ */ new WeakMap(), T2 = ["first", "nearest"];
    self.ITurretBehaviorInstance = class extends r2 {
      constructor() {
        super(), u2.set(this, r2._GetInitInst().GetSdkInstance());
      }
      get currentTarget() {
        const e2 = u2.get(this)._currentTarget;
        return e2 ? e2.GetInterfaceClass() : null;
      }
      set currentTarget(e2) {
        const t3 = u2.get(this);
        e2 ? t3._MaybeAcquireTargetInstance(t3.GetRuntime()._UnwrapIWorldInstance(e2)) : t3._UnacquireTarget();
      }
      get range() {
        return u2.get(this)._GetRange();
      }
      set range(e2) {
        t2.RequireFiniteNumber(e2), u2.get(this)._SetRange(e2);
      }
      get rateOfFire() {
        return u2.get(this)._GetRateOfFire();
      }
      set rateOfFire(e2) {
        t2.RequireFiniteNumber(e2), u2.get(this)._SetRateOfFire(e2);
      }
      get isRotateEnabled() {
        return u2.get(this)._IsRotateEnabled();
      }
      set isRotateEnabled(e2) {
        u2.get(this)._SetRotateEnabled(!!e2);
      }
      get rotateSpeed() {
        return u2.get(this)._GetRotateSpeed();
      }
      set rotateSpeed(e2) {
        t2.RequireFiniteNumber(e2), u2.get(this)._SetRotateSpeed(e2);
      }
      get targetMode() {
        return T2[u2.get(this)._GetTargetMode()];
      }
      set targetMode(e2) {
        const t3 = T2.indexOf(e2);
        if (-1 === t3) throw new Error("invalid targetMode");
        u2.get(this)._SetTargetMode(t3);
      }
      get isPredictiveAimEnabled() {
        return u2.get(this)._IsPredictiveAim();
      }
      set isPredictiveAimEnabled(e2) {
        u2.get(this)._SetPredictiveAim(!!e2);
      }
      get projectileSpeed() {
        return u2.get(this)._GetProjectileSpeed();
      }
      set projectileSpeed(e2) {
        t2.RequireFiniteNumber(e2), u2.get(this)._SetProjectileSpeed(e2);
      }
      get isEnabled() {
        return u2.get(this)._IsEnabled();
      }
      set isEnabled(e2) {
        u2.get(this)._SetEnabled(e2);
      }
    };
  }
  self.C3.Behaviors.Turret.Cnds = { HasTarget() {
    return !!this._currentTarget;
  }, OnShoot: () => true, OnTargetAcquired: () => true, IsEnabled() {
    return this._IsEnabled();
  } };
  {
    const e = self.C3;
    e.Behaviors.Turret.Acts = { AcquireTarget(e2) {
      if (!e2) return;
      const t2 = e2.GetCurrentSol().GetInstances();
      for (const e3 of t2) if (this._MaybeAcquireTargetInstance(e3)) break;
    }, AddTarget(e2) {
      const t2 = this.GetSdkType().GetTargetTypes();
      if (!t2.includes(e2)) {
        for (const r2 of t2) if (r2.IsFamily() && r2.FamilyHasMember(e2)) return;
        t2.push(e2);
      }
    }, ClearTargets() {
      e.clearArray(this.GetSdkType().GetTargetTypes());
    }, UnacquireTarget() {
      this._UnacquireTarget();
    }, SetEnabled(e2) {
      this._SetEnabled(0 !== e2);
    }, SetRange(e2) {
      this._SetRange(e2);
    }, SetRateOfFire(e2) {
      this._SetRateOfFire(e2);
    }, SetRotate(e2) {
      this._SetRotateEnabled(0 !== e2);
    }, SetRotateSpeed(t2) {
      this._SetRotateSpeed(e.toRadians(t2));
    }, SetTargetMode(e2) {
      this._SetTargetMode(e2);
    }, SetPredictiveAim(e2) {
      this._SetPredictiveAim(0 !== e2);
    }, SetProjectileSpeed(e2) {
      this._SetProjectileSpeed(e2);
    } };
  }
  {
    const e = self.C3;
    e.Behaviors.Turret.Exps = { TargetUID() {
      return this._currentTarget ? this._currentTarget.GetUID() : 0;
    }, Range() {
      return this._GetRange();
    }, RateOfFire() {
      return this._GetRateOfFire();
    }, RotateSpeed() {
      return e.toDegrees(this._GetRotateSpeed());
    } };
  }
}
{
  {
    const t2 = self.C3;
    t2.Behaviors.Platform = class extends t2.SDKBehaviorBase {
      constructor(t3) {
        super(t3);
      }
      Release() {
        super.Release();
      }
    };
  }
  {
    const e = self.C3;
    e.Behaviors.Platform.Type = class extends e.SDKBehaviorTypeBase {
      constructor(t2) {
        super(t2);
      }
      Release() {
        super.Release();
      }
      OnCreate() {
      }
    };
  }
  {
    let accelerate = function(t2, e, s2, n2, h3) {
      const r3 = e * h3, o3 = s2 * h3;
      return i.clamp(t2 * h3 + 0.5 * n2 * h3 * h3, r3, o3);
    };
    accelerate2 = accelerate;
    const i = self.C3, s = self.C3X, n = self.IBehaviorInstance, h2 = 0, r2 = 1, o2 = 2, l = 3, a2 = 4, _2 = 5, u2 = 6, d2 = 7, m2 = 8, p2 = 9, g2 = 0.05;
    i.Behaviors.Platform.Instance = class extends i.SDKBehaviorInstanceBase {
      constructor(t2, e) {
        super(t2), this._keyboardDisposables = null, this._leftKey = false, this._rightKey = false, this._jumpKey = false, this._jumped = false, this._doubleJumped = false, this._canDoubleJump = false, this._ignoreInput = false, this._simLeft = false, this._simRight = false, this._simJump = false, this._lastFloorObject = null, this._loadFloorUid = -1, this._lastFloorX = 0, this._lastFloorY = 0, this._floorIsJumpthru = false, this._wasOnFloor = false, this._wasOverJumpthru = this._runtime.GetCollisionEngine().TestOverlapJumpthru(this._inst), this._loadJumpthruUid = -1, this._animMode = "stopped", this._fallThroughTime = -1, this._isFirstTick = true, this._dx = 0, this._dy = 0, this._downX = 0, this._downY = 0, this._rightX = 0, this._rightY = 0, this._g = 1500, this._g1 = 1500, this._ga = i.toRadians(90), this._maxSpeed = 330, this._acc = 1500, this._dec = 1500, this._jumpStrength = 650, this._maxFall = 1e3, this._enableDoubleJump = false, this._jumpSustain = 0, this._sustainTime = 0, this._defaultControls = true, this._ceilingCollisionMode = 0, this._isEnabled = true, e && (this._maxSpeed = e[h2], this._acc = e[r2], this._dec = e[o2], this._jumpStrength = e[l], this._g = e[a2], this._maxFall = e[_2], this._enableDoubleJump = !!e[u2], this._jumpSustain = e[d2] / 1e3, this._defaultControls = !!e[m2], this._isEnabled = !!e[p2]);
        const s2 = this._runtime.Dispatcher();
        this._disposables = new i.CompositeDisposable(i.Disposable.From(s2, "instancedestroy", (t3) => this._OnInstanceDestroyed(t3.instance)), i.Disposable.From(s2, "afterload", (t3) => this._OnAfterLoad())), this._defaultControls && this._BindEvents(), this._isEnabled && this._StartPostTicking(), this._UpdateGravity();
      }
      Release() {
        this._keyboardDisposables && (this._keyboardDisposables.Release(), this._keyboardDisposables = null), this._lastFloorObject = null, this._wasOverJumpthru = null, super.Release();
      }
      _BindEvents() {
        if (this._keyboardDisposables) return;
        const t2 = this._runtime.Dispatcher();
        this._keyboardDisposables = new i.CompositeDisposable(i.Disposable.From(t2, "keydown", (t3) => this._OnKeyDown(t3.data)), i.Disposable.From(t2, "keyup", (t3) => this._OnKeyUp(t3.data)), i.Disposable.From(t2, "window-blur", () => this._OnWindowOrKeyboardBlur()), i.Disposable.From(t2, "keyboard-blur", () => this._OnWindowOrKeyboardBlur()));
      }
      _UnBindEvents() {
        this._keyboardDisposables && (this._keyboardDisposables.Release(), this._keyboardDisposables = null);
      }
      _OnInstanceDestroyed(t2) {
        this._lastFloorObject === t2 && (this._lastFloorObject = null), this._wasOverJumpthru === t2 && (this._wasOverJumpthru = null);
      }
      _OnKeyDown(t2) {
        switch (t2["key"]) {
          case "ArrowLeft":
            this._leftKey = true;
            break;
          case "ArrowRight":
            this._rightKey = true;
            break;
          case "ArrowUp":
            this._jumpKey = true;
        }
      }
      _OnKeyUp(t2) {
        switch (t2["key"]) {
          case "ArrowLeft":
            this._leftKey = false;
            break;
          case "ArrowRight":
            this._rightKey = false;
            break;
          case "ArrowUp":
            this._jumpKey = false, this._jumped = false;
        }
      }
      _OnWindowOrKeyboardBlur() {
        this._leftKey = false, this._rightKey = false, this._jumpKey = false, this._jumped = false;
      }
      SaveToJson() {
        return { "ii": this._ignoreInput, "lfx": this._lastFloorX, "lfy": this._lastFloorY, "lfo": this._lastFloorObject ? this._lastFloorObject.GetUID() : -1, "am": this._animMode, "en": this._isEnabled, "fallt": this._fallThroughTime, "ft": this._isFirstTick, "dx": this._dx, "dy": this._dy, "ms": this._maxSpeed, "acc": this._acc, "dec": this._dec, "js": this._jumpStrength, "g": this._g, "g1": this._g1, "mf": this._maxFall, "wof": this._wasOnFloor, "woj": this._wasOverJumpthru ? this._wasOverJumpthru.GetUID() : -1, "ga": this._ga, "edj": this._enableDoubleJump, "cdj": this._canDoubleJump, "dj": this._doubleJumped, "sus": this._jumpSustain, "dc": this._defaultControls, "cc": this._ceilingCollisionMode };
      }
      LoadFromJson(t2) {
        this._ignoreInput = t2["ii"], this._lastFloorX = t2["lfx"], this._lastFloorY = t2["lfy"], this._loadFloorUid = t2["lfo"], this._animMode = t2["am"];
        const e = t2["en"];
        this._fallThroughTime = t2["fallt"] || -1, this._isFirstTick = t2["ft"], this._dx = t2["dx"], this._dy = t2["dy"], this._maxSpeed = t2["ms"], this._acc = t2["acc"], this._dec = t2["dec"], this._jumpStrength = t2["js"], this._g = t2["g"], this._g1 = t2["g1"], this._maxFall = t2["mf"], this._wasOnFloor = t2["wof"], this._loadJumpthruUid = t2["woj"], this._ga = t2["ga"], this._enableDoubleJump = t2["edj"], this._canDoubleJump = t2["cdj"], this._doubleJumped = t2["dj"], this._jumpSustain = t2["sus"], this._defaultControls = t2["dc"], this._ceilingCollisionMode = t2["cc"] || 0, this._leftKey = false, this._rightKey = false, this._jumpKey = false, this._jumped = false, this._simLeft = false, this._simRight = false, this._simJump = false, this._sustainTime = 0, this._defaultControls ? this._BindEvents() : this._UnBindEvents(), this._SetEnabled(e), this._UpdateGravity();
      }
      _OnAfterLoad() {
        -1 === this._loadFloorUid ? this._lastFloorObject = null : this._lastFloorObject = this._runtime.GetInstanceByUID(this._loadFloorUid), -1 === this._loadJumpthruUid ? this._wasOverJumpthru = null : this._wasOverJumpthru = this._runtime.GetInstanceByUID(this._loadJumpthruUid);
      }
      _SetLastFloorObject(t2) {
        if (this._lastFloorObject = t2, t2) {
          const e = t2.GetWorldInfo();
          this._lastFloorX = e.GetX(), this._lastFloorY = e.GetY();
        }
      }
      _IsFallThroughEnabled() {
        return this._runtime.GetGameTime() > this._fallThroughTime + g2;
      }
      _UpdateGravity() {
        this._downX = Math.cos(this._ga), this._downY = Math.sin(this._ga), this._rightX = Math.cos(this._ga - Math.PI / 2), this._rightY = Math.sin(this._ga - Math.PI / 2), this._downX = i.roundToDp(this._downX, 6), this._downY = i.roundToDp(this._downY, 6), this._rightX = i.roundToDp(this._rightX, 6), this._rightY = i.roundToDp(this._rightY, 6), this._g1 = this._g, this._g < 0 && (this._downX *= -1, this._downY *= -1, this._g = Math.abs(this._g));
      }
      _GetGDir() {
        return this._g < 0 ? -1 : 1;
      }
      _IsOnFloor() {
        const t2 = this._inst.GetWorldInfo(), e = this._runtime.GetCollisionEngine(), i2 = this._inst, s2 = this._lastFloorObject, n2 = t2.GetX(), h3 = t2.GetY();
        if (t2.OffsetXY(this._downX, this._downY), t2.SetBboxChanged(), !s2 || !e.TestOverlap(i2, s2) || s2.GetObjectClass().HasSolidBehavior() && !e.IsSolidCollisionAllowed(s2, i2) || s2.GetObjectClass().HasJumpthruBehavior() && !s2._IsJumpthruEnabled()) {
          let s3 = e.TestOverlapSolid(i2), r3 = null;
          if (!s3 && this._IsFallThroughEnabled() && (r3 = e.TestOverlapJumpthru(i2, true)), t2.SetXY(n2, h3), t2.SetBboxChanged(), s3) return e.TestOverlap(i2, s3) ? null : (this._floorIsJumpthru = false, s3);
          if (r3 && r3.length) {
            let t3 = 0;
            for (let s4 = 0, n3 = r3.length; s4 < n3; ++s4) r3[t3] = r3[s4], e.TestOverlap(i2, r3[s4]) || ++t3;
            if (t3 >= 1) return this._floorIsJumpthru = true, r3[0];
          }
          return null;
        }
        return t2.SetXY(n2, h3), t2.SetBboxChanged(), s2;
      }
      PostTick() {
        if (!this._isEnabled) return;
        const t2 = this._runtime.GetDt(this._inst);
        this._jumpKey || this._simJump || (this._jumped = false);
        let e = this._leftKey || this._simLeft, i2 = this._rightKey || this._simRight, s2 = this._jumpKey || this._simJump, n2 = s2 && !this._jumped;
        this._simLeft = false, this._simRight = false, this._simJump = false, this._ignoreInput && (e = false, i2 = false, s2 = false, n2 = false), s2 || (this._sustainTime = 0), this._HandleFirstTick();
        const [h3, r3, o3] = this._TrackMovingPlatform();
        let l2 = this._IsOnFloor();
        const a3 = l2 && !this._wasOnFloor;
        let _3 = false;
        if ([_3, l2] = this._MaybePushOutSolid(l2), _3) return;
        this._TrackFloor(l2, o3, h3, s2), n2 = this._HandleJump(l2, n2, s2), l2 || this._HandleAirTime(n2, s2, t2), this._wasOnFloor = !!l2;
        const u3 = this._CalculateHorizontalAcceleration(e, i2);
        let d3 = false, m3 = 0;
        if (0 !== this._dx && ([d3, l2] = this._HandleHorizontalMovement(t2, u3, l2, n2)), 0 !== this._dy) {
          const [e2, i3] = this._HandleVerticalMovement(t2, l2);
          d3 = d3 || e2, m3 = i3;
        }
        !d3 && a3 && this._dy < 0 && m3 > 0 && (this._dy = 0, d3 = true), this._ApplyHorizontalAcceleration(e, i2, u3, t2), l2 && !n2 || d3 || (this._dy = Math.min(this._dy + this._g * t2, this._maxFall)), this._HandleAnimationTriggers(l2, d3, n2), this._wasOverJumpthru = this._runtime.GetCollisionEngine().TestOverlapJumpthru(this._inst);
      }
      _HandleFirstTick() {
        if (!this._isFirstTick) return;
        const t2 = this._inst, e = this._runtime.GetCollisionEngine();
        (e.TestOverlapSolid(t2) || e.TestOverlapJumpthru(t2)) && e.PushOutSolid(t2, -this._downX, -this._downY, 4, true), this._isFirstTick = false;
      }
      _TrackMovingPlatform() {
        const t2 = this._lastFloorObject, e = t2 ? t2.GetWorldInfo() : null;
        let s2 = 0, n2 = 0, h3 = false;
        if (t2 && 0 === this._dy && (e.GetY() !== this._lastFloorY || e.GetX() !== this._lastFloorX)) {
          const t3 = this._inst, r3 = t3.GetWorldInfo(), o3 = this._runtime.GetCollisionEngine(), l2 = e.GetX(), a3 = e.GetY();
          s2 = l2 - this._lastFloorX, n2 = a3 - this._lastFloorY, r3.OffsetXY(s2, n2), r3.SetBboxChanged(), this._lastFloorX = l2, this._lastFloorY = a3, h3 = true;
          const _3 = o3.TestOverlapSolid(t3);
          _3 && (o3.RegisterCollision(t3, _3), o3.PushOutSolid(t3, -s2, -n2, 2.5 * i.hypot2DFast(s2, n2)));
        }
        return [s2, n2, h3];
      }
      _MaybePushOutSolid(t2) {
        let e = false;
        const i2 = this._inst, s2 = i2.GetWorldInfo(), n2 = this._runtime.GetCollisionEngine(), h3 = n2.TestOverlapSolid(i2);
        if (!h3) return [false, t2];
        const r3 = Math.abs(s2.GetWidth()), o3 = Math.abs(s2.GetHeight());
        return n2.PushOutSolid(i2, -this._downX, -this._downY, o3 / 8) ? (n2.RegisterCollision(i2, h3), t2 = h3, this._SetLastFloorObject(h3), this._floorIsJumpthru = false, this._dy = 0) : n2.PushOutSolidAxis(i2, this._rightX, this._rightY, r3 / 2) || n2.PushOutSolidAxis(i2, this._downX, this._downY, o3 / 2) || n2.PushOutSolidNearest(i2, Math.max(r3, o3) / 2) ? n2.RegisterCollision(i2, h3) : e = true, [e, t2];
      }
      _TrackFloor(t2, e, i2, s2) {
        const n2 = this._inst, h3 = this._runtime.GetCollisionEngine();
        if (t2) {
          const s3 = this._downX, r3 = this._downY, o3 = this._rightX, l2 = this._rightY;
          if (this._doubleJumped = false, this._canDoubleJump = false, this._dy > 0 && (this._wasOnFloor || (h3.PushInFractional(n2, -s3, -r3, t2, 16), this._wasOnFloor = true), this._dy = 0), this._lastFloorObject !== t2) this._SetLastFloorObject(t2), h3.RegisterCollision(n2, t2);
          else if (e) {
            const t3 = h3.TestOverlapSolid(n2);
            t3 && (h3.RegisterCollision(n2, t3), 0 !== i2 && (i2 > 0 ? h3.PushOutSolid(n2, -o3, -l2) : h3.PushOutSolid(n2, o3, l2)), h3.PushOutSolid(n2, -s3, -r3));
          }
        } else s2 || (this._canDoubleJump = true);
      }
      _HandleJump(t2, e, s2) {
        if (t2 && e || !t2 && this._enableDoubleJump && s2 && this._canDoubleJump && !this._doubleJumped) {
          const s3 = this._inst, n2 = s3.GetWorldInfo(), h3 = this._runtime.GetCollisionEngine(), r3 = n2.GetX(), o3 = n2.GetY();
          n2.OffsetXY(-this._downX, -this._downY), n2.SetBboxChanged(), h3.TestOverlapSolid(s3) ? e = false : (this._sustainTime = this._jumpSustain, this.Trigger(i.Behaviors.Platform.Cnds.OnJump), this._animMode = "jumping", this._dy = -this._jumpStrength, e = true, t2 ? this._jumped = true : this._doubleJumped = true), n2.SetXY(r3, o3), n2.SetBboxChanged();
        }
        return e;
      }
      _HandleAirTime(t2, e, i2) {
        e && this._sustainTime > 0 ? (this._dy = -this._jumpStrength, this._sustainTime -= i2) : this._lastFloorObject = null, t2 && (this._jumped = true);
      }
      _CalculateHorizontalAcceleration(t2, e) {
        let i2 = 0;
        const s2 = this._acc, n2 = this._dec;
        return t2 && !e && (i2 = this._dx > 0 ? -(s2 + n2) : -s2), e && !t2 && (i2 = this._dx < 0 ? s2 + n2 : s2), i2;
      }
      _ApplyHorizontalAcceleration(t2, e, s2, n2) {
        const h3 = this._dec;
        t2 === e && (this._dx < 0 ? this._dx = Math.min(this._dx + h3 * n2, 0) : this._dx > 0 && (this._dx = Math.max(this._dx - h3 * n2, 0))), this._dx = i.clamp(this._dx + s2 * n2, -this._maxSpeed, this._maxSpeed);
        const r3 = this._runtime.GetCollisionEngine(), o3 = this._dx < 0 ? this._GetWallObstacle(0, 1, 1) : null;
        if (o3) this._dx = 0, r3.RegisterCollision(this._inst, o3);
        else {
          const t3 = this._dx > 0 ? this._GetWallObstacle(1, 1, 1) : null;
          t3 && (this._dx = 0, r3.RegisterCollision(this._inst, t3));
        }
      }
      _HandleHorizontalMovement(t2, e, i2, s2) {
        const n2 = this._inst, h3 = n2.GetWorldInfo(), r3 = this._runtime.GetCollisionEngine(), o3 = this._downX, l2 = this._downY, a3 = this._rightX, _3 = this._rightY, u3 = this._maxSpeed;
        let d3 = false;
        const m3 = new Set(r3.TestOverlapJumpthru(n2, true));
        let p3 = h3.GetX(), g3 = h3.GetY();
        const c3 = accelerate(this._dx, -u3, u3, e, t2) * a3, S3 = accelerate(this._dx, -u3, u3, e, t2) * _3;
        h3.OffsetXY(a3 * (this._dx > 1 ? 1 : -1) - o3, _3 * (this._dx > 1 ? 1 : -1) - l2), h3.SetBboxChanged();
        let b2 = false;
        const f2 = r3.TestOverlapSolid(n2);
        h3.SetXY(p3 + c3, g3 + S3), h3.SetBboxChanged();
        let G = r3.TestOverlapSolid(n2);
        if (!G && i2 && this._floorIsJumpthru && (G = r3.TestOverlapJumpthru(n2), m3.has(G) ? G = null : b2 = true), G) {
          let e2 = Math.abs(this._dx * t2) + 2;
          f2 || !r3.PushOutSolid(n2, -o3, -l2, e2, b2, G) ? (r3.RegisterCollision(n2, G), e2 = Math.max(Math.abs(this._dx * t2 * 2.5), Math.floor(h3.GetWidth())), r3.PushOutSolid(n2, a3 * (this._dx < 0 ? 1 : -1), _3 * (this._dx < 0 ? 1 : -1), e2, false) ? !i2 || b2 || this._floorIsJumpthru || (p3 = h3.GetX(), g3 = h3.GetY(), h3.OffsetXY(o3, l2), r3.TestOverlapSolid(n2) && r3.PushOutSolid(n2, -o3, -l2, 3, false) || (h3.SetXY(p3, g3), h3.SetBboxChanged())) : (h3.SetXY(p3, g3), h3.SetBboxChanged()), b2 || (this._dx = 0)) : !f2 && !s2 && Math.abs(this._dy) < Math.abs(this._jumpStrength / 4) && (this._dy = 0, i2 || (d3 = true));
        } else {
          const e2 = this._IsOnFloor();
          if (i2 && !e2) {
            const e3 = Math.ceil(Math.abs(this._dx * t2)) + 2;
            p3 = h3.GetX(), g3 = h3.GetY(), h3.OffsetXY(o3 * e3, l2 * e3), h3.SetBboxChanged();
            const s3 = r3.TestOverlapJumpthru(n2);
            let a4 = false;
            s3 && !m3.has(s3) && r3.PushOutSolid(n2, -o3, -l2, e3 + 2, true, s3) && (i2 = s3, this._SetLastFloorObject(s3), this._floorIsJumpthru = true, a4 = true), a4 || (r3.TestOverlapSolid(n2) ? r3.PushOutSolid(n2, -o3, -l2, e3 + 2, false) : (h3.SetXY(p3, g3), h3.SetBboxChanged()));
          } else e2 && (!i2 && this._floorIsJumpthru && (this._SetLastFloorObject(e2), this._dy = 0, d3 = true), 0 === this._dy && r3.PushInFractional(n2, -o3, -l2, e2, 16));
        }
        return [d3, i2];
      }
      _HandleVerticalMovement(t2, e) {
        const s2 = this._inst, n2 = s2.GetWorldInfo(), h3 = this._runtime.GetCollisionEngine(), r3 = this._downX, o3 = this._downY;
        let l2 = false, a3 = n2.GetX(), _3 = n2.GetY();
        const u3 = accelerate(this._dy, -1 / 0, this._maxFall, this._g, t2);
        if (this._dy < 0 && u3 > 0 && e) return this._dy = 0, [false, 0];
        n2.OffsetXY(u3 * r3, u3 * o3);
        const d3 = n2.GetX(), m3 = n2.GetY();
        n2.SetBboxChanged();
        let p3 = h3.TestOverlapSolid(s2), g3 = false;
        if (!p3 && this._dy > 0 && !e) {
          const t3 = this._IsFallThroughEnabled() ? h3.TestOverlapJumpthru(s2, true) : null;
          if (t3 && t3.length) {
            if (this._wasOverJumpthru) {
              n2.SetXY(a3, _3), n2.SetBboxChanged();
              let e2 = 0;
              for (let i2 = 0, n3 = t3.length; i2 < n3; ++i2) t3[e2] = t3[i2], h3.TestOverlap(s2, t3[i2]) || ++e2;
              i.truncateArray(t3, e2), n2.SetXY(d3, m3), n2.SetBboxChanged();
            }
            t3.length >= 1 && (p3 = t3[0]);
          }
          g3 = !!p3;
        }
        if (p3) {
          h3.RegisterCollision(s2, p3), this._sustainTime = 0;
          let e2 = 1.1;
          g3 && !this._wasOverJumpthru && (e2 = 2);
          const i2 = Math.max(Math.abs(this._dy * t2 * e2), 2);
          h3.PushOutSolid(s2, r3 * (this._dy < 0 ? 1 : -1), o3 * (this._dy < 0 ? 1 : -1), i2, g3, p3) ? (this._SetLastFloorObject(p3), this._floorIsJumpthru = g3, this._dy > 0 && (l2 = true), (this._dy > 0 || 0 === this._ceilingCollisionMode) && (this._dy = 0), this._dy < 0 && 1 === this._ceilingCollisionMode && h3.PushInFractional(s2, r3, o3, p3, 32)) : (n2.SetXY(a3, _3), n2.SetBboxChanged(), this._wasOnFloor = true, g3 || (this._dy = 0));
        }
        return [l2, u3];
      }
      _HandleAnimationTriggers(t2, e, s2) {
        "falling" !== this._animMode && this._dy > 0 && !t2 && (this.Trigger(i.Behaviors.Platform.Cnds.OnFall), this._animMode = "falling"), (t2 || e) && this._dy >= 0 && ("falling" === this._animMode || e || s2 && 0 === this._dy ? (this.Trigger(i.Behaviors.Platform.Cnds.OnLand), 0 === this._dx && 0 === this._dy ? this._animMode = "stopped" : this._animMode = "moving") : ("stopped" !== this._animMode && 0 === this._dx && 0 === this._dy && (this.Trigger(i.Behaviors.Platform.Cnds.OnStop), this._animMode = "stopped"), "moving" === this._animMode || 0 === this._dx && 0 === this._dy || s2 || (this.Trigger(i.Behaviors.Platform.Cnds.OnMove), this._animMode = "moving")));
      }
      _IsMoving() {
        return 0 !== this._GetVectorX() || 0 !== this._GetVectorY();
      }
      _CheckIfStandingOnFloor() {
        if (0 !== this._dy) return false;
        const t2 = this._inst, e = this.GetWorldInfo(), i2 = this._runtime.GetCollisionEngine(), s2 = e.GetX(), n2 = e.GetY();
        e.OffsetXY(this._downX, this._downY), e.SetBboxChanged();
        const h3 = i2.TestOverlapSolid(t2);
        let r3 = null;
        if (!h3 && this._IsFallThroughEnabled() && (r3 = i2.TestOverlapJumpthru(t2, true)), e.SetXY(s2, n2), e.SetBboxChanged(), h3) return !i2.TestOverlap(t2, h3);
        if (r3 && r3.length) {
          let e2 = 0;
          for (let s3 = 0, n3 = r3.length; s3 < n3; ++s3) r3[e2] = r3[s3], i2.TestOverlap(t2, r3[s3]) || e2++;
          if (e2 >= 1) return true;
        }
        return false;
      }
      _IsByWall(t2, e = 2, i2 = 3) {
        return !!this._GetWallObstacle(t2, e, i2);
      }
      _GetWallObstacle(t2, e = 2, i2 = 3) {
        const s2 = this._inst, n2 = this.GetWorldInfo(), h3 = this._runtime.GetCollisionEngine(), r3 = n2.GetX(), o3 = n2.GetY();
        if (0 === t2 ? n2.OffsetXY(-this._rightX * e, -this._rightY * e) : n2.OffsetXY(this._rightX * e, this._rightY * e), n2.SetBboxChanged(), !h3.TestOverlapSolid(s2)) return n2.SetXY(r3, o3), n2.SetBboxChanged(), null;
        n2.OffsetXY(-this._downX * i2, -this._downY * i2), n2.SetBboxChanged();
        const l2 = h3.TestOverlapSolid(s2);
        return n2.SetXY(r3, o3), n2.SetBboxChanged(), l2;
      }
      _FallThroughJumpThru() {
        const t2 = this.GetWorldInfo(), e = t2.GetX(), i2 = t2.GetY();
        t2.OffsetXY(this._downX, this._downY), t2.SetBboxChanged();
        const s2 = this._runtime.GetCollisionEngine().TestOverlapJumpthru(this._inst, false);
        t2.SetXY(e, i2), t2.SetBboxChanged(), s2 && (this._fallThroughTime = this._runtime.GetGameTime(), this._lastFloorObject = null);
      }
      _ResetDoubleJump(t2) {
        this._doubleJumped = !t2;
      }
      _GetSpeed() {
        return Math.hypot(this._dx, this._dy);
      }
      _GetMovingAngle() {
        return Math.atan2(this._dy, this._dx);
      }
      _IsJumping() {
        return this._dy < 0;
      }
      _IsFalling() {
        return this._dy > 0;
      }
      _SetMaxSpeed(t2) {
        this._maxSpeed = Math.max(t2, 0);
      }
      _GetMaxSpeed() {
        return this._maxSpeed;
      }
      _SetAcceleration(t2) {
        this._acc = Math.max(t2, 0);
      }
      _GetAcceleration() {
        return this._acc;
      }
      _SetDeceleration(t2) {
        this._dec = Math.max(t2, 0);
      }
      _GetDeceleration() {
        return this._dec;
      }
      _SetJumpStrength(t2) {
        this._jumpStrength = Math.max(t2, 0);
      }
      _GetJumpStrength() {
        return this._jumpStrength;
      }
      _SetMaxFallSpeed(t2) {
        this._maxFall = Math.max(t2, 0);
      }
      _GetMaxFallSpeed() {
        return this._maxFall;
      }
      _SetGravity(t2) {
        if (this._g1 === t2) return;
        this._g = t2, this._UpdateGravity();
        const e = this._runtime.GetCollisionEngine(), i2 = this.GetWorldInfo();
        e.TestOverlapSolid(this._inst) && (e.PushOutSolid(this._inst, this._downX, this._downY, 10), i2.OffsetXY(2 * this._downX, 2 * this._downY), i2.SetBboxChanged()), this._lastFloorObject = null;
      }
      _GetGravity() {
        return this._g;
      }
      _SetGravityAngle(t2) {
        t2 = i.clampAngle(t2), this._ga !== t2 && (this._ga = t2, this._UpdateGravity(), this._lastFloorObject = null);
      }
      _GetGravityAngle() {
        return this._ga;
      }
      _SetDoubleJumpEnabled(t2) {
        this._enableDoubleJump = !!t2;
      }
      _IsDoubleJumpEnabled() {
        return this._enableDoubleJump;
      }
      _SetJumpSustain(t2) {
        this._jumpSustain = t2;
      }
      _GetJumpSustain() {
        return this._jumpSustain;
      }
      _SetCeilingCollisionMode(t2) {
        this._ceilingCollisionMode = t2;
      }
      _GetCeilingCollisionMode() {
        return this._ceilingCollisionMode;
      }
      _SetVectorX(t2) {
        this._dx = t2;
      }
      _GetVectorX() {
        return this._dx;
      }
      _SetVectorY(t2) {
        this._dy = t2;
      }
      _GetVectorY() {
        return this._dy;
      }
      _SimulateControl(t2) {
        if (this._isEnabled) switch (t2) {
          case 0:
            this._simLeft = true;
            break;
          case 1:
            this._simRight = true;
            break;
          case 2:
            this._simJump = true;
        }
      }
      _SetDefaultControls(t2) {
        t2 = !!t2, this._defaultControls !== t2 && (this._defaultControls = t2, this._defaultControls ? this._BindEvents() : (this._UnBindEvents(), this._OnWindowOrKeyboardBlur()));
      }
      _IsDefaultControls() {
        return this._defaultControls;
      }
      _SetIgnoreInput(t2) {
        this._ignoreInput = !!t2;
      }
      _IsIgnoreInput() {
        return this._ignoreInput;
      }
      _SetEnabled(t2) {
        t2 = !!t2, this._isEnabled !== t2 && (this._isEnabled = t2, this._isEnabled ? this._StartPostTicking() : (this._StopPostTicking(), this._lastFloorObject = null, this._simLeft = false, this._simRight = false, this._simJump = false));
      }
      _IsEnabled() {
        return this._isEnabled;
      }
      GetPropertyValueByIndex(t2) {
        switch (t2) {
          case h2:
            return this._GetMaxSpeed();
          case r2:
            return this._GetAcceleration();
          case o2:
            return this._GetDeceleration();
          case l:
            return this._GetJumpStrength();
          case a2:
            return this._GetGravity();
          case _2:
            return this._GetMaxFallSpeed();
          case u2:
            return this._IsDoubleJumpEnabled();
          case d2:
            return 1e3 * this._GetJumpSustain();
          case m2:
            return this._IsDefaultControls();
          case p2:
            return this._IsEnabled();
        }
      }
      SetPropertyValueByIndex(t2, e) {
        switch (t2) {
          case h2:
            this._SetMaxSpeed(e);
            break;
          case r2:
            this._SetAcceleration(e);
            break;
          case o2:
            this._SetDeceleration(e);
            break;
          case l:
            this._SetJumpStrength(e);
            break;
          case a2:
            this._SetGravity(e);
            break;
          case _2:
            this._SetMaxFallSpeed(e);
            break;
          case u2:
            this._SetDoubleJumpEnabled(!!e);
            break;
          case d2:
            this._SetJumpSustain(e / 1e3);
            break;
          case m2:
            this._SetDefaultControls(!!e);
            break;
          case p2:
            this._SetEnabled(!!e);
        }
      }
      GetDebuggerProperties() {
        const t2 = "behaviors.platform";
        return [{ title: "$" + this.GetBehaviorType().GetName(), properties: [{ name: t2 + ".debugger.vector-x", value: this._GetVectorX(), onedit: (t3) => this._SetVectorX(t3) }, { name: t2 + ".debugger.vector-y", value: this._GetVectorY(), onedit: (t3) => this._SetVectorY(t3) }, { name: t2 + ".properties.max-speed.name", value: this._GetMaxSpeed(), onedit: (t3) => this._SetMaxSpeed(t3) }, { name: t2 + ".properties.acceleration.name", value: this._GetAcceleration(), onedit: (t3) => this._SetAcceleration(t3) }, { name: t2 + ".properties.deceleration.name", value: this._GetDeceleration(), onedit: (t3) => this._SetDeceleration(t3) }, { name: t2 + ".properties.jump-strength.name", value: this._GetJumpStrength(), onedit: (t3) => this._SetJumpStrength(t3) }, { name: t2 + ".properties.gravity.name", value: this._GetGravity(), onedit: (t3) => this._SetGravity(t3) }, { name: t2 + ".debugger.gravity-angle", value: i.toDegrees(this._GetGravityAngle()), onedit: (t3) => this._SetGravityAngle(i.toRadians(t3)) }, { name: t2 + ".properties.max-fall-speed.name", value: this._GetMaxFallSpeed(), onedit: (t3) => this._SetMaxFallSpeed(t3) }, { name: t2 + ".properties.double-jump.name", value: this._IsDoubleJumpEnabled(), onedit: (t3) => this._SetDoubleJumpEnabled(t3) }, { name: t2 + ".properties.jump-sustain.name", value: 1e3 * this._GetJumpSustain(), onedit: (t3) => this._SetJumpSustain(t3 / 1e3) }, { name: t2 + ".debugger.animation-mode", value: [t2 + ".debugger.anim-" + this._animMode] }, { name: t2 + ".properties.enabled.name", value: this._IsEnabled(), onedit: (t3) => this._SetEnabled(t3) }] }];
      }
      GetScriptInterfaceClass() {
        return self.IPlatformBehaviorInstance;
      }
    };
    const c2 = /* @__PURE__ */ new WeakMap(), S2 = /* @__PURE__ */ new Map([["left", 0], ["right", 1], ["jump", 2]]);
    self.IPlatformBehaviorInstance = class extends n {
      constructor() {
        super(), c2.set(this, n._GetInitInst().GetSdkInstance());
      }
      fallThrough() {
        c2.get(this)._FallThroughJumpThru();
      }
      resetDoubleJump(t2) {
        c2.get(this)._ResetDoubleJump(!!t2);
      }
      simulateControl(t2) {
        s.RequireString(t2);
        const e = S2.get(t2);
        if ("number" != typeof e) throw new Error("invalid control");
        c2.get(this)._SimulateControl(e);
      }
      get speed() {
        return c2.get(this)._GetSpeed();
      }
      get maxSpeed() {
        return c2.get(this)._GetMaxSpeed();
      }
      set maxSpeed(t2) {
        s.RequireFiniteNumber(t2), c2.get(this)._SetMaxSpeed(t2);
      }
      get acceleration() {
        return c2.get(this)._GetAcceleration();
      }
      set acceleration(t2) {
        s.RequireFiniteNumber(t2), c2.get(this)._SetAcceleration(t2);
      }
      get deceleration() {
        return c2.get(this)._GetDeceleration();
      }
      set deceleration(t2) {
        s.RequireFiniteNumber(t2), c2.get(this)._SetDeceleration(t2);
      }
      get jumpStrength() {
        return c2.get(this)._GetJumpStrength();
      }
      set jumpStrength(t2) {
        s.RequireFiniteNumber(t2), c2.get(this)._SetJumpStrength(t2);
      }
      get maxFallSpeed() {
        return c2.get(this)._GetMaxFallSpeed();
      }
      set maxFallSpeed(t2) {
        s.RequireFiniteNumber(t2), c2.get(this)._SetMaxFallSpeed(t2);
      }
      get gravity() {
        return c2.get(this)._GetGravity();
      }
      set gravity(t2) {
        s.RequireFiniteNumber(t2), c2.get(this)._SetGravity(t2);
      }
      get gravityAngle() {
        return c2.get(this)._GetGravityAngle();
      }
      set gravityAngle(t2) {
        s.RequireFiniteNumber(t2), c2.get(this)._SetGravityAngle(t2);
      }
      get isDoubleJumpEnabled() {
        return c2.get(this)._IsDoubleJumpEnabled();
      }
      set isDoubleJumpEnabled(t2) {
        c2.get(this)._SetDoubleJumpEnabled(!!t2);
      }
      get jumpSustain() {
        return c2.get(this)._GetJumpSustain();
      }
      set jumpSustain(t2) {
        s.RequireFiniteNumber(t2), c2.get(this)._SetJumpSustain(t2);
      }
      get ceilingCollisionMode() {
        return 0 === c2.get(this)._GetCeilingCollisionMode() ? "stop" : "preserve-momentum";
      }
      set ceilingCollisionMode(t2) {
        s.RequireString(t2);
        const e = c2.get(this);
        if ("stop" === t2) e._SetCeilingCollisionMode(0);
        else {
          if ("preserve-momentum" !== t2) throw new Error("invalid mode");
          e._SetCeilingCollisionMode(1);
        }
      }
      get isOnFloor() {
        return c2.get(this)._CheckIfStandingOnFloor();
      }
      isByWall(t2) {
        s.RequireString(t2);
        const e = c2.get(this);
        if ("left" === t2) return e._IsByWall(0);
        if ("right" === t2) return e._IsByWall(1);
        throw new Error("invalid side");
      }
      get isMoving() {
        return c2.get(this)._IsMoving();
      }
      get isJumping() {
        return c2.get(this)._IsJumping();
      }
      get isFalling() {
        return c2.get(this)._IsFalling();
      }
      get vectorX() {
        return c2.get(this)._GetVectorX();
      }
      set vectorX(t2) {
        s.RequireFiniteNumber(t2), c2.get(this)._SetVectorX(t2);
      }
      get vectorY() {
        return c2.get(this)._GetVectorY();
      }
      set vectorY(t2) {
        s.RequireFiniteNumber(t2), c2.get(this)._SetVectorY(t2);
      }
      setVector(t2, e) {
        s.RequireFiniteNumber(t2), s.RequireFiniteNumber(e);
        const i2 = c2.get(this);
        i2._SetVectorX(t2), i2._SetVectorY(e);
      }
      getVector() {
        const t2 = c2.get(this);
        return [t2._GetVectorX(), t2._GetVectorY()];
      }
      get isDefaultControls() {
        return c2.get(this)._IsDefaultControls();
      }
      set isDefaultControls(t2) {
        c2.get(this)._SetDefaultControls(!!t2);
      }
      get isIgnoringInput() {
        return c2.get(this)._IsIgnoreInput();
      }
      set isIgnoringInput(t2) {
        c2.get(this)._SetIgnoreInput(!!t2);
      }
      get isEnabled() {
        return c2.get(this)._IsEnabled();
      }
      set isEnabled(t2) {
        c2.get(this)._SetEnabled(!!t2);
      }
    };
  }
  {
    const b2 = self.C3;
    b2.Behaviors.Platform.Cnds = { IsMoving() {
      return this._IsMoving();
    }, CompareSpeed(t2, e) {
      return b2.compare(this._GetSpeed(), t2, e);
    }, IsOnFloor() {
      return this._CheckIfStandingOnFloor();
    }, IsByWall(t2) {
      return this._IsByWall(t2);
    }, IsJumping() {
      return this._IsJumping();
    }, IsFalling() {
      return this._IsFalling();
    }, IsDoubleJumpEnabled() {
      return this._IsDoubleJumpEnabled();
    }, OnJump: () => true, OnFall: () => true, OnStop: () => true, OnMove: () => true, OnLand: () => true, IsEnabled() {
      return this._IsEnabled();
    } };
  }
  {
    const f2 = self.C3;
    f2.Behaviors.Platform.Acts = { SetMaxSpeed(t2) {
      this._SetMaxSpeed(t2);
    }, SetAcceleration(t2) {
      this._SetAcceleration(t2);
    }, SetDeceleration(t2) {
      this._SetDeceleration(t2);
    }, SetJumpStrength(t2) {
      this._SetJumpStrength(t2);
    }, SetMaxFallSpeed(t2) {
      this._SetMaxFallSpeed(t2);
    }, SetGravity(t2) {
      this._SetGravity(t2);
    }, SimulateControl(t2) {
      this._SimulateControl(t2);
    }, SetIgnoreInput(t2) {
      this._SetIgnoreInput(!!t2);
    }, SetVectorX(t2) {
      this._SetVectorX(t2);
    }, SetVectorY(t2) {
      this._SetVectorY(t2);
    }, SetGravityAngle(t2) {
      this._SetGravityAngle(f2.toRadians(t2));
    }, SetEnabled(t2) {
      this._SetEnabled(0 !== t2);
    }, FallThrough() {
      this._FallThroughJumpThru();
    }, SetDoubleJumpEnabled(t2) {
      this._SetDoubleJumpEnabled(0 !== t2);
    }, SetJumpSustain(t2) {
      this._SetJumpSustain(t2 / 1e3);
    }, SetCeilingCollision(t2) {
      this._SetCeilingCollisionMode(t2);
    }, SetDefaultControls(t2) {
      this._SetDefaultControls(t2);
    }, ResetDoubleJump(t2) {
      this._ResetDoubleJump(t2);
    } };
  }
  {
    const G = self.C3;
    G.Behaviors.Platform.Exps = { Speed() {
      return this._GetSpeed();
    }, MaxSpeed() {
      return this._GetMaxSpeed();
    }, Acceleration() {
      return this._GetAcceleration();
    }, Deceleration() {
      return this._GetDeceleration();
    }, JumpStrength() {
      return this._GetJumpStrength();
    }, Gravity() {
      return this._GetGravity();
    }, GravityAngle() {
      return G.toDegrees(this._GetGravityAngle());
    }, MaxFallSpeed() {
      return this._GetMaxFallSpeed();
    }, MovingAngle() {
      return G.toDegrees(this._GetMovingAngle());
    }, VectorX() {
      return this._GetVectorX();
    }, VectorY() {
      return this._GetVectorY();
    }, JumpSustain() {
      return 1e3 * this._GetJumpSustain();
    } };
  }
}
var accelerate2;
{
  {
    const t2 = self.C3;
    t2.Behaviors.TileMovement = class extends t2.SDKBehaviorBase {
      constructor(t3) {
        super(t3);
      }
      Release() {
        super.Release();
      }
    };
  }
  {
    const t2 = self.C3;
    t2.Behaviors.TileMovement.Type = class extends t2.SDKBehaviorTypeBase {
      constructor(t3) {
        super(t3);
      }
      Release() {
        super.Release();
      }
      OnCreate() {
      }
    };
  }
  {
    const t2 = self.C3, e = self.C3X, i = self.IBehaviorInstance, s = 0, r2 = 1, n = 2, h2 = 3, o2 = 4, a2 = 5, d2 = 6, _2 = 7, g2 = 0.01, l = 10, u2 = [];
    t2.Behaviors.TileMovement.Instance = class extends t2.SDKBehaviorInstanceBase {
      constructor(e2, i2) {
        super(e2), this._upKey = false, this._downKey = false, this._leftKey = false, this._rightKey = false, this._ignoreInput = false, this._simUp = false, this._simDown = false, this._simLeft = false, this._simRight = false, this._gridWidth = 32, this._gridHeight = 32, this._gridOffsetX = 0, this._gridOffsetY = 0, this._speedX = 100, this._speedY = 100, this._isEnabled = true, this._defaultControls = true, this._iso = false, i2 && (this._gridWidth = i2[0], this._gridHeight = i2[1], this._gridOffsetX = i2[2], this._gridOffsetY = i2[3], this._speedX = i2[4], this._speedY = i2[5], this._isEnabled = i2[6], this._defaultControls = i2[7], this._iso = i2[8]), this._targetX = 0, this._targetY = 0, this._targetGridX = 0, this._targetGridY = 0, this._lastX = NaN, this._lastY = NaN, this._lastX2 = NaN, this._lastY2 = NaN, this._collisionRect = t2.New(t2.Rect), this._disposables = null, this._isEnabled && this._StartTicking(), this._defaultControls && this._BindEvents(), this._ResetTarget();
      }
      Release() {
        this._UnBindEvents(), super.Release();
      }
      _BindEvents() {
        if (this._disposables) return;
        const e2 = this._runtime.Dispatcher();
        this._disposables = new t2.CompositeDisposable(t2.Disposable.From(e2, "keydown", (t3) => this._OnKeyDown(t3.data)), t2.Disposable.From(e2, "keyup", (t3) => this._OnKeyUp(t3.data)), t2.Disposable.From(e2, "window-blur", () => this._OnWindowOrKeyboardBlur()), t2.Disposable.From(e2, "keyboard-blur", () => this._OnWindowOrKeyboardBlur()));
      }
      _UnBindEvents() {
        this._disposables && (this._disposables.Release(), this._disposables = null);
      }
      _OnKeyDown(t3) {
        switch (t3["key"]) {
          case "ArrowLeft":
            this._leftKey = true;
            break;
          case "ArrowUp":
            this._upKey = true;
            break;
          case "ArrowRight":
            this._rightKey = true;
            break;
          case "ArrowDown":
            this._downKey = true;
        }
      }
      _OnKeyUp(t3) {
        switch (t3["key"]) {
          case "ArrowLeft":
            this._leftKey = false;
            break;
          case "ArrowUp":
            this._upKey = false;
            break;
          case "ArrowRight":
            this._rightKey = false;
            break;
          case "ArrowDown":
            this._downKey = false;
        }
      }
      _OnWindowOrKeyboardBlur() {
        this._upKey = false, this._downKey = false, this._leftKey = false, this._rightKey = false;
      }
      _ResetLastPositions() {
        this._lastX = NaN, this._lastY = NaN, this._lastX2 = NaN, this._lastY2 = NaN;
      }
      SaveToJson() {
        return { "gw": this._gridWidth, "gh": this._gridHeight, "ox": this._gridOffsetX, "oy": this._gridOffsetY, "sx": this._speedX, "sy": this._speedY, "x": this._targetX, "y": this._targetY, "gx": this._targetGridX, "gy": this._targetGridY, "e": this._isEnabled, "i": this._ignoreInput, "c": this._defaultControls };
      }
      LoadFromJson(t3) {
        this._gridWidth = t3["gw"], this._gridHeight = t3["gh"], this._gridOffsetX = t3["ox"], this._gridOffsetY = t3["oy"], this._speedX = t3["sx"], this._speedY = t3["sy"], this._targetX = t3["x"], this._targetY = t3["y"], this._targetGridX = t3["gx"], this._targetGridY = t3["gy"], this._isEnabled = !!t3["e"], this._ignoreInput = !!t3["i"], this._defaultControls = !!t3["c"], this._isEnabled ? this._StartTicking() : (this._simLeft = false, this._simRight = false, this._simUp = false, this._simDown = false, this._StopTicking()), this._defaultControls ? this._BindEvents() : this._UnBindEvents(), this._ResetLastPositions();
      }
      _GetTargetDelta() {
        const t3 = this.GetWorldInfo();
        return [this._targetX - t3.GetX(), this._targetY - t3.GetY()];
      }
      IsMoving() {
        if (!this.IsEnabled()) return false;
        const [t3, e2] = this._GetTargetDelta();
        return Math.abs(t3) > 0 && 0 !== this._speedX || Math.abs(e2) > 0 && 0 !== this._speedY;
      }
      IsMovingDirection(t3) {
        if (!this.IsEnabled()) return false;
        const [e2, i2] = this._GetTargetDelta();
        return t3 < 2 && 0 !== this._speedX ? 0 === t3 ? e2 > 0 : e2 < 0 : 0 !== this._speedY && (2 === t3 ? i2 > 0 : i2 < 0);
      }
      CanMoveTo(t3, e2) {
        const i2 = this.GetWorldInfo(), s2 = i2.GetX(), r3 = i2.GetY(), n2 = this._WorldPosition(t3, e2);
        i2.SetX(n2[0]), i2.SetY(n2[1]), i2.SetBboxChanged();
        const h3 = this._TestCollision();
        return i2.SetX(s2), i2.SetY(r3), i2.SetBboxChanged(), !h3;
      }
      CanMoveDirection(t3, e2) {
        const i2 = this.GetWorldInfo(), s2 = i2.GetX(), r3 = i2.GetY();
        let n2 = 0, h3 = 0;
        switch (t3) {
          case 0:
            n2 = 1;
            break;
          case 1:
            n2 = -1;
            break;
          case 2:
            h3 = 1;
            break;
          case 3:
            h3 = -1;
        }
        (e2 = Math.floor(e2)) < 0 && (n2 = -n2, h3 = -h3, e2 = -e2);
        let o3 = this._GridX(s2, r3), a3 = this._GridY(s2, r3), d3 = null;
        for (let t4 = 0; t4 < e2; t4++) {
          o3 += n2, a3 += h3;
          const t5 = this._WorldPosition(o3, a3);
          if (i2.SetX(t5[0]), i2.SetY(t5[1]), i2.SetBboxChanged(), d3 = this._TestCollision(), d3) break;
        }
        return i2.SetX(s2), i2.SetY(r3), i2.SetBboxChanged(), !d3;
      }
      SetIgnoreInput(t3) {
        this._ignoreInput = !!t3;
      }
      GetDefaultControls() {
        return this._defaultControls;
      }
      SimulateControl(t3) {
        if (this.IsEnabled()) switch (t3) {
          case 0:
            this._simLeft = true;
            break;
          case 1:
            this._simRight = true;
            break;
          case 2:
            this._simUp = true;
            break;
          case 3:
            this._simDown = true;
        }
      }
      SetSpeed(t3, e2) {
        this._speedX = t3, this._speedY = e2;
      }
      SetGridPosition(t3, e2, i2) {
        i2 = !!i2;
        !this._UpdateTarget(t3, e2) && i2 && this._MoveToTarget();
      }
      SetGridDimensions(t3, e2, i2, s2) {
        this._gridWidth = t3, this._gridHeight = e2, this._gridOffsetX = i2, this._gridOffsetY = s2, this._TargetCurrentPositon();
      }
      _GridX(t3, e2) {
        return this._iso ? this._IsoGridX(t3, e2) : (t3 -= this._gridOffsetX, t3 /= this._gridWidth, Math.round(t3));
      }
      _GridY(t3, e2) {
        return this._iso ? this._IsoGridY(t3, e2) : (e2 -= this._gridOffsetY, e2 /= this._gridHeight, Math.round(e2));
      }
      _IsoGridX(t3, e2) {
        t3 -= this._gridOffsetX, e2 -= this._gridOffsetY;
        const i2 = ((t3 /= this._gridWidth / 2) + (e2 /= this._gridHeight / 2)) / 2;
        return Math.round(i2);
      }
      _IsoGridY(t3, e2) {
        t3 -= this._gridOffsetX, e2 -= this._gridOffsetY, t3 /= this._gridWidth / 2;
        const i2 = ((e2 /= this._gridHeight / 2) - t3) / 2;
        return Math.round(i2);
      }
      _ClampedGridPosition(t3, e2) {
        const [i2, s2] = this._GridPosition(t3, e2);
        return [Math.round(i2), Math.round(s2)];
      }
      _GridPosition(t3, e2) {
        return this._iso ? this._IsoGridPosition(t3, e2) : (t3 -= this._gridOffsetX, e2 -= this._gridOffsetY, [t3 /= this._gridWidth, e2 /= this._gridHeight]);
      }
      _WorldPosition(t3, e2) {
        return this._iso ? this._IsoWorldPosition(t3, e2) : (t3 *= this._gridWidth, e2 *= this._gridHeight, [t3 += this._gridOffsetX, e2 += this._gridOffsetY]);
      }
      _IsoGridPosition(t3, e2) {
        t3 -= this._gridOffsetX, e2 -= this._gridOffsetY;
        return [((t3 /= this._gridWidth / 2) + (e2 /= this._gridHeight / 2)) / 2, (e2 - t3) / 2];
      }
      _IsoWorldPosition(t3, e2) {
        let i2 = t3 - e2, s2 = t3 + e2;
        return i2 *= this._gridWidth / 2, s2 *= this._gridHeight / 2, i2 += this._gridOffsetX, s2 += this._gridOffsetY, [i2, s2];
      }
      _UpdateTarget(t3, e2) {
        const i2 = this.GetWorldInfo(), s2 = i2.GetX(), r3 = i2.GetY(), n2 = this._WorldPosition(t3, e2);
        i2.SetX(n2[0]), i2.SetY(n2[1]), i2.SetBboxChanged();
        const h3 = this._TestCollision();
        return i2.SetX(s2), i2.SetY(r3), i2.SetBboxChanged(), !!h3 || (this._targetGridX = t3, this._targetGridY = e2, this._targetX = n2[0], this._targetY = n2[1], this._ResetLastPositions(), false);
      }
      _MoveToTarget() {
        const t3 = this.GetWorldInfo();
        t3.SetXY(this._targetX, this._targetY), t3.SetBboxChanged();
      }
      _TargetCurrentPositon() {
        const t3 = this.GetWorldInfo(), e2 = this._ClampedGridPosition(t3.GetX(), t3.GetY()), i2 = this._WorldPosition(e2[0], e2[1]);
        this._targetGridX = e2[0], this._targetGridY = e2[1], this._targetX = i2[0], this._targetY = i2[1], this._ResetLastPositions();
      }
      _ResetTarget() {
        this._TargetCurrentPositon(), this._MoveToTarget();
      }
      _UpdateCollisionRect() {
        const t3 = this.GetWorldInfo().GetBoundingBox();
        this._collisionRect.copy(t3);
        let e2 = g2, i2 = g2;
        const s2 = t3.width(), r3 = t3.height();
        if (s2 < g2 + g2) {
          const i3 = t3.midX();
          e2 = 0, t3.setRight(i3), t3.setLeft(i3);
        }
        if (r3 < g2 + g2) {
          const e3 = t3.midY();
          i2 = 0, t3.setRight(e3), t3.setLeft(e3);
        }
        return this._collisionRect.deflate(e2, i2), this._collisionRect;
      }
      _TestCollision() {
        const e2 = this.GetObjectInstance();
        if (!e2.GetWorldInfo().IsCollisionEnabled()) return null;
        const i2 = this._runtime.GetCollisionEngine(), s2 = this._UpdateCollisionRect();
        i2.GetSolidCollisionCandidates(null, s2, u2);
        for (const r3 of u2) if (r3 !== e2 && i2.IsSolidCollisionAllowed(r3, e2) && i2.TestRectOverlap(s2, r3)) return t2.clearArray(u2), r3;
        return t2.clearArray(u2), null;
      }
      _MaybePushOut() {
        const t3 = this._runtime.GetCollisionEngine(), e2 = this._TestCollision();
        if (!e2) return null;
        const i2 = this.GetWorldInfo(), s2 = i2.GetX(), r3 = i2.GetY(), n2 = i2.GetBoundingBox(), h3 = e2.GetWorldInfo().GetBoundingBox(), o3 = Math.max(n2.getRight(), h3.getRight()) - Math.min(n2.getLeft(), h3.getLeft()), a3 = Math.max(n2.getBottom(), h3.getBottom()) - Math.min(n2.getTop(), h3.getTop());
        let d3 = n2.width() + h3.width() - o3, _3 = n2.height() + h3.height() - a3, g3 = false;
        return d3 < _3 ? (d3 > l && (g3 = true), d3 = Math.min(d3, l), n2.getLeft() < h3.getLeft() ? i2.OffsetX(-d3) : i2.OffsetX(d3)) : (_3 > l && (g3 = true), _3 = Math.min(_3, l), n2.getTop() < h3.getTop() ? i2.OffsetY(-_3) : i2.OffsetY(_3)), i2.SetBboxChanged(), this._TestCollision() && (i2.SetX(s2), i2.SetY(r3), i2.SetBboxChanged()), g3 && t3.RegisterCollision(this._inst, e2), this._TargetCurrentPositon(), e2;
      }
      Tick() {
        const e2 = this._runtime.GetDt(this._inst), i2 = this.GetWorldInfo();
        let s2 = this._leftKey || this._simLeft, r3 = this._rightKey || this._simRight, n2 = this._upKey || this._simUp, h3 = this._downKey || this._simDown;
        if (this._simLeft = false, this._simRight = false, this._simUp = false, this._simDown = false, !this.IsEnabled()) return;
        if (this._ignoreInput && (s2 = r3 = n2 = h3 = false), n2 && h3 && (n2 = h3 = false), s2 && r3 && (s2 = r3 = false), this._MaybePushOut()) return;
        if (0 === e2) return;
        const o3 = i2.GetX(), a3 = i2.GetY(), d3 = e2 * this._speedX, _3 = e2 * this._speedY;
        let g3 = this._targetGridX, l2 = this._targetGridY, u3 = this._targetX - o3, f3 = this._targetY - a3, c2 = Math.abs(u3), p2 = Math.abs(f3), b2 = 0, G = 0;
        if (c2 > 0) {
          const e3 = Math.sign(u3), i3 = e3 < 0 && s2, n3 = e3 > 0 && r3;
          if (i3 || n3) for (; !(!(c2 < d3) || n3 && this._UpdateTarget(++g3, l2) || i3 && this._UpdateTarget(--g3, l2)); ) u3 = this._targetX - o3, c2 = Math.abs(u3);
          b2 = e3 * t2.clamp(c2, 0, d3);
        }
        if (p2 > 0) {
          const e3 = Math.sign(f3), i3 = e3 > 0 && h3, s3 = e3 < 0 && n2;
          if (i3 || s3) for (; !(!(p2 < _3) || i3 && this._UpdateTarget(g3, ++l2) || s3 && this._UpdateTarget(g3, --l2)); ) f3 = this._targetY - a3, p2 = Math.abs(f3);
          G = e3 * t2.clamp(p2, 0, _3);
        }
        if (0 != b2 || 0 != G) if (this._lastX2 = this._lastX, this._lastY2 = this._lastY, this._lastX = i2.GetX(), this._lastY = i2.GetY(), this._lastX === this._lastX2 && this._lastY === this._lastY2) this._UpdateTarget(g3 - Math.sign(b2), l2 - Math.sign(G));
        else if (Math.abs(this._lastX - this._lastX2) >= this._gridWidth || Math.abs(this._lastY - this._lastY2) >= this._gridHeight) {
          const [t3, e3] = this._GridPosition(this._lastX, this._lastY);
          this._UpdateTarget(Math.floor(t3) + (b2 > 0 ? 1 : 0), Math.floor(e3) + (G > 0 ? 1 : 0));
        } else i2.OffsetXY(b2, G), i2.SetBboxChanged(), this._MaybePushOut();
        else 0 !== this._speedX && (s2 ? this._UpdateTarget(g3 - 1, l2) : r3 && this._UpdateTarget(g3 + 1, l2)), 0 !== this._speedY && (s2 || r3 || !n2 ? h3 && this._UpdateTarget(g3, l2 + 1) : this._UpdateTarget(g3, l2 - 1));
      }
      GetPropertyValueByIndex(t3) {
        switch (t3) {
          case s:
            return this._gridWidth;
          case r2:
            return this._gridHeight;
          case n:
            return this._gridOffsetX;
          case h2:
            return this._gridOffsetY;
          case o2:
            return this._speedX;
          case a2:
            return this._speedY;
          case d2:
            return this.IsEnabled();
          case _2:
            return this._defaultControls;
        }
      }
      SetPropertyValueByIndex(t3, e2) {
        switch (t3) {
          case s:
            this._gridWidth = e2, this._TargetCurrentPositon();
            break;
          case r2:
            this._gridHeight = e2, this._TargetCurrentPositon();
            break;
          case n:
            this._gridOffsetX = e2, this._TargetCurrentPositon();
            break;
          case h2:
            this._gridOffsetY = e2, this._TargetCurrentPositon();
            break;
          case o2:
            this._speedX = e2;
            break;
          case a2:
            this._speedY = e2;
            break;
          case d2:
            this.SetEnabled(e2);
            break;
          case _2:
            this._SetDefaultControls(e2);
        }
      }
      SetEnabled(t3) {
        t3 = !!t3, this._isEnabled !== t3 && (this._isEnabled = t3, this._isEnabled ? this._StartTicking() : (this._simLeft = false, this._simRight = false, this._simUp = false, this._simDown = false, this._StopTicking()), this._ResetLastPositions());
      }
      IsEnabled() {
        return this._isEnabled;
      }
      _SetDefaultControls(t3) {
        t3 = !!t3, this._defaultControls !== t3 && (this._defaultControls = t3, this._defaultControls ? this._BindEvents() : (this._UnBindEvents(), this._OnWindowOrKeyboardBlur()));
      }
      GetDebuggerProperties() {
        const t3 = "behaviors.tilemovement", e2 = this.GetWorldInfo(), i2 = this._GridPosition(e2.GetX(), e2.GetY());
        return [{ title: "$" + this.GetBehaviorType().GetName(), properties: [{ name: t3 + ".debugger.grid-x", value: i2[0], onedit: (t4) => {
          const s2 = this._WorldPosition(t4, i2[1]);
          e2.SetX(s2[0]), e2.SetBboxChanged();
        } }, { name: t3 + ".debugger.grid-y", value: i2[1], onedit: (t4) => {
          const s2 = this._WorldPosition(i2[0], t4);
          e2.SetY(s2[1]), e2.SetBboxChanged();
        } }, { name: t3 + ".properties.grid-width.name", value: this._gridWidth, onedit: (t4) => {
          this._gridWidth = t4, this._TargetCurrentPositon();
        } }, { name: t3 + ".properties.grid-height.name", value: this._gridHeight, onedit: (t4) => {
          this._gridHeight = t4, this._TargetCurrentPositon();
        } }, { name: t3 + ".properties.grid-offset-x.name", value: this._gridOffsetX, onedit: (t4) => {
          this._gridOffsetX = t4, this._TargetCurrentPositon();
        } }, { name: t3 + ".properties.grid-offset-y.name", value: this._gridOffsetY, onedit: (t4) => {
          this._gridOffsetY = t4, this._TargetCurrentPositon();
        } }, { name: t3 + ".properties.speed-x.name", value: this._speedX, onedit: (t4) => this._speedX = t4 }, { name: t3 + ".properties.speed-y.name", value: this._speedY, onedit: (t4) => this._speedY = t4 }, { name: t3 + ".debugger.target-x", value: this._targetX, onedit: (t4) => {
          this._targetX = t4;
          const e3 = this._ClampedGridPosition(this._targetX, this._targetY);
          this._targetGridX = e3[0], this._ResetLastPositions();
        } }, { name: t3 + ".debugger.target-y", value: this._targetY, onedit: (t4) => {
          this._targetY = t4;
          const e3 = this._ClampedGridPosition(this._targetX, this._targetY);
          this._targetGridY = e3[1], this._ResetLastPositions();
        } }, { name: t3 + ".debugger.grid-target-x", value: this._targetGridX, onedit: (t4) => {
          this._targetGridX = t4;
          const e3 = this._WorldPosition(this._targetGridX, this._targetGridY);
          this._targetX = e3[0];
        } }, { name: t3 + ".debugger.grid-target-y", value: this._targetGridY, onedit: (t4) => {
          this._targetGridY = t4;
          const e3 = this._WorldPosition(this._targetGridX, this._targetGridY);
          this._targetY = e3[1];
        } }, { name: t3 + ".properties.enabled.name", value: this.IsEnabled(), onedit: (t4) => this.SetEnabled(t4) }, { name: t3 + ".properties.default-controls.name", value: this._defaultControls, onedit: (t4) => this._SetDefaultControls(t4) }] }];
      }
      GetScriptInterfaceClass() {
        return self.ITileMovementBehaviorInstance;
      }
    };
    const f2 = /* @__PURE__ */ new WeakMap();
    self.ITileMovementBehaviorInstance = class extends i {
      constructor() {
        super(), f2.set(this, i._GetInitInst().GetSdkInstance());
      }
      set isIgnoringInput(t3) {
        f2.get(this).SetIgnoreInput(!!t3);
      }
      get isIgnoringInput() {
        return f2.get(this)._ignoreInput;
      }
      simulateControl(t3) {
        e.RequireString(t3);
        let i2 = -1;
        switch (t3) {
          case "left":
            i2 = 0;
            break;
          case "right":
            i2 = 1;
            break;
          case "up":
            i2 = 2;
            break;
          case "down":
            i2 = 3;
            break;
          default:
            throw new Error(`Invalid direction ${t3}`);
        }
        f2.get(this).SimulateControl(i2);
      }
      set isEnabled(t3) {
        f2.get(this).SetEnabled(!!t3);
      }
      get isEnabled() {
        return f2.get(this).IsEnabled();
      }
      get isDefaultControls() {
        return f2.get(this).GetDefaultControls();
      }
      set isDefaultControls(t3) {
        f2.get(this)._SetDefaultControls(!!t3);
      }
      setSpeed(t3, i2) {
        e.RequireFiniteNumber(t3), e.RequireFiniteNumber(i2), f2.get(this).SetSpeed(t3, i2);
      }
      getSpeed() {
        const t3 = f2.get(this);
        return [t3._speedX, t3._speedY];
      }
      setGridPosition(t3, i2, s2) {
        e.RequireFiniteNumber(t3), e.RequireFiniteNumber(i2), f2.get(this).SetGridPosition(t3, i2, !!s2);
      }
      getGridPosition() {
        const t3 = f2.get(this), e2 = t3.GetWorldInfo(), i2 = e2.GetX(), s2 = e2.GetY();
        return [t3._GridX(i2, s2), t3._GridY(i2, s2)];
      }
      modifyGridDimensions(t3, i2, s2, r3) {
        e.RequireFiniteNumber(t3), e.RequireFiniteNumber(i2), e.RequireFiniteNumber(s2), e.RequireFiniteNumber(r3), f2.get(this).SetGridDimensions(t3, i2, s2, r3);
      }
      isMoving() {
        return f2.get(this).IsMoving();
      }
      isMovingDirection(t3) {
        e.RequireString(t3);
        let i2 = -1;
        switch (t3) {
          case "right":
            i2 = 0;
            break;
          case "left":
            i2 = 1;
            break;
          case "down":
            i2 = 2;
            break;
          case "up":
            i2 = 3;
            break;
          default:
            throw new Error(`Invalid direction ${t3}`);
        }
        return f2.get(this).IsMovingDirection(i2);
      }
      canMoveTo(t3, i2) {
        return e.RequireFiniteNumber(t3), e.RequireFiniteNumber(i2), f2.get(this).CanMoveTo(t3, i2);
      }
      canMoveDirection(t3, i2) {
        e.RequireString(t3);
        let s2 = -1;
        switch (t3) {
          case "right":
            s2 = 0;
            break;
          case "left":
            s2 = 1;
            break;
          case "down":
            s2 = 2;
            break;
          case "up":
            s2 = 3;
            break;
          default:
            throw new Error(`invalid direction '${t3}'`);
        }
        return f2.get(this).CanMoveDirection(s2, i2);
      }
      getTargetPosition() {
        const t3 = f2.get(this);
        return [t3._targetX, t3._targetY];
      }
      getGridTargetPosition() {
        const t3 = f2.get(this);
        return [t3._targetGridX, t3._targetGridY];
      }
      toGridSpace(t3, i2) {
        return e.RequireFiniteNumber(t3), e.RequireFiniteNumber(i2), f2.get(this)._GridPosition(t3, i2);
      }
      fromGridSpace(t3, i2) {
        return e.RequireFiniteNumber(t3), e.RequireFiniteNumber(i2), f2.get(this)._WorldPosition(t3, i2);
      }
    };
  }
  self.C3.Behaviors.TileMovement.Cnds = { IsMoving() {
    return this.IsMoving();
  }, IsMovingDirection(t2) {
    return this.IsMovingDirection(t2);
  }, IsEnabled() {
    return this._isEnabled;
  }, CanMoveTo(t2, e) {
    return this.CanMoveTo(t2, e);
  }, CanMoveDirection(t2, e) {
    return this.CanMoveDirection(t2, e);
  } };
  self.C3.Behaviors.TileMovement.Acts = { SetIgnoreInput(t2) {
    this.SetIgnoreInput(t2);
  }, SimulateControl(t2) {
    this.SimulateControl(t2);
  }, SetEnabled(t2) {
    this.SetEnabled(t2);
  }, SetSpeed(t2, e) {
    this.SetSpeed(t2, e);
  }, SetGridPosition(t2, e, i) {
    this.SetGridPosition(t2, e, i);
  }, SetGridDimensions(t2, e, i, s) {
    this.SetGridDimensions(t2, e, i, s);
  }, SetDefaultControls(t2) {
    this._SetDefaultControls(!!t2);
  } };
  self.C3.Behaviors.TileMovement.Exps = { GridX() {
    const t2 = this.GetWorldInfo();
    return this._GridX(t2.GetX(), t2.GetY());
  }, GridY() {
    const t2 = this.GetWorldInfo();
    return this._GridY(t2.GetX(), t2.GetY());
  }, SpeedX() {
    return this._speedX;
  }, SpeedY() {
    return this._speedY;
  }, TargetX() {
    return this._targetX;
  }, TargetY() {
    return this._targetY;
  }, GridTargetX() {
    return this._targetGridX;
  }, GridTargetY() {
    return this._targetGridY;
  } };
}
{
  {
    const e = self.C3;
    e.Behaviors.bound = class extends e.SDKBehaviorBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
    };
  }
  {
    const e = self.C3;
    e.Behaviors.bound.Type = class extends e.SDKBehaviorTypeBase {
      constructor(e2) {
        super(e2);
      }
      Release() {
        super.Release();
      }
      OnCreate() {
      }
    };
  }
  {
    const e = self.C3, t2 = 0;
    e.Behaviors.bound.Instance = class extends e.SDKBehaviorInstanceBase {
      constructor(e2, s) {
        super(e2), this._mode = 0, s && (this._mode = s[t2]), this._StartTicking2();
      }
      Release() {
        super.Release();
      }
      SaveToJson() {
        return { "m": this._mode };
      }
      LoadFromJson(e2) {
        this._mode = e2["m"];
      }
      Tick2() {
        const e2 = this._inst.GetWorldInfo(), t3 = e2.GetBoundingBox(), s = e2.GetLayout();
        let o2 = false;
        0 === this._mode ? (e2.GetX() < 0 && (e2.SetX(0), o2 = true), e2.GetY() < 0 && (e2.SetY(0), o2 = true), e2.GetX() > s.GetWidth() && (e2.SetX(s.GetWidth()), o2 = true), e2.GetY() > s.GetHeight() && (e2.SetY(s.GetHeight()), o2 = true)) : (t3.getLeft() < 0 && (e2.OffsetX(-t3.getLeft()), o2 = true), t3.getTop() < 0 && (e2.OffsetY(-t3.getTop()), o2 = true), t3.getRight() > s.GetWidth() && (e2.OffsetX(-(t3.getRight() - s.GetWidth())), o2 = true), t3.getBottom() > s.GetHeight() && (e2.OffsetY(-(t3.getBottom() - s.GetHeight())), o2 = true)), o2 && e2.SetBboxChanged();
      }
      GetPropertyValueByIndex(e2) {
        if (e2 === t2) return this._mode;
      }
      SetPropertyValueByIndex(e2, s) {
        if (e2 === t2) this._mode = s;
      }
    };
  }
  self.C3.Behaviors.bound.Cnds = {};
  self.C3.Behaviors.bound.Acts = {};
  self.C3.Behaviors.bound.Exps = {};
}
{
  let unaryminus = function(n) {
    return typeof n === "number" ? -n : n;
  }, bothNumbers = function(a2, b2) {
    return typeof a2 === "number" && typeof b2 === "number";
  }, add = function(l, r2) {
    if (bothNumbers(l, r2))
      return l + r2;
    else
      return l;
  }, subtract = function(l, r2) {
    if (bothNumbers(l, r2))
      return l - r2;
    else
      return l;
  }, multiply = function(l, r2) {
    if (bothNumbers(l, r2))
      return l * r2;
    else
      return l;
  }, divide = function(l, r2) {
    if (bothNumbers(l, r2))
      return l / r2;
    else
      return l;
  }, mod = function(l, r2) {
    if (bothNumbers(l, r2))
      return l % r2;
    else
      return l;
  }, pow = function(l, r2) {
    if (bothNumbers(l, r2))
      return Math.pow(l, r2);
    else
      return l;
  }, and = function(l, r2) {
    if (typeof l === "string" || typeof r2 === "string") {
      let lstr, rstr;
      if (typeof l === "number")
        lstr = (Math.round(l * 1e10) / 1e10).toString();
      else
        lstr = l;
      if (typeof r2 === "number")
        rstr = (Math.round(r2 * 1e10) / 1e10).toString();
      else
        rstr = r2;
      return lstr + rstr;
    } else {
      return l && r2 ? 1 : 0;
    }
  }, or = function(l, r2) {
    if (bothNumbers(l, r2))
      return l || r2 ? 1 : 0;
    else
      return l;
  };
  unaryminus2 = unaryminus, bothNumbers2 = bothNumbers, add2 = add, subtract2 = subtract, multiply2 = multiply, divide2 = divide, mod2 = mod, pow2 = pow, and2 = and, or2 = or;
  const C32 = self.C3;
  self.C3_ExpressionFuncs = [
    () => "Player",
    () => "PlayerPickups",
    () => "PlusUps",
    () => "Pulse",
    () => 4,
    () => 1,
    () => -1e3,
    () => 2,
    () => 12,
    () => 3,
    () => "Echoite",
    () => 5,
    () => 25,
    () => 50,
    () => 100,
    () => 500,
    () => "PlayerControls",
    () => 0,
    () => 1e-5,
    () => 8,
    () => "PlayerMOVEMENT",
    () => "Walk",
    () => "Stand",
    () => "Jump",
    () => "PlayerATKS",
    () => "atkBowNArrow",
    () => "You don't have any arrows!",
    () => 0.1,
    () => 0.5,
    () => "",
    (p2) => {
      const f0 = p2._GetNode(0).GetBoundMethod();
      return () => f0();
    },
    () => "PlayerMovement",
    () => "MagicAttack",
    () => "atkMelee",
    (p2) => {
      const n0 = p2._GetNode(0);
      return () => n0.ExpObject() - 125;
    },
    (p2) => {
      const n0 = p2._GetNode(0);
      return () => n0.ExpObject() + 125;
    },
    (p2) => {
      const n0 = p2._GetNode(0);
      return () => n0.ExpObject() - 75;
    },
    (p2) => {
      const n0 = p2._GetNode(0);
      return () => n0.ExpObject() + 75;
    },
    () => "Attack",
    () => "Animation 1",
    () => "atkMagic",
    () => "You need to wait for cooldown!",
    (p2) => {
      const v0 = p2._GetNode(0).GetVar();
      return () => v0.GetValue();
    },
    () => "Your Mana is too low!",
    () => "Basic",
    () => "Attack Type: Basic",
    () => "Basic+",
    () => "Attack Type: Basic+",
    () => "BasicFire",
    () => "Attack Type: Fire Spark",
    () => "BasicElectric",
    () => "Attack Type: Lightning Spark",
    () => "Extreme",
    () => "Attack Type: Extreme",
    () => "Extreme+",
    () => "Attack Type: Extreme+",
    () => "Insane",
    () => 6,
    () => "Attack Type: Insane",
    () => 650,
    () => "NOR1",
    () => -100,
    () => "BOSSTIME",
    () => 141,
    () => "NOR2",
    () => "NOR3",
    () => "PlayerStats",
    (p2) => {
      const n0 = p2._GetNode(0);
      return () => n0.ExpInstVar();
    },
    () => "Damaged",
    () => "PlayerStatRestore",
    () => "Death",
    () => 2.5,
    () => "PlayerSkills",
    () => "You can now double jump!",
    () => "PlayerHP",
    () => 120,
    () => 30,
    () => 119,
    () => 118,
    () => 117,
    () => 116,
    () => 115,
    () => 29,
    () => 114,
    () => 113,
    () => 7,
    () => 112,
    () => 28,
    () => 111,
    () => 9,
    () => 110,
    () => 10,
    () => 109,
    () => 11,
    () => 108,
    () => 27,
    () => 107,
    () => 13,
    () => 106,
    () => 14,
    () => 105,
    () => 15,
    () => 104,
    () => 26,
    () => 16,
    () => 103,
    () => 17,
    () => 102,
    () => 18,
    () => 101,
    () => 19,
    () => 20,
    () => 99,
    () => 21,
    () => 98,
    () => 22,
    () => 97,
    () => 23,
    () => 96,
    () => 24,
    () => 95,
    () => 94,
    () => 93,
    () => 92,
    () => 91,
    () => 90,
    () => 89,
    () => 31,
    () => 88,
    () => 32,
    () => 87,
    () => 33,
    () => 86,
    () => 34,
    () => 85,
    () => 35,
    () => 84,
    () => 36,
    () => 83,
    () => 37,
    () => 82,
    () => 38,
    () => 81,
    () => 39,
    () => 80,
    () => 40,
    () => 79,
    () => 41,
    () => 78,
    () => 42,
    () => 77,
    () => 43,
    () => 76,
    () => 44,
    () => 75,
    () => 45,
    () => 74,
    () => 46,
    () => 73,
    () => 47,
    () => 72,
    () => 48,
    () => 71,
    () => 49,
    () => 70,
    () => 69,
    () => 51,
    () => 68,
    () => 52,
    () => 67,
    () => 53,
    () => 66,
    () => 54,
    () => 65,
    () => 55,
    () => 64,
    () => 56,
    () => 63,
    () => 57,
    () => 62,
    () => 58,
    () => 61,
    () => 59,
    () => 60,
    () => "PlayerMP",
    () => "You don't have any of those!",
    () => "Enemies",
    () => "breakableBlock",
    () => "breakableBlock1",
    () => " / 20",
    (p2) => {
      const n0 = p2._GetNode(0);
      return () => n0.ExpObject();
    },
    () => "breakableBlock2",
    () => " / 10",
    () => 273,
    () => "355",
    () => 355,
    () => "Necromancer",
    () => "NercomancerCollisions",
    (p2) => {
      const v0 = p2._GetNode(0).GetVar();
      return () => 2 + v0.GetValue();
    },
    (p2) => {
      const v0 = p2._GetNode(0).GetVar();
      return () => 5 + v0.GetValue();
    },
    (p2) => {
      const v0 = p2._GetNode(0).GetVar();
      return () => 14 + v0.GetValue();
    },
    (p2) => {
      const v0 = p2._GetNode(0).GetVar();
      return () => 8 + v0.GetValue();
    },
    (p2) => {
      const v0 = p2._GetNode(0).GetVar();
      return () => 12 + v0.GetValue();
    },
    (p2) => {
      const v0 = p2._GetNode(0).GetVar();
      return () => 15 + v0.GetValue();
    },
    (p2) => {
      const v0 = p2._GetNode(0).GetVar();
      return () => 25 + v0.GetValue();
    },
    (p2) => {
      const v0 = p2._GetNode(0).GetVar();
      return () => 6 + v0.GetValue();
    },
    (p2) => {
      const v0 = p2._GetNode(0).GetVar();
      return () => 12 - v0.GetValue();
    },
    () => -20,
    (p2) => {
      const v0 = p2._GetNode(0).GetVar();
      return () => Math.floor(7 - v0.GetValue() * 0.75);
    },
    (p2) => {
      const n0 = p2._GetNode(0);
      return () => n0.ExpObject() + 5;
    },
    (p2) => {
      const n0 = p2._GetNode(0);
      return () => n0.ExpObject() - 5;
    },
    () => "SpiritOrb",
    () => "spiritOrbHealth",
    () => "LVL2",
    () => 177,
    () => 176,
    () => 383,
    () => 372,
    () => 361,
    () => 295,
    () => 334,
    () => 178,
    () => 122,
    () => 121,
    () => 128,
    () => 127,
    () => 130,
    () => 129,
    () => "30SOkill",
    () => "10SOkill",
    () => "spiritOrbCollisions",
    (p2) => {
      const v0 = p2._GetNode(0).GetVar();
      return () => 4 + v0.GetValue();
    },
    (p2) => {
      const v0 = p2._GetNode(0).GetVar();
      return () => 3 + v0.GetValue();
    },
    (p2) => {
      const v0 = p2._GetNode(0).GetVar();
      return () => 20 + v0.GetValue();
    },
    (p2) => {
      const v0 = p2._GetNode(0).GetVar();
      return () => 45 + v0.GetValue();
    },
    (p2) => {
      const v0 = p2._GetNode(0).GetVar();
      return () => 5 - v0.GetValue();
    },
    () => 135,
    () => 148,
    () => 160,
    () => 159,
    () => 146,
    () => 147,
    () => 139,
    () => "systemStuff",
    () => "LVL1",
    () => "LVL3",
    () => "LVL4",
    () => 140,
    () => 144,
    () => 143,
    () => 145,
    () => 142,
    () => "Shop",
    () => "StartGame",
    () => "IntroMovie",
    () => "StartScreen",
    () => "StartScreenControls",
    () => "StartScreenSound",
    () => "SSM",
    () => "intro",
    () => "Wauh?! Where... where am I?!",
    () => 1.5,
    () => "???:",
    () => "This is called..... The Echo Chambers. You must survive the trials ahead. Certain death awaits if you are defeated. Ruby, take your sword and fight your way out.",
    () => 3.5,
    () => "Ruby:",
    () => "Who... Who are you?",
    () => "*chuckles* That is a question for another time. Go on and fight.",
    () => "But--",
    () => "But nothing. Idling around won't get you anywhere.",
    () => "But I need information, not mindless quests.",
    () => "...",
    () => "Good point.",
    () => 0.75,
    () => 1.75,
    () => "This Echo Chambers is a dungeon filled with Skeletons, Spirit Orbs, Necromancers, and unholy magicks. With the amount of magic around, you are capable of some small spells. But be careful, Ruby. You will never know what is around the corner, or behind a door.",
    () => 7.5,
    () => "That seems good...",
    () => 1.25,
    () => "Idling around won't get you anywhere.",
    () => "Now go. You have difficult times ahead of you.",
    () => 6.25,
    (p2) => {
      const f0 = p2._GetNode(0).GetBoundMethod();
      const v1 = p2._GetNode(1).GetVar();
      return () => f0(v1.GetValue(), 6);
    },
    (p2) => {
      const f0 = p2._GetNode(0).GetBoundMethod();
      const v1 = p2._GetNode(1).GetVar();
      return () => f0(v1.GetValue(), 4);
    },
    () => 740,
    () => "$740",
    () => "Restores one of the hearts stolen from you by the Cursed Dark.",
    () => " Increases max health by 4.",
    () => " ",
    () => " -> ",
    (p2) => {
      const v0 = p2._GetNode(0).GetVar();
      return () => v0.GetValue() + 1;
    },
    () => "  (Current Number -> New)",
    () => "$650",
    () => "Restores one of the stars stolen from you by the Cursed Dark.",
    () => " Increases max mana by 4.",
    () => "$50",
    () => "A bundle of six wooden arrows, fletched with goose feathers. The wood seems oddly strange, this deep underground...",
    () => " Increases Arrows by 6.",
    () => "(Current number of arrows to after purchase)   ",
    () => "  ->  ",
    (p2) => {
      const v0 = p2._GetNode(0).GetVar();
      return () => v0.GetValue() + 6;
    },
    () => "$10",
    () => "A single wooden arrow, fletched with a goose feather. The wood seems oddly strange, this deep underground...",
    () => " Increases Arrows by 1.",
    () => "$120",
    () => "A health restorative drink, obviously made if magic. The shopkeeper says it is safe though...",
    () => " Restores 12 HP",
    () => "$75",
    () => "A mana restorative drink, obviously made if magic. The shopkeeper says it is safe though...",
    () => " Restores 16 MP",
    () => -717706215031807,
    () => -43805490175,
    () => "Insufficent Funds!",
    () => " You need ",
    (p2) => {
      const v0 = p2._GetNode(0).GetVar();
      const v1 = p2._GetNode(1).GetVar();
      return () => v0.GetValue() - v1.GetValue();
    },
    () => " more Echoite!",
    () => -30737107967,
    () => "Purchased 6 Arrows",
    () => "Purchased 1 Arrow",
    () => "Purchased 1 Heart Container",
    () => "Purchased 1 Mana Container",
    () => "Purchased 1 Healing Potion",
    () => "Purchased 1 Mana Potion"
  ];
}
var unaryminus2;
var bothNumbers2;
var add2;
var subtract2;
var multiply2;
var divide2;
var mod2;
var pow2;
var and2;
var or2;

// file-map:scripts/behaviors/skymen_FollowMouse/c3runtime/main.js
function d(n) {
  return class extends n {
    constructor() {
      super();
    }
  };
}
function c(n) {
  return class extends n {
    constructor() {
      super();
    }
    _onCreate() {
    }
  };
}
var h = { SetEnabled: { enabled: { enabled: 0, disabled: 1 } } };
var u = { PLUGIN: "plugin", BEHAVIOR: "behavior" };
var g = { WORLD: "world", OBJECT: "object", DOM: "dom" };
var p = u.BEHAVIOR;
var E = g.OBJECT;
var o = "skymen_FollowMouse";
var _ = false;
function f(n) {
  class i {
    constructor() {
    }
    setMeEnabled(s) {
      this.ignoreNextDisableMe = true, this.lastEnabled && this.lastEnabled !== s && (this.lastEnabled.enabled = false), s.SetCursorSprite() ? (this.lastEnabled = s, s._setTicking(true)) : (this.lastEnabled = null, s.enabled = false), this.ignoreNextDisableMe = false;
    }
    setMeDisabled(s) {
      s.RemoveCustomCursor(this.ignoreNextDisableMe), !this.ignoreNextDisableMe && (this.lastEnabled = null);
    }
  }
  return class extends n {
    constructor() {
      super();
      const e = this._getInitProperties();
      this._wasVisible = false, this._wasCollisionEnabled = false, this._wasEnabled = false, this._enabled = false, globalThis.skymen_FollowMouseManagerInstance || (globalThis.skymen_FollowMouseManagerInstance = new i());
      let s = false;
      e && (s = e[0]);
      let l = () => {
        this.enabled = s, this.removeEventListener("instancecreate", l);
      };
      this.addEventListener("instancecreate", l);
    }
    _canBeEnabled() {
      return !this.runtime.platformInfo.isMobile && !!this.runtime.mouse;
    }
    get enabled() {
      return this._enabled;
    }
    set enabled(e) {
      this._enabled !== !!e && (this._enabled = !!e, this._enabled ? globalThis.skymen_FollowMouseManagerInstance.setMeEnabled(this) : globalThis.skymen_FollowMouseManagerInstance.setMeDisabled(this));
    }
    _trigger(e) {
      super._trigger(self.C3.Plugins[o].Cnds[e]);
    }
    _release() {
      super._release();
    }
    SetCursorSprite() {
      if (!this._canBeEnabled()) return false;
      if (this.runtime.mouse.setCursorObjectClass(this.instance.objectType), !this._wasEnabled) return this._wasEnabled = true, this._wasVisible = this.instance.isVisible, this._wasCollisionEnabled = this.instance.isCollisionEnabled, this.instance.isVisible = false, this.instance.isCollisionEnabled = false, true;
    }
    RemoveCustomCursor(e = false) {
      this._wasEnabled && (this._setTicking(false), this._wasEnabled = false, e || this.runtime.mouse.setCursorStyle("auto"), this.instance.isVisible = this._wasVisible, this.instance.isCollisionEnabled = this._wasCollisionEnabled);
    }
    _saveToJson() {
      return { wasVisible: this._wasVisible, wasCollisionEnabled: this._wasCollisionEnabled, wasEnabled: this._wasEnabled, enabled: this.enabled };
    }
    _tick() {
      this.SetCursorSprite();
    }
    _loadFromJson(e) {
      this._wasVisible = e.wasVisible, this._wasCollisionEnabled = e.wasCollisionEnabled, this._wasEnabled = e.wasEnabled, this.enabled = e.enabled;
    }
  };
}
var t = { addonType: p, type: E, id: o, hasDomside: _ };
function r(n) {
  return function(...i) {
    return this[n](...i);
  };
}
function w(n) {
  this.enabled = n === 0;
}
var C = { SetEnabled: w };
var T = { SetEnabled: r("SetEnabled") };
function I() {
  return this.enabled;
}
var m = { IsEnabled: I };
var y = { IsEnabled: r("IsEnabled") };
var M = {};
var D = {};
var B = { object: globalThis.ISDKPluginBase, world: globalThis.ISDKPluginBase, dom: globalThis.ISDKDOMPluginBase };
var S = { plugin: B[t.type], behavior: globalThis.ISDKBehaviorBase };
var x = { plugin: globalThis.ISDKObjectTypeBase, behavior: globalThis.ISDKBehaviorTypeBase };
var O = { object: globalThis.ISDKInstanceBase, world: globalThis.ISDKWorldInstanceBase, dom: globalThis.ISDKDOMInstanceBase };
var v = { plugin: O[t.type], behavior: globalThis.ISDKBehaviorInstanceBase };
var a = f(class extends v[t.addonType] {
  constructor() {
    super();
  }
});
Object.assign(a.prototype, C);
Object.assign(a.prototype, m);
Object.assign(a.prototype, M);
var b = c(x[t.addonType]);
Object.assign(b.prototype, h);
var P = { plugin: "Plugins", behavior: "Behaviors" };
globalThis.C3[P[t.addonType]][t.id] = { Acts: T, Cnds: y, Exps: D, Instance: a, Type: b, Plugin: d(S[t.addonType]) };

// file-map:scripts/objRefTable.js
var C3 = self.C3;
self.C3_GetObjectRefTable = function() {
  return [
    C3.Plugins.Text,
    C3.Plugins.Sprite,
    C3.Behaviors.Anchor,
    C3.Behaviors.Pin,
    C3.Plugins.progressbar,
    C3.Behaviors.Sin,
    C3.Plugins.sliderbar,
    C3.Plugins.Button,
    C3.Behaviors.Flash,
    C3.Behaviors.skymen_FollowMouse,
    C3.Plugins.TiledBg,
    C3.Behaviors.scrollto,
    C3.Plugins.Tilemap,
    C3.Behaviors.solid,
    C3.Behaviors.shadowcaster,
    C3.Behaviors.jumpthru,
    C3.Behaviors.Bullet,
    C3.Behaviors.Turret,
    C3.Behaviors.Platform,
    C3.Behaviors.TileMovement,
    C3.Behaviors.bound,
    C3.Plugins.Particles,
    C3.Plugins.shadowlight,
    C3.Plugins.Keyboard,
    C3.Plugins.Mouse,
    C3.Plugins.Audio,
    C3.Plugins.System.Cnds.IsGroupActive,
    C3.Plugins.Sprite.Cnds.OnCollision,
    C3.Plugins.Sprite.Acts.SetEffectEnabled,
    C3.Plugins.System.Acts.AddVar,
    C3.Plugins.System.Acts.Wait,
    C3.Plugins.Sprite.Acts.SetPos,
    C3.Behaviors.Platform.Acts.SetEnabled,
    C3.Plugins.Sprite.Acts.SubInstanceVar,
    C3.Plugins.Sprite.Acts.AddInstanceVar,
    C3.Plugins.Sprite.Acts.Destroy,
    C3.Plugins.Keyboard.Cnds.IsKeyDown,
    C3.Plugins.System.Cnds.TriggerOnce,
    C3.Plugins.Sprite.Acts.SetOpacity,
    C3.Plugins.Text.Acts.SetOpacity,
    C3.Plugins.Keyboard.Cnds.OnKey,
    C3.Plugins.Button.Acts.SetVisible,
    C3.Plugins.Button.Acts.SetEnabled,
    C3.Plugins.System.Acts.SetTimescale,
    C3.Plugins.Button.Cnds.OnClicked,
    C3.Plugins.Button.Acts.SetBlur,
    C3.Plugins.Sprite.Acts.ToggleBoolInstanceVar,
    C3.Plugins.Keyboard.Cnds.OnKeyReleased,
    C3.Plugins.System.Acts.SubVar,
    C3.Plugins.Sprite.Cnds.IsBoolInstanceVarSet,
    C3.Plugins.Sprite.Acts.SetVisible,
    C3.Plugins.Sprite.Acts.SetMirrored,
    C3.Behaviors.Platform.Acts.SimulateControl,
    C3.Plugins.Sprite.Acts.SetAnim,
    C3.Plugins.System.Cnds.Else,
    C3.Plugins.System.Acts.WaitForPreviousActions,
    C3.Plugins.Mouse.Cnds.OnClick,
    C3.Plugins.System.Cnds.CompareVar,
    C3.Plugins.Text.Acts.SetText,
    C3.Plugins.Text.Acts.SetVisible,
    C3.Behaviors.Flash.Acts.Flash,
    C3.Plugins.Sprite.Acts.SetCollisions,
    C3.Plugins.Sprite.Acts.SetPosToObject,
    C3.Plugins.Sprite.Acts.SetTowardPosition,
    C3.Plugins.Mouse.Exps.X,
    C3.Plugins.Mouse.Exps.Y,
    C3.Behaviors.Bullet.Acts.SetEnabled,
    C3.Behaviors.Platform.Acts.SetIgnoreInput,
    C3.Plugins.System.Acts.SetGroupActive,
    C3.Plugins.System.Cnds.CompareBetween,
    C3.Plugins.Sprite.Exps.X,
    C3.Plugins.Sprite.Exps.Y,
    C3.Plugins.Sprite.Acts.StartAnim,
    C3.Plugins.Sprite.Cnds.OnAnimFinished,
    C3.Behaviors.Bullet.Cnds.IsEnabled,
    C3.Plugins.Sprite.Cnds.CompareInstanceVar,
    C3.Plugins.System.Acts.SetVar,
    C3.Behaviors.Bullet.Acts.SetDistanceTravelled,
    C3.Plugins.Audio.Acts.Play,
    C3.Plugins.Sprite.Acts.SetInstanceVar,
    C3.Behaviors.Bullet.Cnds.CompareTravelled,
    C3.Behaviors.Turret.Acts.AddTarget,
    C3.Plugins.progressbar.Acts.SetVisible,
    C3.Plugins.Audio.Acts.FadeVolume,
    C3.Plugins.System.Acts.ToggleBoolVar,
    C3.Plugins.Text.Cnds.PickByUID,
    C3.Plugins.Text.Acts.Destroy,
    C3.Plugins.System.Cnds.EveryTick,
    C3.Plugins.Sprite.Cnds.OnInstanceSignal,
    C3.Behaviors.Flash.Acts.StopFlashing,
    C3.Plugins.Sprite.Acts.SetAnimFrame,
    C3.Behaviors.Sin.Acts.SetEnabled,
    C3.Plugins.System.Acts.RestartLayout,
    C3.Behaviors.Platform.Acts.SetDoubleJumpEnabled,
    C3.Plugins.System.Cnds.Every,
    C3.Plugins.Mouse.Cnds.IsOverObject,
    C3.Plugins.Particles.Acts.SetVisible,
    C3.Plugins.progressbar.Acts.SetPosToObject,
    C3.Plugins.progressbar.Acts.SetProgress,
    C3.Plugins.Text.Acts.AppendText,
    C3.Plugins.progressbar.Acts.SetTooltip,
    C3.Plugins.Text.Exps.PlainText,
    C3.Plugins.progressbar.Acts.SetPos,
    C3.Plugins.Sprite.Cnds.PickByUID,
    C3.Plugins.System.Acts.Signal,
    C3.Plugins.System.Cnds.OnSignal,
    C3.Behaviors.jumpthru.Acts.SetEnabled,
    C3.Plugins.Sprite.Cnds.IsVisible,
    C3.Plugins.Sprite.Acts.InstanceSignal,
    C3.Behaviors.Platform.Acts.SetVectorX,
    C3.Behaviors.Platform.Acts.SetVectorY,
    C3.Plugins.Sprite.Acts.MoveForward,
    C3.Plugins.System.Acts.CreateObject,
    C3.Plugins.Sprite.Exps.LayerName,
    C3.Plugins.progressbar.Acts.Destroy,
    C3.Behaviors.Turret.Cnds.OnShoot,
    C3.Plugins.System.Cnds.CompareBoolVar,
    C3.Behaviors.Turret.Acts.SetEnabled,
    C3.Plugins.System.Cnds.OnLayoutStart,
    C3.Behaviors.Pin.Acts.PinByImagePoint,
    C3.Plugins.Sprite.Cnds.PickInstVarHiLow,
    C3.Plugins.Text.Cnds.PickDistance,
    C3.Plugins.Sprite.Cnds.OnDestroyed,
    C3.Behaviors.skymen_FollowMouse.Acts.SetEnabled,
    C3.Behaviors.Platform.Acts.SetCeilingCollision,
    C3.Plugins.System.Cnds.Compare,
    C3.Plugins.System.Exps.layoutname,
    C3.Plugins.Audio.Acts.StopAll,
    C3.Plugins.Sprite.Exps.Count,
    C3.Plugins.System.Acts.GoToLayoutByName,
    C3.Plugins.Sprite.Acts.StopAnim,
    C3.Plugins.Sprite.Acts.SetAnimSpeed,
    C3.Plugins.Mouse.Cnds.OnObjectClicked,
    C3.Plugins.sliderbar.Cnds.OnChanged,
    C3.Plugins.sliderbar.Exps.Value,
    C3.Plugins.Audio.Acts.SetMasterVolume,
    C3.Plugins.Text.Acts.TypewriterText,
    C3.Plugins.Button.Cnds.IsEnabled,
    C3.Plugins.System.Acts.GoToLayout,
    C3.Plugins.System.Exps.zeropad,
    C3.Plugins.Text.Acts.SetFontColor
  ];
};
self.C3_JsPropNameTable = [
  { ArrowNumberstatic: 0 },
  { BossBarLVLstatic: 0 },
  { MoneyTextStatic: 0 },
  { Anchor: 0 },
  { HPbar: 0 },
  { HPTEXT: 0 },
  { MPbar: 0 },
  { MPTEXT: 0 },
  { Pin: 0 },
  { ShieldBar: 0 },
  { SOHPTEXT: 0 },
  { ManaBar30: 0 },
  { LifeBar30: 0 },
  { NECROT1HPtext: 0 },
  { BossBarLVL1variable: 0 },
  { BossBarLVL1PROGRESS: 0 },
  { ATKtypeText: 0 },
  { blockhptexttest: 0 },
  { SKHPTEXT: 0 },
  { StartBCGRND: 0 },
  { StartGameText: 0 },
  { StartHUD: 0 },
  { Sine: 0 },
  { StartScreenGameTitle: 0 },
  { ControlsText: 0 },
  { BackToMainMenuText: 0 },
  { StartScreenGameWarning: 0 },
  { SoundText1: 0 },
  { SoundText2: 0 },
  { VolumeSliderBar: 0 },
  { ShopHUDbckgrd: 0 },
  { HeartContainer: 0 },
  { ItemCostDescription: 0 },
  { ItemCostVariable: 0 },
  { ItemCostStatic: 0 },
  { ArrowItemPurchaseable: 0 },
  { ArrowItemPurchaseable2: 0 },
  { ItemCostDescription2: 0 },
  { ManaContainer: 0 },
  { HPpot: 0 },
  { MPpot: 0 },
  { ShopDescriptionBorder: 0 },
  { MPpotHUD1: 0 },
  { InventoryHUD: 0 },
  { HPpotHUD1: 0 },
  { ArrowsNumberVariable: 0 },
  { HPpotsHUD2: 0 },
  { MPpotsHUD2: 0 },
  { MoneyHUD1: 0 },
  { ArrowHUD: 0 },
  { MoneyTextVariable: 0 },
  { inv1: 0 },
  { inv2: 0 },
  { inv3: 0 },
  { inv4: 0 },
  { Flash: 0 },
  { CooldownText: 0 },
  { FollowMouse: 0 },
  { CursorSprite: 0 },
  { InstructionsText: 0 },
  { InstructionHUDbringup: 0 },
  { InstructionsText2: 0 },
  { ContinueGameButton: 0 },
  { DeathScreen: 0 },
  { TheVoiceTextSpeak: 0 },
  { TextSpeakCollisionsAppear: 0 },
  { RubyTextSpeak: 0 },
  { Instructions: 0 },
  { bkgrdfix: 0 },
  { ScrollTo: 0 },
  { fullscreenfix: 0 },
  { ToNextLevelButton: 0 },
  { Solid: 0 },
  { a: 0 },
  { DungeonBackGround: 0 },
  { ShadowCaster: 0 },
  { DungeonTileMap: 0 },
  { Jumpthru: 0 },
  { Platform: 0 },
  { Platform2: 0 },
  { Platform3: 0 },
  { BlockHealth: 0 },
  { BreakableBlock1: 0 },
  { BreakableBlock1hp: 0 },
  { BreakableBlock2: 0 },
  { BreakableBlock2hp: 0 },
  { Bullet: 0 },
  { NecromancerATKS: 0 },
  { HP: 0 },
  { Turret: 0 },
  { NecromancerT1: 0 },
  { Sine2: 0 },
  { Sine3: 0 },
  { Sine4: 0 },
  { SpiritOrbT1: 0 },
  { TileMovement: 0 },
  { SkeletonT1: 0 },
  { Type: 0 },
  { RubyATKS: 0 },
  { RubyMelee: 0 },
  { FriendlyArrow: 0 },
  { CC: 0 },
  { GC: 0 },
  { PC: 0 },
  { SC: 0 },
  { TC: 0 },
  { HPpickup: 0 },
  { MPpickup: 0 },
  { ShieldEpickup: 0 },
  { JumpSkillPickup: 0 },
  { DEFboost: 0 },
  { ATKboost: 0 },
  { ArrowPickup: 0 },
  { ExitPortal: 0 },
  { LVL1Portal: 0 },
  { LVL2Portal: 0 },
  { LVL3Portal: 0 },
  { TPportal: 0 },
  { tpportalend1: 0 },
  { TPportal2: 0 },
  { tpportalend2: 0 },
  { TPportal3: 0 },
  { tpportalend3: 0 },
  { TPportal2a: 0 },
  { tpportalend2a: 0 },
  { tpportalend3a: 0 },
  { TPportal3a: 0 },
  { MP: 0 },
  { DEF: 0 },
  { Guarding: 0 },
  { ShieldEnergy: 0 },
  { BoundToLayout: 0 },
  { Ruby: 0 },
  { TorchFlames: 0 },
  { Sapphire: 0 },
  { particlesBlue: 0 },
  { particlesRed: 0 },
  { ShadowLight: 0 },
  { Keyboard: 0 },
  { Mouse: 0 },
  { Audio: 0 },
  { background: 0 },
  { DialogueText: 0 },
  { DialogueText2: 0 },
  { RubyCharacterPRO: 0 },
  { SapphireCharacterPRO: 0 },
  { letsGo: 0 },
  { skipIntroMovieButton: 0 },
  { SplashC3: 0 },
  { SplashPiskel: 0 },
  { SplashKrita: 0 },
  { aaaaaa: 0 },
  { Enemies: 0 },
  { ATKcooldown: 0 },
  { ATKanticooldownfix: 0 },
  { RubyHeartsNumber: 0 },
  { RubyMaxHP: 0 },
  { RubyMaxMP: 0 },
  { RubyStarsNumber: 0 },
  { ManaUsed: 0 },
  { MoneyCollected: 0 },
  { RubySTRmod: 0 },
  { RubyDEFmod: 0 },
  { LVL1BOSSTIME: 0 },
  { LVL2BOSSTIME: 0 },
  { NecromancerT1isDefeated: 0 },
  { ArrowsLeft: 0 },
  { NecroMancerT1HP: 0 },
  { SoundVolume: 0 },
  { HPpots: 0 },
  { MPpots: 0 },
  { LayoutNext: 0 },
  { IntroMovieTextVariableThingy: 0 },
  { ItemCost: 0 }
];
self.InstanceType = {
  ArrowNumberstatic: class extends self.ITextInstance {
  },
  BossBarLVLstatic: class extends self.ISpriteInstance {
  },
  MoneyTextStatic: class extends self.ITextInstance {
  },
  HPbar: class extends self.ISpriteInstance {
  },
  HPTEXT: class extends self.ITextInstance {
  },
  MPbar: class extends self.ISpriteInstance {
  },
  MPTEXT: class extends self.ITextInstance {
  },
  ShieldBar: class extends self.ISpriteInstance {
  },
  SOHPTEXT: class extends self.ITextInstance {
  },
  ManaBar30: class extends self.ISpriteInstance {
  },
  LifeBar30: class extends self.ISpriteInstance {
  },
  NECROT1HPtext: class extends self.ITextInstance {
  },
  BossBarLVL1variable: class extends self.ISpriteInstance {
  },
  BossBarLVL1PROGRESS: class extends self.IProgressBarInstance {
  },
  ATKtypeText: class extends self.ITextInstance {
  },
  blockhptexttest: class extends self.ITextInstance {
  },
  SKHPTEXT: class extends self.ITextInstance {
  },
  StartBCGRND: class extends self.ISpriteInstance {
  },
  StartGameText: class extends self.ITextInstance {
  },
  StartHUD: class extends self.ISpriteInstance {
  },
  StartScreenGameTitle: class extends self.ITextInstance {
  },
  ControlsText: class extends self.ITextInstance {
  },
  BackToMainMenuText: class extends self.ITextInstance {
  },
  StartScreenGameWarning: class extends self.ITextInstance {
  },
  SoundText1: class extends self.ITextInstance {
  },
  SoundText2: class extends self.ITextInstance {
  },
  VolumeSliderBar: class extends self.ISliderBarInstance {
  },
  ShopHUDbckgrd: class extends self.ISpriteInstance {
  },
  HeartContainer: class extends self.ISpriteInstance {
  },
  ItemCostDescription: class extends self.ITextInstance {
  },
  ItemCostVariable: class extends self.ITextInstance {
  },
  ItemCostStatic: class extends self.ITextInstance {
  },
  ArrowItemPurchaseable: class extends self.ISpriteInstance {
  },
  ArrowItemPurchaseable2: class extends self.ISpriteInstance {
  },
  ItemCostDescription2: class extends self.ITextInstance {
  },
  ManaContainer: class extends self.ISpriteInstance {
  },
  HPpot: class extends self.ISpriteInstance {
  },
  MPpot: class extends self.ISpriteInstance {
  },
  ShopDescriptionBorder: class extends self.ISpriteInstance {
  },
  MPpotHUD1: class extends self.ISpriteInstance {
  },
  InventoryHUD: class extends self.ISpriteInstance {
  },
  HPpotHUD1: class extends self.ISpriteInstance {
  },
  ArrowsNumberVariable: class extends self.ITextInstance {
  },
  HPpotsHUD2: class extends self.ITextInstance {
  },
  MPpotsHUD2: class extends self.ITextInstance {
  },
  MoneyHUD1: class extends self.ISpriteInstance {
  },
  ArrowHUD: class extends self.ISpriteInstance {
  },
  MoneyTextVariable: class extends self.ITextInstance {
  },
  inv1: class extends self.IButtonInstance {
  },
  inv2: class extends self.IButtonInstance {
  },
  inv3: class extends self.IButtonInstance {
  },
  inv4: class extends self.IButtonInstance {
  },
  CooldownText: class extends self.ITextInstance {
  },
  CursorSprite: class extends self.ISpriteInstance {
  },
  InstructionsText: class extends self.ITextInstance {
  },
  InstructionHUDbringup: class extends self.ISpriteInstance {
  },
  InstructionsText2: class extends self.ITextInstance {
  },
  ContinueGameButton: class extends self.IButtonInstance {
  },
  DeathScreen: class extends self.ISpriteInstance {
  },
  TheVoiceTextSpeak: class extends self.ITextInstance {
  },
  TextSpeakCollisionsAppear: class extends self.ISpriteInstance {
  },
  RubyTextSpeak: class extends self.ITextInstance {
  },
  Instructions: class extends self.ISpriteInstance {
  },
  bkgrdfix: class extends self.ITiledBackgroundInstance {
  },
  fullscreenfix: class extends self.ISpriteInstance {
  },
  ToNextLevelButton: class extends self.IButtonInstance {
  },
  a: class extends self.ITilemapInstance {
  },
  DungeonBackGround: class extends self.ITiledBackgroundInstance {
  },
  DungeonTileMap: class extends self.ITilemapInstance {
  },
  Platform: class extends self.ISpriteInstance {
  },
  Platform2: class extends self.ISpriteInstance {
  },
  Platform3: class extends self.ISpriteInstance {
  },
  BreakableBlock1: class extends self.ISpriteInstance {
  },
  BreakableBlock1hp: class extends self.IProgressBarInstance {
  },
  BreakableBlock2: class extends self.ISpriteInstance {
  },
  BreakableBlock2hp: class extends self.IProgressBarInstance {
  },
  NecromancerATKS: class extends self.ISpriteInstance {
  },
  NecromancerT1: class extends self.ISpriteInstance {
  },
  SpiritOrbT1: class extends self.ISpriteInstance {
  },
  SkeletonT1: class extends self.ISpriteInstance {
  },
  RubyATKS: class extends self.ISpriteInstance {
  },
  RubyMelee: class extends self.ISpriteInstance {
  },
  FriendlyArrow: class extends self.ISpriteInstance {
  },
  CC: class extends self.ISpriteInstance {
  },
  GC: class extends self.ISpriteInstance {
  },
  PC: class extends self.ISpriteInstance {
  },
  SC: class extends self.ISpriteInstance {
  },
  TC: class extends self.ISpriteInstance {
  },
  HPpickup: class extends self.ISpriteInstance {
  },
  MPpickup: class extends self.ISpriteInstance {
  },
  ShieldEpickup: class extends self.ISpriteInstance {
  },
  JumpSkillPickup: class extends self.ISpriteInstance {
  },
  DEFboost: class extends self.ISpriteInstance {
  },
  ATKboost: class extends self.ISpriteInstance {
  },
  ArrowPickup: class extends self.ISpriteInstance {
  },
  ExitPortal: class extends self.ISpriteInstance {
  },
  LVL1Portal: class extends self.ISpriteInstance {
  },
  LVL2Portal: class extends self.ISpriteInstance {
  },
  LVL3Portal: class extends self.ISpriteInstance {
  },
  TPportal: class extends self.ISpriteInstance {
  },
  tpportalend1: class extends self.ISpriteInstance {
  },
  TPportal2: class extends self.ISpriteInstance {
  },
  tpportalend2: class extends self.ISpriteInstance {
  },
  TPportal3: class extends self.ISpriteInstance {
  },
  tpportalend3: class extends self.ISpriteInstance {
  },
  TPportal2a: class extends self.ISpriteInstance {
  },
  tpportalend2a: class extends self.ISpriteInstance {
  },
  tpportalend3a: class extends self.ISpriteInstance {
  },
  TPportal3a: class extends self.ISpriteInstance {
  },
  Ruby: class extends self.ISpriteInstance {
  },
  TorchFlames: class extends self.ISpriteInstance {
  },
  Sapphire: class extends self.ISpriteInstance {
  },
  particlesBlue: class extends self.IParticlesInstance {
  },
  particlesRed: class extends self.IParticlesInstance {
  },
  ShadowLight: class extends self.IShadowLightInstance {
  },
  Keyboard: class extends self.IInstance {
  },
  Mouse: class extends self.IInstance {
  },
  Audio: class extends self.IInstance {
  },
  background: class extends self.ITiledBackgroundInstance {
  },
  DialogueText: class extends self.ITextInstance {
  },
  DialogueText2: class extends self.ITextInstance {
  },
  RubyCharacterPRO: class extends self.ISpriteInstance {
  },
  SapphireCharacterPRO: class extends self.ISpriteInstance {
  },
  letsGo: class extends self.IButtonInstance {
  },
  skipIntroMovieButton: class extends self.IButtonInstance {
  },
  SplashC3: class extends self.ISpriteInstance {
  },
  SplashPiskel: class extends self.ISpriteInstance {
  },
  SplashKrita: class extends self.ISpriteInstance {
  },
  aaaaaa: class extends self.ISpriteInstance {
  },
  Enemies: class extends self.ISpriteInstance {
  }
};
/*!
@fileoverview gl-matrix - High performance matrix and vector operations
@author Brandon Jones
@author Colin MacKenzie IV
@version 3.4.1

Copyright (c) 2015-2021, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
